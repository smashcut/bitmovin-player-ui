{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/ts/components/adclickoverlay.ts","src/ts/components/admessagelabel.ts","src/ts/components/adskipbutton.ts","src/ts/components/airplaytogglebutton.ts","src/ts/components/audioqualityselectbox.ts","src/ts/components/audiotrackselectbox.ts","src/ts/components/bufferingoverlay.ts","src/ts/components/button.ts","src/ts/components/caststatusoverlay.ts","src/ts/components/casttogglebutton.ts","src/ts/components/castuicontainer.ts","src/ts/components/clickoverlay.ts","src/ts/components/closebutton.ts","src/ts/components/component.ts","src/ts/components/container.ts","src/ts/components/controlbar.ts","src/ts/components/errormessageoverlay.ts","src/ts/components/fullscreentogglebutton.ts","src/ts/components/hugeplaybacktogglebutton.ts","src/ts/components/hugereplaybutton.ts","src/ts/components/label.ts","src/ts/components/listselector.ts","src/ts/components/metadatalabel.ts","src/ts/components/pictureinpicturetogglebutton.ts","src/ts/components/playbackspeedselectbox.ts","src/ts/components/playbacktimelabel.ts","src/ts/components/playbacktogglebutton.ts","src/ts/components/playbacktoggleoverlay.ts","src/ts/components/recommendationoverlay.ts","src/ts/components/seekbar.ts","src/ts/components/seekbarlabel.ts","src/ts/components/selectbox.ts","src/ts/components/settingspanel.ts","src/ts/components/settingstogglebutton.ts","src/ts/components/spacer.ts","src/ts/components/subtitleoverlay.ts","src/ts/components/subtitleselectbox.ts","src/ts/components/titlebar.ts","src/ts/components/togglebutton.ts","src/ts/components/tvnoisecanvas.ts","src/ts/components/uicontainer.ts","src/ts/components/videoqualityselectbox.ts","src/ts/components/volumecontrolbutton.ts","src/ts/components/volumeslider.ts","src/ts/components/volumetogglebutton.ts","src/ts/components/vrtogglebutton.ts","src/ts/components/watermark.ts","src/ts/dom.ts","src/ts/eventdispatcher.ts","src/ts/guid.ts","src/ts/main.ts","src/ts/timeout.ts","src/ts/uimanager.ts","src/ts/utils.ts"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","clickoverlay_1","AdClickOverlay","_super","__extends","prototype","configure","player","uimanager","_this","this","clickThroughUrl","clickThroughEnabled","getConfig","advertising","hasOwnProperty","addEventHandler","EVENT","ON_AD_STARTED","event","setUrl","adFinishedHandler","ON_AD_FINISHED","ON_AD_SKIPPED","ON_AD_ERROR","onClick","subscribe","pause","fireEvent","ON_AD_CLICKED","ClickOverlay","label_1","utils_1","AdMessageLabel","config","mergeConfig","cssClass","text","updateMessageHandler","setText","StringUtils","replaceAdMessagePlaceholders","adStartHandler","adMessage","ON_TIME_CHANGED","ON_CAST_TIME_UPDATED","adEndHandler","removeEventHandler","Label","button_1","AdSkipButton","skipMessage","countdown","skip","adEvent","updateSkipMessageHandler","skipOffset","show","hide","getCurrentTime","skipAd","Button","togglebutton_1","AirPlayToggleButton","isAirplayAvailable","showAirplayTargetPicker","console","log","airPlayAvailableHandler","ON_AIRPLAY_AVAILABLE","ToggleButton","selectbox_1","AudioQualitySelectBox","updateAudioQualities","audioQualities","getAvailableAudioQualities","clearItems","addItem","_i","audioQualities_1","audioQuality","id","label","onItemSelected","sender","value","setAudioQuality","ON_AUDIO_CHANGED","ON_SOURCE_UNLOADED","ON_READY","ON_AUDIO_DOWNLOAD_QUALITY_CHANGE","data","getDownloadedAudioData","selectItem","isAuto","SelectBox","AudioTrackSelectBox","getAudioTrackLabel","updateAudioTracks","audioTracks","getAvailableAudio","audioTracks_1","audioTrack","setAudio","audioTrackHandler","currentAudioTrack","getAudio","container_1","component_1","timeout_1","BufferingOverlay","indicators","Component","tag","hidden","components","showDelayMs","overlayShowTimeout","Timeout","showOverlay","start","hideOverlay","clear","ON_STALL_STARTED","ON_STALL_ENDED","isStalled","Container","dom_1","eventdispatcher_1","buttonEvents","EventDispatcher","toDomElement","buttonElement","DOM","type","class","getCssClasses","append","prefixCss","html","on","onClickEvent","getDomElement","find","dispatch","Object","defineProperty","getEvent","CastStatusOverlay","statusLabel","ON_CAST_WAITING_FOR_DEVICE","castDeviceName","castPayload","deviceName","ON_CAST_STARTED","ON_CAST_STOPPED","CastToggleButton","isCastAvailable","isCasting","castStop","castVideo","castAvailableHander","ON_CAST_AVAILABLE","off","uicontainer_1","CastUIContainer","isUiShown","hideUi","onControlsHide","castUiHideTimeout","hideDelay","showUi","onControlsShow","showUiPermanently","showUiWithTimeout","showUiAfterSeek","isPlaying","ON_SOURCE_LOADED","ON_PLAY","ON_PAUSED","ON_SEEK","ON_SEEKED","release","UIContainer","initialize","url","element","window","open","getUrl","undefined","CloseButton","target","guid_1","componentEvents","onShow","onHide","onHoverChanged","Guid","next","cssPrefix","cssClasses","isHidden","onComponentShow","onComponentHide","onHoverChangedEvent","defaults","base","assign","flattenedArray","concat","map","css","join","trim","cssClassOrId","addClass","CLASS_HIDDEN","onHideEvent","removeClass","onShowEvent","isShown","toggleHidden","isHovered","hovered","addComponent","component","push","removeComponent","ArrayUtils","remove","getComponents","removeComponents","_a","updateComponents","innerContainerElement","empty","containerElement","innerContainer","spacer_1","ControlBar","hoverStackCount","UIUtils","traverseTree","Spacer","args","onPreviewControlsHide","cancel","tvnoisecanvas_1","ErrorMessageOverlay","errorLabel","tvNoiseBackground","TvNoiseCanvas","ON_ERROR","message","messages","customMessage","stop","FullscreenToggleButton","fullscreenStateHandler","isFullscreen","ON_FULLSCREEN_ENTER","ON_FULLSCREEN_EXIT","exitFullscreen","enterFullscreen","playbacktogglebutton_1","HugePlaybackToggleButton","togglePlayback","play","toggleFullscreen","firstPlay","clickTime","doubleClickTime","now","Date","setTimeout","castInitializationHandler","ON_CAST_START","PlaybackToggleButton","HugeReplayButton","labelEvents","onTextChanged","labelElement","onTextChangedEvent","getText","clearText","isEmpty","ListSelector","listSelectorEvents","onItemAdded","onItemRemoved","items","getItemIndex","key","index","parseInt","hasItem","removeItem","onItemAddedEvent","onItemRemovedEvent","selectedItem","onItemSelectedEvent","getSelectedItem","items_1","item","itemCount","keys","MetadataLabelContent","MetadataLabel","content","toLowerCase","uiconfig","init","Title","metadata","title","source","Description","description","unload","PictureInPictureToggleButton","isPictureInPictureAvailable","isPictureInPicture","exitPictureInPicture","enterPictureInPicture","pipAvailableHander","ON_PICTURE_IN_PICTURE_ENTER","ON_PICTURE_IN_PICTURE_EXIT","PlaybackSpeedSelectBox","setPlaybackSpeed","parseFloat","PlaybackTimeLabelMode","PlaybackTimeLabel","timeLabelMode","CurrentAndTotalTime","hideInLivePlayback","live","liveCssClass","liveEdgeCssClass","minWidth","liveClickHandler","timeShift","updateLiveState","isLive","updateLiveTimeshiftState","unsubscribe","PlayerUtils","LiveStreamDetector","onLiveChanged","getTimeShift","playbackTimeHandler","getDuration","Infinity","setTime","width","min-width","ON_TIME_SHIFT","ON_TIME_SHIFTED","timeFormat","Math","abs","getMaxTimeShift","FORMAT_HHMMSS","FORMAT_MMSS","playbackSeconds","durationSeconds","currentTime","secondsToTime","totalTime","CurrentTime","TotalTime","handleClickEvent","isSeeking","playbackStateHandler","ON_PLAYBACK_FINISHED","ON_CAST_PLAYING","ON_CAST_PAUSED","ON_CAST_PLAYBACK_FINISHED","TimeShiftAvailabilityDetector","onTimeShiftAvailabilityChanged","timeShiftAvailable","CLASS_STOPTOGGLE","onSeek","onSeeked","hugeplaybacktogglebutton_1","PlaybackToggleOverlay","playbackToggleButton","hugereplaybutton_1","RecommendationOverlay","replayButton","clearRecommendations","RecommendationItem","setupRecommendations","hasRecommendationsInUiConfig","recommendations","hasRecommendationsInPlayerConfig","recommendations_1","itemConfig","isAd","itemElement","href","background-image","thumbnail","bgElement","titleElement","timeElement","duration","SeekBar","playbackPositionPercentage","touchSupported","seekBarEvents","onSeekPreview","vertical","smoothPlaybackPositionUpdateIntervalMs","timelineMarkers","hasLabel","getLabel","configureSeek","playbackNotInitialized","playbackPositionHandler","forceUpdate","setPlaybackPosition","setBufferPosition","videoBufferLength","getVideoBufferLength","audioBufferLength","getAudioBufferLength","bufferLength","min","Number","MAX_VALUE","bufferPercentage","SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED","isPaused","ON_SEGMENT_REQUEST_FINISHED","setSeeking","seek","percentage","subscribeRateLimited","scrubbing","position","hasTimeShift","switchVisibility","refreshPlaybackPosition","ON_PLAYER_RESIZE","onConfigured","setSeekPosition","configureSmoothPlaybackPositionUpdater","configureMarkers","currentTimeSeekBar","currentTimePlayer","smoothPlaybackPositionUpdater","updateIntervalMs","currentTimeDelta","startSmoothPlaybackPositionUpdater","stopSmoothPlaybackPositionUpdater","clearMarkers","updateMarkers","setupMarkers","hasMarkersInUiConfig","markers","hasMarkersInPlayerConfig","markers_1","marker","time","markerType","comment","avatar","number","seekBarContainer","seekBar","seekBarBufferLevel","seekBarBufferPosition","seekBarPlaybackPosition","seekBarPlaybackPositionMarker","seekBarSeekPosition","seekBarBackdrop","seekBarChapterMarkersContainer","seekBarMarkersContainer","seeking","mouseTouchMoveHandler","preventDefault","stopPropagation","targetPercentage","getOffset","onSeekPreviewEvent","mouseTouchUpHandler","document","snappedChapter","getMarkerAtPosition","onSeekedEvent","isTouchEvent","TouchEvent","onSeekEvent","className","markerDom","data-marker-time","String","data-marker-title","snappedMarker","getHorizontalOffset","eventPageX","elementOffsetPx","offset","left","widthPx","offsetPx","sanitizeOffset","getVerticalOffset","eventPageY","top","height","changedTouches","pageY","touches","pageX","MouseEvent","warn","percent","setPosition","px","style","transform","-ms-transform","scale","CLASS_SEEKING","hasClass","SeekBarLabel","timeLabel","titleLabel","commentLabel","numberLabel","avatarLabel","setTitleText","setSmashcutData","setThumbnail","setBackground","getThumb","seconds","thumbnailElement","display","w","h","background-position","x","y","onOff","metadataElement","background","listselector_1","selectElement","updateDomItems","val","selectedValue","optionElement","attr","videoqualityselectbox_1","audioqualityselectbox_1","SettingsPanel","settingsPanelEvents","onSettingsStateChanged","hideTimeout","reset","settingsStateChangedHandler","onSettingsStateChangedEvent","lastShownItem","getItems","SettingsPanelItem","CLASS_LAST","onActiveChanged","hasActiveSettings","isActive","selectBox","settingsPanelItemEvents","setting","handleConfigItemChanged","minItemsToDisplay","VideoQualitySelectBox","onActiveChangedEvent","SettingsToggleButton","settingsPanel","autoHideWhenNoActiveSettings","settingsPanelItemsChangedHandler","controlbar_1","SubtitleOverlay","subtitleManager","ActiveSubtitleManager","ON_CUE_ENTER","labelToAdd","cueEnter","ON_CUE_EXIT","labelToRemove","cueExit","hasCues","subtitleClearHandler","ON_SUBTITLE_CHANGED","CLASS_CONTROLBAR_VISIBLE","SubtitleLabel","activeSubtitleCueMap","calculateId","activeSubtitleCue","cueCount","SubtitleSelectBox","updateSubtitles","getAvailableSubtitles","subtitle","setSubtitle","ON_SUBTITLE_ADDED","targetSubtitle","ON_SUBTITLE_REMOVED","subtitleId","metadatalabel_1","TitleBar","keepHiddenWithoutMetadata","shouldBeShown","hasMetadataText","checkMetadataTextAndUpdateVisibility","toggleButtonEvents","onToggle","onToggleOn","onToggleOff","isOff","onState","CLASS_OFF","CLASS_ON","onToggleEvent","onToggleOnEvent","isOn","onToggleOffEvent","toggle","canvasWidth","canvasHeight","interferenceHeight","lastFrameUpdate","frameInterval","useAnimationFrame","requestAnimationFrame","canvas","canvasElement","getElements","canvasContext","getContext","noiseAnimationWindowPos","renderFrame","cancelAnimationFrame","frameUpdateHandlerId","clearTimeout","getTime","scheduleNextRender","currentPixelOffset","noiseImage","createImageData","random","putImageData","bind","configureUIShowHide","configurePlayerStates","container","isFirstTouch","uiHideTimeout","previewHideEventArgs","stateClassNames","state","PlayerState","isNaN","enumName","STATE_PREFIX","removeStates","IDLE","PREPARED","PLAYING","PAUSED","FINISHED","getState","FULLSCREEN","BUFFERING","REMOTE_CONTROL","CONTROLS_HIDDEN","CONTROLS_SHOWN","updateLayoutSizeClasses","round","substring","getFigure","createElement","flex","updateVideoQualities","videoQualities","getAvailableVideoQualities","videoQualities_1","videoQuality","setVideoQuality","ON_VIDEO_DOWNLOAD_QUALITY_CHANGE","getDownloadedVideoData","volumeslider_1","volumetogglebutton_1","VolumeControlButton","volumeToggleButton","VolumeToggleButton","volumeSlider","VolumeSlider","getVolumeToggleButton","getVolumeSlider","volumeSliderHideTimeout","volumeSliderHovered","seekbar_1","hideIfVolumeControlProhibited","detectVolumeControlAvailability","volumeChangeHandler","isMuted","getVolume","ON_VOLUME_CHANGED","ON_MUTED","ON_UNMUTED","setVolume","volume","muted","playing","mute","muteStateHandler","volumeLevelHandler","unmute","VRToggleButton","isVRConfigured","vr","contentType","isVRStereoAvailable","getVRStatus","vrStateHandler","isStereo","vrButtonVisibilityHandler","ON_VR_MODE_CHANGED","ON_VR_STEREO_CHANGED","ON_VR_ERROR","setVRStereo","Watermark","something","attributes","Array","HTMLElement","elements","Document","tagName","attributeName","attributeValue","setAttribute","selector","findChildElements","forEach","handler","findChildElementsOfElement","childElements","querySelectorAll","slice","allChildElements","arguments","setHtml","getHtml","innerHTML","HTMLSelectElement","HTMLInputElement","attribute","setAttr","getAttr","getAttribute","dataAttribute","setData","getData","childElement","_","appendChild","parent","parentNode","removeChild","elementRect","getBoundingClientRect","htmlRect","body","parentElement","offsetWidth","offsetHeight","eventName","eventHandler","split","addEventListener","removeEventListener","classList","add","replace","RegExp","contains","test","propertyNameOrCollection","propertyName","setCss","getCss","propertyValueCollection","setCssCollection","getComputedStyle","ruleValueCollection","listeners","listener","EventListenerWrapper","subscribeOnce","rateMs","RateLimitedEventListenerWrapper","subscribedListener","unsubscribeAll","listenersToRemove","fire","isOnce","_b","listenersToRemove_1","listenerToRemove","once","eventListener","lastFireTime","rateLimitingEventListener","fireSuper","guid","uimanager_1","fullscreentogglebutton_1","playbacktimelabel_1","settingspanel_1","settingstogglebutton_1","vrtogglebutton_1","watermark_1","audiotrackselectbox_1","caststatusoverlay_1","casttogglebutton_1","errormessageoverlay_1","recommendationoverlay_1","seekbarlabel_1","subtitleoverlay_1","subtitleselectbox_1","titlebar_1","volumecontrolbutton_1","adskipbutton_1","admessagelabel_1","adclickoverlay_1","playbackspeedselectbox_1","bufferingoverlay_1","castuicontainer_1","playbacktoggleoverlay_1","closebutton_1","airplaytogglebutton_1","pictureinpicturetogglebutton_1","TypeError","bitmovin","playerui","UIManager","UIInstanceManager","BrowserUtils","delay","callback","repeat","timeoutHandle","lastScheduleTime","delayAdjust","internalCallback","delta","playerUiOrUiVariants","playerUi","uiVariants","ui","managerPlayerWrapper","PlayerWrapper","playerElement","uiInstanceManagers","uiVariantsWithoutCondition","uiVariant","condition","InternalUIInstanceManager","adStartedEvent","isMobile","resolveUiVariant","ad","adWithUI","clientType","context","isAdWithUI","documentWidth","clientWidth","nextUi","uiVariantChanged","indexOf","currentUi","getUI","isConfigured","addUi","getWrappedPlayer","fireEventInUI","getPlayer","dom","configureControls","releaseUi","releaseControls","clearEventHandlers","uiInstanceManager","Factory","buildDefaultUI","buildModernUI","buildDefaultSmallScreenUI","buildModernSmallScreenUI","buildDefaultCastReceiverUI","buildModernCastReceiverUI","smashcutUi","controlBarTop","controlBarMiddle","controlBarBottom","controlBar","modernAdsUI","modernSmallScreenUI","modernSmallScreenAdsUI","modernCastReceiverUI","legacyUI","legacyAdsUI","legacyCastReceiverUI","legacyTestUI","buildLegacyUI","buildLegacyCastReceiverUI","buildLegacyTestUI","events","playerWrapper","event_1","configureControlsTree","configured","configuredComponents","configuredComponents_1","error","constructor","name","releaseControlsTree","released","isReleased","childComponent","eventHandlers","methods","member","wrapper","methods_1","apply","eventType","playerEventData","timestamp","uiSourced","array","splice","totalSeconds","format","isNegative","hours","floor","minutes","leftPadWithZeros","num","substr","adMessagePlaceholderRegex","formatString","ceil","formatNumber","formatStringValidationRegex","leadingZeroes","leadingZeroesMatches","match","numDecimalPlaces","decimalPlacesMatches","timeString","toFixed","isSourceLoaded","isTimeShiftAvailable","hasEnded","timeShiftAvailabilityChangedEvent","timeShiftDetector","timeShiftAvailableNow","liveChangedEvent","liveDetector","liveNow","isAndroid","isChrome","visit","recursiveTreeWalker","navigator","userAgent"],"mappings":"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","file":"bitmovinplayer-ui.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import {ClickOverlay} from './clickoverlay';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A simple click capture overlay for clickThroughUrls of ads.\n */\nexport class AdClickOverlay extends ClickOverlay {\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let clickThroughUrl = <string>null;\n    let clickThroughEnabled = !player.getConfig().advertising\n      || !player.getConfig().advertising.hasOwnProperty('clickThroughEnabled')\n      || player.getConfig().advertising.clickThroughEnabled;\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, (event: bitmovin.player.AdStartedEvent) => {\n      clickThroughUrl = event.clickThroughUrl;\n\n      if (clickThroughEnabled) {\n        this.setUrl(clickThroughUrl);\n      } else {\n        // If click-through is disabled, we set the url to null to avoid it open\n        this.setUrl(null);\n      }\n    });\n\n    // Clear click-through URL when ad has finished\n    let adFinishedHandler = () => {\n      this.setUrl(null);\n    };\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adFinishedHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adFinishedHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adFinishedHandler);\n\n    this.onClick.subscribe(() => {\n      // Pause the ad when overlay is clicked\n      player.pause('ui-content-click');\n\n      // Notify the player of the clicked ad\n      player.fireEvent(player.EVENT.ON_AD_CLICKED, {\n        clickThroughUrl: clickThroughUrl\n      });\n    });\n  }\n}","import {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {StringUtils} from '../utils';\n\n/**\n * A label that displays a message about a running ad, optionally with a countdown.\n */\nexport class AdMessageLabel extends Label<LabelConfig> {\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-label-ad-message',\n      text: 'This ad will end in {remainingTime} seconds.'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let text = this.getConfig().text;\n\n    let updateMessageHandler = () => {\n      this.setText(StringUtils.replaceAdMessagePlaceholders(text, null, player));\n    };\n\n    let adStartHandler = (event: bitmovin.player.AdStartedEvent) => {\n      text = event.adMessage || text;\n      updateMessageHandler();\n\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, updateMessageHandler);\n      player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateMessageHandler);\n    };\n\n    let adEndHandler = () => {\n      player.removeEventHandler(player.EVENT.ON_TIME_CHANGED, updateMessageHandler);\n      player.removeEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateMessageHandler);\n    };\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, adStartHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adEndHandler);\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {UIInstanceManager} from '../uimanager';\nimport SkipMessage = bitmovin.player.SkipMessage;\nimport {StringUtils} from '../utils';\n\n/**\n * Configuration interface for the {@link AdSkipButton}.\n */\nexport interface AdSkipButtonConfig extends ButtonConfig {\n  skipMessage?: SkipMessage;\n}\n\n/**\n * A button that is displayed during ads and can be used to skip the ad.\n */\nexport class AdSkipButton extends Button<AdSkipButtonConfig> {\n\n  constructor(config: AdSkipButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <AdSkipButtonConfig>{\n      cssClass: 'ui-button-ad-skip',\n      skipMessage: {\n        countdown: 'Skip ad in {remainingTime}',\n        skip: 'Skip ad'\n      }\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <AdSkipButtonConfig>this.getConfig(); // TODO get rid of generic cast\n    let skipMessage = config.skipMessage;\n    let adEvent = <bitmovin.player.AdStartedEvent>null;\n\n    let updateSkipMessageHandler = () => {\n      // Display this button only if ad is skippable\n      if (adEvent.skipOffset) {\n        this.show();\n      } else {\n        this.hide();\n      }\n\n      // Update the skip message on the button\n      if (player.getCurrentTime() < adEvent.skipOffset) {\n        this.setText(\n          StringUtils.replaceAdMessagePlaceholders(config.skipMessage.countdown, adEvent.skipOffset, player));\n      } else {\n        this.setText(config.skipMessage.skip);\n      }\n    };\n\n    let adStartHandler = (event: bitmovin.player.AdStartedEvent) => {\n      adEvent = event;\n      skipMessage = adEvent.skipMessage || skipMessage;\n      updateSkipMessageHandler();\n\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, updateSkipMessageHandler);\n      player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateSkipMessageHandler);\n    };\n\n    let adEndHandler = () => {\n      player.removeEventHandler(player.EVENT.ON_TIME_CHANGED, updateSkipMessageHandler);\n      player.removeEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateSkipMessageHandler);\n    };\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, adStartHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adEndHandler);\n\n    this.onClick.subscribe(() => {\n      // Try to skip the ad (this only works if it is skippable so we don't need to take extra care of that here)\n      player.skipAd();\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles Apple AirPlay.\n */\nexport class AirPlayToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-airplaytogglebutton',\n      text: 'Apple AirPlay'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      if (player.isAirplayAvailable()) {\n        player.showAirplayTargetPicker();\n      } else {\n        if (console) {\n          console.log('AirPlay unavailable');\n        }\n      }\n    });\n\n    let airPlayAvailableHandler = () => {\n      if (player.isAirplayAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_AIRPLAY_AVAILABLE, airPlayAvailableHandler);\n\n    // Startup init\n    airPlayAvailableHandler(); // Hide button if AirPlay is not available\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between 'auto' and the available audio qualities.\n */\nexport class AudioQualitySelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let updateAudioQualities = () => {\n      let audioQualities = player.getAvailableAudioQualities();\n\n      this.clearItems();\n\n      // Add entry for automatic quality switching (default setting)\n      this.addItem('Auto', 'Auto');\n\n      // Add audio qualities\n      for (let audioQuality of audioQualities) {\n        this.addItem(audioQuality.id, audioQuality.label);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: AudioQualitySelectBox, value: string) => {\n      player.setAudioQuality(value);\n    });\n\n    // Update qualities when audio track has changed\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, updateAudioQualities);\n    // Update qualities when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateAudioQualities);\n    // Update qualities when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateAudioQualities);\n    // Update quality selection when quality is changed (from outside)\n    player.addEventHandler(player.EVENT.ON_AUDIO_DOWNLOAD_QUALITY_CHANGE, () => {\n      let data = player.getDownloadedAudioData();\n      this.selectItem(data.isAuto ? 'Auto' : data.id);\n    });\n\n    // Populate qualities at startup\n    updateAudioQualities();\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between available audio tracks (e.g. different languages).\n */\nexport class AudioTrackSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    // TODO Move to config?\n    let getAudioTrackLabel = (id: string) => {\n      switch (id) {\n        case 'en_stereo':\n          return 'English - Stereo';\n        case 'no-voices_stereo':\n          return 'No Voices - Stereo';\n        case 'en_surround':\n          return 'English - Surround';\n        default:\n          return id\n      }\n    }\n\n    let updateAudioTracks = () => {\n      let audioTracks = player.getAvailableAudio();\n\n      this.clearItems();\n\n      // Add audio tracks\n      for (let audioTrack of audioTracks) {\n        this.addItem(audioTrack.id, getAudioTrackLabel(audioTrack.label));\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: AudioTrackSelectBox, value: string) => {\n      player.setAudio(value);\n    });\n\n    let audioTrackHandler = () => {\n      let currentAudioTrack = player.getAudio();\n\n      // HLS streams don't always provide this, so we have to check\n      if (currentAudioTrack) {\n        this.selectItem(currentAudioTrack.id);\n      }\n    };\n\n    // Update selection when selected track has changed\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, audioTrackHandler);\n    // Update tracks when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateAudioTracks);\n    // Update tracks when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateAudioTracks);\n\n    // Populate tracks at startup\n    updateAudioTracks();\n\n    // When `playback.audioLanguage` is set, the `ON_AUDIO_CHANGED` event for that change is triggered before the\n    // UI is created. Therefore we need to set the audio track on configure.\n    audioTrackHandler();\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {Component, ComponentConfig} from './component';\nimport {Timeout} from '../timeout';\n\n/**\n * Configuration interface for the {@link BufferingOverlay} component.\n */\nexport interface BufferingOverlayConfig extends ContainerConfig {\n  /**\n   * Delay in milliseconds after which the buffering overlay will be displayed. Useful to bypass short stalls without\n   * displaying the overlay. Set to 0 to display the overlay instantly.\n   * Default: 1000ms (1 second)\n   */\n  showDelayMs?: number;\n}\n\n/**\n * Overlays the player and displays a buffering indicator.\n */\nexport class BufferingOverlay extends Container<BufferingOverlayConfig> {\n\n  private indicators: Component<ComponentConfig>[];\n\n  constructor(config: BufferingOverlayConfig = {}) {\n    super(config);\n\n    this.indicators = [\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n    ];\n\n    this.config = this.mergeConfig(config, <BufferingOverlayConfig>{\n      cssClass: 'ui-buffering-overlay',\n      hidden: true,\n      components: this.indicators,\n      showDelayMs: 1000,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <BufferingOverlayConfig>this.getConfig();\n\n    let overlayShowTimeout = new Timeout(config.showDelayMs, () => {\n      this.show();\n    });\n\n    let showOverlay = () => {\n      overlayShowTimeout.start();\n    };\n\n    let hideOverlay = () => {\n      overlayShowTimeout.clear();\n      this.hide();\n    };\n\n    player.addEventHandler(player.EVENT.ON_STALL_STARTED, showOverlay);\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, hideOverlay);\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, hideOverlay);\n\n    // Show overlay if player is already stalled at init\n    if (player.isStalled()) {\n      this.show();\n    }\n  }\n}\n","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {EventDispatcher, NoArgs, Event} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link Button} component.\n */\nexport interface ButtonConfig extends ComponentConfig {\n  /**\n   * The text on the button.\n   */\n  text?: string;\n}\n\n/**\n * A simple clickable button.\n */\nexport class Button<Config extends ButtonConfig> extends Component<ButtonConfig> {\n\n  private buttonEvents = {\n    onClick: new EventDispatcher<Button<Config>, NoArgs>()\n  };\n\n  constructor(config: ButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-button'\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    // Create the button element with the text label\n    let buttonElement = new DOM('button', {\n      'type': 'button',\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    }).append(new DOM('span', {\n      'class': this.prefixCss('label')\n    }).html(this.config.text));\n\n    // Listen for the click event on the button element and trigger the corresponding event on the button component\n    buttonElement.on('click', () => {\n      this.onClickEvent();\n    });\n\n    return buttonElement;\n  }\n\n  /**\n   * Sets text on the label of the button.\n   * @param text the text to put into the label of the button\n   */\n  setText(text: string): void {\n    this.getDomElement().find('.' + this.prefixCss('label')).html(text);\n  }\n\n  protected onClickEvent() {\n    this.buttonEvents.onClick.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the button is clicked.\n   * @returns {Event<Button<Config>, NoArgs>}\n   */\n  get onClick(): Event<Button<Config>, NoArgs> {\n    return this.buttonEvents.onClick.getEvent();\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport CastWaitingForDeviceEvent = bitmovin.player.CastWaitingForDeviceEvent;\nimport CastStartedEvent = bitmovin.player.CastStartedEvent;\n\n/**\n * Overlays the player and displays the status of a Cast session.\n */\nexport class CastStatusOverlay extends Container<ContainerConfig> {\n\n  private statusLabel: Label<LabelConfig>;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.statusLabel = new Label<LabelConfig>({ cssClass: 'ui-cast-status-label' });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-cast-status-overlay',\n      components: [this.statusLabel],\n      hidden: true\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    player.addEventHandler(player.EVENT.ON_CAST_WAITING_FOR_DEVICE,\n      (event: CastWaitingForDeviceEvent) => {\n        this.show();\n        // Get device name and update status text while connecting\n        let castDeviceName = event.castPayload.deviceName;\n        this.statusLabel.setText(`Connecting to <strong>${castDeviceName}</strong>...`);\n      });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, (event: CastStartedEvent) => {\n      // Session is started or resumed\n      // For cases when a session is resumed, we do not receive the previous events and therefore show the status panel\n      // here too\n      this.show();\n      let castDeviceName = event.deviceName;\n      this.statusLabel.setText(`Playing on <strong>${castDeviceName}</strong>`);\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, (event) => {\n      // Cast session gone, hide the status panel\n      this.hide();\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles casting to a Cast receiver.\n */\nexport class CastToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-casttogglebutton',\n      text: 'Google Cast'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      if (player.isCastAvailable()) {\n        if (player.isCasting()) {\n          player.castStop();\n        } else {\n          player.castVideo();\n        }\n      } else {\n        if (console) {\n          console.log('Cast unavailable');\n        }\n      }\n    });\n\n    let castAvailableHander = () => {\n      if (player.isCastAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_CAST_AVAILABLE, castAvailableHander);\n\n    // Toggle button 'on' state\n    player.addEventHandler(player.EVENT.ON_CAST_WAITING_FOR_DEVICE, () => {\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      // When a session is resumed, there is no ON_CAST_START event, so we also need to toggle here for such cases\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, () => {\n      this.off();\n    });\n\n    // Startup init\n    castAvailableHander(); // Hide button if Cast not available\n    if (player.isCasting()) {\n      this.on();\n    }\n  }\n}","import {UIContainer, UIContainerConfig} from './uicontainer';\nimport {UIInstanceManager} from '../uimanager';\nimport {Timeout} from '../timeout';\n\n/**\n * The base container for Cast receivers that contains all of the UI and takes care that the UI is shown on\n * certain playback events.\n */\nexport class CastUIContainer extends UIContainer {\n\n  private castUiHideTimeout: Timeout;\n\n  constructor(config: UIContainerConfig) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <UIContainerConfig>this.getConfig();\n\n    /*\n     * Show UI on Cast devices at certain playback events\n     *\n     * Since a Cast receiver does not have a direct HCI, we show the UI on certain playback events to give the user\n     * a chance to see on the screen what's going on, e.g. on play/pause or a seek the UI is shown and the user can\n     * see the current time and position on the seek bar.\n     * The UI is shown permanently while playback is paused, otherwise hides automatically after the configured\n     * hide delay time.\n     */\n\n    let isUiShown = false;\n\n    let hideUi = () => {\n      uimanager.onControlsHide.dispatch(this);\n      isUiShown = false;\n    };\n\n    this.castUiHideTimeout = new Timeout(config.hideDelay, hideUi);\n\n    let showUi = () => {\n      if (!isUiShown) {\n        uimanager.onControlsShow.dispatch(this);\n        isUiShown = true;\n      }\n    };\n\n    let showUiPermanently = () => {\n      showUi();\n      this.castUiHideTimeout.clear();\n    };\n\n    let showUiWithTimeout = () => {\n      showUi();\n      this.castUiHideTimeout.start();\n    };\n\n    let showUiAfterSeek = () => {\n      if (player.isPlaying()) {\n        showUiWithTimeout();\n      } else {\n        showUiPermanently();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_PLAY, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_PAUSED, showUiPermanently);\n    player.addEventHandler(player.EVENT.ON_SEEK, showUiPermanently);\n    player.addEventHandler(player.EVENT.ON_SEEKED, showUiAfterSeek);\n  }\n\n  release(): void {\n    super.release();\n    this.castUiHideTimeout.clear();\n  }\n}","import {Button, ButtonConfig} from './button';\n\n/**\n * Configuration interface for a {@link ClickOverlay}.\n */\nexport interface ClickOverlayConfig extends ButtonConfig {\n  /**\n   * The url to open when the overlay is clicked. Set to null to disable the click handler.\n   */\n  url?: string;\n}\n\n/**\n * A click overlay that opens an url in a new tab if clicked.\n */\nexport class ClickOverlay extends Button<ClickOverlayConfig> {\n\n  constructor(config: ClickOverlayConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-clickoverlay'\n    }, <ClickOverlayConfig>this.config);\n  }\n\n  initialize(): void {\n    super.initialize();\n\n    this.setUrl((<ClickOverlayConfig>this.config).url);\n    let element = this.getDomElement();\n    element.on('click', () => {\n      if (element.data('url')) {\n        window.open(element.data('url'), '_blank');\n      }\n    });\n  }\n\n  /**\n   * Gets the URL that should be followed when the watermark is clicked.\n   * @returns {string} the watermark URL\n   */\n  getUrl(): string {\n    return this.getDomElement().data('url');\n  }\n\n  setUrl(url: string): void {\n    if (url === undefined || url == null) {\n      url = '';\n    }\n    this.getDomElement().data('url', url);\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {UIInstanceManager} from '../uimanager';\nimport {Component, ComponentConfig} from './component';\n\n/**\n * Configuration interface for the {@link CloseButton}.\n */\nexport interface CloseButtonConfig extends ButtonConfig {\n  /**\n   * The component that should be closed when the button is clicked.\n   */\n  target: Component<ComponentConfig>;\n}\n\n/**\n * A button that closes (hides) a configured component.\n */\nexport class CloseButton extends Button<CloseButtonConfig> {\n\n  constructor(config: CloseButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-closebutton',\n      text: 'Close'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <CloseButtonConfig>this.getConfig();\n\n    this.onClick.subscribe(() => {\n      config.target.hide();\n    });\n  }\n}","import {Guid} from '../guid';\nimport {DOM} from '../dom';\nimport {EventDispatcher, NoArgs, Event} from '../eventdispatcher';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Base configuration interface for a component.\n * Should be extended by components that want to add additional configuration options.\n */\nexport interface ComponentConfig {\n  /**\n   * The HTML tag name of the component.\n   * Default: 'div'\n   */\n  tag?: string;\n  /**\n   * The HTML ID of the component.\n   * Default: automatically generated with pattern 'ui-id-{guid}'.\n   */\n  id?: string;\n\n  /**\n   * A prefix to prepend all CSS classes with.\n   */\n  cssPrefix?: string;\n\n  /**\n   * The CSS classes of the component. This is usually the class from where the component takes its styling.\n   */\n  cssClass?: string; // 'class' is a reserved keyword, so we need to make the name more complicated\n\n  /**\n   * Additional CSS classes of the component.\n   */\n  cssClasses?: string[];\n\n  /**\n   * Specifies if the component should be hidden at startup.\n   * Default: false\n   */\n  hidden?: boolean;\n}\n\nexport interface ComponentHoverChangedEventArgs extends NoArgs {\n  /**\n   * True is the component is hovered, else false.\n   */\n  hovered: boolean;\n}\n\n/**\n * The base class of the UI framework.\n * Each component must extend this class and optionally the config interface.\n */\nexport class Component<Config extends ComponentConfig> {\n\n  /**\n   * The classname that is attached to the element when it is in the hidden state.\n   * @type {string}\n   */\n  private static readonly CLASS_HIDDEN = 'hidden';\n\n  /**\n   * Configuration object of this component.\n   */\n  protected config: Config;\n\n  /**\n   * The component's DOM element.\n   */\n  private element: DOM;\n\n  /**\n   * Flag that keeps track of the hidden state.\n   */\n  private hidden: boolean;\n\n  /**\n   * Flag that keeps track of the hover state.\n   */\n  private hovered: boolean;\n\n  /**\n   * The list of events that this component offers. These events should always be private and only directly\n   * accessed from within the implementing component.\n   *\n   * Because TypeScript does not support private properties with the same name on different class hierarchy levels\n   * (i.e. superclass and subclass cannot contain a private property with the same name), the default naming\n   * convention for the event list of a component that should be followed by subclasses is the concatenation of the\n   * camel-cased class name + 'Events' (e.g. SubClass extends Component => subClassEvents).\n   * See {@link #componentEvents} for an example.\n   *\n   * Event properties should be named in camel case with an 'on' prefix and in the present tense. Async events may\n   * have a start event (when the operation starts) in the present tense, and must have an end event (when the\n   * operation ends) in the past tense (or present tense in special cases (e.g. onStart/onStarted or onPlay/onPlaying).\n   * See {@link #componentEvents#onShow} for an example.\n   *\n   * Each event should be accompanied with a protected method named by the convention eventName + 'Event'\n   * (e.g. onStartEvent), that actually triggers the event by calling {@link EventDispatcher#dispatch dispatch} and\n   * passing a reference to the component as first parameter. Components should always trigger their events with these\n   * methods. Implementing this pattern gives subclasses means to directly listen to the events by overriding the\n   * method (and saving the overhead of passing a handler to the event dispatcher) and more importantly to trigger\n   * these events without having access to the private event list.\n   * See {@link #onShow} for an example.\n   *\n   * To provide external code the possibility to listen to this component's events (subscribe, unsubscribe, etc.),\n   * each event should also be accompanied by a public getter function with the same name as the event's property,\n   * that returns the {@link Event} obtained from the event dispatcher by calling {@link EventDispatcher#getEvent}.\n   * See {@link #onShow} for an example.\n   *\n   * Full example for an event representing an example action in a example component:\n   *\n   * <code>\n   * // Define an example component class with an example event\n   * class ExampleComponent extends Component<ComponentConfig> {\n     *\n     *     private exampleComponentEvents = {\n     *         onExampleAction: new EventDispatcher<ExampleComponent, NoArgs>()\n     *     }\n     *\n     *     // constructor and other stuff...\n     *\n     *     protected onExampleActionEvent() {\n     *        this.exampleComponentEvents.onExampleAction.dispatch(this);\n     *    }\n     *\n     *    get onExampleAction(): Event<ExampleComponent, NoArgs> {\n     *        return this.exampleComponentEvents.onExampleAction.getEvent();\n     *    }\n     * }\n   *\n   * // Create an instance of the component somewhere\n   * var exampleComponentInstance = new ExampleComponent();\n   *\n   * // Subscribe to the example event on the component\n   * exampleComponentInstance.onExampleAction.subscribe(function (sender: ExampleComponent) {\n     *     console.log('onExampleAction of ' + sender + ' has fired!');\n     * });\n   * </code>\n   */\n  private componentEvents = {\n    onShow: new EventDispatcher<Component<Config>, NoArgs>(),\n    onHide: new EventDispatcher<Component<Config>, NoArgs>(),\n    onHoverChanged: new EventDispatcher<Component<Config>, ComponentHoverChangedEventArgs>(),\n  };\n\n  /**\n   * Constructs a component with an optionally supplied config. All subclasses must call the constructor of their\n   * superclass and then merge their configuration into the component's configuration.\n   * @param config the configuration for the component\n   */\n  constructor(config: ComponentConfig = {}) {\n    // Create the configuration for this component\n    this.config = <Config>this.mergeConfig(config, {\n      tag: 'div',\n      id: 'bmpui-id-' + Guid.next(),\n      cssPrefix: 'bmpui',\n      cssClass: 'ui-component',\n      cssClasses: [],\n      hidden: false\n    }, {});\n  }\n\n  /**\n   * Initializes the component, e.g. by applying config settings.\n   * This method must not be called from outside the UI framework.\n   *\n   * This method is automatically called by the {@link UIInstanceManager}. If the component is an inner component of\n   * some component, and thus encapsulated abd managed internally and never directly exposed to the UIManager,\n   * this method must be called from the managing component's {@link #initialize} method.\n   */\n  initialize(): void {\n    this.hidden = this.config.hidden;\n\n    // Hide the component at initialization if it is configured to be hidden\n    if (this.isHidden()) {\n      this.hidden = false; // Set flag to false for the following hide() call to work (hide() checks the flag)\n      this.hide();\n    }\n  }\n\n  /**\n   * Configures the component for the supplied Player and UIInstanceManager. This is the place where all the magic\n   * happens, where components typically subscribe and react to events (on their DOM element, the Player, or the\n   * UIInstanceManager), and basically everything that makes them interactive.\n   * This method is called only once, when the UIManager initializes the UI.\n   *\n   * Subclasses usually overwrite this method to add their own functionality.\n   *\n   * @param player the player which this component controls\n   * @param uimanager the UIInstanceManager that manages this component\n   */\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    this.onShow.subscribe(() => {\n      uimanager.onComponentShow.dispatch(this);\n    });\n    this.onHide.subscribe(() => {\n      uimanager.onComponentHide.dispatch(this);\n    });\n\n    // Track the hovered state of the element\n    this.getDomElement().on('mouseenter', () => {\n      this.onHoverChangedEvent(true);\n    });\n    this.getDomElement().on('mouseleave', () => {\n      this.onHoverChangedEvent(false);\n    });\n  }\n\n  /**\n   * Releases all resources and dependencies that the component holds. Player, DOM, and UIManager events are\n   * automatically removed during release and do not explicitly need to be removed here.\n   * This method is called by the UIManager when it releases the UI.\n   *\n   * Subclasses that need to release resources should override this method and call super.release().\n   */\n  release(): void {\n    // Nothing to do here, override where necessary\n  }\n\n  /**\n   * Generate the DOM element for this component.\n   *\n   * Subclasses usually overwrite this method to extend or replace the DOM element with their own design.\n   */\n  protected toDomElement(): DOM {\n    let element = new DOM(this.config.tag, {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    return element;\n  }\n\n  /**\n   * Returns the DOM element of this component. Creates the DOM element if it does not yet exist.\n   *\n   * Should not be overwritten by subclasses.\n   *\n   * @returns {DOM}\n   */\n  getDomElement(): DOM {\n    if (!this.element) {\n      this.element = this.toDomElement();\n    }\n\n    return this.element;\n  }\n\n  /**\n   * Merges a configuration with a default configuration and a base configuration from the superclass.\n   *\n   * @param config the configuration settings for the components, as usually passed to the constructor\n   * @param defaults a default configuration for settings that are not passed with the configuration\n   * @param base configuration inherited from a superclass\n   * @returns {Config}\n   */\n  protected mergeConfig<Config>(config: Config, defaults: Config, base: Config): Config {\n    // Extend default config with supplied config\n    let merged = Object.assign({}, base, defaults, config);\n\n    // Return the extended config\n    return merged;\n  }\n\n  /**\n   * Helper method that returns a string of all CSS classes of the component.\n   *\n   * @returns {string}\n   */\n  protected getCssClasses(): string {\n    // Merge all CSS classes into single array\n    let flattenedArray = [this.config.cssClass].concat(this.config.cssClasses);\n    // Prefix classes\n    flattenedArray = flattenedArray.map((css) => {\n      return this.prefixCss(css);\n    });\n    // Join array values into a string\n    let flattenedString = flattenedArray.join(' ');\n    // Return trimmed string to prevent whitespace at the end from the join operation\n    return flattenedString.trim();\n  }\n\n  protected prefixCss(cssClassOrId: string): string {\n    return this.config.cssPrefix + '-' + cssClassOrId;\n  }\n\n  /**\n   * Returns the configuration object of the component.\n   * @returns {Config}\n   */\n  public getConfig(): Config {\n    return this.config;\n  }\n\n  /**\n   * Hides the component if shown.\n   * This method basically transfers the component into the hidden state. Actual hiding is done via CSS.\n   */\n  hide() {\n    if (!this.hidden) {\n      this.hidden = true;\n      this.getDomElement().addClass(this.prefixCss(Component.CLASS_HIDDEN));\n      this.onHideEvent();\n    }\n  }\n\n  /**\n   * Shows the component if hidden.\n   */\n  show() {\n    if (this.hidden) {\n      this.getDomElement().removeClass(this.prefixCss(Component.CLASS_HIDDEN));\n      this.hidden = false;\n      this.onShowEvent();\n    }\n  }\n\n  /**\n   * Determines if the component is hidden.\n   * @returns {boolean} true if the component is hidden, else false\n   */\n  isHidden(): boolean {\n    return this.hidden;\n  }\n\n  /**\n   * Determines if the component is shown.\n   * @returns {boolean} true if the component is visible, else false\n   */\n  isShown(): boolean {\n    return !this.isHidden();\n  }\n\n  /**\n   * Toggles the hidden state by hiding the component if it is shown, or showing it if hidden.\n   */\n  toggleHidden() {\n    if (this.isHidden()) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  }\n\n  /**\n   * Determines if the component is currently hovered.\n   * @returns {boolean} true if the component is hovered, else false\n   */\n  isHovered(): boolean {\n    return this.hovered;\n  }\n\n  /**\n   * Fires the onShow event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onShowEvent(): void {\n    this.componentEvents.onShow.dispatch(this);\n  }\n\n  /**\n   * Fires the onHide event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onHideEvent(): void {\n    this.componentEvents.onHide.dispatch(this);\n  }\n\n  /**\n   * Fires the onHoverChanged event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onHoverChangedEvent(hovered: boolean): void {\n    this.hovered = hovered;\n    this.componentEvents.onHoverChanged.dispatch(this, { hovered: hovered });\n  }\n\n  /**\n   * Gets the event that is fired when the component is showing.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   * @returns {Event<Component<Config>, NoArgs>}\n   */\n  get onShow(): Event<Component<Config>, NoArgs> {\n    return this.componentEvents.onShow.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the component is hiding.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   * @returns {Event<Component<Config>, NoArgs>}\n   */\n  get onHide(): Event<Component<Config>, NoArgs> {\n    return this.componentEvents.onHide.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the component's hover-state is changing.\n   * @returns {Event<Component<Config>, ComponentHoverChangedEventArgs>}\n   */\n  get onHoverChanged(): Event<Component<Config>, ComponentHoverChangedEventArgs> {\n    return this.componentEvents.onHoverChanged.getEvent();\n  }\n}","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {ArrayUtils} from '../utils';\n\n/**\n * Configuration interface for a {@link Container}.\n */\nexport interface ContainerConfig extends ComponentConfig {\n  /**\n   * Child components of the container.\n   */\n  components?: Component<ComponentConfig>[];\n}\n\n/**\n * A container component that can contain a collection of child components.\n * Components can be added at construction time through the {@link ContainerConfig#components} setting, or later\n * through the {@link Container#addComponent} method. The UIManager automatically takes care of all components, i.e. it\n * initializes and configures them automatically.\n *\n * In the DOM, the container consists of an outer <div> (that can be configured by the config) and an inner wrapper\n * <div> that contains the components. This double-<div>-structure is often required to achieve many advanced effects\n * in CSS and/or JS, e.g. animations and certain formatting with absolute positioning.\n *\n * DOM example:\n * <code>\n *     <div class='ui-container'>\n *         <div class='container-wrapper'>\n *             ... child components ...\n *         </div>\n *     </div>\n * </code>\n */\nexport class Container<Config extends ContainerConfig> extends Component<ContainerConfig> {\n\n  /**\n   * A reference to the inner element that contains the components of the container.\n   */\n  private innerContainerElement: DOM;\n\n  constructor(config: ContainerConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-container',\n      components: []\n    }, this.config);\n  }\n\n  /**\n   * Adds a child component to the container.\n   * @param component the component to add\n   */\n  addComponent(component: Component<ComponentConfig>) {\n    this.config.components.push(component);\n  }\n\n  /**\n   * Removes a child component from the container.\n   * @param component the component to remove\n   * @returns {boolean} true if the component has been removed, false if it is not contained in this container\n   */\n  removeComponent(component: Component<ComponentConfig>): boolean {\n    return ArrayUtils.remove(this.config.components, component) != null;\n  }\n\n  /**\n   * Gets an array of all child components in this container.\n   * @returns {Component<ComponentConfig>[]}\n   */\n  getComponents(): Component<ComponentConfig>[] {\n    return this.config.components;\n  }\n\n  /**\n   * Removes all child components from the container.\n   */\n  removeComponents(): void {\n    for (let component of this.getComponents()) {\n      this.removeComponent(component);\n    }\n  }\n\n  /**\n   * Updates the DOM of the container with the current components.\n   */\n  protected updateComponents(): void {\n    this.innerContainerElement.empty();\n\n    for (let component of this.config.components) {\n      this.innerContainerElement.append(component.getDomElement());\n    }\n  }\n\n  protected toDomElement(): DOM {\n    // Create the container element (the outer <div>)\n    let containerElement = new DOM(this.config.tag, {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    // Create the inner container element (the inner <div>) that will contain the components\n    let innerContainer = new DOM(this.config.tag, {\n      'class': this.prefixCss('container-wrapper')\n    });\n    this.innerContainerElement = innerContainer;\n\n    this.updateComponents();\n\n    containerElement.append(innerContainer);\n\n    return containerElement;\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {UIUtils} from '../utils';\nimport {Spacer} from './spacer';\n\n/**\n * Configuration interface for the {@link ControlBar}.\n */\nexport interface ControlBarConfig extends ContainerConfig {\n  // nothing yet\n}\n\n/**\n * A container for main player control components, e.g. play toggle button, seek bar, volume control, fullscreen toggle\n * button.\n */\nexport class ControlBar extends Container<ControlBarConfig> {\n\n  constructor(config: ControlBarConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-controlbar',\n      hidden: true,\n    }, <ControlBarConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    // Counts how many components are hovered and block hiding of the control bar\n    let hoverStackCount = 0;\n\n    // Track hover status of child components\n    UIUtils.traverseTree(this, (component) => {\n      // Do not track hover status of child containers or spacers, only of 'real' controls\n      if (component instanceof Container || component instanceof Spacer) {\n        return;\n      }\n\n      // Subscribe hover event and keep a count of the number of hovered children\n      component.onHoverChanged.subscribe((sender, args) => {\n        if (args.hovered) {\n          hoverStackCount++;\n        } else {\n          hoverStackCount--;\n        }\n      });\n    });\n\n    uimanager.onControlsShow.subscribe(() => {\n      this.show();\n    });\n    uimanager.onPreviewControlsHide.subscribe((sender, args) => {\n      // Cancel the hide event if hovered child components block hiding\n      args.cancel = (hoverStackCount > 0);\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      this.hide();\n    });\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport ErrorEvent = bitmovin.player.ErrorEvent;\nimport {TvNoiseCanvas} from './tvnoisecanvas';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\nexport interface ErrorMessageTranslator {\n  (error: ErrorEvent): string;\n}\n\nexport interface ErrorMessageMap {\n  [code: number]: string | ErrorMessageTranslator;\n}\n\n/**\n * Configuration interface for the {@link ErrorMessageOverlay}.\n */\nexport interface ErrorMessageOverlayConfig extends ContainerConfig {\n  /**\n   * Allows overwriting of the error messages displayed in the overlay for customization and localization.\n   * This is either a function that receives any {@link ErrorEvent} as parameter and translates error messages,\n   * or a map of error codes that overwrites specific error messages with a plain string or a function that\n   * receives the {@link ErrorEvent} as parameter and returns a customized string.\n   * The translation functions can be used to extract data (e.g. parameters) from the original error message.\n   *\n   * Example 1 (catch-all translation function):\n   * <code>\n   * errorMessageOverlayConfig = {\n   *   messages: function(error) {\n   *     switch (error.code) {\n   *       // Overwrite error 3000 'Unknown error'\n   *       case 3000:\n   *         return 'Houston, we have a problem'\n   *\n   *       // Transform error 3001 'Unsupported manifest format' to uppercase\n   *       case 3001:\n   *         return error.message.toUpperCase();\n   *\n   *       // Customize error 3006 'Could not load manifest, got HTTP status code XXX'\n   *       case 3006:\n   *         var statusCode = error.message.substring(46);\n   *         return 'Manifest loading failed with HTTP error ' + statusCode;\n   *     }\n   *     // Return unmodified error message for all other errors\n   *     return error.message;\n   *   }\n   * };\n   * </code>\n   *\n   * Example 2 (translating specific errors):\n   * <code>\n   * errorMessageOverlayConfig = {\n   *   messages: {\n   *     // Overwrite error 3000 'Unknown error'\n   *     3000: 'Houston, we have a problem',\n   *\n   *     // Transform error 3001 'Unsupported manifest format' to uppercase\n   *     3001: function(error) {\n   *       return error.message.toUpperCase();\n   *     },\n   *\n   *     // Customize error 3006 'Could not load manifest, got HTTP status code XXX'\n   *     3006: function(error) {\n   *       var statusCode = error.message.substring(46);\n   *       return 'Manifest loading failed with HTTP error ' + statusCode;\n   *     }\n   *   }\n   * };\n   * </code>\n   */\n  messages?: ErrorMessageMap | ErrorMessageTranslator;\n}\n\n/**\n * Overlays the player and displays error messages.\n */\nexport class ErrorMessageOverlay extends Container<ErrorMessageOverlayConfig> {\n\n  private errorLabel: Label<LabelConfig>;\n  private tvNoiseBackground: TvNoiseCanvas;\n\n  constructor(config: ErrorMessageOverlayConfig = {}) {\n    super(config);\n\n    this.errorLabel = new Label<LabelConfig>({ cssClass: 'ui-errormessage-label' });\n    this.tvNoiseBackground = new TvNoiseCanvas();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-errormessage-overlay',\n      components: [this.tvNoiseBackground, this.errorLabel],\n      hidden: true\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <ErrorMessageOverlayConfig>this.getConfig();\n\n    player.addEventHandler(player.EVENT.ON_ERROR, (event: ErrorEvent) => {\n      let message = event.message;\n\n      // Process message translations\n      if (config.messages) {\n        if (typeof config.messages === 'function') {\n          // Translation function for all errors\n          message = config.messages(event);\n        } else if (config.messages[event.code]) {\n          // It's not a translation function, so it must be a map of strings or translation functions\n          let customMessage = config.messages[event.code];\n\n          if (typeof customMessage === 'string') {\n            message = customMessage;\n          } else {\n            // The message is a translation function, so we call it\n            message = customMessage(event);\n          }\n        }\n      }\n\n      this.errorLabel.setText(message);\n      this.tvNoiseBackground.start();\n      this.show();\n    });\n\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, (event: PlayerEvent) => {\n      if (this.isShown()) {\n        this.tvNoiseBackground.stop();\n        this.hide();\n      }\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles the player between windowed and fullscreen view.\n */\nexport class FullscreenToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-fullscreentogglebutton',\n      text: 'Fullscreen'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let fullscreenStateHandler = () => {\n      if (player.isFullscreen()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_ENTER, fullscreenStateHandler);\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_EXIT, fullscreenStateHandler);\n\n    this.onClick.subscribe(() => {\n      if (player.isFullscreen()) {\n        player.exitFullscreen();\n      } else {\n        player.enterFullscreen();\n      }\n    });\n\n    // Startup init\n    fullscreenStateHandler();\n  }\n}","import {ToggleButtonConfig} from './togglebutton';\nimport {PlaybackToggleButton} from './playbacktogglebutton';\nimport {DOM} from '../dom';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\n/**\n * A button that overlays the video and toggles between playback and pause.\n */\nexport class HugePlaybackToggleButton extends PlaybackToggleButton {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-hugeplaybacktogglebutton',\n      text: 'Play/Pause'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    // Update button state through API events\n    super.configure(player, uimanager, false);\n\n    let togglePlayback = () => {\n      if (player.isPlaying()) {\n        player.pause('ui-overlay');\n      } else {\n        player.play('ui-overlay');\n      }\n    };\n\n    let toggleFullscreen = () => {\n      if (player.isFullscreen()) {\n        player.exitFullscreen();\n      } else {\n        player.enterFullscreen();\n      }\n    };\n\n    let firstPlay = true;\n    let clickTime = 0;\n    let doubleClickTime = 0;\n\n    /*\n     * YouTube-style toggle button handling\n     *\n     * The goal is to prevent a short pause or playback interval between a click, that toggles playback, and a\n     * double click, that toggles fullscreen. In this naive approach, the first click would e.g. start playback,\n     * the second click would be detected as double click and toggle to fullscreen, and as second normal click stop\n     * playback, which results is a short playback interval with max length of the double click detection\n     * period (usually 500ms).\n     *\n     * To solve this issue, we defer handling of the first click for 200ms, which is almost unnoticeable to the user,\n     * and just toggle playback if no second click (double click) has been registered during this period. If a double\n     * click is registered, we just toggle the fullscreen. In the first 200ms, undesired playback changes thus cannot\n     * happen. If a double click is registered within 500ms, we undo the playback change and switch fullscreen mode.\n     * In the end, this method basically introduces a 200ms observing interval in which playback changes are prevented\n     * if a double click happens.\n     */\n    this.onClick.subscribe(() => {\n      // Directly start playback on first click of the button.\n      // This is a required workaround for mobile browsers where video playback needs to be triggered directly\n      // by the user. A deferred playback start through the timeout below is not considered as user action and\n      // therefore ignored by mobile browsers.\n      if (firstPlay) {\n        // Try to start playback. Then we wait for ON_PLAY and only when it arrives, we disable the firstPlay flag.\n        // If we disable the flag here, onClick was triggered programmatically instead of by a user interaction, and\n        // playback is blocked (e.g. on mobile devices due to the programmatic play() call), we loose the chance to\n        // ever start playback through a user interaction again with this button.\n        togglePlayback();\n        return;\n      }\n\n      let now = Date.now();\n\n      if (now - clickTime < 200) {\n        // We have a double click inside the 200ms interval, just toggle fullscreen mode\n        toggleFullscreen();\n        doubleClickTime = now;\n        return;\n      } else if (now - clickTime < 500) {\n        // We have a double click inside the 500ms interval, undo playback toggle and toggle fullscreen mode\n        toggleFullscreen();\n        togglePlayback();\n        doubleClickTime = now;\n        return;\n      }\n\n      clickTime = now;\n\n      setTimeout(() => {\n        if (Date.now() - doubleClickTime > 200) {\n          // No double click detected, so we toggle playback and wait what happens next\n          togglePlayback();\n        }\n      }, 200);\n    });\n\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      // Playback has really started, we can disable the flag to switch to normal toggle button handling\n      firstPlay = false;\n    });\n\n    // Hide button while initializing a Cast session\n    let castInitializationHandler = (event: PlayerEvent) => {\n      if (event.type === player.EVENT.ON_CAST_START) {\n        // Hide button when session is being initialized\n        this.hide();\n      } else {\n        // Show button when session is established or initialization was aborted\n        this.show();\n      }\n    };\n    player.addEventHandler(player.EVENT.ON_CAST_START, castInitializationHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, castInitializationHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, castInitializationHandler);\n  }\n\n  protected toDomElement(): DOM {\n    let buttonElement = super.toDomElement();\n\n    // Add child that contains the play button image\n    // Setting the image directly on the button does not work together with scaling animations, because the button\n    // can cover the whole video player are and scaling would extend it beyond. By adding an inner element, confined\n    // to the size if the image, it can scale inside the player without overshooting.\n    buttonElement.append(new DOM('div', {\n      'class': this.prefixCss('image')\n    }));\n\n    return buttonElement;\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {DOM} from '../dom';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\n/**\n * A button to play/replay a video.\n */\nexport class HugeReplayButton extends Button<ButtonConfig> {\n\n  constructor(config: ButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-hugereplaybutton',\n      text: 'Replay'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      player.play('ui-overlay');\n    });\n  }\n\n  protected toDomElement(): DOM {\n    let buttonElement = super.toDomElement();\n\n    // Add child that contains the play button image\n    // Setting the image directly on the button does not work together with scaling animations, because the button\n    // can cover the whole video player are and scaling would extend it beyond. By adding an inner element, confined\n    // to the size if the image, it can scale inside the player without overshooting.\n    buttonElement.append(new DOM('div', {\n      'class': this.prefixCss('image')\n    }));\n\n    return buttonElement;\n  }\n}","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {EventDispatcher, Event, NoArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link Label} component.\n */\nexport interface LabelConfig extends ComponentConfig {\n  /**\n   * The text on the label.\n   */\n  text?: string;\n}\n\n/**\n * A simple text label.\n *\n * DOM example:\n * <code>\n *     <span class='ui-label'>...some text...</span>\n * </code>\n */\nexport class Label<Config extends LabelConfig> extends Component<LabelConfig> {\n\n  private text: string;\n\n  private labelEvents = {\n    onClick: new EventDispatcher<Label<Config>, NoArgs>(),\n    onTextChanged: new EventDispatcher<Label<Config>, string>(),\n  };\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-label'\n    }, this.config);\n\n    this.text = this.config.text;\n  }\n\n  protected toDomElement(): DOM {\n    let labelElement = new DOM('span', {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    }).html(this.text);\n\n    labelElement.on('click', () => {\n      this.onClickEvent();\n    });\n\n    return labelElement;\n  }\n\n  /**\n   * Set the text on this label.\n   * @param text\n   */\n  setText(text: string) {\n    this.text = text;\n    this.getDomElement().html(text);\n    this.onTextChangedEvent(text);\n  }\n\n  /**\n   * Gets the text on this label.\n   * @return {string} The text on the label\n   */\n  getText(): string {\n    return this.text;\n  }\n\n  /**\n   * Clears the text on this label.\n   */\n  clearText() {\n    this.getDomElement().html('');\n    this.onTextChangedEvent(null);\n  }\n\n  /**\n   * Tests if the label is empty and does not contain any text.\n   * @return {boolean} True if the label is empty, else false\n   */\n  isEmpty(): boolean {\n    return !this.text;\n  }\n\n  /**\n   * Fires the {@link #onClick} event.\n   * Can be used by subclasses to listen to this event without subscribing an event listener by overwriting the method\n   * and calling the super method.\n   */\n  protected onClickEvent() {\n    this.labelEvents.onClick.dispatch(this);\n  }\n\n  /**\n   * Fires the {@link #onClick} event.\n   * Can be used by subclasses to listen to this event without subscribing an event listener by overwriting the method\n   * and calling the super method.\n   */\n  protected onTextChangedEvent(text: string) {\n    this.labelEvents.onTextChanged.dispatch(this, text);\n  }\n\n  /**\n   * Gets the event that is fired when the label is clicked.\n   * @returns {Event<Label<LabelConfig>, NoArgs>}\n   */\n  get onClick(): Event<Label<LabelConfig>, NoArgs> {\n    return this.labelEvents.onClick.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the text on the label is changed.\n   * @returns {Event<Label<LabelConfig>, string>}\n   */\n  get onTextChanged(): Event<Label<LabelConfig>, string> {\n    return this.labelEvents.onTextChanged.getEvent();\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {EventDispatcher, Event} from '../eventdispatcher';\nimport {ArrayUtils} from '../utils';\n\n/**\n * A map of items (key/value -> label} for a {@link ListSelector} in a {@link ListSelectorConfig}.\n */\nexport interface ListItem {\n  key: string;\n  label: string;\n}\n\n/**\n * Configuration interface for a {@link ListSelector}.\n */\nexport interface ListSelectorConfig extends ComponentConfig {\n  items?: ListItem[];\n}\n\nexport abstract class ListSelector<Config extends ListSelectorConfig> extends Component<ListSelectorConfig> {\n\n  protected items: ListItem[];\n  protected selectedItem: string;\n\n  private listSelectorEvents = {\n    onItemAdded: new EventDispatcher<ListSelector<Config>, string>(),\n    onItemRemoved: new EventDispatcher<ListSelector<Config>, string>(),\n    onItemSelected: new EventDispatcher<ListSelector<Config>, string>()\n  };\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      items: [],\n      cssClass: 'ui-listselector'\n    }, this.config);\n\n    this.items = this.config.items;\n  }\n\n  private getItemIndex(key: string): number {\n    for (let index in this.items) {\n      if (key === this.items[index].key) {\n        return parseInt(index);\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Checks if the specified item is part of this selector.\n   * @param key the key of the item to check\n   * @returns {boolean} true if the item is part of this selector, else false\n   */\n  hasItem(key: string): boolean {\n    return this.getItemIndex(key) > -1;\n  }\n\n  /**\n   * Adds an item to this selector by appending it to the end of the list of items. If an item with the specified\n   * key already exists, it is replaced.\n   * @param key the key of the item to add\n   * @param label the (human-readable) label of the item to add\n   */\n  addItem(key: string, label: string) {\n    this.removeItem(key); // Try to remove key first to get overwrite behavior and avoid duplicate keys\n    this.items.push({ key: key, label: label });\n    this.onItemAddedEvent(key);\n  }\n\n  /**\n   * Removes an item from this selector.\n   * @param key the key of the item to remove\n   * @returns {boolean} true if removal was successful, false if the item is not part of this selector\n   */\n  removeItem(key: string): boolean {\n    let index = this.getItemIndex(key);\n    if (index > -1) {\n      ArrayUtils.remove(this.items, this.items[index]);\n      this.onItemRemovedEvent(key);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Selects an item from the items in this selector.\n   * @param key the key of the item to select\n   * @returns {boolean} true is the selection was successful, false if the selected item is not part of the selector\n   */\n  selectItem(key: string): boolean {\n    if (key === this.selectedItem) {\n      // itemConfig is already selected, suppress any further action\n      return true;\n    }\n\n    let index = this.getItemIndex(key);\n\n    if (index > -1) {\n      this.selectedItem = key;\n      this.onItemSelectedEvent(key);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns the key of the selected item.\n   * @returns {string} the key of the selected item or null if no item is selected\n   */\n  getSelectedItem(): string | null {\n    return this.selectedItem;\n  }\n\n  /**\n   * Removes all items from this selector.\n   */\n  clearItems() {\n    let items = this.items; // local copy for iteration after clear\n    this.items = []; // clear items\n\n    // fire events\n    for (let item of items) {\n      this.onItemRemovedEvent(item.key);\n    }\n  }\n\n  /**\n   * Returns the number of items in this selector.\n   * @returns {number}\n   */\n  itemCount(): number {\n    return Object.keys(this.items).length;\n  }\n\n  protected onItemAddedEvent(key: string) {\n    this.listSelectorEvents.onItemAdded.dispatch(this, key);\n  }\n\n  protected onItemRemovedEvent(key: string) {\n    this.listSelectorEvents.onItemRemoved.dispatch(this, key);\n  }\n\n  protected onItemSelectedEvent(key: string) {\n    this.listSelectorEvents.onItemSelected.dispatch(this, key);\n  }\n\n  /**\n   * Gets the event that is fired when an item is added to the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemAdded(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemAdded.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when an item is removed from the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemRemoved(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemRemoved.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when an item is selected from the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemSelected(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemSelected.getEvent();\n  }\n}","import {LabelConfig, Label} from './label';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Enumerates the types of content that the {@link MetadataLabel} can display.\n */\nexport enum MetadataLabelContent {\n  /**\n   * Title of the data source.\n   */\n  Title,\n  /**\n   * Description fo the data source.\n   */\n  Description,\n}\n\n/**\n * Configuration interface for {@link MetadataLabel}.\n */\nexport interface MetadataLabelConfig extends LabelConfig {\n  /**\n   * The type of content that should be displayed in the label.\n   */\n  content: MetadataLabelContent;\n}\n\n/**\n * A label that can be configured to display certain metadata.\n */\nexport class MetadataLabel extends Label<MetadataLabelConfig> {\n\n  constructor(config: MetadataLabelConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClasses: ['label-metadata', 'label-metadata-' + MetadataLabelContent[config.content].toLowerCase()]\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <MetadataLabelConfig>this.getConfig();\n    let uiconfig = uimanager.getConfig();\n\n    let init = () => {\n      switch (config.content) {\n        case MetadataLabelContent.Title:\n          if (uiconfig && uiconfig.metadata && uiconfig.metadata.title) {\n            this.setText(uiconfig.metadata.title);\n          } else if (player.getConfig().source && player.getConfig().source.title) {\n            this.setText(player.getConfig().source.title);\n          }\n          break;\n        case MetadataLabelContent.Description:\n          if (uiconfig && uiconfig.metadata && uiconfig.metadata.description) {\n            this.setText(uiconfig.metadata.description);\n          } else if (player.getConfig().source && player.getConfig().source.description) {\n            this.setText(player.getConfig().source.description);\n          }\n          break;\n      }\n    };\n\n    let unload = () => {\n      this.setText(null);\n    };\n\n    // Init label\n    init();\n    // Reinit label when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, init);\n    // Clear labels when source is unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, unload);\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles Apple macOS picture-in-picture mode.\n */\nexport class PictureInPictureToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-piptogglebutton',\n      text: 'Picture-in-Picture'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      if (player.isPictureInPictureAvailable()) {\n        if (player.isPictureInPicture()) {\n          player.exitPictureInPicture();\n        } else {\n          player.enterPictureInPicture();\n        }\n      } else {\n        if (console) {\n          console.log('PIP unavailable');\n        }\n      }\n    });\n\n    let pipAvailableHander = () => {\n      if (player.isPictureInPictureAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, pipAvailableHander);\n\n    // Toggle button 'on' state\n    player.addEventHandler(player.EVENT.ON_PICTURE_IN_PICTURE_ENTER, () => {\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_PICTURE_IN_PICTURE_EXIT, () => {\n      this.off();\n    });\n\n    // Startup init\n    pipAvailableHander(); // Hide button if PIP not available\n    if (player.isPictureInPicture()) {\n      this.on();\n    }\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection of different playback speeds.\n */\nexport class PlaybackSpeedSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem('0.25', '0.25x');\n    this.addItem('0.5', '0.5x');\n    this.addItem('1', 'Normal');\n    this.addItem('1.5', '1.5x');\n    this.addItem('2', '2x');\n\n    this.selectItem('1');\n\n\n    this.onItemSelected.subscribe((sender: PlaybackSpeedSelectBox, value: string) => {\n      player.setPlaybackSpeed(parseFloat(value));\n    });\n  }\n}","import {LabelConfig, Label} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {StringUtils, PlayerUtils} from '../utils';\nimport LiveStreamDetectorEventArgs = PlayerUtils.LiveStreamDetectorEventArgs;\n\nexport enum PlaybackTimeLabelMode {\n  CurrentTime,\n  TotalTime,\n  CurrentAndTotalTime,\n}\n\nexport interface PlaybackTimeLabelConfig extends LabelConfig {\n  timeLabelMode?: PlaybackTimeLabelMode;\n  hideInLivePlayback?: boolean;\n}\n\n/**\n * A label that display the current playback time and the total time through {@link PlaybackTimeLabel#setTime setTime}\n * or any string through {@link PlaybackTimeLabel#setText setText}.\n */\nexport class PlaybackTimeLabel extends Label<PlaybackTimeLabelConfig> {\n\n  private timeFormat: string;\n\n  constructor(config: PlaybackTimeLabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <PlaybackTimeLabelConfig>{\n      cssClass: 'ui-playbacktimelabel',\n      timeLabelMode: PlaybackTimeLabelMode.CurrentAndTotalTime,\n      hideInLivePlayback: false,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <PlaybackTimeLabelConfig>this.getConfig();\n    let live = false;\n    let liveCssClass = this.prefixCss('ui-playbacktimelabel-live');\n    let liveEdgeCssClass = this.prefixCss('ui-playbacktimelabel-live-edge');\n    let minWidth = 0;\n\n    let liveClickHandler = () => {\n      player.timeShift(0);\n    };\n\n    let updateLiveState = () => {\n      // Player is playing a live stream when the duration is infinite\n      live = player.isLive();\n\n      // Attach/detach live marker class\n      if (live) {\n        this.getDomElement().addClass(liveCssClass);\n        this.setText('Live');\n        if (config.hideInLivePlayback) {\n          this.hide();\n        }\n        this.onClick.subscribe(liveClickHandler);\n        updateLiveTimeshiftState();\n      } else {\n        this.getDomElement().removeClass(liveCssClass);\n        this.getDomElement().removeClass(liveEdgeCssClass);\n        this.show();\n        this.onClick.unsubscribe(liveClickHandler);\n      }\n    };\n\n    new PlayerUtils.LiveStreamDetector(player).onLiveChanged.subscribe((sender, args: LiveStreamDetectorEventArgs) => {\n      live = args.live;\n      updateLiveState();\n    });\n\n    let updateLiveTimeshiftState = () => {\n      if (player.getTimeShift() === 0) {\n        this.getDomElement().addClass(liveEdgeCssClass);\n      } else {\n        this.getDomElement().removeClass(liveEdgeCssClass);\n      }\n    };\n\n    let playbackTimeHandler = () => {\n      if (!live && player.getDuration() !== Infinity) {\n        this.setTime(player.getCurrentTime(), player.getDuration());\n      }\n\n      // To avoid 'jumping' in the UI by varying label sizes due to non-monospaced fonts,\n      // we gradually increase the min-width with the content to reach a stable size.\n      let width = this.getDomElement().width();\n      if (width > minWidth) {\n        minWidth = width;\n        this.getDomElement().css({\n          'min-width': minWidth + 'px'\n        });\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_TIME_CHANGED, playbackTimeHandler);\n    player.addEventHandler(player.EVENT.ON_SEEKED, playbackTimeHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, playbackTimeHandler);\n\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, updateLiveTimeshiftState);\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, updateLiveTimeshiftState);\n\n    let init = () => {\n      // Reset min-width when a new source is ready (especially for switching VOD/Live modes where the label content\n      // changes)\n      minWidth = 0;\n      this.getDomElement().css({\n        'min-width': null\n      });\n\n      // Set time format depending on source duration\n      this.timeFormat = Math.abs(player.isLive() ? player.getMaxTimeShift() : player.getDuration()) >= 3600 ?\n        StringUtils.FORMAT_HHMMSS : StringUtils.FORMAT_MMSS;\n\n      // Update time after the format has been set\n      playbackTimeHandler();\n    };\n    player.addEventHandler(player.EVENT.ON_READY, init);\n\n    init();\n  }\n\n  /**\n   * Sets the current playback time and total duration.\n   * @param playbackSeconds the current playback time in seconds\n   * @param durationSeconds the total duration in seconds\n   */\n  setTime(playbackSeconds: number, durationSeconds: number) {\n    let currentTime = StringUtils.secondsToTime(playbackSeconds, this.timeFormat);\n    let totalTime = StringUtils.secondsToTime(durationSeconds, this.timeFormat);\n\n    switch ((<PlaybackTimeLabelConfig>this.config).timeLabelMode) {\n      case PlaybackTimeLabelMode.CurrentTime:\n        this.setText(`${currentTime}`);\n        break;\n      case PlaybackTimeLabelMode.TotalTime:\n        this.setText(`${totalTime}`);\n        break;\n      case PlaybackTimeLabelMode.CurrentAndTotalTime:\n        this.setText(`${currentTime} / ${totalTime}`);\n        break;\n    }\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\nimport {PlayerUtils} from '../utils';\nimport TimeShiftAvailabilityChangedArgs = PlayerUtils.TimeShiftAvailabilityChangedArgs;\n\n/**\n * A button that toggles between playback and pause.\n */\nexport class PlaybackToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  private static readonly CLASS_STOPTOGGLE = 'stoptoggle';\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-playbacktogglebutton',\n      text: 'Play/Pause'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager, handleClickEvent: boolean = true): void {\n    super.configure(player, uimanager);\n\n    let isSeeking = false;\n\n    // Handler to update button state based on player state\n    let playbackStateHandler = (event: PlayerEvent) => {\n      // If the UI is currently seeking, playback is temporarily stopped but the buttons should\n      // not reflect that and stay as-is (e.g indicate playback while seeking).\n      if (isSeeking) {\n        return;\n      }\n\n      if (player.isPlaying()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    // Call handler upon these events\n    player.addEventHandler(player.EVENT.ON_PLAY, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_PAUSED, playbackStateHandler);\n    // when playback finishes, player turns to paused mode\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYING, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PAUSED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYBACK_FINISHED, playbackStateHandler);\n\n    // Detect absence of timeshifting on live streams and add tagging class to convert button icons to play/stop\n    new PlayerUtils.TimeShiftAvailabilityDetector(player).onTimeShiftAvailabilityChanged.subscribe(\n      (sender, args: TimeShiftAvailabilityChangedArgs) => {\n        if (!args.timeShiftAvailable) {\n          this.getDomElement().addClass(this.prefixCss(PlaybackToggleButton.CLASS_STOPTOGGLE));\n        } else {\n          this.getDomElement().removeClass(this.prefixCss(PlaybackToggleButton.CLASS_STOPTOGGLE));\n        }\n      }\n    );\n\n    if (handleClickEvent) {\n      // Control player by button events\n      // When a button event triggers a player API call, events are fired which in turn call the event handler\n      // above that updated the button state.\n      this.onClick.subscribe(() => {\n        if (player.isPlaying()) {\n          player.pause('ui-button');\n        } else {\n          player.play('ui-button');\n        }\n      });\n    }\n\n    // Track UI seeking status\n    uimanager.onSeek.subscribe(() => {\n      isSeeking = true;\n    });\n    uimanager.onSeeked.subscribe(() => {\n      isSeeking = false;\n    });\n\n    // Startup init\n    playbackStateHandler(null);\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {HugePlaybackToggleButton} from './hugeplaybacktogglebutton';\n\n/**\n * Overlays the player and displays error messages.\n */\nexport class PlaybackToggleOverlay extends Container<ContainerConfig> {\n\n  private playbackToggleButton: HugePlaybackToggleButton;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.playbackToggleButton = new HugePlaybackToggleButton();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-playbacktoggle-overlay',\n      components: [this.playbackToggleButton]\n    }, this.config);\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\nimport {UIInstanceManager, UIRecommendationConfig} from '../uimanager';\nimport {StringUtils} from '../utils';\nimport {HugeReplayButton} from './hugereplaybutton';\n\n/**\n * Overlays the player and displays recommended videos.\n */\nexport class RecommendationOverlay extends Container<ContainerConfig> {\n\n  private replayButton: HugeReplayButton;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.replayButton = new HugeReplayButton();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-recommendation-overlay',\n      hidden: true,\n      components: [this.replayButton]\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let clearRecommendations = () => {\n      for (let component of this.getComponents()) {\n        if (component instanceof RecommendationItem) {\n          this.removeComponent(component);\n        }\n      }\n      this.updateComponents();\n      this.getDomElement().removeClass(this.prefixCss('recommendations'));\n    };\n\n    let setupRecommendations = () => {\n      clearRecommendations();\n\n      let hasRecommendationsInUiConfig = uimanager.getConfig().recommendations\n        && uimanager.getConfig().recommendations.length > 0;\n      let hasRecommendationsInPlayerConfig = player.getConfig().source && player.getConfig().source.recommendations\n        && player.getConfig().source.recommendations.length > 0;\n\n      // Take markers from the UI config. If no markers defined, try to take them from the player's source config.\n      let recommendations = hasRecommendationsInUiConfig ? uimanager.getConfig().recommendations :\n        hasRecommendationsInPlayerConfig ? player.getConfig().source.recommendations : null;\n\n      // Generate timeline markers from the config if we have markers and if we have a duration\n      // The duration check is for buggy platforms where the duration is not available instantly (Chrome on Android 4.3)\n      if (recommendations) {\n        let index = 1;\n        for (let item of recommendations) {\n          this.addComponent(new RecommendationItem({\n            itemConfig: item,\n            cssClasses: ['recommendation-item-' + (index++)]\n          }));\n        }\n        this.updateComponents(); // create container DOM elements\n\n        this.getDomElement().addClass(this.prefixCss('recommendations'));\n      }\n    };\n\n    // Add recommendation when a source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, setupRecommendations);\n    // Remove recommendations and hide overlay when source is unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, () => {\n      clearRecommendations();\n      this.hide();\n    });\n    // Display recommendations when playback has finished\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, () => {\n      // Dismiss ON_PLAYBACK_FINISHED events at the end of ads\n      // TODO remove this workaround once issue #1278 is solved\n      if (player.isAd()) {\n        return;\n      }\n\n      this.show();\n    });\n    // Hide recommendations when playback starts, e.g. a restart\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      this.hide();\n    });\n\n    // Init on startup\n    setupRecommendations();\n  }\n}\n\n/**\n * Configuration interface for the {@link RecommendationItem}\n */\ninterface RecommendationItemConfig extends ComponentConfig {\n  itemConfig: UIRecommendationConfig;\n}\n\n/**\n * An item of the {@link RecommendationOverlay}. Used only internally in {@link RecommendationOverlay}.\n */\nclass RecommendationItem extends Component<RecommendationItemConfig> {\n\n  constructor(config: RecommendationItemConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-recommendation-item',\n      itemConfig: null // this must be passed in from outside\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    let config = (<RecommendationItemConfig>this.config).itemConfig; // TODO fix generics and get rid of cast\n\n    let itemElement = new DOM('a', {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n      'href': config.url\n    }).css({ 'background-image': `url(${config.thumbnail})` });\n\n    let bgElement = new DOM('div', {\n      'class': this.prefixCss('background')\n    });\n    itemElement.append(bgElement);\n\n    let titleElement = new DOM('span', {\n      'class': this.prefixCss('title')\n    }).append(new DOM('span', {\n      'class': this.prefixCss('innertitle')\n    }).html(config.title));\n    itemElement.append(titleElement);\n\n    let timeElement = new DOM('span', {\n      'class': this.prefixCss('duration')\n    }).append(new DOM('span', {\n      'class': this.prefixCss('innerduration')\n    }).html(config.duration ? StringUtils.secondsToTime(config.duration) : ''));\n    itemElement.append(timeElement);\n\n    return itemElement;\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\nimport {Event, EventDispatcher, NoArgs} from '../eventdispatcher';\nimport {SeekBarLabel} from './seekbarlabel';\nimport {UIInstanceManager, TimelineMarker, SeekPreviewArgs} from '../uimanager';\nimport {Timeout} from '../timeout';\nimport {PlayerUtils} from '../utils';\nimport TimeShiftAvailabilityChangedArgs = PlayerUtils.TimeShiftAvailabilityChangedArgs;\nimport LiveStreamDetectorEventArgs = PlayerUtils.LiveStreamDetectorEventArgs;\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\n/**\n * Configuration interface for the {@link SeekBar} component.\n */\nexport interface SeekBarConfig extends ComponentConfig {\n  /**\n   * The label above the seek position.\n   */\n  label?: SeekBarLabel;\n  /**\n   * Bar will be vertical instead of horizontal if set to true.\n   */\n  vertical?: boolean;\n  /**\n   * The interval in milliseconds in which the playback position on the seek bar will be updated. The shorter the\n   * interval, the smoother it looks and the more resource intense it is. The update interval will be kept as steady\n   * as possible to avoid jitter.\n   * Set to -1 to disable smooth updating and update it on player ON_TIME_CHANGED events instead.\n   * Default: 50 (50ms = 20fps).\n   */\n  smoothPlaybackPositionUpdateIntervalMs?: number;\n}\n\n/**\n * Event argument interface for a seek preview event.\n */\nexport interface SeekPreviewEventArgs extends SeekPreviewArgs {\n  /**\n   * Tells if the seek preview event comes from a scrubbing.\n   */\n  scrubbing: boolean;\n}\n\n/**\n * A seek bar to seek within the player's media. It displays the current playback position, amount of buffed data, seek\n * target, and keeps status about an ongoing seek.\n *\n * The seek bar displays different 'bars':\n *  - the playback position, i.e. the position in the media at which the player current playback pointer is positioned\n *  - the buffer position, which usually is the playback position plus the time span that is already buffered ahead\n *  - the seek position, used to preview to where in the timeline a seek will jump to\n */\nexport class SeekBar extends Component<SeekBarConfig> {\n\n  public static readonly SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED = -1;\n\n  /**\n   * The CSS class that is added to the DOM element while the seek bar is in 'seeking' state.\n   */\n  private static readonly CLASS_SEEKING = 'seeking';\n\n  private seekBar: DOM;\n  private seekBarPlaybackPosition: DOM;\n  private seekBarPlaybackPositionMarker: DOM;\n  private seekBarBufferPosition: DOM;\n  private seekBarSeekPosition: DOM;\n  private seekBarBackdrop: DOM;\n  private seekBarMarkersContainer: DOM;\n\n  private label: SeekBarLabel;\n\n  private timelineMarkers: TimelineMarker[];\n\n  /**\n   * Buffer of the the current playback position. The position must be buffered in case the element\n   * needs to be refreshed with {@link #refreshPlaybackPosition}.\n   * @type {number}\n   */\n  private playbackPositionPercentage = 0;\n\n  private smoothPlaybackPositionUpdater: Timeout;\n\n  // https://hacks.mozilla.org/2013/04/detecting-touch-its-the-why-not-the-how/\n  private touchSupported = ('ontouchstart' in window);\n\n  private seekBarEvents = {\n    /**\n     * Fired when a scrubbing seek operation is started.\n     */\n    onSeek: new EventDispatcher<SeekBar, NoArgs>(),\n    /**\n     * Fired during a scrubbing seek to indicate that the seek preview (i.e. the video frame) should be updated.\n     */\n    onSeekPreview: new EventDispatcher<SeekBar, SeekPreviewEventArgs>(),\n    /**\n     * Fired when a scrubbing seek has finished or when a direct seek is issued.\n     */\n    onSeeked: new EventDispatcher<SeekBar, number>()\n  };\n\n  constructor(config: SeekBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-seekbar',\n      vertical: false,\n      smoothPlaybackPositionUpdateIntervalMs: 50,\n    }, this.config);\n\n    this.label = this.config.label;\n    this.timelineMarkers = [];\n  }\n\n  initialize(): void {\n    super.initialize();\n\n    if (this.hasLabel()) {\n      this.getLabel().initialize();\n    }\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager, configureSeek: boolean = true): void {\n    super.configure(player, uimanager);\n\n    if (!configureSeek) {\n      // The configureSeek flag can be used by subclasses to disable configuration as seek bar. E.g. the volume\n      // slider is reusing this component but adds its own functionality, and does not need the seek functionality.\n      // This is actually a hack, the proper solution would be for both seek bar and volume sliders to extend\n      // a common base slider component and implement their functionality there.\n      return;\n    }\n\n    let playbackNotInitialized = true;\n    let isPlaying = false;\n    let isSeeking = false;\n\n    // Update playback and buffer positions\n    let playbackPositionHandler = (event: PlayerEvent = null, forceUpdate: boolean = false) => {\n      // Once this handler os called, playback has been started and we set the flag to false\n      playbackNotInitialized = false;\n\n      if (isSeeking) {\n        // We caught a seek preview seek, do not update the seekbar\n        return;\n      }\n\n      if (player.isLive()) {\n        if (player.getMaxTimeShift() === 0) {\n          // This case must be explicitly handled to avoid division by zero\n          this.setPlaybackPosition(100);\n        }\n        else {\n          let playbackPositionPercentage = 100 - (100 / player.getMaxTimeShift() * player.getTimeShift());\n          this.setPlaybackPosition(playbackPositionPercentage);\n        }\n\n        // Always show full buffer for live streams\n        this.setBufferPosition(100);\n      }\n      else {\n        let playbackPositionPercentage = 100 / player.getDuration() * player.getCurrentTime();\n\n        let videoBufferLength = player.getVideoBufferLength();\n        let audioBufferLength = player.getAudioBufferLength();\n        // Calculate the buffer length which is the smaller length of the audio and video buffers. If one of these\n        // buffers is not available, we set it's value to MAX_VALUE to make sure that the other real value is taken\n        // as the buffer length.\n        let bufferLength = Math.min(\n          videoBufferLength != null ? videoBufferLength : Number.MAX_VALUE,\n          audioBufferLength != null ? audioBufferLength : Number.MAX_VALUE);\n        // If both buffer lengths are missing, we set the buffer length to zero\n        if (bufferLength === Number.MAX_VALUE) {\n          bufferLength = 0;\n        }\n\n        let bufferPercentage = 100 / player.getDuration() * bufferLength;\n\n        // Update playback position only in paused state or in the initial startup state where player is neither\n        // paused nor playing. Playback updates are handled in the Timeout below.\n        if (this.config.smoothPlaybackPositionUpdateIntervalMs === SeekBar.SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED\n          || forceUpdate || player.isPaused() || (player.isPaused() === player.isPlaying())) {\n          this.setPlaybackPosition(playbackPositionPercentage);\n        }\n\n        this.setBufferPosition(playbackPositionPercentage + bufferPercentage);\n      }\n    };\n\n    // Update seekbar upon these events\n    // init playback position when the player is ready\n    player.addEventHandler(player.EVENT.ON_READY, playbackPositionHandler);\n    // update playback position when it changes\n    player.addEventHandler(player.EVENT.ON_TIME_CHANGED, playbackPositionHandler);\n    // update bufferlevel when buffering is complete\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, playbackPositionHandler);\n    // update playback position when a seek has finished\n    player.addEventHandler(player.EVENT.ON_SEEKED, playbackPositionHandler);\n    // update playback position when a timeshift has finished\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, playbackPositionHandler);\n    // update bufferlevel when a segment has been downloaded\n    player.addEventHandler(player.EVENT.ON_SEGMENT_REQUEST_FINISHED, playbackPositionHandler);\n    // update playback position of Cast playback\n    player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, playbackPositionHandler);\n\n\n    // Seek handling\n    player.addEventHandler(player.EVENT.ON_SEEK, () => {\n      this.setSeeking(true);\n    });\n    player.addEventHandler(player.EVENT.ON_SEEKED, () => {\n      this.setSeeking(false);\n    });\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, () => {\n      this.setSeeking(true);\n    });\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, () => {\n      this.setSeeking(false);\n    });\n\n    let seek = (percentage: number) => {\n      if (player.isLive()) {\n        player.timeShift(player.getMaxTimeShift() - (player.getMaxTimeShift() * (percentage / 100)));\n      } else {\n        player.seek(player.getDuration() * (percentage / 100));\n      }\n    };\n    this.onSeek.subscribe((sender) => {\n      isSeeking = true; // track seeking status so we can catch events from seek preview seeks\n\n      // Notify UI manager of started seek\n      uimanager.onSeek.dispatch(sender);\n\n      // Save current playback state\n      isPlaying = player.isPlaying();\n\n      // Pause playback while seeking\n      if (isPlaying) {\n        player.pause('ui-seek');\n      }\n    });\n    this.onSeekPreview.subscribe((sender: SeekBar, args: SeekPreviewEventArgs) => {\n      // Notify UI manager of seek preview\n      uimanager.onSeekPreview.dispatch(sender, args);\n    });\n    this.onSeekPreview.subscribeRateLimited((sender: SeekBar, args: SeekPreviewEventArgs) => {\n      // Rate-limited scrubbing seek\n      if (args.scrubbing) {\n        seek(args.position);\n      }\n    }, 200);\n    this.onSeeked.subscribe((sender, percentage) => {\n      isSeeking = false;\n\n      // Do the seek\n      seek(percentage);\n\n      // Continue playback after seek if player was playing when seek started\n      if (isPlaying) {\n        player.play('ui-seek');\n      }\n\n      // Notify UI manager of finished seek\n      uimanager.onSeeked.dispatch(sender);\n    });\n\n    if (this.hasLabel()) {\n      // Configure a seekbar label that is internal to the seekbar)\n      this.getLabel().configure(player, uimanager);\n    }\n\n    // Hide seekbar for live sources without timeshift\n    let isLive = false;\n    let hasTimeShift = false;\n    let switchVisibility = (isLive: boolean, hasTimeShift: boolean) => {\n      if (isLive && !hasTimeShift) {\n        this.hide();\n      } else {\n        this.show();\n      }\n      playbackPositionHandler(null, true);\n      this.refreshPlaybackPosition();\n    };\n    new PlayerUtils.LiveStreamDetector(player).onLiveChanged.subscribe((sender, args: LiveStreamDetectorEventArgs) => {\n      isLive = args.live;\n      switchVisibility(isLive, hasTimeShift);\n    });\n    new PlayerUtils.TimeShiftAvailabilityDetector(player).onTimeShiftAvailabilityChanged.subscribe(\n      (sender, args: TimeShiftAvailabilityChangedArgs) => {\n        hasTimeShift = args.timeShiftAvailable;\n        switchVisibility(isLive, hasTimeShift);\n      }\n    );\n\n    // Refresh the playback position when the player resized or the UI is configured. The playback position marker\n    // is positioned absolutely and must therefore be updated when the size of the seekbar changes.\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => {\n      this.refreshPlaybackPosition();\n    });\n    // Additionally, when this code is called, the seekbar is not part of the UI yet and therefore does not have a size,\n    // resulting in a wrong initial position of the marker. Refreshing it once the UI is configured solved this issue.\n    uimanager.onConfigured.subscribe(() => {\n      this.refreshPlaybackPosition();\n    });\n    // It can also happen that the value changes once the player is ready, or when a new source is loaded, so we need\n    // to update on ON_READY too\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      this.refreshPlaybackPosition();\n    });\n\n    // Initialize seekbar\n    playbackPositionHandler(); // Set the playback position\n    this.setBufferPosition(0);\n    this.setSeekPosition(0);\n    if (this.config.smoothPlaybackPositionUpdateIntervalMs !== SeekBar.SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED) {\n      this.configureSmoothPlaybackPositionUpdater(player, uimanager);\n    }\n    this.configureMarkers(player, uimanager);\n  }\n\n  private configureSmoothPlaybackPositionUpdater(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    /*\n     * Playback position update\n     *\n     * We do not update the position directly from the ON_TIME_CHANGED event, because it arrives very jittery and\n     * results in a jittery position indicator since the CSS transition time is statically set.\n     * To work around this issue, we maintain a local playback position that is updated in a stable regular interval\n     * and kept in sync with the player.\n     */\n    let currentTimeSeekBar = 0;\n    let currentTimePlayer = 0;\n    let updateIntervalMs = 50;\n    let currentTimeUpdateDeltaSecs = updateIntervalMs / 1000;\n\n    this.smoothPlaybackPositionUpdater = new Timeout(updateIntervalMs, () => {\n      currentTimeSeekBar += currentTimeUpdateDeltaSecs;\n      currentTimePlayer = player.getCurrentTime();\n\n      // Sync currentTime of seekbar to player\n      let currentTimeDelta = currentTimeSeekBar - currentTimePlayer;\n      // If the delta is larger that 2 secs, directly jump the seekbar to the\n      // player time instead of smoothly fast forwarding/rewinding.\n      if (Math.abs(currentTimeDelta) > 2) {\n        currentTimeSeekBar = currentTimePlayer;\n      }\n      // If currentTimeDelta is negative and below the adjustment threshold,\n      // the player is ahead of the seekbar and we 'fast forward' the seekbar\n      else if (currentTimeDelta <= -currentTimeUpdateDeltaSecs) {\n        currentTimeSeekBar += currentTimeUpdateDeltaSecs;\n      }\n      // If currentTimeDelta is positive and above the adjustment threshold,\n      // the player is behind the seekbar and we 'rewind' the seekbar\n      else if (currentTimeDelta >= currentTimeUpdateDeltaSecs) {\n        currentTimeSeekBar -= currentTimeUpdateDeltaSecs;\n      }\n\n      let playbackPositionPercentage = 100 / player.getDuration() * currentTimeSeekBar;\n      this.setPlaybackPosition(playbackPositionPercentage);\n    }, true);\n\n    let startSmoothPlaybackPositionUpdater = () => {\n      if (!player.isLive()) {\n        currentTimeSeekBar = player.getCurrentTime();\n        this.smoothPlaybackPositionUpdater.start();\n      }\n    };\n\n    let stopSmoothPlaybackPositionUpdater = () => {\n      this.smoothPlaybackPositionUpdater.clear();\n    };\n\n    player.addEventHandler(player.EVENT.ON_PLAY, startSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYING, startSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_PAUSED, stopSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_CAST_PAUSED, stopSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_SEEKED, () => {\n      currentTimeSeekBar = player.getCurrentTime();\n    });\n\n    if (player.isPlaying()) {\n      startSmoothPlaybackPositionUpdater();\n    }\n  }\n\n  private configureMarkers(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let clearMarkers = () => {\n      this.timelineMarkers = [];\n      this.updateMarkers();\n    };\n\n    let setupMarkers = () => {\n      clearMarkers();\n\n      let hasMarkersInUiConfig = uimanager.getConfig().metadata && uimanager.getConfig().metadata.markers\n        && uimanager.getConfig().metadata.markers.length > 0;\n      let hasMarkersInPlayerConfig = player.getConfig().source && player.getConfig().source.markers\n        && player.getConfig().source.markers.length > 0;\n\n      // Take markers from the UI config. If no markers defined, try to take them from the player's source config.\n      let markers = hasMarkersInUiConfig ? uimanager.getConfig().metadata.markers :\n        hasMarkersInPlayerConfig ? player.getConfig().source.markers : null;\n\n      // Generate timeline markers from the config if we have markers and if we have a duration\n      // The duration check is for buggy platforms where the duration is not available instantly (Chrome on Android 4.3)\n      if (markers && player.getDuration() !== Infinity) {\n        for (let o of markers) {\n          let marker = {\n            time: 100 / player.getDuration() * o.time, // convert time to percentage\n            title: o.title,\n            markerType: '' + (o.markerType || 1),\n            comment: o.comment || '',\n            avatar: o.avatar,\n            number: o.number || ''\n          }\n          this.timelineMarkers.push(marker)\n        }\n      }\n\n      // Populate the timeline with the markers\n      this.updateMarkers();\n    };\n\n    // Add markers when a source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, setupMarkers);\n    // Remove markers when unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, clearMarkers);\n\n    // Init markers at startup\n    setupMarkers();\n  }\n\n  release(): void {\n    super.release();\n\n    if (this.smoothPlaybackPositionUpdater) { // object must not necessarily exist, e.g. in volume slider subclass\n      this.smoothPlaybackPositionUpdater.clear();\n    }\n  }\n\n  protected toDomElement(): DOM {\n    if (this.config.vertical) {\n      this.config.cssClasses.push('vertical');\n    }\n\n    let seekBarContainer = new DOM('div', {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    let seekBar = new DOM('div', {\n      'class': this.prefixCss('seekbar')\n    });\n    this.seekBar = seekBar;\n\n    // Indicator that shows the buffer fill level\n    let seekBarBufferLevel = new DOM('div', {\n      'class': this.prefixCss('seekbar-bufferlevel')\n    });\n    this.seekBarBufferPosition = seekBarBufferLevel;\n\n    // Indicator that shows the current playback position\n    let seekBarPlaybackPosition = new DOM('div', {\n      'class': this.prefixCss('seekbar-playbackposition')\n    });\n    this.seekBarPlaybackPosition = seekBarPlaybackPosition;\n\n    // A marker of the current playback position, e.g. a dot or line\n    let seekBarPlaybackPositionMarker = new DOM('div', {\n      'class': this.prefixCss('seekbar-playbackposition-marker')\n    });\n    this.seekBarPlaybackPositionMarker = seekBarPlaybackPositionMarker;\n\n    // Indicator that show where a seek will go to\n    let seekBarSeekPosition = new DOM('div', {\n      'class': this.prefixCss('seekbar-seekposition')\n    });\n    this.seekBarSeekPosition = seekBarSeekPosition;\n\n    // Indicator that shows the full seekbar\n    let seekBarBackdrop = new DOM('div', {\n      'class': this.prefixCss('seekbar-backdrop')\n    });\n    this.seekBarBackdrop = seekBarBackdrop;\n\n    let seekBarChapterMarkersContainer = new DOM('div', {\n      'class': this.prefixCss('seekbar-markers')\n    });\n    this.seekBarMarkersContainer = seekBarChapterMarkersContainer;\n\n    seekBar.append(seekBarBackdrop, seekBarBufferLevel, seekBarSeekPosition,\n      seekBarPlaybackPosition, seekBarChapterMarkersContainer, seekBarPlaybackPositionMarker);\n\n    let seeking = false;\n\n    // Define handler functions so we can attach/remove them later\n    let mouseTouchMoveHandler = (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n      // Avoid propagation to VR handler\n      e.stopPropagation();\n\n      let targetPercentage = 100 * this.getOffset(e);\n      this.setSeekPosition(targetPercentage);\n      this.setPlaybackPosition(targetPercentage);\n      this.onSeekPreviewEvent(targetPercentage, true);\n    };\n    let mouseTouchUpHandler = (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      // Remove handlers, seek operation is finished\n      new DOM(document).off('touchmove mousemove', mouseTouchMoveHandler);\n      new DOM(document).off('touchend mouseup', mouseTouchUpHandler);\n\n      let targetPercentage = 100 * this.getOffset(e);\n      let snappedChapter = this.getMarkerAtPosition(targetPercentage);\n\n      this.setSeeking(false);\n      seeking = false;\n\n      // Fire seeked event\n      this.onSeekedEvent(snappedChapter ? snappedChapter.time : targetPercentage);\n    };\n\n    // A seek always start with a touchstart or mousedown directly on the seekbar.\n    // To track a mouse seek also outside the seekbar (for touch events this works automatically),\n    // so the user does not need to take care that the mouse always stays on the seekbar, we attach the mousemove\n    // and mouseup handlers to the whole document. A seek is triggered when the user lifts the mouse key.\n    // A seek mouse gesture is thus basically a click with a long time frame between down and up events.\n    seekBar.on('touchstart mousedown', (e: MouseEvent | TouchEvent) => {\n      let isTouchEvent = this.touchSupported && e instanceof TouchEvent;\n\n      // Prevent selection of DOM elements (also prevents mousedown if current event is touchstart)\n      e.preventDefault();\n      // Avoid propagation to VR handler\n      e.stopPropagation();\n\n      this.setSeeking(true); // Set seeking class on DOM element\n      seeking = true; // Set seek tracking flag\n\n      // Fire seeked event\n      this.onSeekEvent();\n\n      // Add handler to track the seek operation over the whole document\n      new DOM(document).on(isTouchEvent ? 'touchmove' : 'mousemove', mouseTouchMoveHandler);\n      new DOM(document).on(isTouchEvent ? 'touchend' : 'mouseup', mouseTouchUpHandler);\n    });\n\n    // Display seek target indicator when mouse hovers or finger slides over seekbar\n    seekBar.on('touchmove mousemove', (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      if (seeking) {\n        // During a seek (when mouse is down or touch move active), we need to stop propagation to avoid\n        // the VR viewport reacting to the moves.\n        e.stopPropagation();\n        // Because the stopped propagation inhibits the event on the document, we need to call it from here\n        mouseTouchMoveHandler(e);\n      }\n\n      let position = 100 * this.getOffset(e);\n      this.setSeekPosition(position);\n      this.onSeekPreviewEvent(position, false);\n\n      if (this.hasLabel() && this.getLabel().isHidden()) {\n        this.getLabel().show();\n      }\n    });\n\n    // Hide seek target indicator when mouse or finger leaves seekbar\n    seekBar.on('touchend mouseleave', (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      this.setSeekPosition(0);\n\n      if (this.hasLabel()) {\n        this.getLabel().hide();\n      }\n    });\n\n    seekBarContainer.append(seekBar);\n\n    if (this.label) {\n      seekBarContainer.append(this.label.getDomElement());\n    }\n\n    return seekBarContainer;\n  }\n\n  protected updateMarkers(): void {\n    this.seekBarMarkersContainer.empty();\n\n    for (let marker of this.timelineMarkers) {\n      let className = marker.markerType === '2' ? this.prefixCss('seekbar-marker-typetwo') : this.prefixCss('seekbar-marker')\n\n      let markerDom = new DOM('div', {\n        'class': className,\n        'data-marker-time': String(marker.time),\n        'data-marker-title': String(marker.title),\n      }).css({\n        'width': marker.time + '%',\n      })\n      this.seekBarMarkersContainer.append(markerDom)\n    }\n  }\n\n  protected getMarkerAtPosition(percentage: number): TimelineMarker | null {\n    let snappedMarker: TimelineMarker = null;\n    let snappingRange = 1;\n    if (this.timelineMarkers.length > 0) {\n      for (let marker of this.timelineMarkers) {\n        if (percentage >= marker.time - snappingRange && percentage <= marker.time + snappingRange) {\n          snappedMarker = marker;\n          break;\n        }\n      }\n    }\n\n    return snappedMarker;\n  }\n\n  /**\n   * Gets the horizontal offset of a mouse/touch event point from the left edge of the seek bar.\n   * @param eventPageX the pageX coordinate of an event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1], where 0 is the left edge and 1 is the right edge\n   */\n  private getHorizontalOffset(eventPageX: number): number {\n    let elementOffsetPx = this.seekBar.offset().left;\n    let widthPx = this.seekBar.width();\n    let offsetPx = eventPageX - elementOffsetPx;\n    let offset = 1 / widthPx * offsetPx;\n\n    return this.sanitizeOffset(offset);\n  }\n\n  /**\n   * Gets the vertical offset of a mouse/touch event point from the bottom edge of the seek bar.\n   * @param eventPageY the pageX coordinate of an event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1], where 0 is the bottom edge and 1 is the top edge\n   */\n  private getVerticalOffset(eventPageY: number): number {\n    let elementOffsetPx = this.seekBar.offset().top;\n    let widthPx = this.seekBar.height();\n    let offsetPx = eventPageY - elementOffsetPx;\n    let offset = 1 / widthPx * offsetPx;\n\n    return 1 - this.sanitizeOffset(offset);\n  }\n\n  /**\n   * Gets the mouse or touch event offset for the current configuration (horizontal or vertical).\n   * @param e the event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1]\n   * @see #getHorizontalOffset\n   * @see #getVerticalOffset\n   */\n  private getOffset(e: MouseEvent | TouchEvent): number {\n    if (this.touchSupported && e instanceof TouchEvent) {\n      if (this.config.vertical) {\n        return this.getVerticalOffset(e.type === 'touchend' ? e.changedTouches[0].pageY : e.touches[0].pageY);\n      } else {\n        return this.getHorizontalOffset(e.type === 'touchend' ? e.changedTouches[0].pageX : e.touches[0].pageX);\n      }\n    }\n    else if (e instanceof MouseEvent) {\n      if (this.config.vertical) {\n        return this.getVerticalOffset(e.pageY);\n      } else {\n        return this.getHorizontalOffset(e.pageX);\n      }\n    }\n    else {\n      if (console) {\n        console.warn('invalid event');\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Sanitizes the mouse offset to the range of [0, 1].\n   *\n   * When tracking the mouse outside the seek bar, the offset can be outside the desired range and this method\n   * limits it to the desired range. E.g. a mouse event left of the left edge of a seek bar yields an offset below\n   * zero, but to display the seek target on the seek bar, we need to limit it to zero.\n   *\n   * @param offset the offset to sanitize\n   * @returns {number} the sanitized offset.\n   */\n  private sanitizeOffset(offset: number) {\n    // Since we track mouse moves over the whole document, the target can be outside the seek range,\n    // and we need to limit it to the [0, 1] range.\n    if (offset < 0) {\n      offset = 0;\n    } else if (offset > 1) {\n      offset = 1;\n    }\n\n    return offset;\n  }\n\n  /**\n   * Sets the position of the playback position indicator.\n   * @param percent a number between 0 and 100 as returned by the player\n   */\n  setPlaybackPosition(percent: number) {\n    this.playbackPositionPercentage = percent;\n\n    // Set position of the bar\n    this.setPosition(this.seekBarPlaybackPosition, percent);\n\n    // Set position of the marker\n    let px = (this.config.vertical ? this.seekBar.height() : this.seekBar.width()) / 100 * percent;\n    if (this.config.vertical) {\n      px = this.seekBar.height() - px;\n    }\n    let style = this.config.vertical ?\n      // -ms-transform required for IE9\n      { 'transform': 'translateY(' + px + 'px)', '-ms-transform': 'translateY(' + px + 'px)' } :\n      { 'transform': 'translateX(' + px + 'px)', '-ms-transform': 'translateX(' + px + 'px)' };\n    this.seekBarPlaybackPositionMarker.css(style);\n  }\n\n  /**\n   * Refreshes the playback position. Can be used by subclasses to refresh the position when\n   * the size of the component changes.\n   */\n  protected refreshPlaybackPosition() {\n    this.setPlaybackPosition(this.playbackPositionPercentage);\n  }\n\n  /**\n   * Sets the position until which media is buffered.\n   * @param percent a number between 0 and 100\n   */\n  setBufferPosition(percent: number) {\n    this.setPosition(this.seekBarBufferPosition, percent);\n  }\n\n  /**\n   * Sets the position where a seek, if executed, would jump to.\n   * @param percent a number between 0 and 100\n   */\n  setSeekPosition(percent: number) {\n    this.setPosition(this.seekBarSeekPosition, percent);\n  }\n\n  /**\n   * Set the actual position (width or height) of a DOM element that represent a bar in the seek bar.\n   * @param element the element to set the position for\n   * @param percent a number between 0 and 100\n   */\n  private setPosition(element: DOM, percent: number) {\n    let scale = percent / 100;\n    let style = this.config.vertical ?\n      // -ms-transform required for IE9\n      { 'transform': 'scaleY(' + scale + ')', '-ms-transform': 'scaleY(' + scale + ')' } :\n      { 'transform': 'scaleX(' + scale + ')', '-ms-transform': 'scaleX(' + scale + ')' };\n    element.css(style);\n  }\n\n  /**\n   * Puts the seek bar into or out of seeking state by adding/removing a class to the DOM element. This can be used\n   * to adjust the styling while seeking.\n   *\n   * @param seeking should be true when entering seek state, false when exiting the seek state\n   */\n  setSeeking(seeking: boolean) {\n    if (seeking) {\n      this.getDomElement().addClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n    } else {\n      this.getDomElement().removeClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n    }\n  }\n\n  /**\n   * Checks if the seek bar is currently in the seek state.\n   * @returns {boolean} true if in seek state, else false\n   */\n  isSeeking(): boolean {\n    return this.getDomElement().hasClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n  }\n\n  /**\n   * Checks if the seek bar has a {@link SeekBarLabel}.\n   * @returns {boolean} true if the seek bar has a label, else false\n   */\n  hasLabel(): boolean {\n    return this.label != null;\n  }\n\n  /**\n   * Gets the label of this seek bar.\n   * @returns {SeekBarLabel} the label if this seek bar has a label, else null\n   */\n  getLabel(): SeekBarLabel | null {\n    return this.label;\n  }\n\n  protected onSeekEvent() {\n    this.seekBarEvents.onSeek.dispatch(this);\n  }\n\n  protected onSeekPreviewEvent(percentage: number, scrubbing: boolean) {\n    let snappedMarker = this.getMarkerAtPosition(percentage);\n\n    if (this.label) {\n      this.label.getDomElement().css({\n        'left': (snappedMarker ? snappedMarker.time : percentage) + '%'\n      });\n    }\n\n    this.seekBarEvents.onSeekPreview.dispatch(this, {\n      scrubbing: scrubbing,\n      position: percentage,\n      marker: snappedMarker,\n    });\n  }\n\n  protected onSeekedEvent(percentage: number) {\n    this.seekBarEvents.onSeeked.dispatch(this, percentage);\n  }\n\n  /**\n   * Gets the event that is fired when a scrubbing seek operation is started.\n   * @returns {Event<SeekBar, NoArgs>}\n   */\n  get onSeek(): Event<SeekBar, NoArgs> {\n    return this.seekBarEvents.onSeek.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired during a scrubbing seek (to indicate that the seek preview, i.e. the video frame,\n   * should be updated), or during a normal seek preview when the seek bar is hovered (and the seek target,\n   * i.e. the seek bar label, should be updated).\n   * @returns {Event<SeekBar, SeekPreviewEventArgs>}\n   */\n  get onSeekPreview(): Event<SeekBar, SeekPreviewEventArgs> {\n    return this.seekBarEvents.onSeekPreview.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when a scrubbing seek has finished or when a direct seek is issued.\n   * @returns {Event<SeekBar, number>}\n   */\n  get onSeeked(): Event<SeekBar, number> {\n    return this.seekBarEvents.onSeeked.getEvent();\n  }\n\n\n  protected onShowEvent(): void {\n    super.onShowEvent();\n\n    // Refresh the position of the playback position when the seek bar becomes visible. To correctly set the position,\n    // the DOM element must be fully initialized an have its size calculated, because the position is set as an absolute\n    // value calculated from the size. This required size is not known when it is hidden.\n    // For such cases, we refresh the position here in onShow because here it is guaranteed that the component knows\n    // its size and can set the position correctly.\n    this.refreshPlaybackPosition();\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {Label, LabelConfig} from './label';\nimport {Component, ComponentConfig} from './component';\nimport {UIInstanceManager, SeekPreviewArgs} from '../uimanager';\nimport {StringUtils} from '../utils';\n\n/**\n * Configuration interface for a {@link SeekBarLabel}.\n */\nexport interface SeekBarLabelConfig extends ContainerConfig {\n  // nothing yet\n}\n\n/**\n * A label for a {@link SeekBar} that can display the seek target time, a thumbnail, and title (e.g. chapter title).\n */\nexport class SeekBarLabel extends Container<SeekBarLabelConfig> {\n\n  private timeLabel: Label<LabelConfig>;\n  private titleLabel: Label<LabelConfig>;\n  private numberLabel: Label<LabelConfig>;\n  private commentLabel: Label<LabelConfig>;\n  private avatarLabel: Label<LabelConfig>;\n  private thumbnail: Component<ComponentConfig>;\n  private metadata: Component<ComponentConfig>;\n\n  private timeFormat: string;\n\n  constructor(config: SeekBarLabelConfig = {}) {\n    super(config);\n\n    this.timeLabel = new Label({cssClasses: ['seekbar-label-time']});\n    this.titleLabel = new Label({cssClasses: ['seekbar-label-title']});\n    this.commentLabel = new Label({cssClasses: ['seekbar-label-comment']});\n    this.numberLabel = new Label({cssClasses: ['seekbar-label-number']});\n    this.avatarLabel = new Label({cssClasses: ['seekbar-label-avatar']});\n    this.thumbnail = new Component({cssClasses: ['seekbar-thumbnail']});\n    this.metadata = new Container({\n      components: [\n        new Container({\n          components: [\n            this.avatarLabel,\n            this.titleLabel,\n            this.numberLabel],\n          cssClass: 'seekbar-label-metadata-title',\n        }),\n        new Container({\n          components: [\n            this.commentLabel,\n            this.timeLabel],\n          cssClass: 'seekbar-label-metadata-content',\n        }),\n      ],\n      cssClass: 'seekbar-label-metadata'\n    });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-seekbar-label',\n      components: [new Container({\n        components: [\n          this.thumbnail,\n          this.metadata\n        ],\n        cssClass: 'seekbar-label-inner',\n      })],\n      hidden: true\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    uimanager.onSeekPreview.subscribe((sender, args: SeekPreviewArgs) => {\n      if (player.isLive()) {\n        let time = player.getMaxTimeShift() - player.getMaxTimeShift() * (args.position / 100);\n        this.setTime(time);\n      } else {\n        let percentage = 0;\n        if (args.marker) {\n          this.setTitleText(args.marker.title);\n          this.setSmashcutData(args.marker);\n          this.setTime(args.marker.time);\n          this.setThumbnail(null);\n          this.setBackground(true);\n        } else {\n          percentage = args.position;\n          this.setTitleText(null);\n          this.setSmashcutData(null);\n          let time = player.getDuration() * (percentage / 100);\n          this.setTime(time);\n          this.setThumbnail(player.getThumb(time));\n          this.setBackground(false);\n        }\n      }\n    });\n\n    let init = () => {\n      // Set time format depending on source duration\n      this.timeFormat = Math.abs(player.isLive() ? player.getMaxTimeShift() : player.getDuration()) >= 3600 ?\n        StringUtils.FORMAT_HHMMSS : StringUtils.FORMAT_MMSS;\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, init);\n    init();\n  }\n\n  /**\n   * Sets arbitrary text on the label.\n   * @param text the text to show on the label\n   */\n  setText(text: string) {\n    this.timeLabel.setText(text);\n  }\n\n  /**\n   * Sets a time to be displayed on the label.\n   * @param seconds the time in seconds to display on the label\n   */\n  setTime(seconds: number) {\n    this.setText(StringUtils.secondsToTime(seconds, this.timeFormat));\n  }\n\n  /**\n   * Sets the text on the title label.\n   * @param text the text to show on the label\n   */\n  setTitleText(text: string) {\n    this.titleLabel.setText(text);\n  }\n\n  setSmashcutData(marker: any) {\n    if (marker) {\n      this.commentLabel.setText(marker.comment);\n      this.numberLabel.setText(marker.number);\n      this.avatarLabel.setText(marker.avatar);\n    } else {\n      this.commentLabel.setText(null);\n      this.numberLabel.setText(null);\n      this.avatarLabel.setText(null);\n    }\n  }\n\n  /**\n   * Sets or removes a thumbnail on the label.\n   * @param thumbnail the thumbnail to display on the label or null to remove a displayed thumbnail\n   */\n  setThumbnail(thumbnail: bitmovin.player.Thumbnail = null) {\n    let thumbnailElement = this.thumbnail.getDomElement();\n\n    if (thumbnail == null) {\n      thumbnailElement.css({\n        'background-image': null,\n        'display': 'null',\n        'width': 'null',\n        'height': 'null'\n      });\n    }\n    else {\n      thumbnailElement.css({\n        'display': 'inherit',\n        'background-image': `url(${thumbnail.url})`,\n        'width': thumbnail.w + 'px',\n        'height': thumbnail.h + 'px',\n        'background-position': `-${thumbnail.x}px -${thumbnail.y}px`\n      });\n    }\n  }\n\n  setBackground(onOff: boolean) {\n    let metadataElement = this.metadata.getDomElement();\n\n    if (onOff) {\n      metadataElement.css({\n        'background': '#000'\n      });\n    }\n    else {\n      metadataElement.css({\n        'background': 'initial'\n      });\n    }\n  }\n}","import {ListSelector, ListSelectorConfig} from './listselector';\nimport {DOM} from '../dom';\n\n/**\n * A simple select box providing the possibility to select a single item out of a list of available items.\n *\n * DOM example:\n * <code>\n *     <select class='ui-selectbox'>\n *         <option value='key'>label</option>\n *         ...\n *     </select>\n * </code>\n */\nexport class SelectBox extends ListSelector<ListSelectorConfig> {\n\n  private selectElement: DOM;\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-selectbox'\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    let selectElement = new DOM('select', {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    this.selectElement = selectElement;\n    this.updateDomItems();\n\n    selectElement.on('change', () => {\n      let value = selectElement.val();\n      this.onItemSelectedEvent(value, false);\n    });\n\n    return selectElement;\n  }\n\n  protected updateDomItems(selectedValue: string = null) {\n    // Delete all children\n    this.selectElement.empty();\n\n    // Add updated children\n    for (let item of this.items) {\n      let optionElement = new DOM('option', {\n        'value': item.key\n      }).html(item.label);\n\n      if (item.key === selectedValue + '') { // convert selectedValue to string to catch 'null'/null case\n        optionElement.attr('selected', 'selected');\n      }\n\n      this.selectElement.append(optionElement);\n    }\n  }\n\n  protected onItemAddedEvent(value: string) {\n    super.onItemAddedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemRemovedEvent(value: string) {\n    super.onItemRemovedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemSelectedEvent(value: string, updateDomItems: boolean = true) {\n    super.onItemSelectedEvent(value);\n    if (updateDomItems) {\n      this.updateDomItems(value);\n    }\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {SelectBox} from './selectbox';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {VideoQualitySelectBox} from './videoqualityselectbox';\nimport {AudioQualitySelectBox} from './audioqualityselectbox';\nimport {Timeout} from '../timeout';\nimport {Event, EventDispatcher, NoArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link SettingsPanel}.\n */\nexport interface SettingsPanelConfig extends ContainerConfig {\n  /**\n   * The delay in milliseconds after which the settings panel will be hidden when there is no user interaction.\n   * Set to -1 to disable automatic hiding.\n   * Default: 3 seconds (3000)\n   */\n  hideDelay?: number;\n}\n\n/**\n * A panel containing a list of {@link SettingsPanelItem items} that represent labelled settings.\n */\nexport class SettingsPanel extends Container<SettingsPanelConfig> {\n\n  private static readonly CLASS_LAST = 'last';\n\n  private settingsPanelEvents = {\n    onSettingsStateChanged: new EventDispatcher<SettingsPanel, NoArgs>()\n  };\n\n  private hideTimeout: Timeout;\n\n  constructor(config: SettingsPanelConfig) {\n    super(config);\n\n    this.config = this.mergeConfig<SettingsPanelConfig>(config, {\n      cssClass: 'ui-settings-panel',\n      hideDelay: 3000\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <SettingsPanelConfig>this.getConfig(); // TODO fix generics type inference\n\n    if (config.hideDelay > -1) {\n      this.hideTimeout = new Timeout(config.hideDelay, () => {\n        this.hide();\n      });\n\n      this.onShow.subscribe(() => {\n        // Activate timeout when shown\n        this.hideTimeout.start();\n      });\n      this.getDomElement().on('mousemove', () => {\n        // Reset timeout on interaction\n        this.hideTimeout.reset();\n      });\n      this.onHide.subscribe(() => {\n        // Clear timeout when hidden from outside\n        this.hideTimeout.clear();\n      });\n    }\n\n    // Fire event when the state of a settings-item has changed\n    let settingsStateChangedHandler = () => {\n      this.onSettingsStateChangedEvent();\n\n      // Attach marker class to last visible item\n      let lastShownItem = null;\n      for (let component of this.getItems()) {\n        if (component instanceof SettingsPanelItem) {\n          component.getDomElement().removeClass(this.prefixCss(SettingsPanel.CLASS_LAST));\n          if (component.isShown()) {\n            lastShownItem = component;\n          }\n        }\n      }\n      if (lastShownItem) {\n        lastShownItem.getDomElement().addClass(this.prefixCss(SettingsPanel.CLASS_LAST));\n      }\n    };\n    for (let component of this.getItems()) {\n      if (component instanceof SettingsPanelItem) {\n        component.onActiveChanged.subscribe(settingsStateChangedHandler);\n      }\n    }\n  }\n\n  release(): void {\n    super.release();\n    if (this.hideTimeout) {\n      this.hideTimeout.clear();\n    }\n  }\n\n  /**\n   * Checks if there are active settings within this settings panel. An active setting is a setting that is visible\n   * and enabled, which the user can interact with.\n   * @returns {boolean} true if there are active settings, false if the panel is functionally empty to a user\n   */\n  hasActiveSettings(): boolean {\n    for (let component of this.getItems()) {\n      if (component.isActive()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private getItems(): SettingsPanelItem[] {\n    return <SettingsPanelItem[]>this.config.components;\n  }\n\n  protected onSettingsStateChangedEvent() {\n    this.settingsPanelEvents.onSettingsStateChanged.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when one or more {@link SettingsPanelItem items} have changed state.\n   * @returns {Event<SettingsPanel, NoArgs>}\n   */\n  get onSettingsStateChanged(): Event<SettingsPanel, NoArgs> {\n    return this.settingsPanelEvents.onSettingsStateChanged.getEvent();\n  }\n}\n\n/**\n * An item for a {@link SettingsPanel}, containing a {@link Label} and a component that configures a setting.\n * Supported setting components: {@link SelectBox}\n */\nexport class SettingsPanelItem extends Container<ContainerConfig> {\n\n  private label: Label<LabelConfig>;\n  private setting: SelectBox;\n\n  private settingsPanelItemEvents = {\n    onActiveChanged: new EventDispatcher<SettingsPanelItem, NoArgs>()\n  };\n\n  constructor(label: string, selectBox: SelectBox, config: ContainerConfig = {}) {\n    super(config);\n\n    this.label = new Label({ text: label });\n    this.setting = selectBox;\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-settings-panel-item',\n      components: [this.label, this.setting]\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let handleConfigItemChanged = () => {\n      // The minimum number of items that must be available for the setting to be displayed\n      // By default, at least two items must be available, else a selection is not possible\n      let minItemsToDisplay = 2;\n      // Audio/video quality select boxes contain an additional 'auto' mode, which in combination with a single\n      // available quality also does not make sense\n      if (this.setting instanceof VideoQualitySelectBox || this.setting instanceof AudioQualitySelectBox) {\n        minItemsToDisplay = 3;\n      }\n\n      // Hide the setting if no meaningful choice is available\n      if (this.setting.itemCount() < minItemsToDisplay) {\n        this.hide();\n      } else {\n        this.show();\n      }\n\n      // Visibility might have changed and therefore the active state might have changed so we fire the event\n      // TODO fire only when state has really changed (e.g. check if visibility has really changed)\n      this.onActiveChangedEvent();\n    };\n\n    this.setting.onItemAdded.subscribe(handleConfigItemChanged);\n    this.setting.onItemRemoved.subscribe(handleConfigItemChanged);\n\n    // Initialize hidden state\n    handleConfigItemChanged();\n  }\n\n  /**\n   * Checks if this settings panel item is active, i.e. visible and enabled and a user can interact with it.\n   * @returns {boolean} true if the panel is active, else false\n   */\n  isActive(): boolean {\n    return this.isShown();\n  }\n\n  protected onActiveChangedEvent() {\n    this.settingsPanelItemEvents.onActiveChanged.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the 'active' state of this item changes.\n   * @see #isActive\n   * @returns {Event<SettingsPanelItem, NoArgs>}\n   */\n  get onActiveChanged(): Event<SettingsPanelItem, NoArgs> {\n    return this.settingsPanelItemEvents.onActiveChanged.getEvent();\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {SettingsPanel} from './settingspanel';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Configuration interface for the {@link SettingsToggleButton}.\n */\nexport interface SettingsToggleButtonConfig extends ToggleButtonConfig {\n  /**\n   * The settings panel whose visibility the button should toggle.\n   */\n  settingsPanel: SettingsPanel;\n\n  /**\n   * Decides if the button should be automatically hidden when the settings panel does not contain any active settings.\n   * Default: true\n   */\n  autoHideWhenNoActiveSettings?: boolean;\n}\n\n/**\n * A button that toggles visibility of a settings panel.\n */\nexport class SettingsToggleButton extends ToggleButton<SettingsToggleButtonConfig> {\n\n  constructor(config: SettingsToggleButtonConfig) {\n    super(config);\n\n    if (!config.settingsPanel) {\n      throw new Error('Required SettingsPanel is missing');\n    }\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-settingstogglebutton',\n      text: 'Settings',\n      settingsPanel: null,\n      autoHideWhenNoActiveSettings: true\n    }, <SettingsToggleButtonConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <SettingsToggleButtonConfig>this.getConfig(); // TODO fix generics type inference\n    let settingsPanel = config.settingsPanel;\n\n    this.onClick.subscribe(() => {\n      settingsPanel.toggleHidden();\n    });\n    settingsPanel.onShow.subscribe(() => {\n      // Set toggle status to on when the settings panel shows\n      this.on();\n    });\n    settingsPanel.onHide.subscribe(() => {\n      // Set toggle status to off when the settings panel hides\n      this.off();\n    });\n\n    // Handle automatic hiding of the button if there are no settings for the user to interact with\n    if (config.autoHideWhenNoActiveSettings) {\n      // Setup handler to show/hide button when the settings change\n      let settingsPanelItemsChangedHandler = () => {\n        if (settingsPanel.hasActiveSettings()) {\n          if (this.isHidden()) {\n            this.show();\n          }\n        } else {\n          if (this.isShown()) {\n            this.hide();\n          }\n        }\n      };\n      // Wire the handler to the event\n      settingsPanel.onSettingsStateChanged.subscribe(settingsPanelItemsChangedHandler);\n      // Call handler for first init at startup\n      settingsPanelItemsChangedHandler();\n    }\n  }\n}","import {Component, ComponentConfig} from './component';\n\n/**\n * A dummy component that just reserves some space and does nothing else.\n */\nexport class Spacer extends Component<ComponentConfig> {\n\n  constructor(config: ComponentConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-spacer',\n    }, this.config);\n  }\n\n\n  protected onShowEvent(): void {\n    // disable event firing by overwriting and not calling super\n  }\n\n  protected onHideEvent(): void {\n    // disable event firing by overwriting and not calling super\n  }\n\n  protected onHoverChangedEvent(hovered: boolean): void {\n    // disable event firing by overwriting and not calling super\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport SubtitleCueEvent = bitmovin.player.SubtitleCueEvent;\nimport {Label, LabelConfig} from './label';\nimport {ComponentConfig, Component} from './component';\nimport {ControlBar} from './controlbar';\n\n/**\n * Overlays the player to display subtitles.\n */\nexport class SubtitleOverlay extends Container<ContainerConfig> {\n\n  private static readonly CLASS_CONTROLBAR_VISIBLE = 'controlbar-visible';\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitle-overlay',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let subtitleManager = new ActiveSubtitleManager();\n\n    player.addEventHandler(player.EVENT.ON_CUE_ENTER, (event: SubtitleCueEvent) => {\n      let labelToAdd = subtitleManager.cueEnter(event);\n\n      this.addComponent(labelToAdd);\n      this.updateComponents();\n\n      this.show();\n    });\n    player.addEventHandler(player.EVENT.ON_CUE_EXIT, (event: SubtitleCueEvent) => {\n      let labelToRemove = subtitleManager.cueExit(event);\n\n      this.removeComponent(labelToRemove);\n      this.updateComponents();\n\n      if (!subtitleManager.hasCues) {\n        this.hide();\n      }\n    });\n\n    let subtitleClearHandler = () => {\n      this.hide();\n      subtitleManager.clear();\n      this.removeComponents();\n      this.updateComponents();\n    };\n\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_CHANGED, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_SEEK, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, subtitleClearHandler);\n\n    uimanager.onComponentShow.subscribe((component: Component<ComponentConfig>) => {\n      if (component instanceof ControlBar) {\n        this.getDomElement().addClass(this.prefixCss(SubtitleOverlay.CLASS_CONTROLBAR_VISIBLE));\n      }\n    });\n    uimanager.onComponentHide.subscribe((component: Component<ComponentConfig>) => {\n      if (component instanceof ControlBar) {\n        this.getDomElement().removeClass(this.prefixCss(SubtitleOverlay.CLASS_CONTROLBAR_VISIBLE));\n      }\n    });\n\n    // Init\n    subtitleClearHandler();\n  }\n}\n\ninterface ActiveSubtitleCue {\n  event: SubtitleCueEvent;\n  label: SubtitleLabel;\n}\n\ninterface ActiveSubtitleCueMap {\n  [id: string]: ActiveSubtitleCue;\n}\n\nclass SubtitleLabel extends Label<LabelConfig> {\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitle-label'\n    }, this.config);\n  }\n}\n\nclass ActiveSubtitleManager {\n\n  private activeSubtitleCueMap: ActiveSubtitleCueMap;\n\n  constructor() {\n    this.activeSubtitleCueMap = {};\n  }\n\n  /**\n   * Calculates a unique ID for a subtitle cue, which is needed to associate an ON_CUE_ENTER with its ON_CUE_EXIT\n   * event so we can remove the correct subtitle in ON_CUE_EXIT when multiple subtitles are active at the same time.\n   * The start time plus the text should make a unique identifier, and in the only case where a collision\n   * can happen, two similar texts will displayed at a similar time so it does not matter which one we delete.\n   * The start time should always be known, because it is required to schedule the ON_CUE_ENTER event. The end time\n   * must not necessarily be known and therefore cannot be used for the ID.\n   * @param event\n   * @return {string}\n   */\n  private static calculateId(event: SubtitleCueEvent): string {\n    return event.start + event.text;\n  }\n\n  /**\n   * Adds a subtitle cue to the manager and returns the label that should be added to the subtitle overlay.\n   * @param event\n   * @return {SubtitleLabel}\n   */\n  cueEnter(event: SubtitleCueEvent): SubtitleLabel {\n    let id = ActiveSubtitleManager.calculateId(event);\n\n    let label = new SubtitleLabel({\n      // Prefer the HTML subtitle text if set, else use the plain text\n      text: event.html || event.text\n    });\n\n    this.activeSubtitleCueMap[id] = { event, label };\n\n    return label;\n  }\n\n  /**\n   * Removes the subtitle cue from the manager and returns the label that should be removed from the subtitle overlay.\n   * @param event\n   * @return {SubtitleLabel}\n   */\n  cueExit(event: SubtitleCueEvent): SubtitleLabel {\n    let id = ActiveSubtitleManager.calculateId(event);\n    let activeSubtitleCue = this.activeSubtitleCueMap[id];\n    delete this.activeSubtitleCueMap[id];\n    return activeSubtitleCue.label;\n  }\n\n  /**\n   * Returns the number of active subtitle cues.\n   * @return {number}\n   */\n  get cueCount(): number {\n    return Object.keys(this.activeSubtitleCueMap).length;\n  }\n\n  /**\n   * Returns true if there are active subtitle cues, else false.\n   * @return {boolean}\n   */\n  get hasCues(): boolean {\n    return this.cueCount > 0;\n  }\n\n  /**\n   * Removes all subtitle cues from the manager.\n   */\n  clear(): void {\n    this.activeSubtitleCueMap = {};\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\nimport SubtitleAddedEvent = bitmovin.player.SubtitleAddedEvent;\nimport SubtitleChangedEvent = bitmovin.player.SubtitleChangedEvent;\nimport SubtitleRemovedEvent = bitmovin.player.SubtitleRemovedEvent;\n\n/**\n * A select box providing a selection between available subtitle and caption tracks.\n */\nexport class SubtitleSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let getLabel = (id: string) => {\n      switch (id) {\n        case 'off' :\n          return 'Off'\n        case 'en' :\n          return 'English'\n        case 'fr' :\n          return 'Francais'\n        case 'de' :\n          return 'Deutsch'\n        case 'es' :\n          return 'Espaniol'\n        default:\n          return id\n      }\n    }\n\n    let updateSubtitles = () => {\n      this.clearItems();\n\n      for (let subtitle of player.getAvailableSubtitles()) {\n        this.addItem(subtitle.id, getLabel(subtitle.label));\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: SubtitleSelectBox, value: string) => {\n      player.setSubtitle(value === 'null' ? null : value);\n    });\n\n    // React to API events\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_ADDED, (event: SubtitleAddedEvent) => {\n      this.addItem(event.subtitle.id, event.subtitle.label);\n    });\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_CHANGED, (event: SubtitleChangedEvent) => {\n      this.selectItem(event.targetSubtitle.id);\n    });\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_REMOVED, (event: SubtitleRemovedEvent) => {\n      this.removeItem(event.subtitleId);\n    });\n\n    // Update subtitles when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateSubtitles);\n    // Update subtitles when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateSubtitles);\n\n    // Populate subtitles at startup\n    updateSubtitles();\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {MetadataLabel, MetadataLabelContent} from './metadatalabel';\n\n/**\n * Configuration interface for a {@link TitleBar}.\n */\nexport interface TitleBarConfig extends ContainerConfig {\n  /**\n   * Specifies if the title bar should stay hidden when no metadata label contains any text. Does not make a lot\n   * of sense if the title bar contains other components than just MetadataLabels (like in the default configuration).\n   * Default: false\n   */\n  keepHiddenWithoutMetadata?: boolean;\n}\n\n/**\n * Displays a title bar containing a label with the title of the video.\n */\nexport class TitleBar extends Container<TitleBarConfig> {\n\n  constructor(config: TitleBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-titlebar',\n      hidden: true,\n      components: [\n        new MetadataLabel({ content: MetadataLabelContent.Title }),\n        new MetadataLabel({ content: MetadataLabelContent.Description })\n      ],\n      keepHiddenWithoutMetadata: false,\n    }, <TitleBarConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <TitleBarConfig>this.getConfig();\n    let shouldBeShown = !this.isHidden();\n    let hasMetadataText = true; // Flag to track if any metadata label contains text\n\n    let checkMetadataTextAndUpdateVisibility = () => {\n      hasMetadataText = false;\n\n      // Iterate through metadata labels and check if at least one of them contains text\n      for (let component of this.getComponents()) {\n        if (component instanceof MetadataLabel) {\n          if (!component.isEmpty()) {\n            hasMetadataText = true;\n            break;\n          }\n        }\n      }\n\n      if (this.isShown()) {\n        // Hide a visible titlebar if it does not contain any text and the hidden flag is set\n        if (config.keepHiddenWithoutMetadata && !hasMetadataText) {\n          this.hide();\n        }\n      } else if (shouldBeShown) {\n        // Show a hidden titlebar if it should actually be shown\n        this.show();\n      }\n    };\n\n    // Listen to text change events to update the hasMetadataText flag when the metadata dynamically changes\n    for (let component of this.getComponents()) {\n      if (component instanceof MetadataLabel) {\n        component.onTextChanged.subscribe(checkMetadataTextAndUpdateVisibility);\n      }\n    }\n\n    uimanager.onControlsShow.subscribe(() => {\n      shouldBeShown = true;\n      if (!(config.keepHiddenWithoutMetadata && !hasMetadataText)) {\n        this.show();\n      }\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      shouldBeShown = false;\n      this.hide();\n    });\n\n    // init\n    checkMetadataTextAndUpdateVisibility();\n  }\n}","import {Button, ButtonConfig} from './button';\nimport {NoArgs, EventDispatcher, Event} from '../eventdispatcher';\n\n/**\n * Configuration interface for a toggle button component.\n */\nexport interface ToggleButtonConfig extends ButtonConfig {\n  /**\n   * The text on the button.\n   */\n  text?: string;\n}\n\n/**\n * A button that can be toggled between 'on' and 'off' states.\n */\nexport class ToggleButton<Config extends ToggleButtonConfig> extends Button<ToggleButtonConfig> {\n\n  private static readonly CLASS_ON = 'on';\n  private static readonly CLASS_OFF = 'off';\n\n  private onState: boolean;\n\n  private toggleButtonEvents = {\n    onToggle: new EventDispatcher<ToggleButton<Config>, NoArgs>(),\n    onToggleOn: new EventDispatcher<ToggleButton<Config>, NoArgs>(),\n    onToggleOff: new EventDispatcher<ToggleButton<Config>, NoArgs>()\n  };\n\n  constructor(config: ToggleButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-togglebutton'\n    }, this.config);\n  }\n\n  /**\n   * Toggles the button to the 'on' state.\n   */\n  on() {\n    if (this.isOff()) {\n      this.onState = true;\n      this.getDomElement().removeClass(this.prefixCss(ToggleButton.CLASS_OFF));\n      this.getDomElement().addClass(this.prefixCss(ToggleButton.CLASS_ON));\n\n      this.onToggleEvent();\n      this.onToggleOnEvent();\n    }\n  }\n\n  /**\n   * Toggles the button to the 'off' state.\n   */\n  off() {\n    if (this.isOn()) {\n      this.onState = false;\n      this.getDomElement().removeClass(this.prefixCss(ToggleButton.CLASS_ON));\n      this.getDomElement().addClass(this.prefixCss(ToggleButton.CLASS_OFF));\n\n      this.onToggleEvent();\n      this.onToggleOffEvent();\n    }\n  }\n\n  /**\n   * Toggle the button 'on' if it is 'off', or 'off' if it is 'on'.\n   */\n  toggle() {\n    if (this.isOn()) {\n      this.off();\n    } else {\n      this.on();\n    }\n  }\n\n  /**\n   * Checks if the toggle button is in the 'on' state.\n   * @returns {boolean} true if button is 'on', false if 'off'\n   */\n  isOn(): boolean {\n    return this.onState;\n  }\n\n  /**\n   * Checks if the toggle button is in the 'off' state.\n   * @returns {boolean} true if button is 'off', false if 'on'\n   */\n  isOff(): boolean {\n    return !this.isOn();\n  }\n\n  protected onClickEvent() {\n    super.onClickEvent();\n\n    // Fire the toggle event together with the click event\n    // (they are technically the same, only the semantics are different)\n    this.onToggleEvent();\n  }\n\n  protected onToggleEvent() {\n    this.toggleButtonEvents.onToggle.dispatch(this);\n  }\n\n  protected onToggleOnEvent() {\n    this.toggleButtonEvents.onToggleOn.dispatch(this);\n  }\n\n  protected onToggleOffEvent() {\n    this.toggleButtonEvents.onToggleOff.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggle(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggle.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled 'on'.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggleOn(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggleOn.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled 'off'.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggleOff(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggleOff.getEvent();\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\n\n/**\n * Animated analog TV static noise.\n */\nexport class TvNoiseCanvas extends Component<ComponentConfig> {\n\n  private canvas: DOM;\n\n  private canvasElement: HTMLCanvasElement;\n  private canvasContext: CanvasRenderingContext2D;\n  private canvasWidth = 160;\n  private canvasHeight = 90;\n  private interferenceHeight = 50;\n  private lastFrameUpdate: number = 0;\n  private frameInterval: number = 60;\n  private useAnimationFrame: boolean = !!window.requestAnimationFrame;\n  private noiseAnimationWindowPos: number;\n  private frameUpdateHandlerId: number;\n\n  constructor(config: ComponentConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-tvnoisecanvas'\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    return this.canvas = new DOM('canvas', { 'class': this.getCssClasses() });\n  }\n\n  start(): void {\n    this.canvasElement = <HTMLCanvasElement>this.canvas.getElements()[0];\n    this.canvasContext = this.canvasElement.getContext('2d');\n    this.noiseAnimationWindowPos = -this.canvasHeight;\n    this.lastFrameUpdate = 0;\n\n    this.canvasElement.width = this.canvasWidth;\n    this.canvasElement.height = this.canvasHeight;\n\n    this.renderFrame();\n  }\n\n  stop(): void {\n    if (this.useAnimationFrame) {\n      cancelAnimationFrame(this.frameUpdateHandlerId);\n    } else {\n      clearTimeout(this.frameUpdateHandlerId);\n    }\n  }\n\n  private renderFrame(): void {\n    // This code has been copied from the player controls.js and simplified\n\n    if (this.lastFrameUpdate + this.frameInterval > new Date().getTime()) {\n      // It's too early to render the next frame\n      this.scheduleNextRender();\n      return;\n    }\n\n    let currentPixelOffset;\n    let canvasWidth = this.canvasWidth;\n    let canvasHeight = this.canvasHeight;\n\n    // Create texture\n    let noiseImage = this.canvasContext.createImageData(canvasWidth, canvasHeight);\n\n    // Fill texture with noise\n    for (let y = 0; y < canvasHeight; y++) {\n      for (let x = 0; x < canvasWidth; x++) {\n        currentPixelOffset = (canvasWidth * y * 4) + x * 4;\n        noiseImage.data[currentPixelOffset] = Math.random() * 255;\n        if (y < this.noiseAnimationWindowPos || y > this.noiseAnimationWindowPos + this.interferenceHeight) {\n          noiseImage.data[currentPixelOffset] *= 0.85;\n        }\n        noiseImage.data[currentPixelOffset + 1] = noiseImage.data[currentPixelOffset];\n        noiseImage.data[currentPixelOffset + 2] = noiseImage.data[currentPixelOffset];\n        noiseImage.data[currentPixelOffset + 3] = 50;\n      }\n    }\n\n    // Put texture onto canvas\n    this.canvasContext.putImageData(noiseImage, 0, 0);\n\n    this.lastFrameUpdate = new Date().getTime();\n    this.noiseAnimationWindowPos += 7;\n    if (this.noiseAnimationWindowPos > canvasHeight) {\n      this.noiseAnimationWindowPos = -canvasHeight;\n    }\n\n    this.scheduleNextRender();\n  }\n\n  private scheduleNextRender(): void {\n    if (this.useAnimationFrame) {\n      this.frameUpdateHandlerId = window.requestAnimationFrame(this.renderFrame.bind(this));\n    } else {\n      this.frameUpdateHandlerId = setTimeout(this.renderFrame.bind(this), this.frameInterval);\n    }\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {DOM} from '../dom';\nimport {Timeout} from '../timeout';\nimport {PlayerUtils} from '../utils';\nimport PlayerResizeEvent = bitmovin.player.PlayerResizeEvent;\nimport {CancelEventArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link UIContainer}.\n */\nexport interface UIContainerConfig extends ContainerConfig {\n  /**\n   * The delay in milliseconds after which the control bar will be hidden when there is no user interaction.\n   * Default: 5 seconds (5000)\n   */\n  hideDelay?: number;\n}\n\n/**\n * The base container that contains all of the UI. The UIContainer is passed to the {@link UIManager} to build and\n * setup the UI.\n */\nexport class UIContainer extends Container<UIContainerConfig> {\n\n  private static readonly STATE_PREFIX = 'player-state-';\n\n  private static readonly FULLSCREEN = 'fullscreen';\n  private static readonly BUFFERING = 'buffering';\n  private static readonly REMOTE_CONTROL = 'remote-control';\n  private static readonly CONTROLS_SHOWN = 'controls-shown';\n  private static readonly CONTROLS_HIDDEN = 'controls-hidden';\n\n  private uiHideTimeout: Timeout;\n\n  constructor(config: UIContainerConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <UIContainerConfig>{\n      cssClass: 'ui-uicontainer',\n      hideDelay: 5000,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.configureUIShowHide(player, uimanager);\n    this.configurePlayerStates(player, uimanager);\n  }\n\n  private configureUIShowHide(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let container = this.getDomElement();\n    let config = <UIContainerConfig>this.getConfig();\n\n    let isUiShown = false;\n    let isSeeking = false;\n    let isFirstTouch = true;\n\n    let showUi = () => {\n      if (!isUiShown) {\n        // Let subscribers know that they should reveal themselves\n        uimanager.onControlsShow.dispatch(this);\n        isUiShown = true;\n      }\n      // Don't trigger timeout while seeking (it will be triggered once the seek is finished) or casting\n      if (!isSeeking && !player.isCasting()) {\n        this.uiHideTimeout.start();\n      }\n    };\n\n    let hideUi = () => {\n      // Hide the UI only if it is shown, and if not casting\n      if (isUiShown && !player.isCasting()) {\n        // Issue a preview event to check if we are good to hide the controls\n        let previewHideEventArgs = <CancelEventArgs>{};\n        uimanager.onPreviewControlsHide.dispatch(this, previewHideEventArgs);\n\n        if (!previewHideEventArgs.cancel) {\n          // If the preview wasn't canceled, let subscribers know that they should now hide themselves\n          uimanager.onControlsHide.dispatch(this);\n          isUiShown = false;\n        } else {\n          // If the hide preview was canceled, continue to show UI\n          showUi();\n        }\n      }\n    };\n\n    // Timeout to defer UI hiding by the configured delay time\n    this.uiHideTimeout = new Timeout(config.hideDelay, hideUi);\n\n    // On touch displays, the first touch reveals the UI\n    container.on('touchend', (e) => {\n      if (!isUiShown) {\n        // Only if the UI is hidden, we prevent other actions (except for the first touch) and reveal the UI instead.\n        // The first touch is not prevented to let other listeners receive the event and trigger an initial action, e.g.\n        // the huge playback button can directly start playback instead of requiring a double tap which 1. reveals\n        // the UI and 2. starts playback.\n        if (isFirstTouch) {\n          isFirstTouch = false;\n        } else {\n          e.preventDefault();\n        }\n        showUi();\n      }\n    });\n    // When the mouse enters, we show the UI\n    container.on('mouseenter', () => {\n      showUi();\n    });\n    // When the mouse moves within, we show the UI\n    container.on('mousemove', () => {\n      showUi();\n    });\n    // When the mouse leaves, we can prepare to hide the UI, except a seek is going on\n    container.on('mouseleave', () => {\n      // When a seek is going on, the seek scrub pointer may exit the UI area while still seeking, and we do not hide\n      // the UI in such cases\n      if (!isSeeking) {\n        this.uiHideTimeout.start();\n      }\n    });\n\n    uimanager.onSeek.subscribe(() => {\n      this.uiHideTimeout.clear(); // Don't hide UI while a seek is in progress\n      isSeeking = true;\n    });\n    uimanager.onSeeked.subscribe(() => {\n      isSeeking = false;\n      this.uiHideTimeout.start(); // Re-enable UI hide timeout after a seek\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      showUi(); // Show UI when a Cast session has started (UI will then stay permanently on during the session)\n    });\n  }\n\n  private configurePlayerStates(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let container = this.getDomElement();\n\n    // Convert player states into CSS class names\n    let stateClassNames = <any>[];\n    for (let state in PlayerUtils.PlayerState) {\n      if (isNaN(Number(state))) {\n        let enumName = PlayerUtils.PlayerState[<any>PlayerUtils.PlayerState[state]];\n        stateClassNames[PlayerUtils.PlayerState[state]] =\n          this.prefixCss(UIContainer.STATE_PREFIX + enumName.toLowerCase());\n      }\n    }\n\n    let removeStates = () => {\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.IDLE]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PREPARED]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PLAYING]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PAUSED]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.FINISHED]);\n    };\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PREPARED]);\n    });\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PLAYING]);\n    });\n    player.addEventHandler(player.EVENT.ON_PAUSED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PAUSED]);\n    });\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.FINISHED]);\n    });\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.IDLE]);\n    });\n    // Init in current player state\n    container.addClass(stateClassNames[PlayerUtils.getState(player)]);\n\n    // Fullscreen marker class\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_ENTER, () => {\n      container.addClass(this.prefixCss(UIContainer.FULLSCREEN));\n    });\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_EXIT, () => {\n      container.removeClass(this.prefixCss(UIContainer.FULLSCREEN));\n    });\n    // Init fullscreen state\n    if (player.isFullscreen()) {\n      container.addClass(this.prefixCss(UIContainer.FULLSCREEN));\n    }\n\n    // Buffering marker class\n    player.addEventHandler(player.EVENT.ON_STALL_STARTED, () => {\n      container.addClass(this.prefixCss(UIContainer.BUFFERING));\n    });\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, () => {\n      container.removeClass(this.prefixCss(UIContainer.BUFFERING));\n    });\n    // Init buffering state\n    if (player.isStalled()) {\n      container.addClass(this.prefixCss(UIContainer.BUFFERING));\n    }\n\n    // RemoteControl marker class\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      container.addClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, () => {\n      container.removeClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    });\n    // Init RemoteControl state\n    if (player.isCasting()) {\n      container.addClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    }\n\n    // Controls visibility marker class\n    uimanager.onControlsShow.subscribe(() => {\n      container.removeClass(this.prefixCss(UIContainer.CONTROLS_HIDDEN));\n      container.addClass(this.prefixCss(UIContainer.CONTROLS_SHOWN));\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      container.removeClass(this.prefixCss(UIContainer.CONTROLS_SHOWN));\n      container.addClass(this.prefixCss(UIContainer.CONTROLS_HIDDEN));\n    });\n\n    // Layout size classes\n    let updateLayoutSizeClasses = (width: number, height: number) => {\n      container.removeClass(this.prefixCss('layout-max-width-400'));\n      container.removeClass(this.prefixCss('layout-max-width-600'));\n      container.removeClass(this.prefixCss('layout-max-width-800'));\n      container.removeClass(this.prefixCss('layout-max-width-1200'));\n\n      if (width <= 400) {\n        container.addClass(this.prefixCss('layout-max-width-400'));\n      } else if (width <= 600) {\n        container.addClass(this.prefixCss('layout-max-width-600'));\n      } else if (width <= 800) {\n        container.addClass(this.prefixCss('layout-max-width-800'));\n      } else if (width <= 1200) {\n        container.addClass(this.prefixCss('layout-max-width-1200'));\n      }\n    };\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, (e: PlayerResizeEvent) => {\n      // Convert strings (with \"px\" suffix) to ints\n      let width = Math.round(Number(e.width.substring(0, e.width.length - 2)));\n      let height = Math.round(Number(e.height.substring(0, e.height.length - 2)));\n\n      updateLayoutSizeClasses(width, height);\n    });\n\n    // Init layout state\n    updateLayoutSizeClasses(new DOM(player.getFigure()).width(), new DOM(player.getFigure()).height());\n  }\n\n  release(): void {\n    super.release();\n    this.uiHideTimeout.clear();\n  }\n\n  protected toDomElement(): DOM {\n    let container = super.toDomElement();\n\n    // Detect flexbox support (not supported in IE9)\n    if (document && typeof document.createElement('p').style.flex !== 'undefined') {\n      container.addClass(this.prefixCss('flexbox'));\n    } else {\n      container.addClass(this.prefixCss('no-flexbox'));\n    }\n\n    return container;\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between 'auto' and the available video qualities.\n */\nexport class VideoQualitySelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let updateVideoQualities = () => {\n      let videoQualities = player.getAvailableVideoQualities();\n\n      this.clearItems();\n\n      // Add entry for automatic quality switching (default setting)\n      this.addItem('Auto', 'Auto');\n\n      // Add video qualities\n      for (let videoQuality of videoQualities) {\n        this.addItem(videoQuality.id, videoQuality.label);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: VideoQualitySelectBox, value: string) => {\n      player.setVideoQuality(value);\n    });\n\n    // Update qualities when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateVideoQualities);\n    // Update qualities when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateVideoQualities);\n    // Update quality selection when quality is changed (from outside)\n    player.addEventHandler(player.EVENT.ON_VIDEO_DOWNLOAD_QUALITY_CHANGE, () => {\n      let data = player.getDownloadedVideoData();\n      this.selectItem(data.isAuto ? 'Auto' : data.id);\n    });\n\n    // Populate qualities at startup\n    updateVideoQualities();\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {VolumeSlider} from './volumeslider';\nimport {VolumeToggleButton} from './volumetogglebutton';\nimport {UIInstanceManager} from '../uimanager';\nimport {Timeout} from '../timeout';\n\n/**\n * Configuration interface for a {@link VolumeControlButton}.\n */\nexport interface VolumeControlButtonConfig extends ContainerConfig {\n  /**\n   * The delay after which the volume slider will be hidden when there is no user interaction.\n   * Care must be taken that the delay is long enough so users can reach the slider from the toggle button, e.g. by\n   * mouse movement. If the delay is too short, the sliders disappears before the mouse pointer has reached it and\n   * the user is not able to use it.\n   * Default: 500ms\n   */\n  hideDelay?: number;\n  /**\n   * Specifies if the volume slider should be vertically or horizontally aligned.\n   * Default: true\n   */\n  vertical?: boolean;\n}\n\n/**\n * A composite volume control that consists of and internally manages a volume control button that can be used\n * for muting, and a (depending on the CSS style, e.g. slide-out) volume control bar.\n */\nexport class VolumeControlButton extends Container<VolumeControlButtonConfig> {\n\n  private volumeToggleButton: VolumeToggleButton;\n  private volumeSlider: VolumeSlider;\n\n  private volumeSliderHideTimeout: Timeout;\n\n  constructor(config: VolumeControlButtonConfig = {}) {\n    super(config);\n\n    this.volumeToggleButton = new VolumeToggleButton();\n    this.volumeSlider = new VolumeSlider({\n      vertical: config.vertical != null ? config.vertical : true,\n      hidden: true\n    });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-volumecontrolbutton',\n      components: [this.volumeToggleButton, this.volumeSlider],\n      hideDelay: 500\n    }, <VolumeControlButtonConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let volumeToggleButton = this.getVolumeToggleButton();\n    let volumeSlider = this.getVolumeSlider();\n\n    this.volumeSliderHideTimeout = new Timeout((<VolumeControlButtonConfig>this.getConfig()).hideDelay, () => {\n      volumeSlider.hide();\n    });\n\n    /*\n     * Volume Slider visibility handling\n     *\n     * The volume slider shall be visible while the user hovers the mute toggle button, while the user hovers the\n     * volume slider, and while the user slides the volume slider. If none of these situations are true, the slider\n     * shall disappear.\n     */\n    let volumeSliderHovered = false;\n    volumeToggleButton.getDomElement().on('mouseenter', () => {\n      // Show volume slider when mouse enters the button area\n      if (volumeSlider.isHidden()) {\n        volumeSlider.show();\n      }\n      // Avoid hiding of the slider when button is hovered\n      this.volumeSliderHideTimeout.clear();\n    });\n    volumeToggleButton.getDomElement().on('mouseleave', () => {\n      // Hide slider delayed when button is left\n      this.volumeSliderHideTimeout.reset();\n    });\n    volumeSlider.getDomElement().on('mouseenter', () => {\n      // When the slider is entered, cancel the hide timeout activated by leaving the button\n      this.volumeSliderHideTimeout.clear();\n      volumeSliderHovered = true;\n    });\n    volumeSlider.getDomElement().on('mouseleave', () => {\n      // When mouse leaves the slider, only hide it if there is no slide operation in progress\n      if (volumeSlider.isSeeking()) {\n        this.volumeSliderHideTimeout.clear();\n      } else {\n        this.volumeSliderHideTimeout.reset();\n      }\n      volumeSliderHovered = false;\n    });\n    volumeSlider.onSeeked.subscribe(() => {\n      // When a slide operation is done and the slider not hovered (mouse outside slider), hide slider delayed\n      if (!volumeSliderHovered) {\n        this.volumeSliderHideTimeout.reset();\n      }\n    });\n  }\n\n  release(): void {\n    super.release();\n    this.volumeSliderHideTimeout.clear();\n  }\n\n  /**\n   * Provides access to the internally managed volume toggle button.\n   * @returns {VolumeToggleButton}\n   */\n  getVolumeToggleButton(): VolumeToggleButton {\n    return this.volumeToggleButton;\n  }\n\n  /**\n   * Provides access to the internally managed volume silder.\n   * @returns {VolumeSlider}\n   */\n  getVolumeSlider(): VolumeSlider {\n    return this.volumeSlider;\n  }\n}","import {SeekBar, SeekBarConfig} from './seekbar';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Configuration interface for the {@link VolumeSlider} component.\n */\nexport interface VolumeSliderConfig extends SeekBarConfig {\n  /**\n   * Specifies if the volume slider should be automatically hidden when volume control is prohibited by the\n   * browser or platform. This currently only applies to iOS.\n   * Default: true\n   */\n  hideIfVolumeControlProhibited: boolean;\n}\n\n/**\n * A simple volume slider component to adjust the player's volume setting.\n */\nexport class VolumeSlider extends SeekBar {\n\n  constructor(config: SeekBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <VolumeSliderConfig>{\n      cssClass: 'ui-volumeslider',\n      hideIfVolumeControlProhibited: true,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager, false);\n\n    let config = <VolumeSliderConfig>this.getConfig();\n\n    if (config.hideIfVolumeControlProhibited && !this.detectVolumeControlAvailability(player)) {\n      this.hide();\n\n      // We can just return from here, because the user will never interact with the control and any configured\n      // functionality would only eat resources for no reason.\n      return;\n    }\n\n    let volumeChangeHandler = () => {\n      if (player.isMuted()) {\n        this.setPlaybackPosition(0);\n        this.setBufferPosition(0);\n      } else {\n        this.setPlaybackPosition(player.getVolume());\n\n        this.setBufferPosition(player.getVolume());\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_VOLUME_CHANGED, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_MUTED, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_UNMUTED, volumeChangeHandler);\n\n    this.onSeekPreview.subscribe((sender, args) => {\n      if (args.scrubbing) {\n        player.setVolume(args.position);\n      }\n    });\n    this.onSeeked.subscribe((sender, percentage) => {\n      player.setVolume(percentage);\n    });\n\n    // Update the volume slider marker when the player resized, a source is loaded and player is ready,\n    // or the UI is configured. Check the seekbar for a detailed description.\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => {\n      this.refreshPlaybackPosition();\n    });\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      this.refreshPlaybackPosition();\n    });\n    uimanager.onConfigured.subscribe(() => {\n      this.refreshPlaybackPosition();\n    });\n\n    // Init volume bar\n    volumeChangeHandler();\n  }\n\n  private detectVolumeControlAvailability(player: bitmovin.player.Player): boolean {\n    // Store current player state so we can restore it later\n    let volume = player.getVolume();\n    let muted = player.isMuted();\n    let playing = player.isPlaying();\n\n    /*\n     * \"On iOS devices, the audio level is always under the users physical control. The volume property is not\n     * settable in JavaScript. Reading the volume property always returns 1.\"\n     * https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html\n     *\n     * Our player API returns a volume range of [0, 100] so we need to check for 100 instead of 1.\n     */\n\n    // Only if the volume is 100, there's the possibility we are on a volume-control-restricted iOS device\n    if (volume === 100) {\n      // We set the volume to zero (that's the only value that does not unmute a muted player!)\n      player.setVolume(0);\n      // Then we check if the value is still 100\n      if (player.getVolume() === 100) {\n        // If the volume stayed at 100, we're on a volume-control-restricted device\n        return false;\n      } else {\n        // We can control volume, so we must restore the previous player state\n        player.setVolume(volume);\n        if (muted) {\n          player.mute();\n        }\n        if (playing) {\n          // The volume restore above pauses autoplay on mobile devices (e.g. Android) so we need to resume playback\n          // (We cannot check isPaused() here because it is not set when playback is prohibited by the mobile platform)\n          player.play();\n        }\n        return true;\n      }\n    } else {\n      // Volume is not 100, so we're definitely not on a volume-control-restricted iOS device\n      return true;\n    }\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles audio muting.\n */\nexport class VolumeToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-volumetogglebutton',\n      text: 'Volume/Mute'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let muteStateHandler = () => {\n      if (player.isMuted()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    let volumeLevelHandler = () => {\n      // Toggle low class to display low volume icon below 50% volume\n      if (player.getVolume() < 50) {\n        this.getDomElement().addClass(this.prefixCss('low'));\n      } else {\n        this.getDomElement().removeClass(this.prefixCss('low'));\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_MUTED, muteStateHandler);\n    player.addEventHandler(player.EVENT.ON_UNMUTED, muteStateHandler);\n    player.addEventHandler(player.EVENT.ON_VOLUME_CHANGED, volumeLevelHandler);\n\n    this.onClick.subscribe(() => {\n      if (player.isMuted()) {\n        player.unmute();\n      } else {\n        player.mute();\n      }\n    });\n\n    // Startup init\n    muteStateHandler();\n    volumeLevelHandler();\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles the video view between normal/mono and VR/stereo.\n */\nexport class VRToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-vrtogglebutton',\n      text: 'VR'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let isVRConfigured = () => {\n      // VR availability cannot be checked through getVRStatus() because it is asynchronously populated and not\n      // available at UI initialization. As an alternative, we check the VR settings in the config.\n      // TODO use getVRStatus() through isVRStereoAvailable() once the player has been rewritten and the status is\n      // available in ON_READY\n      let config = player.getConfig();\n      return config.source && config.source.vr && config.source.vr.contentType !== 'none';\n    };\n\n    let isVRStereoAvailable = () => {\n      return player.getVRStatus().contentType !== 'none';\n    };\n\n    let vrStateHandler = () => {\n      if (isVRConfigured() && isVRStereoAvailable()) {\n        this.show(); // show button in case it is hidden\n\n        if (player.getVRStatus().isStereo) {\n          this.on();\n        } else {\n          this.off();\n        }\n      } else {\n        this.hide(); // hide button if no stereo mode available\n      }\n    };\n\n    let vrButtonVisibilityHandler = () => {\n      if (isVRConfigured()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_VR_MODE_CHANGED, vrStateHandler);\n    player.addEventHandler(player.EVENT.ON_VR_STEREO_CHANGED, vrStateHandler);\n    player.addEventHandler(player.EVENT.ON_VR_ERROR, vrStateHandler);\n    // Hide button when VR source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, vrButtonVisibilityHandler);\n    // Show button when a new source is loaded and it's VR\n    player.addEventHandler(player.EVENT.ON_READY, vrButtonVisibilityHandler);\n\n    this.onClick.subscribe(() => {\n      if (!isVRStereoAvailable()) {\n        if (console) {\n          console.log('No VR content');\n        }\n      } else {\n        if (player.getVRStatus().isStereo) {\n          player.setVRStereo(false);\n        } else {\n          player.setVRStereo(true);\n        }\n      }\n    });\n\n    // Set startup visibility\n    vrButtonVisibilityHandler();\n  }\n}","import {ClickOverlay, ClickOverlayConfig} from './clickoverlay';\n\n/**\n * Configuration interface for a {@link ClickOverlay}.\n */\nexport interface WatermarkConfig extends ClickOverlayConfig {\n  // nothing yet\n}\n\n/**\n * A watermark overlay with a clickable logo.\n */\nexport class Watermark extends ClickOverlay {\n\n  constructor(config: WatermarkConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-watermark',\n      url: 'http://bitmovin.com'\n    }, <WatermarkConfig>this.config);\n  }\n}","export interface Offset {\n  left: number;\n  top: number;\n}\n\n/**\n * Simple DOM manipulation and DOM element event handling modeled after jQuery (as replacement for jQuery).\n *\n * Like jQuery, DOM operates on single elements and lists of elements. For example: creating an element returns a DOM\n * instance with a single element, selecting elements returns a DOM instance with zero, one, or many elements. Similar\n * to jQuery, setters usually affect all elements, while getters operate on only the first element.\n * Also similar to jQuery, most methods (except getters) return the DOM instance facilitating easy chaining of method\n * calls.\n *\n * Built with the help of: http://youmightnotneedjquery.com/\n */\nexport class DOM {\n\n  private document: Document;\n\n  /**\n   * The list of elements that the instance wraps. Take care that not all methods can operate on the whole list,\n   * getters usually just work on the first element.\n   */\n  private elements: HTMLElement[];\n\n  /**\n   * Creates a DOM element.\n   * @param tagName the tag name of the DOM element\n   * @param attributes a list of attributes of the element\n   */\n  constructor(tagName: string, attributes: {[name: string]: string});\n  /**\n   * Selects all elements from the DOM that match the specified selector.\n   * @param selector the selector to match DOM elements with\n   */\n  constructor(selector: string);\n  /**\n   * Wraps a plain HTMLElement with a DOM instance.\n   * @param element the HTMLElement to wrap with DOM\n   */\n  constructor(element: HTMLElement);\n  /**\n   * Wraps a list of plain HTMLElements with a DOM instance.\n   * @param element the HTMLElements to wrap with DOM\n   */\n  constructor(elements: HTMLElement[]);\n  /**\n   * Wraps the document with a DOM instance. Useful to attach event listeners to the document.\n   * @param document the document to wrap\n   */\n  constructor(document: Document);\n  constructor(something: string | HTMLElement | HTMLElement[] | Document, attributes?: {[name: string]: string}) {\n    this.document = document; // Set the global document to the local document field\n\n    if (something instanceof Array) {\n      if (something.length > 0 && something[0] instanceof HTMLElement) {\n        let elements = something;\n        this.elements = elements;\n      }\n    }\n    else if (something instanceof HTMLElement) {\n      let element = something;\n      this.elements = [element];\n    }\n    else if (something instanceof Document) {\n      // When a document is passed in, we do not do anything with it, but by setting this.elements to null\n      // we give the event handling method a means to detect if the events should be registered on the document\n      // instead of elements.\n      this.elements = null;\n    }\n    else if (attributes) {\n      let tagName = something;\n      let element = document.createElement(tagName);\n\n      for (let attributeName in attributes) {\n        let attributeValue = attributes[attributeName];\n        element.setAttribute(attributeName, attributeValue);\n      }\n\n      this.elements = [element];\n    }\n    else {\n      let selector = something;\n      this.elements = this.findChildElements(selector);\n    }\n  }\n\n  /**\n   * Gets the number of elements that this DOM instance currently holds.\n   * @returns {number} the number of elements\n   */\n  get length(): number {\n    return this.elements ? this.elements.length : 0;\n  }\n\n  /**\n   * Gets the HTML elements that this DOM instance currently holds.\n   * @returns {HTMLElement[]} the raw HTML elements\n   */\n  getElements(): HTMLElement[] {\n    return this.elements;\n  }\n\n  /**\n   * A shortcut method for iterating all elements. Shorts this.elements.forEach(...) to this.forEach(...).\n   * @param handler the handler to execute an operation on an element\n   */\n  private forEach(handler: (element: HTMLElement) => void): void {\n    this.elements.forEach((element) => {\n      handler(element);\n    });\n  }\n\n  private findChildElementsOfElement(element: HTMLElement | Document, selector: string): HTMLElement[] {\n    let childElements = element.querySelectorAll(selector);\n\n    // Convert NodeList to Array\n    // https://toddmotto.com/a-comprehensive-dive-into-nodelists-arrays-converting-nodelists-and-understanding-the-dom/\n    return [].slice.call(childElements);\n  }\n\n  private findChildElements(selector: string): HTMLElement[] {\n    let allChildElements = <HTMLElement[]>[];\n\n    if (this.elements) {\n      this.forEach((element) => {\n        allChildElements = allChildElements.concat(this.findChildElementsOfElement(element, selector));\n      });\n    }\n    else {\n      return this.findChildElementsOfElement(document, selector);\n    }\n\n    return allChildElements;\n  }\n\n  /**\n   * Finds all child elements of all elements matching the supplied selector.\n   * @param selector the selector to match with child elements\n   * @returns {DOM} a new DOM instance representing all matched children\n   */\n  find(selector: string): DOM {\n    let allChildElements = this.findChildElements(selector);\n    return new DOM(allChildElements);\n  }\n\n  /**\n   * Returns a string of the inner HTML content of the first element.\n   */\n  html(): string;\n  /**\n   * Sets the inner HTML content of all elements.\n   * @param content a string of plain text or HTML markup\n   */\n  html(content: string): DOM;\n  html(content?: string): string | DOM {\n    if (arguments.length > 0) {\n      return this.setHtml(content);\n    }\n    else {\n      return this.getHtml();\n    }\n  }\n\n  private getHtml(): string | null {\n    return this.elements[0].innerHTML;\n  }\n\n  private setHtml(content: string): DOM {\n    if (content === undefined || content == null) {\n      // Set to empty string to avoid innerHTML getting set to 'undefined' (all browsers) or 'null' (IE9)\n      content = '';\n    }\n\n    this.forEach((element) => {\n      element.innerHTML = content;\n    });\n\n    return this;\n  }\n\n  /**\n   * Clears the inner HTML of all elements (deletes all children).\n   * @returns {DOM}\n   */\n  empty(): DOM {\n    this.forEach((element) => {\n      element.innerHTML = '';\n    });\n    return this;\n  }\n\n  /**\n   * Returns the current value of the first form element, e.g. the selected value of a select box or the text if an\n   * input field.\n   * @returns {string} the value of a form element\n   */\n  val(): string {\n    let element = this.elements[0];\n\n    if (element instanceof HTMLSelectElement || element instanceof HTMLInputElement) {\n      return element.value;\n    }\n    else {\n      // TODO add support for missing form elements\n      throw new Error(`val() not supported for ${typeof element}`);\n    }\n  }\n\n  /**\n   * Returns the value of an attribute on the first element.\n   * @param attribute\n   */\n  attr(attribute: string): string | null;\n  /**\n   * Sets an attribute on all elements.\n   * @param attribute the name of the attribute\n   * @param value the value of the attribute\n   */\n  attr(attribute: string, value: string): DOM;\n  attr(attribute: string, value?: string): string | null | DOM {\n    if (arguments.length > 1) {\n      return this.setAttr(attribute, value);\n    }\n    else {\n      return this.getAttr(attribute);\n    }\n  }\n\n  private getAttr(attribute: string): string | null {\n    return this.elements[0].getAttribute(attribute);\n  }\n\n  private setAttr(attribute: string, value: string): DOM {\n    this.forEach((element) => {\n      element.setAttribute(attribute, value);\n    });\n    return this;\n  }\n\n  /**\n   * Returns the value of a data element on the first element.\n   * @param dataAttribute the name of the data attribute without the 'data-' prefix\n   */\n  data(dataAttribute: string): string | null;\n  /**\n   * Sets a data attribute on all elements.\n   * @param dataAttribute the name of the data attribute without the 'data-' prefix\n   * @param value the value of the data attribute\n   */\n  data(dataAttribute: string, value: string): DOM;\n  data(dataAttribute: string, value?: string): string | null | DOM {\n    if (arguments.length > 1) {\n      return this.setData(dataAttribute, value);\n    }\n    else {\n      return this.getData(dataAttribute);\n    }\n  }\n\n  private getData(dataAttribute: string): string | null {\n    return this.elements[0].getAttribute('data-' + dataAttribute);\n  }\n\n  private setData(dataAttribute: string, value: string): DOM {\n    this.forEach((element) => {\n      element.setAttribute('data-' + dataAttribute, value);\n    });\n    return this;\n  }\n\n  /**\n   * Appends one or more DOM elements as children to all elements.\n   * @param childElements the chrild elements to append\n   * @returns {DOM}\n   */\n  append(...childElements: DOM[]): DOM {\n    this.forEach((element) => {\n      childElements.forEach((childElement) => {\n        childElement.elements.forEach((_, index) => {\n          element.appendChild(childElement.elements[index]);\n        });\n      });\n    });\n    return this;\n  }\n\n  /**\n   * Removes all elements from the DOM.\n   */\n  remove(): void {\n    this.forEach((element) => {\n      let parent = element.parentNode;\n      if (parent) {\n        parent.removeChild(element);\n      }\n    });\n  }\n\n  /**\n   * Returns the offset of the first element from the document's top left corner.\n   * @returns {Offset}\n   */\n  offset(): Offset {\n    let element = this.elements[0];\n    let elementRect = element.getBoundingClientRect();\n    let htmlRect = document.body.parentElement.getBoundingClientRect();\n\n    // Virtual viewport scroll handling (e.g. pinch zoomed viewports in mobile browsers or desktop Chrome/Edge)\n    // 'normal' zooms and virtual viewport zooms (aka layout viewport) result in different\n    // element.getBoundingClientRect() results:\n    //  - with normal scrolls, the clientRect decreases with an increase in scroll(Top|Left)/page(X|Y)Offset\n    //  - with pinch zoom scrolls, the clientRect stays the same while scroll/pageOffset changes\n    // This means, that the combination of clientRect + scroll/pageOffset does not work to calculate the offset\n    // from the document's upper left origin when pinch zoom is used.\n    // To work around this issue, we do not use scroll/pageOffset but get the clientRect of the html element and\n    // subtract it from the element's rect, which always results in the offset from the document origin.\n    // NOTE: the current way of offset calculation was implemented specifically to track event positions on the\n    // seek bar, and it might break compatibility with jQuery's offset() method. If this ever turns out to be a\n    // problem, this method should be reverted to the old version and the offset calculation moved to the seek bar.\n\n    return {\n      top: elementRect.top - htmlRect.top,\n      left: elementRect.left - htmlRect.left\n    };\n  }\n\n  /**\n   * Returns the width of the first element.\n   * @returns {number} the width of the first element\n   */\n  width(): number {\n    // TODO check if this is the same as jQuery's width() (probably not)\n    return this.elements[0].offsetWidth;\n  }\n\n  /**\n   * Returns the height of the first element.\n   * @returns {number} the height of the first element\n   */\n  height(): number {\n    // TODO check if this is the same as jQuery's height() (probably not)\n    return this.elements[0].offsetHeight;\n  }\n\n  /**\n   * Attaches an event handler to one or more events on all elements.\n   * @param eventName the event name (or multiple names separated by space) to listen to\n   * @param eventHandler the event handler to call when the event fires\n   * @returns {DOM}\n   */\n  on(eventName: string, eventHandler: EventListenerOrEventListenerObject): DOM {\n    let events = eventName.split(' ');\n\n    events.forEach((event) => {\n      if (this.elements == null) {\n        this.document.addEventListener(event, eventHandler);\n      }\n      else {\n        this.forEach((element) => {\n          element.addEventListener(event, eventHandler);\n        });\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Removes an event handler from one or more events on all elements.\n   * @param eventName the event name (or multiple names separated by space) to remove the handler from\n   * @param eventHandler the event handler to remove\n   * @returns {DOM}\n   */\n  off(eventName: string, eventHandler: EventListenerOrEventListenerObject): DOM {\n    let events = eventName.split(' ');\n\n    events.forEach((event) => {\n      if (this.elements == null) {\n        this.document.removeEventListener(event, eventHandler);\n      }\n      else {\n        this.forEach((element) => {\n          element.removeEventListener(event, eventHandler);\n        });\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds the specified class(es) to all elements.\n   * @param className the class(es) to add, multiple classes separated by space\n   * @returns {DOM}\n   */\n  addClass(className: string): DOM {\n    this.forEach((element) => {\n      if (element.classList) {\n        element.classList.add(className);\n      }\n      else {\n        element.className += ' ' + className;\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Removed the specified class(es) from all elements.\n   * @param className the class(es) to remove, multiple classes separated by space\n   * @returns {DOM}\n   */\n  removeClass(className: string): DOM {\n    this.forEach((element) => {\n      if (element.classList) {\n        element.classList.remove(className);\n      }\n      else {\n        element.className = element.className.replace(\n          new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Checks if any of the elements has the specified class.\n   * @param className the class name to check\n   * @returns {boolean} true if one of the elements has the class attached, else if no element has it attached\n   */\n  hasClass(className: string): boolean {\n    let hasClass = false;\n\n    this.forEach((element) => {\n      if (element.classList) {\n        if (element.classList.contains(className)) {\n          // Since we are inside a handler, we can't just 'return true'. Instead, we save it to a variable\n          // and return it at the end of the function body.\n          hasClass = true;\n        }\n      }\n      else {\n        if (new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className)) {\n          // See comment above\n          hasClass = true;\n        }\n      }\n    });\n\n    return hasClass;\n  }\n\n  /**\n   * Returns the value of a CSS property of the first element.\n   * @param propertyName the name of the CSS property to retrieve the value of\n   */\n  css(propertyName: string): string | null;\n  /**\n   * Sets the value of a CSS property on all elements.\n   * @param propertyName the name of the CSS property to set the value for\n   * @param value the value to set for the given CSS property\n   */\n  css(propertyName: string, value: string): DOM;\n  /**\n   * Sets a collection of CSS properties and their values on all elements.\n   * @param propertyValueCollection an object containing pairs of property names and their values\n   */\n  css(propertyValueCollection: {[propertyName: string]: string}): DOM;\n  css(propertyNameOrCollection: string | {[propertyName: string]: string}, value?: string): string | null | DOM {\n    if (typeof propertyNameOrCollection === 'string') {\n      let propertyName = propertyNameOrCollection;\n\n      if (arguments.length === 2) {\n        return this.setCss(propertyName, value);\n      }\n      else {\n        return this.getCss(propertyName);\n      }\n    }\n    else {\n      let propertyValueCollection = propertyNameOrCollection;\n      return this.setCssCollection(propertyValueCollection);\n    }\n  }\n\n  private getCss(propertyName: string): string | null {\n    return getComputedStyle(this.elements[0])[<any>propertyName];\n  }\n\n  private setCss(propertyName: string, value: string): DOM {\n    this.forEach((element) => {\n      // <any> cast to resolve TS7015: http://stackoverflow.com/a/36627114/370252\n      element.style[<any>propertyName] = value;\n    });\n    return this;\n  }\n\n  private setCssCollection(ruleValueCollection: {[ruleName: string]: string}): DOM {\n    this.forEach((element) => {\n      // http://stackoverflow.com/a/34490573/370252\n      Object.assign(element.style, ruleValueCollection);\n    });\n\n    return this;\n  }\n}\n","import {ArrayUtils} from './utils';\n/**\n * Function interface for event listeners on the {@link EventDispatcher}.\n */\nexport interface EventListener<Sender, Args> {\n  (sender: Sender, args: Args): void;\n}\n\n/**\n * Empty type for creating {@link EventDispatcher event dispatchers} that do not carry any arguments.\n */\nexport interface NoArgs {\n}\n\n/**\n * Event args for an event that can be canceled.\n */\nexport interface CancelEventArgs extends NoArgs {\n  /**\n   * Gets or sets a flag whether the event should be canceled.\n   */\n  cancel?: boolean;\n}\n\n/**\n * Public interface that represents an event. Can be used to subscribe to and unsubscribe from events.\n */\nexport interface Event<Sender, Args> {\n  /**\n   * Subscribes an event listener to this event dispatcher.\n   * @param listener the listener to add\n   */\n  subscribe(listener: EventListener<Sender, Args>): void;\n\n  /**\n   * Subscribes an event listener to this event dispatcher that is only called once.\n   * @param listener the listener to add\n   */\n  subscribeOnce(listener: EventListener<Sender, Args>): void;\n\n  /**\n   * Subscribes an event listener to this event dispatcher that will be called at a limited rate with a minimum\n   * interval of the specified milliseconds.\n   * @param listener the listener to add\n   * @param rateMs the rate in milliseconds to which calling of the listeners should be limited\n   */\n  subscribeRateLimited(listener: EventListener<Sender, Args>, rateMs: number): void;\n\n  /**\n   * Unsubscribes a subscribed event listener from this dispatcher.\n   * @param listener the listener to remove\n   * @returns {boolean} true if the listener was successfully unsubscribed, false if it isn't subscribed on this\n   *   dispatcher\n   */\n  unsubscribe(listener: EventListener<Sender, Args>): boolean;\n}\n\n/**\n * Event dispatcher to subscribe and trigger events. Each event should have its own dispatcher.\n */\nexport class EventDispatcher<Sender, Args> implements Event<Sender, Args> {\n\n  private listeners: EventListenerWrapper<Sender, Args>[] = [];\n\n  constructor() {\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribe(listener: EventListener<Sender, Args>) {\n    this.listeners.push(new EventListenerWrapper(listener));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribeOnce(listener: EventListener<Sender, Args>) {\n    this.listeners.push(new EventListenerWrapper(listener, true));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribeRateLimited(listener: EventListener<Sender, Args>, rateMs: number) {\n    this.listeners.push(new RateLimitedEventListenerWrapper(listener, rateMs));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  unsubscribe(listener: EventListener<Sender, Args>): boolean {\n    // Iterate through listeners, compare with parameter, and remove if found\n    for (let i = 0; i < this.listeners.length; i++) {\n      let subscribedListener = this.listeners[i];\n      if (subscribedListener.listener === listener) {\n        ArrayUtils.remove(this.listeners, subscribedListener);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Removes all listeners from this dispatcher.\n   */\n  unsubscribeAll(): void {\n    this.listeners = [];\n  }\n\n  /**\n   * Dispatches an event to all subscribed listeners.\n   * @param sender the source of the event\n   * @param args the arguments for the event\n   */\n  dispatch(sender: Sender, args: Args = null) {\n    let listenersToRemove = [];\n\n    // Call every listener\n    for (let listener of this.listeners) {\n      listener.fire(sender, args);\n\n      if (listener.isOnce()) {\n        listenersToRemove.push(listener);\n      }\n    }\n\n    // Remove one-time listener\n    for (let listenerToRemove of listenersToRemove) {\n      ArrayUtils.remove(this.listeners, listenerToRemove);\n    }\n  }\n\n  /**\n   * Returns the event that this dispatcher manages and on which listeners can subscribe and unsubscribe event handlers.\n   * @returns {Event}\n   */\n  getEvent(): Event<Sender, Args> {\n    // For now, just cast the event dispatcher to the event interface. At some point in the future when the\n    // codebase grows, it might make sense to split the dispatcher into separate dispatcher and event classes.\n    return <Event<Sender, Args>>this;\n  }\n}\n\n/**\n * A basic event listener wrapper to manage listeners within the {@link EventDispatcher}. This is a 'private' class\n * for internal dispatcher use and it is therefore not exported.\n */\nclass EventListenerWrapper<Sender, Args> {\n\n  private eventListener: EventListener<Sender, Args>;\n  private once: boolean;\n\n  constructor(listener: EventListener<Sender, Args>, once: boolean = false) {\n    this.eventListener = listener;\n    this.once = once;\n  }\n\n  /**\n   * Returns the wrapped event listener.\n   * @returns {EventListener<Sender, Args>}\n   */\n  get listener(): EventListener<Sender, Args> {\n    return this.eventListener;\n  }\n\n  /**\n   * Fires the wrapped event listener with the given arguments.\n   * @param sender\n   * @param args\n   */\n  fire(sender: Sender, args: Args) {\n    this.eventListener(sender, args);\n  }\n\n  /**\n   * Checks if this listener is scheduled to be called only once.\n   * @returns {boolean} once if true\n   */\n  isOnce(): boolean {\n    return this.once;\n  }\n}\n\n/**\n * Extends the basic {@link EventListenerWrapper} with rate-limiting functionality.\n */\nclass RateLimitedEventListenerWrapper<Sender, Args> extends EventListenerWrapper<Sender, Args> {\n\n  private rateMs: number;\n  private rateLimitingEventListener: EventListener<Sender, Args>;\n\n  private lastFireTime: number;\n\n  constructor(listener: EventListener<Sender, Args>, rateMs: number) {\n    super(listener); // sets the event listener sink\n\n    this.rateMs = rateMs;\n    this.lastFireTime = 0;\n\n    // Wrap the event listener with an event listener that does the rate-limiting\n    this.rateLimitingEventListener = (sender: Sender, args: Args) => {\n      if (Date.now() - this.lastFireTime > this.rateMs) {\n        // Only if enough time since the previous call has passed, call the\n        // actual event listener and record the current time\n        this.fireSuper(sender, args);\n        this.lastFireTime = Date.now();\n      }\n    };\n  }\n\n  private fireSuper(sender: Sender, args: Args) {\n    // Fire the actual external event listener\n    super.fire(sender, args);\n  }\n\n  fire(sender: Sender, args: Args) {\n    // Fire the internal rate-limiting listener instead of the external event listener\n    this.rateLimitingEventListener(sender, args);\n  }\n}","export namespace Guid {\n\n  let guid = 1;\n\n  export function next() {\n    return guid++;\n  }\n}\n","/// <reference path='player.d.ts' />\nimport {UIManager, UIInstanceManager} from './uimanager';\nimport {Button} from './components/button';\nimport {ControlBar} from './components/controlbar';\nimport {FullscreenToggleButton} from './components/fullscreentogglebutton';\nimport {HugePlaybackToggleButton} from './components/hugeplaybacktogglebutton';\nimport {PlaybackTimeLabel, PlaybackTimeLabelMode} from './components/playbacktimelabel';\nimport {PlaybackToggleButton} from './components/playbacktogglebutton';\nimport {SeekBar} from './components/seekbar';\nimport {SelectBox} from './components/selectbox';\nimport {SettingsPanel, SettingsPanelItem} from './components/settingspanel';\nimport {SettingsToggleButton} from './components/settingstogglebutton';\nimport {ToggleButton} from './components/togglebutton';\nimport {VideoQualitySelectBox} from './components/videoqualityselectbox';\nimport {VolumeToggleButton} from './components/volumetogglebutton';\nimport {VRToggleButton} from './components/vrtogglebutton';\nimport {Watermark} from './components/watermark';\nimport {UIContainer} from './components/uicontainer';\nimport {Container} from './components/container';\nimport {Label} from './components/label';\nimport {AudioQualitySelectBox} from './components/audioqualityselectbox';\nimport {AudioTrackSelectBox} from './components/audiotrackselectbox';\nimport {CastStatusOverlay} from './components/caststatusoverlay';\nimport {CastToggleButton} from './components/casttogglebutton';\nimport {Component} from './components/component';\nimport {ErrorMessageOverlay} from './components/errormessageoverlay';\nimport {RecommendationOverlay} from './components/recommendationoverlay';\nimport {SeekBarLabel} from './components/seekbarlabel';\nimport {SubtitleOverlay} from './components/subtitleoverlay';\nimport {SubtitleSelectBox} from './components/subtitleselectbox';\nimport {TitleBar} from './components/titlebar';\nimport {VolumeControlButton} from './components/volumecontrolbutton';\nimport {ClickOverlay} from './components/clickoverlay';\nimport {AdSkipButton} from './components/adskipbutton';\nimport {AdMessageLabel} from './components/admessagelabel';\nimport {AdClickOverlay} from './components/adclickoverlay';\nimport {PlaybackSpeedSelectBox} from './components/playbackspeedselectbox';\nimport {HugeReplayButton} from './components/hugereplaybutton';\nimport {BufferingOverlay} from './components/bufferingoverlay';\nimport {CastUIContainer} from './components/castuicontainer';\nimport {PlaybackToggleOverlay} from './components/playbacktoggleoverlay';\nimport {CloseButton} from './components/closebutton';\nimport {MetadataLabel, MetadataLabelContent} from './components/metadatalabel';\nimport {AirPlayToggleButton} from './components/airplaytogglebutton';\nimport {VolumeSlider} from './components/volumeslider';\nimport {PictureInPictureToggleButton} from './components/pictureinpicturetogglebutton';\nimport {Spacer} from './components/spacer';\nimport {ArrayUtils, StringUtils, PlayerUtils, UIUtils, BrowserUtils} from './utils';\n\n// Object.assign polyfill for ES5/IE9\n// https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nif (typeof Object.assign !== 'function') {\n  Object.assign = function(target: any) {\n    'use strict';\n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    target = Object(target);\n    for (let index = 1; index < arguments.length; index++) {\n      let source = arguments[index];\n      if (source != null) {\n        for (let key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n    }\n    return target;\n  };\n}\n\n// Expose classes to window\n(window as any).bitmovin.playerui = {\n  // Management\n  UIManager,\n  UIInstanceManager,\n  // Utils\n  ArrayUtils,\n  StringUtils,\n  PlayerUtils,\n  UIUtils,\n  BrowserUtils,\n  // Components\n  AdClickOverlay,\n  AdMessageLabel,\n  AdSkipButton,\n  AirPlayToggleButton,\n  AudioQualitySelectBox,\n  AudioTrackSelectBox,\n  BufferingOverlay,\n  Button,\n  CastStatusOverlay,\n  CastToggleButton,\n  CastUIContainer,\n  ClickOverlay,\n  CloseButton,\n  Component,\n  Container,\n  ControlBar,\n  ErrorMessageOverlay,\n  FullscreenToggleButton,\n  HugePlaybackToggleButton,\n  HugeReplayButton,\n  Label,\n  MetadataLabel,\n  MetadataLabelContent,\n  PictureInPictureToggleButton,\n  PlaybackSpeedSelectBox,\n  PlaybackTimeLabel,\n  PlaybackTimeLabelMode,\n  PlaybackToggleButton,\n  PlaybackToggleOverlay,\n  RecommendationOverlay,\n  SeekBar,\n  SeekBarLabel,\n  SelectBox,\n  SettingsPanel,\n  SettingsPanelItem,\n  SettingsToggleButton,\n  Spacer,\n  SubtitleOverlay,\n  SubtitleSelectBox,\n  TitleBar,\n  ToggleButton,\n  UIContainer,\n  VideoQualitySelectBox,\n  VolumeControlButton,\n  VolumeSlider,\n  VolumeToggleButton,\n  VRToggleButton,\n  Watermark,\n};","// TODO change to internal (not exported) class, how to use in other files?\n/**\n * Executes a callback after a specified amount of time,\n * optionally repeatedly until stopped. When delay is <= 0\n * the timeout is disabled\n */\nexport class Timeout {\n\n  private delay: number;\n  private callback: () => void;\n  private repeat: boolean;\n  private timeoutHandle: number;\n\n  /**\n   * Creates a new timeout callback handler.\n   * @param delay the delay in milliseconds after which the callback should be executed\n   * @param callback the callback to execute after the delay time\n   * @param repeat if true, call the callback repeatedly in delay intervals\n   */\n  constructor(delay: number, callback: () => void, repeat: boolean = false) {\n    this.delay = delay;\n    this.callback = callback;\n    this.repeat = repeat;\n    this.timeoutHandle = 0;\n  }\n\n  /**\n   * Starts the timeout and calls the callback when the timeout delay has passed.\n   * @returns {Timeout} the current timeout (so the start call can be chained to the constructor)\n   */\n  start(): this {\n    this.reset();\n    return this;\n  }\n\n  /**\n   * Clears the timeout. The callback will not be called if clear is called during the timeout.\n   */\n  clear(): void {\n    clearTimeout(this.timeoutHandle);\n  }\n\n  /**\n   * Resets the passed timeout delay to zero. Can be used to defer the calling of the callback.\n   */\n  reset(): void {\n    let lastScheduleTime = 0;\n    let delayAdjust = 0;\n\n    this.clear();\n\n    let internalCallback = () => {\n      this.callback();\n\n      if (this.repeat) {\n        let now = Date.now();\n\n        // The time of one iteration from scheduling to executing the callback (usually a bit longer than the delay\n        // time)\n        let delta = now - lastScheduleTime;\n\n        // Calculate the delay adjustment for the next schedule to keep a steady delay interval over time\n        delayAdjust = this.delay - delta + delayAdjust;\n\n        lastScheduleTime = now;\n\n        // Schedule next execution by the adjusted delay\n        this.timeoutHandle = setTimeout(internalCallback, this.delay + delayAdjust);\n      }\n    };\n\n    lastScheduleTime = Date.now();\n    if (this.delay > 0) {\n      this.timeoutHandle = setTimeout(internalCallback, this.delay);\n    }\n  }\n}","import {UIContainer} from './components/uicontainer';\nimport {DOM} from './dom';\nimport {Component, ComponentConfig} from './components/component';\nimport {Container} from './components/container';\nimport {PlaybackToggleButton} from './components/playbacktogglebutton';\nimport {FullscreenToggleButton} from './components/fullscreentogglebutton';\nimport {VRToggleButton} from './components/vrtogglebutton';\nimport {VolumeToggleButton} from './components/volumetogglebutton';\nimport {SeekBar} from './components/seekbar';\nimport {PlaybackTimeLabel, PlaybackTimeLabelMode} from './components/playbacktimelabel';\nimport {ControlBar} from './components/controlbar';\nimport {NoArgs, EventDispatcher, CancelEventArgs} from './eventdispatcher';\nimport {SettingsToggleButton} from './components/settingstogglebutton';\nimport {SettingsPanel, SettingsPanelItem} from './components/settingspanel';\nimport {VideoQualitySelectBox} from './components/videoqualityselectbox';\nimport {Watermark} from './components/watermark';\nimport {AudioQualitySelectBox} from './components/audioqualityselectbox';\nimport {AudioTrackSelectBox} from './components/audiotrackselectbox';\nimport {SeekBarLabel} from './components/seekbarlabel';\nimport {VolumeSlider} from './components/volumeslider';\nimport {SubtitleSelectBox} from './components/subtitleselectbox';\nimport {SubtitleOverlay} from './components/subtitleoverlay';\nimport {VolumeControlButton} from './components/volumecontrolbutton';\nimport {CastToggleButton} from './components/casttogglebutton';\nimport {CastStatusOverlay} from './components/caststatusoverlay';\nimport {ErrorMessageOverlay} from './components/errormessageoverlay';\nimport {TitleBar} from './components/titlebar';\nimport Player = bitmovin.player.Player;\nimport {RecommendationOverlay} from './components/recommendationoverlay';\nimport {AdMessageLabel} from './components/admessagelabel';\nimport {AdSkipButton} from './components/adskipbutton';\nimport {AdClickOverlay} from './components/adclickoverlay';\nimport EVENT = bitmovin.player.EVENT;\nimport PlayerEventCallback = bitmovin.player.PlayerEventCallback;\nimport AdStartedEvent = bitmovin.player.AdStartedEvent;\nimport {ArrayUtils, UIUtils, BrowserUtils} from './utils';\nimport {PlaybackSpeedSelectBox} from './components/playbackspeedselectbox';\nimport {BufferingOverlay} from './components/bufferingoverlay';\nimport {CastUIContainer} from './components/castuicontainer';\nimport {PlaybackToggleOverlay} from './components/playbacktoggleoverlay';\nimport {CloseButton} from './components/closebutton';\nimport {MetadataLabel, MetadataLabelContent} from './components/metadatalabel';\nimport {Label} from './components/label';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\nimport {AirPlayToggleButton} from './components/airplaytogglebutton';\nimport {PictureInPictureToggleButton} from './components/pictureinpicturetogglebutton';\nimport {Spacer} from './components/spacer';\n\nexport interface UIRecommendationConfig {\n  title: string;\n  url: string;\n  thumbnail?: string;\n  duration?: number;\n}\n\nexport interface TimelineMarker {\n  time: number;\n  title?: string;\n  markerType?: string;\n  comment?: string;\n  avatar?: string;\n  number?: string;\n}\n\nexport interface UIConfig {\n  metadata?: {\n    title?: string;\n    description?: string;\n    markers?: TimelineMarker[];\n  };\n  recommendations?: UIRecommendationConfig[];\n}\n\n/**\n * The context that will be passed to a {@link UIConditionResolver} to determine if it's conditions fulfil the context.\n */\nexport interface UIConditionContext {\n  isAd: boolean;\n  isAdWithUI: boolean;\n  isFullscreen: boolean;\n  isMobile: boolean;\n  documentWidth: number;\n  width: number;\n}\n\n/**\n * Resolves the conditions of its associated UI in a {@link UIVariant} upon a {@link UIConditionContext} and decides\n * if the UI should be displayed. If it returns true, the UI is a candidate for display; if it returns false, it will\n * not be displayed in the given context.\n */\nexport interface UIConditionResolver {\n  (context: UIConditionContext): boolean;\n}\n\n/**\n * Associates a UI instance with an optional {@link UIConditionResolver} that determines if the UI should be displayed.\n */\nexport interface UIVariant {\n  ui: UIContainer;\n  condition?: UIConditionResolver;\n}\n\nexport class UIManager {\n\n  private player: Player;\n  private playerElement: DOM;\n  private uiVariants: UIVariant[];\n  private uiInstanceManagers: InternalUIInstanceManager[];\n  private currentUi: InternalUIInstanceManager;\n  private config: UIConfig;\n  private managerPlayerWrapper: PlayerWrapper;\n\n  /**\n   * Creates a UI manager with a single UI variant that will be permanently shown.\n   * @param player the associated player of this UI\n   * @param ui the UI to add to the player\n   * @param config optional UI configuration\n   */\n  constructor(player: Player, ui: UIContainer, config?: UIConfig);\n  /**\n   * Creates a UI manager with a list of UI variants that will be dynamically selected and switched according to\n   * the context of the UI.\n   *\n   * Every time the UI context changes, the conditions of the UI variants will be sequentially resolved and the first\n   * UI, whose condition evaluates to true, will be selected and displayed. The last variant in the list might omit the\n   * condition resolver and will be selected as default/fallback UI when all other conditions fail. If there is no\n   * fallback UI and all conditions fail, no UI will be displayed.\n   *\n   * @param player the associated player of this UI\n   * @param uiVariants a list of UI variants that will be dynamically switched\n   * @param config optional UI configuration\n   */\n  constructor(player: Player, uiVariants: UIVariant[], config?: UIConfig);\n  constructor(player: Player, playerUiOrUiVariants: UIContainer | UIVariant[], config: UIConfig = {}) {\n    if (playerUiOrUiVariants instanceof UIContainer) {\n      // Single-UI constructor has been called, transform arguments to UIVariant[] signature\n      let playerUi = <UIContainer>playerUiOrUiVariants;\n      let adsUi = null;\n\n      let uiVariants = [];\n\n      // Add the ads UI if defined\n      if (adsUi) {\n        uiVariants.push({\n          ui: adsUi,\n          condition: (context: UIConditionContext) => {\n            return context.isAdWithUI;\n          },\n        });\n      }\n\n      // Add the default player UI\n      uiVariants.push({ui: playerUi});\n\n      this.uiVariants = uiVariants;\n    }\n    else {\n      // Default constructor (UIVariant[]) has been called\n      this.uiVariants = <UIVariant[]>playerUiOrUiVariants;\n    }\n\n    this.player = player;\n    this.config = config;\n    this.managerPlayerWrapper = new PlayerWrapper(player);\n    this.playerElement = new DOM(player.getFigure());\n\n    // Create UI instance managers for the UI variants\n    // The instance managers map to the corresponding UI variants by their array index\n    this.uiInstanceManagers = [];\n    let uiVariantsWithoutCondition = [];\n    for (let uiVariant of this.uiVariants) {\n      if (uiVariant.condition == null) {\n        // Collect variants without conditions for error checking\n        uiVariantsWithoutCondition.push(uiVariant);\n      }\n      // Create the instance manager for a UI variant\n      this.uiInstanceManagers.push(new InternalUIInstanceManager(player, uiVariant.ui, this.config));\n    }\n    // Make sure that there is only one UI variant without a condition\n    // It does not make sense to have multiple variants without condition, because only the first one in the list\n    // (the one with the lowest index) will ever be selected.\n    if (uiVariantsWithoutCondition.length > 1) {\n      throw Error('Too many UIs without a condition: You cannot have more than one default UI');\n    }\n    // Make sure that the default UI variant, if defined, is at the end of the list (last index)\n    // If it comes earlier, the variants with conditions that come afterwards will never be selected because the\n    // default variant without a condition always evaluates to 'true'\n    if (uiVariantsWithoutCondition.length > 0\n      && uiVariantsWithoutCondition[0] !== this.uiVariants[this.uiVariants.length - 1]) {\n      throw Error('Invalid UI variant order: the default UI (without condition) must be at the end of the list');\n    }\n\n    let adStartedEvent: AdStartedEvent = null; // keep the event stored here during ad playback\n    let isMobile = BrowserUtils.isMobile;\n\n    // Dynamically select a UI variant that matches the current UI condition.\n    let resolveUiVariant = (event: PlayerEvent) => {\n      // Make sure that the ON_AD_STARTED event data is persisted through ad playback in case other events happen\n      // in the meantime, e.g. player resize. We need to store this data because there is no other way to find out\n      // ad details (e.g. the ad client) while an ad is playing.\n      // Existing event data signals that an ad is currently active. We cannot use player.isAd() because it returns\n      // true on ad start and also on ad end events, which is problematic.\n      if (event != null) {\n        switch (event.type) {\n          // When the ad starts, we store the event data\n          case player.EVENT.ON_AD_STARTED:\n            adStartedEvent = <AdStartedEvent>event;\n            break;\n          // When the ad ends, we delete the event data\n          case player.EVENT.ON_AD_FINISHED:\n          case player.EVENT.ON_AD_SKIPPED:\n          case player.EVENT.ON_AD_ERROR:\n            adStartedEvent = null;\n        }\n      }\n\n      // Detect if an ad has started\n      let ad = adStartedEvent != null;\n      let adWithUI = ad && adStartedEvent.clientType === 'vast';\n\n      // Determine the current context for which the UI variant will be resolved\n      let context: UIConditionContext = {\n        isAd: ad,\n        isAdWithUI: adWithUI,\n        isFullscreen: this.player.isFullscreen(),\n        isMobile: isMobile,\n        width: this.playerElement.width(),\n        documentWidth: document.body.clientWidth,\n      };\n\n      let nextUi: InternalUIInstanceManager = null;\n      let uiVariantChanged = false;\n\n      // Select new UI variant\n      // If no variant condition is fulfilled, we switch to *no* UI\n      for (let uiVariant of this.uiVariants) {\n        if (uiVariant.condition == null || uiVariant.condition(context) === true) {\n          nextUi = this.uiInstanceManagers[this.uiVariants.indexOf(uiVariant)];\n          break;\n        }\n      }\n\n      // Determine if the UI variant is changing\n      if (nextUi !== this.currentUi) {\n        uiVariantChanged = true;\n        // console.log('switched from ', this.currentUi ? this.currentUi.getUI() : 'none',\n        //   ' to ', nextUi ? nextUi.getUI() : 'none');\n      }\n\n      // Only if the UI variant is changing, we need to do some stuff. Else we just leave everything as-is.\n      if (uiVariantChanged) {\n        // Hide the currently active UI variant\n        if (this.currentUi) {\n          this.currentUi.getUI().hide();\n        }\n\n        // Assign the new UI variant as current UI\n        this.currentUi = nextUi;\n\n        // When we switch to a different UI instance, there's some additional stuff to manage. If we do not switch\n        // to an instance, we're done here.\n        if (this.currentUi != null) {\n          // Add the UI to the DOM (and configure it) the first time it is selected\n          if (!this.currentUi.isConfigured()) {\n            this.addUi(this.currentUi);\n          }\n\n          // If this is an ad UI, we need to relay the saved ON_AD_STARTED event data so ad components can configure\n          // themselves for the current ad.\n          if (context.isAd) {\n            /* Relay the ON_AD_STARTED event to the ads UI\n             *\n             * Because the ads UI is initialized in the ON_AD_STARTED handler, i.e. when the ON_AD_STARTED event has\n             * already been fired, components in the ads UI that listen for the ON_AD_STARTED event never receive it.\n             * Since this can break functionality of components that rely on this event, we relay the event to the\n             * ads UI components with the following call.\n             */\n            this.currentUi.getWrappedPlayer().fireEventInUI(this.player.EVENT.ON_AD_STARTED, adStartedEvent);\n          }\n\n          this.currentUi.getUI().show();\n        }\n      }\n    };\n\n    // Listen to the following events to trigger UI variant resolution\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_STARTED, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_FINISHED, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_SKIPPED, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_ERROR, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_PLAYER_RESIZE, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_FULLSCREEN_ENTER, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_FULLSCREEN_EXIT, resolveUiVariant);\n\n    // Initialize the UI\n    resolveUiVariant(null);\n  }\n\n  getConfig(): UIConfig {\n    return this.config;\n  }\n\n  private addUi(ui: InternalUIInstanceManager): void {\n    let dom = ui.getUI().getDomElement();\n    ui.configureControls();\n    /* Append the UI DOM after configuration to avoid CSS transitions at initialization\n     * Example: Components are hidden during configuration and these hides may trigger CSS transitions that are\n     * undesirable at this time. */\n\n    /* Append ui to parent instead of player */\n    let parentElement = new DOM(this.playerElement.getElements()[0].parentElement);\n    parentElement.addClass('smashcut-custom-ui-bitmovin-player-holder');\n    parentElement.append(dom);\n\n    // Fire onConfigured after UI DOM elements are successfully added. When fired immediately, the DOM elements\n    // might not be fully configured and e.g. do not have a size.\n    // https://swizec.com/blog/how-to-properly-wait-for-dom-elements-to-show-up-in-modern-browsers/swizec/6663\n    if (window.requestAnimationFrame) {\n      requestAnimationFrame(() => {\n        ui.onConfigured.dispatch(ui.getUI());\n      });\n    } else {\n      // IE9 fallback\n      setTimeout(() => {\n        ui.onConfigured.dispatch(ui.getUI());\n      }, 0);\n    }\n  }\n\n  private releaseUi(ui: InternalUIInstanceManager): void {\n    ui.releaseControls();\n    ui.getUI().getDomElement().remove();\n    ui.clearEventHandlers();\n  }\n\n  release(): void {\n    for (let uiInstanceManager of this.uiInstanceManagers) {\n      this.releaseUi(uiInstanceManager);\n    }\n    this.managerPlayerWrapper.clearEventHandlers();\n  }\n}\n\nexport namespace UIManager.Factory {\n\n  export function buildDefaultUI(player: Player, config: UIConfig = {}): UIManager {\n    return UIManager.Factory.buildModernUI(player, config);\n  }\n\n  export function buildDefaultSmallScreenUI(player: Player, config: UIConfig = {}): UIManager {\n    return UIManager.Factory.buildModernSmallScreenUI(player, config);\n  }\n\n  export function buildDefaultCastReceiverUI(player: Player, config: UIConfig = {}): UIManager {\n    return UIManager.Factory.buildModernCastReceiverUI(player, config);\n  }\n\n  function smashcutUi() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBarTop = new Container({\n      cssClasses: ['controlbar-top'],\n      components: [\n        new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n        new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n      ]\n    });\n\n    let controlBarMiddle = new Container({\n      cssClasses: ['controlbar-middle'],\n      components: [\n        new SeekBar({label: new SeekBarLabel()}),\n      ]\n    });\n\n    let controlBarBottom = new Container({\n      cssClasses: ['controlbar-bottom'],\n      components: [\n        new Spacer(),\n        new VolumeSlider(),\n        new VolumeToggleButton(),\n        new SettingsToggleButton({settingsPanel: settingsPanel}),\n        new FullscreenToggleButton(),\n      ]\n    });\n\n\n    let controlBar = new ControlBar({\n      components: [\n        new PlaybackToggleButton(),\n        new Container({\n          cssClasses: ['controlbar-inner'],\n          components: [\n            settingsPanel,\n            controlBarTop,\n            controlBarMiddle,\n            controlBarBottom,\n          ]\n        })\n      ]\n    });\n\n    return new UIContainer({\n      hideDelay: 0,\n      cssClasses: ['ui-skin-modern ui-skin-smashcut'],\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        /** new PlaybackToggleOverlay(), **/\n        controlBar,\n        new TitleBar(),\n        new RecommendationOverlay(),\n        new ErrorMessageOverlay()\n      ]\n    });\n  }\n\n  function modernUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBar = new ControlBar({\n      components: [\n        settingsPanel,\n        new Container({\n          components: [\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n            new SeekBar({label: new SeekBarLabel()}),\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n          ],\n          cssClasses: ['controlbar-top']\n        }),\n        new Container({\n          components: [\n            new PlaybackToggleButton(),\n            new VolumeToggleButton(),\n            new VolumeSlider(),\n            new Spacer(),\n            new PictureInPictureToggleButton(),\n            new AirPlayToggleButton(),\n            new CastToggleButton(),\n            new VRToggleButton(),\n            new SettingsToggleButton({settingsPanel: settingsPanel}),\n            new FullscreenToggleButton(),\n          ],\n          cssClasses: ['controlbar-bottom']\n        }),\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new PlaybackToggleOverlay(),\n        new CastStatusOverlay(),\n        controlBar,\n        new TitleBar(),\n        new RecommendationOverlay(),\n        new Watermark(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-modern']\n    });\n  }\n\n  function modernAdsUI() {\n    return new UIContainer({\n      components: [\n        new BufferingOverlay(),\n        new AdClickOverlay(),\n        new PlaybackToggleOverlay(),\n        new Container({\n          components: [\n            new AdMessageLabel({text: 'Ad: {remainingTime} secs'}),\n            new AdSkipButton()\n          ],\n          cssClass: 'ui-ads-status'\n        }),\n        new ControlBar({\n          components: [\n            new Container({\n              components: [\n                new PlaybackToggleButton(),\n                new VolumeToggleButton(),\n                new VolumeSlider(),\n                new Spacer(),\n                new FullscreenToggleButton(),\n              ],\n              cssClasses: ['controlbar-bottom']\n            }),\n          ]\n        })\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-ads']\n    });\n  }\n\n  function modernSmallScreenUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true,\n      hideDelay: -1,\n    });\n    settingsPanel.addComponent(new CloseButton({target: settingsPanel}));\n\n    let controlBar = new ControlBar({\n      components: [\n        new Container({\n          components: [\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n            new SeekBar({label: new SeekBarLabel()}),\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n          ],\n          cssClasses: ['controlbar-top']\n        }),\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        controlBar,\n        new TitleBar({\n          components: [\n            new MetadataLabel({content: MetadataLabelContent.Title}),\n            new CastToggleButton(),\n            /*new VRToggleButton(),*/\n            new SettingsToggleButton({settingsPanel: settingsPanel}),\n            new FullscreenToggleButton(),\n          ]\n        }),\n        settingsPanel,\n        new RecommendationOverlay(),\n        new Watermark(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-smallscreen']\n    });\n  }\n\n  function modernSmallScreenAdsUI() {\n    return new UIContainer({\n      components: [\n        new BufferingOverlay(),\n        new AdClickOverlay(),\n        new PlaybackToggleOverlay(),\n        new TitleBar({\n          components: [\n            // dummy label with no content to move buttons to the right\n            new Label({cssClass: 'label-metadata-title'}),\n            new FullscreenToggleButton(),\n          ]\n        }),\n        new Container({\n          components: [\n            new AdMessageLabel({text: 'Ad: {remainingTime} secs'}),\n            new AdSkipButton()\n          ],\n          cssClass: 'ui-ads-status'\n        }),\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-ads', 'ui-skin-smallscreen']\n    });\n  }\n\n  function modernCastReceiverUI() {\n    let controlBar = new ControlBar({\n      components: [\n        new Container({\n          components: [\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n            new SeekBar({smoothPlaybackPositionUpdateIntervalMs: -1}),\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n          ],\n          cssClasses: ['controlbar-top']\n        }),\n      ]\n    });\n\n    return new CastUIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        controlBar,\n        new TitleBar({keepHiddenWithoutMetadata: true}),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-cast-receiver']\n    });\n  }\n\n  export function buildModernUI(player: Player, config: UIConfig = {}): UIManager {\n    // show smallScreen UI only on mobile/handheld devices\n    let smallScreenSwitchWidth = 600;\n\n    return new UIManager(player, [{\n      ui: modernSmallScreenAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isMobile && context.documentWidth < smallScreenSwitchWidth && context.isAdWithUI;\n      }\n    }, {\n      ui: modernAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isAdWithUI;\n      }\n    }, {\n      ui: modernSmallScreenUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isMobile && context.documentWidth < smallScreenSwitchWidth;\n      }\n    }, {\n      ui: smashcutUi()\n    }], config);\n  }\n\n  export function buildModernSmallScreenUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, [{\n      ui: modernSmallScreenAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isAdWithUI;\n      }\n    }, {\n      ui: modernSmallScreenUI()\n    }], config);\n  }\n\n  export function buildModernCastReceiverUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, modernCastReceiverUI(), config);\n  }\n\n  function legacyUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBar = new ControlBar({\n      components: [\n        settingsPanel,\n        new PlaybackToggleButton(),\n        new SeekBar({label: new SeekBarLabel()}),\n        new PlaybackTimeLabel(),\n        new VRToggleButton(),\n        new VolumeControlButton(),\n        new SettingsToggleButton({settingsPanel: settingsPanel}),\n        new CastToggleButton(),\n        new FullscreenToggleButton()\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        new RecommendationOverlay(),\n        controlBar,\n        new TitleBar(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-legacy']\n    });\n  }\n\n  function legacyAdsUI() {\n    return new UIContainer({\n      components: [\n        new AdClickOverlay(),\n        new ControlBar({\n          components: [\n            new PlaybackToggleButton(),\n            new AdMessageLabel(),\n            new VolumeControlButton(),\n            new FullscreenToggleButton()\n          ]\n        }),\n        new AdSkipButton()\n      ], cssClasses: ['ui-skin-legacy', 'ui-skin-ads']\n    });\n  }\n\n  function legacyCastReceiverUI() {\n    let controlBar = new ControlBar({\n      components: [\n        new SeekBar(),\n        new PlaybackTimeLabel(),\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        controlBar,\n        new TitleBar(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-legacy', 'ui-skin-cast-receiver']\n    });\n  }\n\n  function legacyTestUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBar = new ControlBar({\n      components: [settingsPanel,\n        new PlaybackToggleButton(),\n        new SeekBar({label: new SeekBarLabel()}),\n        new PlaybackTimeLabel(),\n        new VRToggleButton(),\n        new VolumeToggleButton(),\n        new VolumeSlider(),\n        new VolumeControlButton(),\n        new VolumeControlButton({vertical: false}),\n        new SettingsToggleButton({settingsPanel: settingsPanel}),\n        new CastToggleButton(),\n        new FullscreenToggleButton()\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        new RecommendationOverlay(),\n        controlBar,\n        new TitleBar(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-legacy']\n    });\n  }\n\n  export function buildLegacyUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, [{\n      ui: legacyAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isAdWithUI;\n      }\n    }, {\n      ui: legacyUI()\n    }], config);\n  }\n\n  export function buildLegacyCastReceiverUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, legacyCastReceiverUI(), config);\n  }\n\n  export function buildLegacyTestUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, legacyTestUI(), config);\n  }\n}\n\nexport interface SeekPreviewArgs extends NoArgs {\n  /**\n   * The timeline position in percent where the event originates from.\n   */\n  position: number;\n  /**\n   * The timeline marker associated with the current position, if existing.\n   */\n  marker?: TimelineMarker;\n}\n\n/**\n * Encapsulates functionality to manage a UI instance. Used by the {@link UIManager} to manage multiple UI instances.\n */\nexport class UIInstanceManager {\n  private playerWrapper: PlayerWrapper;\n  private ui: UIContainer;\n  private config: UIConfig;\n\n  private events = {\n    onConfigured: new EventDispatcher<UIContainer, NoArgs>(),\n    onSeek: new EventDispatcher<SeekBar, NoArgs>(),\n    onSeekPreview: new EventDispatcher<SeekBar, SeekPreviewArgs>(),\n    onSeeked: new EventDispatcher<SeekBar, NoArgs>(),\n    onComponentShow: new EventDispatcher<Component<ComponentConfig>, NoArgs>(),\n    onComponentHide: new EventDispatcher<Component<ComponentConfig>, NoArgs>(),\n    onControlsShow: new EventDispatcher<UIContainer, NoArgs>(),\n    onPreviewControlsHide: new EventDispatcher<UIContainer, CancelEventArgs>(),\n    onControlsHide: new EventDispatcher<UIContainer, NoArgs>(),\n  };\n\n  constructor(player: Player, ui: UIContainer, config: UIConfig = {}) {\n    this.playerWrapper = new PlayerWrapper(player);\n    this.ui = ui;\n    this.config = config;\n  }\n\n  getConfig(): UIConfig {\n    return this.config;\n  }\n\n  getUI(): UIContainer {\n    return this.ui;\n  }\n\n  getPlayer(): Player {\n    return this.playerWrapper.getPlayer();\n  }\n\n  /**\n   * Fires when the UI is fully configured and added to the DOM.\n   * @returns {EventDispatcher}\n   */\n  get onConfigured(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onConfigured;\n  }\n\n  /**\n   * Fires when a seek starts.\n   * @returns {EventDispatcher}\n   */\n  get onSeek(): EventDispatcher<SeekBar, NoArgs> {\n    return this.events.onSeek;\n  }\n\n  /**\n   * Fires when the seek timeline is scrubbed.\n   * @returns {EventDispatcher}\n   */\n  get onSeekPreview(): EventDispatcher<SeekBar, SeekPreviewArgs> {\n    return this.events.onSeekPreview;\n  }\n\n  /**\n   * Fires when a seek is finished.\n   * @returns {EventDispatcher}\n   */\n  get onSeeked(): EventDispatcher<SeekBar, NoArgs> {\n    return this.events.onSeeked;\n  }\n\n  /**\n   * Fires when a component is showing.\n   * @returns {EventDispatcher}\n   */\n  get onComponentShow(): EventDispatcher<Component<ComponentConfig>, NoArgs> {\n    return this.events.onComponentShow;\n  }\n\n  /**\n   * Fires when a component is hiding.\n   * @returns {EventDispatcher}\n   */\n  get onComponentHide(): EventDispatcher<Component<ComponentConfig>, NoArgs> {\n    return this.events.onComponentHide;\n  }\n\n  /**\n   * Fires when the UI controls are showing.\n   * @returns {EventDispatcher}\n   */\n  get onControlsShow(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onControlsShow;\n  }\n\n  /**\n   * Fires before the UI controls are hiding to check if they are allowed to hide.\n   * @returns {EventDispatcher}\n   */\n  get onPreviewControlsHide(): EventDispatcher<UIContainer, CancelEventArgs> {\n    return this.events.onPreviewControlsHide;\n  }\n\n  /**\n   * Fires when the UI controls are hiding.\n   * @returns {EventDispatcher}\n   */\n  get onControlsHide(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onControlsHide;\n  }\n\n  protected clearEventHandlers(): void {\n    this.playerWrapper.clearEventHandlers();\n\n    let events = <any>this.events; // avoid TS7017\n    for (let event in events) {\n      let dispatcher = <EventDispatcher<Object, Object>>events[event];\n      dispatcher.unsubscribeAll();\n    }\n  }\n}\n\n/**\n * Extends the {@link UIInstanceManager} for internal use in the {@link UIManager} and provides access to functionality\n * that components receiving a reference to the {@link UIInstanceManager} should not have access to.\n */\nclass InternalUIInstanceManager extends UIInstanceManager {\n\n  private configured: boolean;\n  private released: boolean;\n\n  getWrappedPlayer(): WrappedPlayer {\n    // TODO find a non-hacky way to provide the WrappedPlayer to the UIManager without exporting it\n    // getPlayer() actually returns the WrappedPlayer but its return type is set to Player so the WrappedPlayer does\n    // not need to be exported\n    return <WrappedPlayer>this.getPlayer();\n  }\n\n  configureControls(): void {\n    this.configureControlsTree(this.getUI());\n    this.configured = true;\n  }\n\n  isConfigured(): boolean {\n    return this.configured;\n  }\n\n  private configureControlsTree(component: Component<ComponentConfig>) {\n    let configuredComponents: Component<ComponentConfig>[] = [];\n\n    UIUtils.traverseTree(component, (component) => {\n      // First, check if we have already configured a component, and throw an error if we did. Multiple configuration\n      // of the same component leads to unexpected UI behavior. Also, a component that is in the UI tree multiple\n      // times hints at a wrong UI structure.\n      // We could just skip configuration in such a case and not throw an exception, but enforcing a clean UI tree\n      // seems like the better choice.\n      for (let configuredComponent of configuredComponents) {\n        if (configuredComponent === component) {\n          // Write the component to the console to simplify identification of the culprit\n          // (e.g. by inspecting the config)\n          if (console) {\n            console.error('Circular reference in UI tree', component);\n          }\n\n          // Additionally throw an error, because this case must not happen and leads to unexpected UI behavior.\n          throw Error('Circular reference in UI tree: ' + component.constructor.name);\n        }\n      }\n\n      component.initialize();\n      component.configure(this.getPlayer(), this);\n      configuredComponents.push(component);\n    });\n  }\n\n  releaseControls(): void {\n    // Do not call release methods if the components have never been configured; this can result in exceptions\n    if (this.configured) {\n      this.releaseControlsTree(this.getUI());\n      this.configured = false;\n    }\n    this.released = true;\n  }\n\n  isReleased(): boolean {\n    return this.released;\n  }\n\n  private releaseControlsTree(component: Component<ComponentConfig>) {\n    component.release();\n\n    if (component instanceof Container) {\n      for (let childComponent of component.getComponents()) {\n        this.releaseControlsTree(childComponent);\n      }\n    }\n  }\n\n  clearEventHandlers(): void {\n    super.clearEventHandlers();\n  }\n}\n\n/**\n * Extended interface of the {@link Player} for use in the UI.\n */\ninterface WrappedPlayer extends Player {\n  /**\n   * Fires an event on the player that targets all handlers in the UI but never enters the real player.\n   * @param event the event to fire\n   * @param data data to send with the event\n   */\n  fireEventInUI(event: EVENT, data: {}): void;\n}\n\n/**\n * Wraps the player to track event handlers and provide a simple method to remove all registered event\n * handlers from the player.\n */\nclass PlayerWrapper {\n\n  private player: Player;\n  private wrapper: WrappedPlayer;\n\n  private eventHandlers: { [eventType: string]: PlayerEventCallback[]; } = {};\n\n  constructor(player: Player) {\n    this.player = player;\n\n    // Collect all public API methods of the player\n    let methods = <any[]>[];\n    for (let member in player) {\n      if (typeof (<any>player)[member] === 'function') {\n        methods.push(member);\n      }\n    }\n\n    // Create wrapper object and add function wrappers for all API methods that do nothing but calling the base method\n    // on the player\n    let wrapper = <any>{};\n    for (let member of methods) {\n      wrapper[member] = function () {\n        // console.log('called ' + member); // track method calls on the player\n        return (<any>player)[member].apply(player, arguments);\n      };\n    }\n\n    // Collect all public properties of the player and add it to the wrapper\n    for (let member in player) {\n      if (typeof (<any>player)[member] !== 'function') {\n        wrapper[member] = (<any>player)[member];\n      }\n    }\n\n    // Explicitly add a wrapper method for 'addEventHandler' that adds added event handlers to the event list\n    wrapper.addEventHandler = (eventType: EVENT, callback: PlayerEventCallback) => {\n      player.addEventHandler(eventType, callback);\n\n      if (!this.eventHandlers[eventType]) {\n        this.eventHandlers[eventType] = [];\n      }\n\n      this.eventHandlers[eventType].push(callback);\n\n      return wrapper;\n    };\n\n    // Explicitly add a wrapper method for 'removeEventHandler' that removes removed event handlers from the event list\n    wrapper.removeEventHandler = (eventType: EVENT, callback: PlayerEventCallback) => {\n      player.removeEventHandler(eventType, callback);\n\n      if (this.eventHandlers[eventType]) {\n        ArrayUtils.remove(this.eventHandlers[eventType], callback);\n      }\n\n      return wrapper;\n    };\n\n    wrapper.fireEventInUI = (event: EVENT, data: {}) => {\n      if (this.eventHandlers[event]) { // check if there are handlers for this event registered\n        // Extend the data object with default values to convert it to a {@link PlayerEvent} object.\n        let playerEventData = <PlayerEvent>Object.assign({}, {\n          timestamp: Date.now(),\n          type: event,\n          // Add a marker property so the UI can detect UI-internal player events\n          uiSourced: true,\n        }, data);\n\n        // Execute the registered callbacks\n        for (let callback of this.eventHandlers[event]) {\n          callback(playerEventData);\n        }\n      }\n    };\n\n    this.wrapper = <WrappedPlayer>wrapper;\n  }\n\n  /**\n   * Returns a wrapped player object that can be used on place of the normal player object.\n   * @returns {WrappedPlayer} a wrapped player\n   */\n  getPlayer(): WrappedPlayer {\n    return this.wrapper;\n  }\n\n  /**\n   * Clears all registered event handlers from the player that were added through the wrapped player.\n   */\n  clearEventHandlers(): void {\n    for (let eventType in this.eventHandlers) {\n      for (let callback of this.eventHandlers[eventType]) {\n        this.player.removeEventHandler(eventType, callback);\n      }\n    }\n  }\n}\n","import {EventDispatcher, Event, NoArgs} from './eventdispatcher';\nimport {Component, ComponentConfig} from './components/component';\nimport {Container} from './components/container';\n\nexport namespace ArrayUtils {\n  /**\n   * Removes an item from an array.\n   * @param array the array that may contain the item to remove\n   * @param item the item to remove from the array\n   * @returns {any} the removed item or null if it wasn't part of the array\n   */\n  export function remove<T>(array: T[], item: T): T | null {\n    let index = array.indexOf(item);\n\n    if (index > -1) {\n      return array.splice(index, 1)[0];\n    } else {\n      return null;\n    }\n  }\n}\n\nexport namespace StringUtils {\n\n  export let FORMAT_HHMMSS: string = 'hh:mm:ss';\n  export let FORMAT_MMSS: string = 'mm:ss';\n\n  /**\n   * Formats a number of seconds into a time string with the pattern hh:mm:ss.\n   *\n   * @param totalSeconds the total number of seconds to format to string\n   * @param format the time format to output (default: hh:mm:ss)\n   * @returns {string} the formatted time string\n   */\n  export function secondsToTime(totalSeconds: number, format: string = FORMAT_HHMMSS): string {\n    let isNegative = totalSeconds < 0;\n\n    if (isNegative) {\n      // If the time is negative, we make it positive for the calculation below\n      // (else we'd get all negative numbers) and reattach the negative sign later.\n      totalSeconds = -totalSeconds;\n    }\n\n    // Split into separate time parts\n    let hours = Math.floor(totalSeconds / 3600);\n    let minutes = Math.floor(totalSeconds / 60) - hours * 60;\n    let seconds = Math.floor(totalSeconds) % 60;\n\n    return (isNegative ? '-' : '') + format\n        .replace('hh', leftPadWithZeros(hours, 2))\n        .replace('mm', leftPadWithZeros(minutes, 2))\n        .replace('ss', leftPadWithZeros(seconds, 2));\n  }\n\n  /**\n   * Converts a number to a string and left-pads it with zeros to the specified length.\n   * Example: leftPadWithZeros(123, 5) => '00123'\n   *\n   * @param num the number to convert to string and pad with zeros\n   * @param length the desired length of the padded string\n   * @returns {string} the padded number as string\n   */\n  function leftPadWithZeros(num: number | string, length: number): string {\n    let text = num + '';\n    let padding = '0000000000'.substr(0, length - text.length);\n    return padding + text;\n  }\n\n  /**\n   * Fills out placeholders in an ad message.\n   *\n   * Has the placeholders '{remainingTime[formatString]}', '{playedTime[formatString]}' and\n   * '{adDuration[formatString]}', which are replaced by the remaining time until the ad can be skipped, the current\n   * time or the ad duration. The format string is optional. If not specified, the placeholder is replaced by the time\n   * in seconds. If specified, it must be of the following format:\n   * - %d - Inserts the time as an integer.\n   * - %0Nd - Inserts the time as an integer with leading zeroes, if the length of the time string is smaller than N.\n   * - %f - Inserts the time as a float.\n   * - %0Nf - Inserts the time as a float with leading zeroes.\n   * - %.Mf - Inserts the time as a float with M decimal places. Can be combined with %0Nf, e.g. %04.2f (the time\n   * 10.123\n   * would be printed as 0010.12).\n   * - %hh:mm:ss\n   * - %mm:ss\n   *\n   * @param adMessage an ad message with optional placeholders to fill\n   * @param skipOffset if specified, {remainingTime} will be filled with the remaining time until the ad can be skipped\n   * @param player the player to get the time data from\n   * @returns {string} the ad message with filled placeholders\n   */\n  export function replaceAdMessagePlaceholders(adMessage: string, skipOffset: number, player: bitmovin.player.Player) {\n    let adMessagePlaceholderRegex = new RegExp(\n      '\\\\{(remainingTime|playedTime|adDuration)(}|%((0[1-9]\\\\d*(\\\\.\\\\d+(d|f)|d|f)|\\\\.\\\\d+f|d|f)|hh:mm:ss|mm:ss)})',\n      'g'\n    );\n\n    return adMessage.replace(adMessagePlaceholderRegex, (formatString) => {\n      let time = 0;\n      if (formatString.indexOf('remainingTime') > -1) {\n        if (skipOffset) {\n          time = Math.ceil(skipOffset - player.getCurrentTime());\n        } else {\n          time = player.getDuration() - player.getCurrentTime();\n        }\n      } else if (formatString.indexOf('playedTime') > -1) {\n        time = player.getCurrentTime();\n      } else if (formatString.indexOf('adDuration') > -1) {\n        time = player.getDuration();\n      }\n      return formatNumber(time, formatString);\n    });\n  }\n\n  function formatNumber(time: number, format: string) {\n    let formatStringValidationRegex = /%((0[1-9]\\d*(\\.\\d+(d|f)|d|f)|\\.\\d+f|d|f)|hh:mm:ss|mm:ss)/;\n    let leadingZeroesRegex = /(%0[1-9]\\d*)(?=(\\.\\d+f|f|d))/;\n    let decimalPlacesRegex = /\\.\\d*(?=f)/;\n\n    if (!formatStringValidationRegex.test(format)) {\n      // If the format is invalid, we set a default fallback format\n      format = '%d';\n    }\n\n    // Determine the number of leading zeros\n    let leadingZeroes = 0;\n    let leadingZeroesMatches = format.match(leadingZeroesRegex);\n    if (leadingZeroesMatches) {\n      leadingZeroes = parseInt(leadingZeroesMatches[0].substring(2));\n    }\n\n    // Determine the number of decimal places\n    let numDecimalPlaces = null;\n    let decimalPlacesMatches = format.match(decimalPlacesRegex);\n    if (decimalPlacesMatches && !isNaN(parseInt(decimalPlacesMatches[0].substring(1)))) {\n      numDecimalPlaces = parseInt(decimalPlacesMatches[0].substring(1));\n      if (numDecimalPlaces > 20) {\n        numDecimalPlaces = 20;\n      }\n    }\n\n    // Float format\n    if (format.indexOf('f') > -1) {\n      let timeString = '';\n\n      if (numDecimalPlaces !== null) {\n        // Apply fixed number of decimal places\n        timeString = time.toFixed(numDecimalPlaces);\n      } else {\n        timeString = '' + time;\n      }\n\n      // Apply leading zeros\n      if (timeString.indexOf('.') > -1) {\n        return leftPadWithZeros(timeString, timeString.length + (leadingZeroes - timeString.indexOf('.')));\n      } else {\n        return leftPadWithZeros(timeString, leadingZeroes);\n      }\n\n    }\n    // Time format\n    else if (format.indexOf(':') > -1) {\n      let totalSeconds = Math.ceil(time);\n\n      // hh:mm:ss format\n      if (format.indexOf('hh') > -1) {\n        return secondsToTime(totalSeconds);\n      }\n      // mm:ss format\n      else {\n        let minutes = Math.floor(totalSeconds / 60);\n        let seconds = totalSeconds % 60;\n\n        return leftPadWithZeros(minutes, 2) + ':' + leftPadWithZeros(seconds, 2);\n      }\n    }\n    // Integer format\n    else {\n      return leftPadWithZeros(Math.ceil(time), leadingZeroes);\n    }\n  }\n}\n\nexport namespace PlayerUtils {\n\n  import Player = bitmovin.player.Player;\n\n  export enum PlayerState {\n    IDLE,\n    PREPARED,\n    PLAYING,\n    PAUSED,\n    FINISHED,\n  }\n\n  export function isSourceLoaded(player: Player): boolean {\n    return player.getConfig().source !== undefined;\n  }\n\n  export function isTimeShiftAvailable(player: Player): boolean {\n    return player.isLive() && player.getMaxTimeShift() !== 0;\n  }\n\n  export function getState(player: Player): PlayerState {\n    if (player.hasEnded()) {\n      return PlayerState.FINISHED;\n    } else if (player.isPlaying()) {\n      return PlayerState.PLAYING;\n    } else if (player.isPaused()) {\n      return PlayerState.PAUSED;\n    } else if (isSourceLoaded(player)) {\n      return PlayerState.PREPARED;\n    } else {\n      return PlayerState.IDLE;\n    }\n  }\n\n  export interface TimeShiftAvailabilityChangedArgs extends NoArgs {\n    timeShiftAvailable: boolean;\n  }\n\n  export class TimeShiftAvailabilityDetector {\n\n    private timeShiftAvailabilityChangedEvent = new EventDispatcher<Player, TimeShiftAvailabilityChangedArgs>();\n\n    constructor(player: Player) {\n      let timeShiftAvailable: boolean = undefined;\n\n      let timeShiftDetector = () => {\n        if (player.isLive()) {\n          let timeShiftAvailableNow = PlayerUtils.isTimeShiftAvailable(player);\n\n          // When the availability changes, we fire the event\n          if (timeShiftAvailableNow !== timeShiftAvailable) {\n            this.timeShiftAvailabilityChangedEvent.dispatch(player, { timeShiftAvailable: timeShiftAvailableNow });\n            timeShiftAvailable = timeShiftAvailableNow;\n          }\n        }\n      };\n      // Try to detect timeshift availability in ON_READY, which works for DASH streams\n      player.addEventHandler(player.EVENT.ON_READY, timeShiftDetector);\n      // With HLS/NativePlayer streams, getMaxTimeShift can be 0 before the buffer fills, so we need to additionally\n      // check timeshift availability in ON_TIME_CHANGED\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, timeShiftDetector);\n    }\n\n    get onTimeShiftAvailabilityChanged(): Event<Player, TimeShiftAvailabilityChangedArgs> {\n      return this.timeShiftAvailabilityChangedEvent.getEvent();\n    }\n  }\n\n  export interface LiveStreamDetectorEventArgs extends NoArgs {\n    live: boolean;\n  }\n\n  /**\n   * Detects changes of the stream type, i.e. changes of the return value of the player#isLive method.\n   * Normally, a stream cannot change its type during playback, it's either VOD or live. Due to bugs on some\n   * platforms or browsers, it can still change. It is therefore unreliable to just check #isLive and this detector\n   * should be used as a workaround instead.\n   *\n   * Known cases:\n   *\n   * - HLS VOD on Android 4.3\n   * Video duration is initially 'Infinity' and only gets available after playback starts, so streams are wrongly\n   * reported as 'live' before playback (the live-check in the player checks for infinite duration).\n   */\n  export class LiveStreamDetector {\n\n    private liveChangedEvent = new EventDispatcher<Player, LiveStreamDetectorEventArgs>();\n\n    constructor(player: Player) {\n      let live: boolean = undefined;\n\n      let liveDetector = () => {\n        let liveNow = player.isLive();\n\n        // Compare current to previous live state flag and fire event when it changes. Since we initialize the flag\n        // with undefined, there is always at least an initial event fired that tells listeners the live state.\n        if (liveNow !== live) {\n          this.liveChangedEvent.dispatch(player, { live: liveNow });\n          live = liveNow;\n        }\n      };\n      // Initialize when player is ready\n      player.addEventHandler(player.EVENT.ON_READY, liveDetector);\n      // Re-evaluate when playback starts\n      player.addEventHandler(player.EVENT.ON_PLAY, liveDetector);\n\n      // HLS live detection workaround for Android:\n      // Also re-evaluate during playback, because that is when the live flag might change.\n      // (Doing it only in Android Chrome saves unnecessary overhead on other plattforms)\n      if (BrowserUtils.isAndroid && BrowserUtils.isChrome) {\n        player.addEventHandler(player.EVENT.ON_TIME_CHANGED, liveDetector);\n      }\n    }\n\n    get onLiveChanged(): Event<Player, LiveStreamDetectorEventArgs> {\n      return this.liveChangedEvent.getEvent();\n    }\n  }\n}\n\nexport namespace UIUtils {\n  export interface TreeTraversalCallback {\n    (component: Component<ComponentConfig>, parent?: Component<ComponentConfig>): void;\n  }\n\n  export function traverseTree(component: Component<ComponentConfig>, visit: TreeTraversalCallback): void {\n    let recursiveTreeWalker = (component: Component<ComponentConfig>, parent?: Component<ComponentConfig>) => {\n      visit(component, parent);\n\n      // If the current component is a container, visit it's children\n      if (component instanceof Container) {\n        for (let childComponent of component.getComponents()) {\n          recursiveTreeWalker(childComponent, component);\n        }\n      }\n    };\n\n    // Walk and configure the component tree\n    recursiveTreeWalker(component);\n  }\n}\n\nexport namespace BrowserUtils {\n\n  // isMobile only needs to be evaluated once (it cannot change during a browser session)\n  // Mobile detection according to Mozilla recommendation: \"In summary, we recommend looking for the string Mobi\n  // anywhere in the User Agent to detect a mobile device.\"\n  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent\n  export const isMobile = navigator && navigator.userAgent && /Mobi/.test(navigator.userAgent);\n\n  export const isChrome = navigator && navigator.userAgent && /Chrome/.test(navigator.userAgent);\n\n  export const isAndroid = navigator && navigator.userAgent && /Android/.test(navigator.userAgent);\n}"]}