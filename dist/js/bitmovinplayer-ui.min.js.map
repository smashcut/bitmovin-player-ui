{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/ts/components/adclickoverlay.ts","src/ts/components/admessagelabel.ts","src/ts/components/adskipbutton.ts","src/ts/components/airplaytogglebutton.ts","src/ts/components/audioqualityselectbox.ts","src/ts/components/audiotrackselectbox.ts","src/ts/components/bufferingoverlay.ts","src/ts/components/button.ts","src/ts/components/caststatusoverlay.ts","src/ts/components/casttogglebutton.ts","src/ts/components/castuicontainer.ts","src/ts/components/checkbox.ts","src/ts/components/clickoverlay.ts","src/ts/components/closebutton.ts","src/ts/components/component.ts","src/ts/components/container.ts","src/ts/components/controlbar.ts","src/ts/components/embedvideopanel.ts","src/ts/components/embedvideotogglebutton.ts","src/ts/components/errormessageoverlay.ts","src/ts/components/fullscreentogglebutton.ts","src/ts/components/hugeplaybacktogglebutton.ts","src/ts/components/hugereplaybutton.ts","src/ts/components/label.ts","src/ts/components/listselector.ts","src/ts/components/metadatalabel.ts","src/ts/components/pictureinpicturetogglebutton.ts","src/ts/components/playbackspeedselectbox.ts","src/ts/components/playbacktimelabel.ts","src/ts/components/playbacktogglebutton.ts","src/ts/components/playbacktoggleoverlay.ts","src/ts/components/recommendationoverlay.ts","src/ts/components/seekbar.ts","src/ts/components/seekbarlabel.ts","src/ts/components/selectbox.ts","src/ts/components/settingspanel.ts","src/ts/components/settingstogglebutton.ts","src/ts/components/spacer.ts","src/ts/components/subtitleoverlay.ts","src/ts/components/subtitleselectbox.ts","src/ts/components/titlebar.ts","src/ts/components/togglebutton.ts","src/ts/components/tvnoisecanvas.ts","src/ts/components/uicontainer.ts","src/ts/components/videoqualityselectbox.ts","src/ts/components/volumecontrolbutton.ts","src/ts/components/volumeslider.ts","src/ts/components/volumetogglebutton.ts","src/ts/components/vrtogglebutton.ts","src/ts/components/watermark.ts","src/ts/dom.ts","src/ts/eventdispatcher.ts","src/ts/guid.ts","src/ts/main.ts","src/ts/timeout.ts","src/ts/uimanager.ts","src/ts/utils.ts"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","clickoverlay_1","AdClickOverlay","_super","__extends","prototype","configure","player","uimanager","_this","this","clickThroughUrl","clickThroughEnabled","getConfig","advertising","hasOwnProperty","addEventHandler","EVENT","ON_AD_STARTED","event","setUrl","adFinishedHandler","ON_AD_FINISHED","ON_AD_SKIPPED","ON_AD_ERROR","onClick","subscribe","pause","fireEvent","ON_AD_CLICKED","ClickOverlay","label_1","utils_1","AdMessageLabel","config","mergeConfig","cssClass","text","updateMessageHandler","setText","StringUtils","replaceAdMessagePlaceholders","adStartHandler","adMessage","ON_TIME_CHANGED","ON_CAST_TIME_UPDATED","adEndHandler","removeEventHandler","Label","button_1","AdSkipButton","skipMessage","countdown","skip","adEvent","updateSkipMessageHandler","skipOffset","show","hide","getCurrentTime","skipAd","Button","togglebutton_1","AirPlayToggleButton","isAirplayAvailable","showAirplayTargetPicker","console","log","airPlayAvailableHandler","ON_AIRPLAY_AVAILABLE","ToggleButton","selectbox_1","AudioQualitySelectBox","updateAudioQualities","audioQualities","getAvailableAudioQualities","clearItems","addItem","_i","audioQualities_1","audioQuality","id","label","onItemSelected","sender","value","setAudioQuality","ON_AUDIO_CHANGED","ON_SOURCE_UNLOADED","ON_READY","ON_AUDIO_DOWNLOAD_QUALITY_CHANGE","data","getDownloadedAudioData","selectItem","isAuto","SelectBox","AudioTrackSelectBox","getAudioTrackLabel","updateAudioTracks","audioTracks","getAvailableAudio","audioTracks_1","audioTrack","setAudio","audioTrackHandler","currentAudioTrack","getAudio","container_1","component_1","timeout_1","BufferingOverlay","indicators","Component","tag","hidden","components","showDelayMs","overlayShowTimeout","Timeout","showOverlay","start","hideOverlay","clear","ON_STALL_STARTED","ON_STALL_ENDED","isStalled","Container","dom_1","eventdispatcher_1","buttonEvents","EventDispatcher","toDomElement","buttonElement","DOM","type","class","getCssClasses","append","prefixCss","html","on","onClickEvent","getDomElement","find","dispatch","Object","defineProperty","getEvent","CastStatusOverlay","statusLabel","ON_CAST_WAITING_FOR_DEVICE","castDeviceName","castPayload","deviceName","ON_CAST_STARTED","ON_CAST_STOPPED","CastToggleButton","isCastAvailable","isCasting","castStop","castVideo","castAvailableHander","ON_CAST_AVAILABLE","off","uicontainer_1","CastUIContainer","isUiShown","hideUi","onControlsHide","castUiHideTimeout","hideDelay","showUi","onControlsShow","showUiPermanently","showUiWithTimeout","showUiAfterSeek","isPlaying","ON_SOURCE_LOADED","ON_PLAY","ON_PAUSED","ON_SEEK","ON_SEEKED","release","UIContainer","Checkbox","checkboxEvents","onChange","cssClasses","button","toggle","onChangeEvent","isOn","initialize","url","element","window","open","getUrl","undefined","CloseButton","target","guid_1","componentEvents","onShow","onHide","onHoverChanged","Guid","next","cssPrefix","isHidden","onComponentShow","onComponentHide","onHoverChangedEvent","defaults","base","assign","flattenedArray","concat","map","css","join","trim","cssClassOrId","addClass","CLASS_HIDDEN","onHideEvent","removeClass","onShowEvent","isShown","toggleHidden","isHovered","hovered","addComponent","component","push","removeComponent","ArrayUtils","remove","getComponents","removeComponents","_a","updateComponents","innerContainerElement","empty","containerElement","innerContainer","spacer_1","ControlBar","hoverStackCount","UIUtils","traverseTree","Spacer","args","onPreviewControlsHide","cancel","closebutton_1","checkbox_1","EmbedVideoPanel","title","closeButton","showCommentsCheckbox","codeField","uiconfig","hideTimeout","reset","init","metadata","embedVideo","ev","withComments","setEmbedVideo","default","source","unload","setHtmlCode","htmlCode","toHtmlEntities","copyTextToClipboard","replace","charCodeAt","textArea","document","createElement","body","appendChild","select","execCommand","err","removeChild","EmbedVideoToggleButton","embedVideoPanel","tvnoisecanvas_1","ErrorMessageOverlay","errorLabel","tvNoiseBackground","TvNoiseCanvas","ON_ERROR","message","messages","customMessage","stop","FullscreenToggleButton","fullscreenStateHandler","isFullscreen","ON_FULLSCREEN_ENTER","ON_FULLSCREEN_EXIT","exitFullscreen","enterFullscreen","playbacktogglebutton_1","HugePlaybackToggleButton","togglePlayback","play","toggleFullscreen","firstPlay","clickTime","doubleClickTime","now","Date","setTimeout","castInitializationHandler","ON_CAST_START","PlaybackToggleButton","HugeReplayButton","labelEvents","onTextChanged","labelElement","onTextChangedEvent","getText","clearText","isEmpty","ListSelector","listSelectorEvents","onItemAdded","onItemRemoved","items","getItemIndex","key","index","parseInt","hasItem","removeItem","onItemAddedEvent","onItemRemovedEvent","selectedItem","onItemSelectedEvent","getSelectedItem","items_1","item","itemCount","keys","MetadataLabelContent","MetadataLabel","content","toLowerCase","Title","Description","description","PictureInPictureToggleButton","isPictureInPictureAvailable","isPictureInPicture","exitPictureInPicture","enterPictureInPicture","pipAvailableHander","ON_PICTURE_IN_PICTURE_ENTER","ON_PICTURE_IN_PICTURE_EXIT","PlaybackSpeedSelectBox","setPlaybackSpeed","parseFloat","PlaybackTimeLabelMode","PlaybackTimeLabel","timeLabelMode","CurrentAndTotalTime","hideInLivePlayback","live","liveCssClass","liveEdgeCssClass","minWidth","liveClickHandler","timeShift","updateLiveState","isLive","updateLiveTimeshiftState","unsubscribe","PlayerUtils","LiveStreamDetector","onLiveChanged","getTimeShift","playbackTimeHandler","getDuration","Infinity","setTime","width","min-width","ON_TIME_SHIFT","ON_TIME_SHIFTED","timeFormat","Math","abs","getMaxTimeShift","FORMAT_HHMMSS","FORMAT_MMSS","playbackSeconds","durationSeconds","currentTime","secondsToTime","totalTime","CurrentTime","TotalTime","handleClickEvent","isSeeking","playbackStateHandler","ON_PLAYBACK_FINISHED","ON_CAST_PLAYING","ON_CAST_PAUSED","ON_CAST_PLAYBACK_FINISHED","TimeShiftAvailabilityDetector","onTimeShiftAvailabilityChanged","timeShiftAvailable","CLASS_STOPTOGGLE","onSeek","onSeeked","hugeplaybacktogglebutton_1","PlaybackToggleOverlay","playbackToggleButton","hugereplaybutton_1","RecommendationOverlay","replayButton","clearRecommendations","RecommendationItem","setupRecommendations","hasRecommendationsInUiConfig","recommendations","hasRecommendationsInPlayerConfig","recommendations_1","itemConfig","isAd","itemElement","href","background-image","thumbnail","bgElement","titleElement","timeElement","duration","SeekBar","playbackPositionPercentage","touchSupported","seekBarEvents","onSeekPreview","vertical","smoothPlaybackPositionUpdateIntervalMs","timelineMarkers","hasLabel","getLabel","configureSeek","playbackNotInitialized","playbackPositionHandler","forceUpdate","setPlaybackPosition","setBufferPosition","videoBufferLength","getVideoBufferLength","audioBufferLength","getAudioBufferLength","bufferLength","min","Number","MAX_VALUE","bufferPercentage","SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED","isPaused","ON_SEGMENT_REQUEST_FINISHED","setSeeking","seek","percentage","subscribeRateLimited","scrubbing","position","hasTimeShift","switchVisibility","refreshPlaybackPosition","ON_PLAYER_RESIZE","onConfigured","setSeekPosition","configureSmoothPlaybackPositionUpdater","configureMarkers","currentTimeSeekBar","currentTimePlayer","smoothPlaybackPositionUpdater","updateIntervalMs","currentTimeDelta","startSmoothPlaybackPositionUpdater","stopSmoothPlaybackPositionUpdater","clearMarkers","updateMarkers","setupMarkers","hasMarkersInUiConfig","markers","hasMarkersInPlayerConfig","markers_1","marker","time","markerType","comment","avatar","number","seekBarContainer","seekBar","seekBarBufferLevel","seekBarBufferPosition","seekBarPlaybackPosition","seekBarPlaybackPositionMarker","seekBarSeekPosition","seekBarBackdrop","seekBarChapterMarkersContainer","seekBarMarkersContainer","seeking","mouseTouchMoveHandler","preventDefault","stopPropagation","targetPercentage","getOffset","onSeekPreviewEvent","mouseTouchUpHandler","snappedChapter","getMarkerAtPosition","onSeekedEvent","isTouchEvent","TouchEvent","onSeekEvent","className","markerDom","data-marker-time","String","data-marker-title","snappedMarker","getHorizontalOffset","eventPageX","elementOffsetPx","offset","left","widthPx","offsetPx","sanitizeOffset","getVerticalOffset","eventPageY","top","height","changedTouches","pageY","touches","pageX","MouseEvent","warn","percent","setPosition","px","style","transform","-ms-transform","scale","CLASS_SEEKING","hasClass","SeekBarLabel","timeLabel","titleLabel","commentLabel","numberLabel","avatarLabel","setTitleText","setSmashcutData","setThumbnail","setBackground","getThumb","seconds","thumbnailElement","display","w","h","background-position","x","y","onOff","metadataElement","background","listselector_1","selectElement","updateDomItems","val","selectedValue","optionElement","attr","videoqualityselectbox_1","audioqualityselectbox_1","SettingsPanel","settingsPanelEvents","onSettingsStateChanged","settingsStateChangedHandler","onSettingsStateChangedEvent","lastShownItem","getItems","SettingsPanelItem","CLASS_LAST","onActiveChanged","hasActiveSettings","isActive","selectBox","settingsPanelItemEvents","setting","handleConfigItemChanged","minItemsToDisplay","VideoQualitySelectBox","onActiveChangedEvent","SettingsToggleButton","settingsPanel","autoHideWhenNoActiveSettings","settingsPanelItemsChangedHandler","controlbar_1","SubtitleOverlay","subtitleManager","ActiveSubtitleManager","ON_CUE_ENTER","labelToAdd","cueEnter","ON_CUE_EXIT","labelToRemove","cueExit","hasCues","subtitleClearHandler","ON_SUBTITLE_CHANGED","CLASS_CONTROLBAR_VISIBLE","SubtitleLabel","activeSubtitleCueMap","calculateId","activeSubtitleCue","cueCount","SubtitleSelectBox","updateSubtitles","getAvailableSubtitles","subtitle","setSubtitle","ON_SUBTITLE_ADDED","targetSubtitle","ON_SUBTITLE_REMOVED","subtitleId","metadatalabel_1","TitleBar","keepHiddenWithoutMetadata","shouldBeShown","hasMetadataText","checkMetadataTextAndUpdateVisibility","toggleButtonEvents","onToggle","onToggleOn","onToggleOff","isOff","onState","CLASS_OFF","CLASS_ON","onToggleEvent","onToggleOnEvent","onToggleOffEvent","canvasWidth","canvasHeight","interferenceHeight","lastFrameUpdate","frameInterval","useAnimationFrame","requestAnimationFrame","canvas","canvasElement","getElements","canvasContext","getContext","noiseAnimationWindowPos","renderFrame","cancelAnimationFrame","frameUpdateHandlerId","clearTimeout","getTime","scheduleNextRender","currentPixelOffset","noiseImage","createImageData","random","putImageData","bind","configureUIShowHide","configurePlayerStates","container","isFirstTouch","uiHideTimeout","previewHideEventArgs","stateClassNames","state","PlayerState","isNaN","enumName","STATE_PREFIX","removeStates","IDLE","PREPARED","PLAYING","PAUSED","FINISHED","getState","FULLSCREEN","BUFFERING","REMOTE_CONTROL","CONTROLS_HIDDEN","CONTROLS_SHOWN","updateLayoutSizeClasses","round","substring","getFigure","flex","updateVideoQualities","videoQualities","getAvailableVideoQualities","videoQualities_1","videoQuality","setVideoQuality","ON_VIDEO_DOWNLOAD_QUALITY_CHANGE","getDownloadedVideoData","volumeslider_1","volumetogglebutton_1","VolumeControlButton","volumeToggleButton","VolumeToggleButton","volumeSlider","VolumeSlider","getVolumeToggleButton","getVolumeSlider","volumeSliderHideTimeout","volumeSliderHovered","seekbar_1","hideIfVolumeControlProhibited","detectVolumeControlAvailability","volumeChangeHandler","isMuted","getVolume","ON_VOLUME_CHANGED","ON_MUTED","ON_UNMUTED","setVolume","volume","muted","playing","mute","muteStateHandler","volumeLevelHandler","unmute","VRToggleButton","isVRConfigured","vr","contentType","isVRStereoAvailable","getVRStatus","vrStateHandler","isStereo","vrButtonVisibilityHandler","ON_VR_MODE_CHANGED","ON_VR_STEREO_CHANGED","ON_VR_ERROR","setVRStereo","Watermark","something","attributes","Array","HTMLElement","elements","Document","tagName","attributeName","attributeValue","setAttribute","selector","findChildElements","forEach","handler","findChildElementsOfElement","childElements","querySelectorAll","slice","allChildElements","arguments","setHtml","getHtml","innerHTML","HTMLSelectElement","HTMLInputElement","attribute","setAttr","getAttr","getAttribute","dataAttribute","setData","getData","childElement","_","parent","parentNode","elementRect","getBoundingClientRect","htmlRect","parentElement","offsetWidth","offsetHeight","eventName","eventHandler","split","addEventListener","removeEventListener","classList","add","RegExp","contains","test","propertyNameOrCollection","propertyName","setCss","getCss","propertyValueCollection","setCssCollection","getComputedStyle","ruleValueCollection","listeners","listener","EventListenerWrapper","subscribeOnce","rateMs","RateLimitedEventListenerWrapper","subscribedListener","unsubscribeAll","listenersToRemove","fire","isOnce","_b","listenersToRemove_1","listenerToRemove","once","eventListener","lastFireTime","rateLimitingEventListener","fireSuper","guid","uimanager_1","fullscreentogglebutton_1","playbacktimelabel_1","settingspanel_1","settingstogglebutton_1","vrtogglebutton_1","watermark_1","audiotrackselectbox_1","caststatusoverlay_1","casttogglebutton_1","errormessageoverlay_1","recommendationoverlay_1","seekbarlabel_1","subtitleoverlay_1","subtitleselectbox_1","titlebar_1","volumecontrolbutton_1","adskipbutton_1","admessagelabel_1","adclickoverlay_1","playbackspeedselectbox_1","bufferingoverlay_1","castuicontainer_1","playbacktoggleoverlay_1","airplaytogglebutton_1","pictureinpicturetogglebutton_1","TypeError","bitmovin","playerui","UIManager","UIInstanceManager","BrowserUtils","delay","callback","repeat","timeoutHandle","lastScheduleTime","delayAdjust","internalCallback","delta","embedvideotogglebutton_1","embedvideopanel_1","playerUiOrUiVariants","playerUi","uiVariants","ui","managerPlayerWrapper","PlayerWrapper","playerElement","uiInstanceManagers","uiVariantsWithoutCondition","uiVariant","condition","InternalUIInstanceManager","adStartedEvent","isMobile","resolveUiVariant","ad","adWithUI","clientType","context","isAdWithUI","documentWidth","clientWidth","nextUi","uiVariantChanged","indexOf","currentUi","getUI","isConfigured","addUi","getWrappedPlayer","fireEventInUI","getPlayer","dom","configureControls","releaseUi","releaseControls","clearEventHandlers","uiInstanceManager","Factory","buildDefaultUI","buildModernUI","buildDefaultSmallScreenUI","buildModernSmallScreenUI","buildDefaultCastReceiverUI","buildModernCastReceiverUI","smashcutUi","controlBarTop","controlBarMiddle","controlBarBottom","controlBar","modernAdsUI","modernSmallScreenUI","modernSmallScreenAdsUI","modernCastReceiverUI","legacyUI","legacyAdsUI","legacyCastReceiverUI","legacyTestUI","buildLegacyUI","buildLegacyCastReceiverUI","buildLegacyTestUI","events","playerWrapper","event_1","configureControlsTree","configured","configuredComponents","configuredComponents_1","error","constructor","name","releaseControlsTree","released","isReleased","childComponent","eventHandlers","methods","member","wrapper","methods_1","apply","eventType","playerEventData","timestamp","uiSourced","array","splice","totalSeconds","format","isNegative","hours","floor","minutes","leftPadWithZeros","num","substr","adMessagePlaceholderRegex","formatString","ceil","formatNumber","formatStringValidationRegex","leadingZeroes","leadingZeroesMatches","match","numDecimalPlaces","decimalPlacesMatches","timeString","toFixed","isSourceLoaded","isTimeShiftAvailable","hasEnded","timeShiftAvailabilityChangedEvent","timeShiftDetector","timeShiftAvailableNow","liveChangedEvent","liveDetector","liveNow","isAndroid","isChrome","visit","recursiveTreeWalker","navigator","userAgent"],"mappings":"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","file":"bitmovinplayer-ui.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import {ClickOverlay} from './clickoverlay';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A simple click capture overlay for clickThroughUrls of ads.\n */\nexport class AdClickOverlay extends ClickOverlay {\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let clickThroughUrl = <string>null;\n    let clickThroughEnabled = !player.getConfig().advertising\n      || !player.getConfig().advertising.hasOwnProperty('clickThroughEnabled')\n      || player.getConfig().advertising.clickThroughEnabled;\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, (event: bitmovin.player.AdStartedEvent) => {\n      clickThroughUrl = event.clickThroughUrl;\n\n      if (clickThroughEnabled) {\n        this.setUrl(clickThroughUrl);\n      } else {\n        // If click-through is disabled, we set the url to null to avoid it open\n        this.setUrl(null);\n      }\n    });\n\n    // Clear click-through URL when ad has finished\n    let adFinishedHandler = () => {\n      this.setUrl(null);\n    };\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adFinishedHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adFinishedHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adFinishedHandler);\n\n    this.onClick.subscribe(() => {\n      // Pause the ad when overlay is clicked\n      player.pause('ui-content-click');\n\n      // Notify the player of the clicked ad\n      player.fireEvent(player.EVENT.ON_AD_CLICKED, {\n        clickThroughUrl: clickThroughUrl\n      });\n    });\n  }\n}","import {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {StringUtils} from '../utils';\n\n/**\n * A label that displays a message about a running ad, optionally with a countdown.\n */\nexport class AdMessageLabel extends Label<LabelConfig> {\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-label-ad-message',\n      text: 'This ad will end in {remainingTime} seconds.'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let text = this.getConfig().text;\n\n    let updateMessageHandler = () => {\n      this.setText(StringUtils.replaceAdMessagePlaceholders(text, null, player));\n    };\n\n    let adStartHandler = (event: bitmovin.player.AdStartedEvent) => {\n      text = event.adMessage || text;\n      updateMessageHandler();\n\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, updateMessageHandler);\n      player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateMessageHandler);\n    };\n\n    let adEndHandler = () => {\n      player.removeEventHandler(player.EVENT.ON_TIME_CHANGED, updateMessageHandler);\n      player.removeEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateMessageHandler);\n    };\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, adStartHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adEndHandler);\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {UIInstanceManager} from '../uimanager';\nimport SkipMessage = bitmovin.player.SkipMessage;\nimport {StringUtils} from '../utils';\n\n/**\n * Configuration interface for the {@link AdSkipButton}.\n */\nexport interface AdSkipButtonConfig extends ButtonConfig {\n  skipMessage?: SkipMessage;\n}\n\n/**\n * A button that is displayed during ads and can be used to skip the ad.\n */\nexport class AdSkipButton extends Button<AdSkipButtonConfig> {\n\n  constructor(config: AdSkipButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <AdSkipButtonConfig>{\n      cssClass: 'ui-button-ad-skip',\n      skipMessage: {\n        countdown: 'Skip ad in {remainingTime}',\n        skip: 'Skip ad'\n      }\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <AdSkipButtonConfig>this.getConfig(); // TODO get rid of generic cast\n    let skipMessage = config.skipMessage;\n    let adEvent = <bitmovin.player.AdStartedEvent>null;\n\n    let updateSkipMessageHandler = () => {\n      // Display this button only if ad is skippable\n      if (adEvent.skipOffset) {\n        this.show();\n      } else {\n        this.hide();\n      }\n\n      // Update the skip message on the button\n      if (player.getCurrentTime() < adEvent.skipOffset) {\n        this.setText(\n          StringUtils.replaceAdMessagePlaceholders(config.skipMessage.countdown, adEvent.skipOffset, player));\n      } else {\n        this.setText(config.skipMessage.skip);\n      }\n    };\n\n    let adStartHandler = (event: bitmovin.player.AdStartedEvent) => {\n      adEvent = event;\n      skipMessage = adEvent.skipMessage || skipMessage;\n      updateSkipMessageHandler();\n\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, updateSkipMessageHandler);\n      player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateSkipMessageHandler);\n    };\n\n    let adEndHandler = () => {\n      player.removeEventHandler(player.EVENT.ON_TIME_CHANGED, updateSkipMessageHandler);\n      player.removeEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateSkipMessageHandler);\n    };\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, adStartHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adEndHandler);\n\n    this.onClick.subscribe(() => {\n      // Try to skip the ad (this only works if it is skippable so we don't need to take extra care of that here)\n      player.skipAd();\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles Apple AirPlay.\n */\nexport class AirPlayToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-airplaytogglebutton',\n      text: 'Apple AirPlay'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      if (player.isAirplayAvailable()) {\n        player.showAirplayTargetPicker();\n      } else {\n        if (console) {\n          console.log('AirPlay unavailable');\n        }\n      }\n    });\n\n    let airPlayAvailableHandler = () => {\n      if (player.isAirplayAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_AIRPLAY_AVAILABLE, airPlayAvailableHandler);\n\n    // Startup init\n    airPlayAvailableHandler(); // Hide button if AirPlay is not available\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between 'auto' and the available audio qualities.\n */\nexport class AudioQualitySelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let updateAudioQualities = () => {\n      let audioQualities = player.getAvailableAudioQualities();\n\n      this.clearItems();\n\n      // Add entry for automatic quality switching (default setting)\n      this.addItem('Auto', 'Auto');\n\n      // Add audio qualities\n      for (let audioQuality of audioQualities) {\n        this.addItem(audioQuality.id, audioQuality.label);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: AudioQualitySelectBox, value: string) => {\n      player.setAudioQuality(value);\n    });\n\n    // Update qualities when audio track has changed\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, updateAudioQualities);\n    // Update qualities when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateAudioQualities);\n    // Update qualities when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateAudioQualities);\n    // Update quality selection when quality is changed (from outside)\n    player.addEventHandler(player.EVENT.ON_AUDIO_DOWNLOAD_QUALITY_CHANGE, () => {\n      let data = player.getDownloadedAudioData();\n      this.selectItem(data.isAuto ? 'Auto' : data.id);\n    });\n\n    // Populate qualities at startup\n    updateAudioQualities();\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between available audio tracks (e.g. different languages).\n */\nexport class AudioTrackSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    // TODO Move to config?\n    let getAudioTrackLabel = (id: string) => {\n      switch (id) {\n        case 'en_stereo':\n          return 'English - Stereo';\n        case 'no-voices_stereo':\n          return 'No Voices - Stereo';\n        case 'en_surround':\n          return 'English - Surround';\n        default:\n          return id\n      }\n    }\n\n    let updateAudioTracks = () => {\n      let audioTracks = player.getAvailableAudio();\n\n      this.clearItems();\n\n      // Add audio tracks\n      for (let audioTrack of audioTracks) {\n        this.addItem(audioTrack.id, getAudioTrackLabel(audioTrack.label));\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: AudioTrackSelectBox, value: string) => {\n      player.setAudio(value);\n    });\n\n    let audioTrackHandler = () => {\n      let currentAudioTrack = player.getAudio();\n\n      // HLS streams don't always provide this, so we have to check\n      if (currentAudioTrack) {\n        this.selectItem(currentAudioTrack.id);\n      }\n    };\n\n    // Update selection when selected track has changed\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, audioTrackHandler);\n    // Update tracks when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateAudioTracks);\n    // Update tracks when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateAudioTracks);\n\n    // Populate tracks at startup\n    updateAudioTracks();\n\n    // When `playback.audioLanguage` is set, the `ON_AUDIO_CHANGED` event for that change is triggered before the\n    // UI is created. Therefore we need to set the audio track on configure.\n    audioTrackHandler();\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {Component, ComponentConfig} from './component';\nimport {Timeout} from '../timeout';\n\n/**\n * Configuration interface for the {@link BufferingOverlay} component.\n */\nexport interface BufferingOverlayConfig extends ContainerConfig {\n  /**\n   * Delay in milliseconds after which the buffering overlay will be displayed. Useful to bypass short stalls without\n   * displaying the overlay. Set to 0 to display the overlay instantly.\n   * Default: 1000ms (1 second)\n   */\n  showDelayMs?: number;\n}\n\n/**\n * Overlays the player and displays a buffering indicator.\n */\nexport class BufferingOverlay extends Container<BufferingOverlayConfig> {\n\n  private indicators: Component<ComponentConfig>[];\n\n  constructor(config: BufferingOverlayConfig = {}) {\n    super(config);\n\n    this.indicators = [\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n    ];\n\n    this.config = this.mergeConfig(config, <BufferingOverlayConfig>{\n      cssClass: 'ui-buffering-overlay',\n      hidden: true,\n      components: this.indicators,\n      showDelayMs: 1000,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <BufferingOverlayConfig>this.getConfig();\n\n    let overlayShowTimeout = new Timeout(config.showDelayMs, () => {\n      this.show();\n    });\n\n    let showOverlay = () => {\n      overlayShowTimeout.start();\n    };\n\n    let hideOverlay = () => {\n      overlayShowTimeout.clear();\n      this.hide();\n    };\n\n    player.addEventHandler(player.EVENT.ON_STALL_STARTED, showOverlay);\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, hideOverlay);\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, hideOverlay);\n\n    // Show overlay if player is already stalled at init\n    if (player.isStalled()) {\n      this.show();\n    }\n  }\n}\n","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {EventDispatcher, NoArgs, Event} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link Button} component.\n */\nexport interface ButtonConfig extends ComponentConfig {\n  /**\n   * The text on the button.\n   */\n  text?: string;\n}\n\n/**\n * A simple clickable button.\n */\nexport class Button<Config extends ButtonConfig> extends Component<ButtonConfig> {\n\n  private buttonEvents = {\n    onClick: new EventDispatcher<Button<Config>, NoArgs>()\n  };\n\n  constructor(config: ButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-button'\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    // Create the button element with the text label\n    let buttonElement = new DOM('button', {\n      'type': 'button',\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    }).append(new DOM('span', {\n      'class': this.prefixCss('label')\n    }).html(this.config.text));\n\n    // Listen for the click event on the button element and trigger the corresponding event on the button component\n    buttonElement.on('click', () => {\n      this.onClickEvent();\n    });\n\n    return buttonElement;\n  }\n\n  /**\n   * Sets text on the label of the button.\n   * @param text the text to put into the label of the button\n   */\n  setText(text: string): void {\n    this.getDomElement().find('.' + this.prefixCss('label')).html(text);\n  }\n\n  protected onClickEvent() {\n    this.buttonEvents.onClick.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the button is clicked.\n   * @returns {Event<Button<Config>, NoArgs>}\n   */\n  get onClick(): Event<Button<Config>, NoArgs> {\n    return this.buttonEvents.onClick.getEvent();\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport CastWaitingForDeviceEvent = bitmovin.player.CastWaitingForDeviceEvent;\nimport CastStartedEvent = bitmovin.player.CastStartedEvent;\n\n/**\n * Overlays the player and displays the status of a Cast session.\n */\nexport class CastStatusOverlay extends Container<ContainerConfig> {\n\n  private statusLabel: Label<LabelConfig>;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.statusLabel = new Label<LabelConfig>({ cssClass: 'ui-cast-status-label' });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-cast-status-overlay',\n      components: [this.statusLabel],\n      hidden: true\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    player.addEventHandler(player.EVENT.ON_CAST_WAITING_FOR_DEVICE,\n      (event: CastWaitingForDeviceEvent) => {\n        this.show();\n        // Get device name and update status text while connecting\n        let castDeviceName = event.castPayload.deviceName;\n        this.statusLabel.setText(`Connecting to <strong>${castDeviceName}</strong>...`);\n      });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, (event: CastStartedEvent) => {\n      // Session is started or resumed\n      // For cases when a session is resumed, we do not receive the previous events and therefore show the status panel\n      // here too\n      this.show();\n      let castDeviceName = event.deviceName;\n      this.statusLabel.setText(`Playing on <strong>${castDeviceName}</strong>`);\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, (event) => {\n      // Cast session gone, hide the status panel\n      this.hide();\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles casting to a Cast receiver.\n */\nexport class CastToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-casttogglebutton',\n      text: 'Google Cast'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      if (player.isCastAvailable()) {\n        if (player.isCasting()) {\n          player.castStop();\n        } else {\n          player.castVideo();\n        }\n      } else {\n        if (console) {\n          console.log('Cast unavailable');\n        }\n      }\n    });\n\n    let castAvailableHander = () => {\n      if (player.isCastAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_CAST_AVAILABLE, castAvailableHander);\n\n    // Toggle button 'on' state\n    player.addEventHandler(player.EVENT.ON_CAST_WAITING_FOR_DEVICE, () => {\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      // When a session is resumed, there is no ON_CAST_START event, so we also need to toggle here for such cases\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, () => {\n      this.off();\n    });\n\n    // Startup init\n    castAvailableHander(); // Hide button if Cast not available\n    if (player.isCasting()) {\n      this.on();\n    }\n  }\n}","import {UIContainer, UIContainerConfig} from './uicontainer';\nimport {UIInstanceManager} from '../uimanager';\nimport {Timeout} from '../timeout';\n\n/**\n * The base container for Cast receivers that contains all of the UI and takes care that the UI is shown on\n * certain playback events.\n */\nexport class CastUIContainer extends UIContainer {\n\n  private castUiHideTimeout: Timeout;\n\n  constructor(config: UIContainerConfig) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <UIContainerConfig>this.getConfig();\n\n    /*\n     * Show UI on Cast devices at certain playback events\n     *\n     * Since a Cast receiver does not have a direct HCI, we show the UI on certain playback events to give the user\n     * a chance to see on the screen what's going on, e.g. on play/pause or a seek the UI is shown and the user can\n     * see the current time and position on the seek bar.\n     * The UI is shown permanently while playback is paused, otherwise hides automatically after the configured\n     * hide delay time.\n     */\n\n    let isUiShown = false;\n\n    let hideUi = () => {\n      uimanager.onControlsHide.dispatch(this);\n      isUiShown = false;\n    };\n\n    this.castUiHideTimeout = new Timeout(config.hideDelay, hideUi);\n\n    let showUi = () => {\n      if (!isUiShown) {\n        uimanager.onControlsShow.dispatch(this);\n        isUiShown = true;\n      }\n    };\n\n    let showUiPermanently = () => {\n      showUi();\n      this.castUiHideTimeout.clear();\n    };\n\n    let showUiWithTimeout = () => {\n      showUi();\n      this.castUiHideTimeout.start();\n    };\n\n    let showUiAfterSeek = () => {\n      if (player.isPlaying()) {\n        showUiWithTimeout();\n      } else {\n        showUiPermanently();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_PLAY, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_PAUSED, showUiPermanently);\n    player.addEventHandler(player.EVENT.ON_SEEK, showUiPermanently);\n    player.addEventHandler(player.EVENT.ON_SEEKED, showUiAfterSeek);\n  }\n\n  release(): void {\n    super.release();\n    this.castUiHideTimeout.clear();\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\nimport {Container, ContainerConfig} from './container';\nimport {Label, LabelConfig} from './label';\nimport {Event, EventDispatcher, NoArgs} from '../eventdispatcher';\nimport Config = bitmovin.player.Config;\n\n/**\n * Configuration interface for a {@link Checkbox}.\n */\nexport interface CheckboxConfig extends ContainerConfig {\n  /**\n   * The label for the checkbox.\n   */\n  text: string;\n}\n\nexport class Checkbox extends Container<CheckboxConfig> {\n\n  private label: Label<LabelConfig>;\n  private button: ToggleButton<ToggleButtonConfig>;\n\n  private checkboxEvents = {\n    onClick: new EventDispatcher<Checkbox, NoArgs>(),\n    onChange: new EventDispatcher<Checkbox, NoArgs>()\n  };\n\n  constructor(config: CheckboxConfig = {text: ''}) {\n    super(config);\n\n    this.label = new Label({cssClasses: ['checkbox-label'], text: config.text});\n    this.button = new ToggleButton({cssClasses: ['checkbox-button']});\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-checkbox',\n      components: [this.button, this.label]\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    // Listen for the click event on the element and\n    // trigger the corresponding events on the button component\n    this.getDomElement().on('click', () => {\n      this.button.toggle()\n      this.onClickEvent()\n      this.onChangeEvent()\n    });\n  }\n\n  /**\n   * Sets arbitrary text on the label.\n   * @param text the text to show on the label\n   */\n  setText(text: string) {\n    this.label.setText(text);\n  }\n\n  protected onClickEvent() {\n    this.checkboxEvents.onClick.dispatch(this);\n  }\n\n  protected onChangeEvent() {\n    this.checkboxEvents.onChange.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the button is clicked.\n   * @returns {Event<Checkbox, NoArgs>}\n   */\n  get onClick(): Event<Checkbox, NoArgs> {\n    return this.checkboxEvents.onClick.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the value is changed\n   * @returns {Event<Checkbox, NoArgs>}\n   */\n  get onChange(): Event<Checkbox, NoArgs> {\n    return this.checkboxEvents.onChange.getEvent();\n  }\n\n  get isOn(): boolean {\n    return this.button.isOn()\n  }\n}","import {Button, ButtonConfig} from './button';\n\n/**\n * Configuration interface for a {@link ClickOverlay}.\n */\nexport interface ClickOverlayConfig extends ButtonConfig {\n  /**\n   * The url to open when the overlay is clicked. Set to null to disable the click handler.\n   */\n  url?: string;\n}\n\n/**\n * A click overlay that opens an url in a new tab if clicked.\n */\nexport class ClickOverlay extends Button<ClickOverlayConfig> {\n\n  constructor(config: ClickOverlayConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-clickoverlay'\n    }, <ClickOverlayConfig>this.config);\n  }\n\n  initialize(): void {\n    super.initialize();\n\n    this.setUrl((<ClickOverlayConfig>this.config).url);\n    let element = this.getDomElement();\n    element.on('click', () => {\n      if (element.data('url')) {\n        window.open(element.data('url'), '_blank');\n      }\n    });\n  }\n\n  /**\n   * Gets the URL that should be followed when the watermark is clicked.\n   * @returns {string} the watermark URL\n   */\n  getUrl(): string {\n    return this.getDomElement().data('url');\n  }\n\n  setUrl(url: string): void {\n    if (url === undefined || url == null) {\n      url = '';\n    }\n    this.getDomElement().data('url', url);\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {UIInstanceManager} from '../uimanager';\nimport {Component, ComponentConfig} from './component';\n\n/**\n * Configuration interface for the {@link CloseButton}.\n */\nexport interface CloseButtonConfig extends ButtonConfig {\n  /**\n   * The component that should be closed when the button is clicked.\n   */\n  target: Component<ComponentConfig>;\n}\n\n/**\n * A button that closes (hides) a configured component.\n */\nexport class CloseButton extends Button<CloseButtonConfig> {\n\n  constructor(config: CloseButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-closebutton',\n      text: 'Close'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <CloseButtonConfig>this.getConfig();\n\n    this.onClick.subscribe(() => {\n      config.target.hide();\n    });\n  }\n}","import {Guid} from '../guid';\nimport {DOM} from '../dom';\nimport {EventDispatcher, NoArgs, Event} from '../eventdispatcher';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Base configuration interface for a component.\n * Should be extended by components that want to add additional configuration options.\n */\nexport interface ComponentConfig {\n  /**\n   * The HTML tag name of the component.\n   * Default: 'div'\n   */\n  tag?: string;\n  /**\n   * The HTML ID of the component.\n   * Default: automatically generated with pattern 'ui-id-{guid}'.\n   */\n  id?: string;\n\n  /**\n   * A prefix to prepend all CSS classes with.\n   */\n  cssPrefix?: string;\n\n  /**\n   * The CSS classes of the component. This is usually the class from where the component takes its styling.\n   */\n  cssClass?: string; // 'class' is a reserved keyword, so we need to make the name more complicated\n\n  /**\n   * Additional CSS classes of the component.\n   */\n  cssClasses?: string[];\n\n  /**\n   * Specifies if the component should be hidden at startup.\n   * Default: false\n   */\n  hidden?: boolean;\n}\n\nexport interface ComponentHoverChangedEventArgs extends NoArgs {\n  /**\n   * True is the component is hovered, else false.\n   */\n  hovered: boolean;\n}\n\n/**\n * The base class of the UI framework.\n * Each component must extend this class and optionally the config interface.\n */\nexport class Component<Config extends ComponentConfig> {\n\n  /**\n   * The classname that is attached to the element when it is in the hidden state.\n   * @type {string}\n   */\n  private static readonly CLASS_HIDDEN = 'hidden';\n\n  /**\n   * Configuration object of this component.\n   */\n  protected config: Config;\n\n  /**\n   * The component's DOM element.\n   */\n  private element: DOM;\n\n  /**\n   * Flag that keeps track of the hidden state.\n   */\n  private hidden: boolean;\n\n  /**\n   * Flag that keeps track of the hover state.\n   */\n  private hovered: boolean;\n\n  /**\n   * The list of events that this component offers. These events should always be private and only directly\n   * accessed from within the implementing component.\n   *\n   * Because TypeScript does not support private properties with the same name on different class hierarchy levels\n   * (i.e. superclass and subclass cannot contain a private property with the same name), the default naming\n   * convention for the event list of a component that should be followed by subclasses is the concatenation of the\n   * camel-cased class name + 'Events' (e.g. SubClass extends Component => subClassEvents).\n   * See {@link #componentEvents} for an example.\n   *\n   * Event properties should be named in camel case with an 'on' prefix and in the present tense. Async events may\n   * have a start event (when the operation starts) in the present tense, and must have an end event (when the\n   * operation ends) in the past tense (or present tense in special cases (e.g. onStart/onStarted or onPlay/onPlaying).\n   * See {@link #componentEvents#onShow} for an example.\n   *\n   * Each event should be accompanied with a protected method named by the convention eventName + 'Event'\n   * (e.g. onStartEvent), that actually triggers the event by calling {@link EventDispatcher#dispatch dispatch} and\n   * passing a reference to the component as first parameter. Components should always trigger their events with these\n   * methods. Implementing this pattern gives subclasses means to directly listen to the events by overriding the\n   * method (and saving the overhead of passing a handler to the event dispatcher) and more importantly to trigger\n   * these events without having access to the private event list.\n   * See {@link #onShow} for an example.\n   *\n   * To provide external code the possibility to listen to this component's events (subscribe, unsubscribe, etc.),\n   * each event should also be accompanied by a public getter function with the same name as the event's property,\n   * that returns the {@link Event} obtained from the event dispatcher by calling {@link EventDispatcher#getEvent}.\n   * See {@link #onShow} for an example.\n   *\n   * Full example for an event representing an example action in a example component:\n   *\n   * <code>\n   * // Define an example component class with an example event\n   * class ExampleComponent extends Component<ComponentConfig> {\n     *\n     *     private exampleComponentEvents = {\n     *         onExampleAction: new EventDispatcher<ExampleComponent, NoArgs>()\n     *     }\n     *\n     *     // constructor and other stuff...\n     *\n     *     protected onExampleActionEvent() {\n     *        this.exampleComponentEvents.onExampleAction.dispatch(this);\n     *    }\n     *\n     *    get onExampleAction(): Event<ExampleComponent, NoArgs> {\n     *        return this.exampleComponentEvents.onExampleAction.getEvent();\n     *    }\n     * }\n   *\n   * // Create an instance of the component somewhere\n   * var exampleComponentInstance = new ExampleComponent();\n   *\n   * // Subscribe to the example event on the component\n   * exampleComponentInstance.onExampleAction.subscribe(function (sender: ExampleComponent) {\n     *     console.log('onExampleAction of ' + sender + ' has fired!');\n     * });\n   * </code>\n   */\n  private componentEvents = {\n    onShow: new EventDispatcher<Component<Config>, NoArgs>(),\n    onHide: new EventDispatcher<Component<Config>, NoArgs>(),\n    onHoverChanged: new EventDispatcher<Component<Config>, ComponentHoverChangedEventArgs>(),\n  };\n\n  /**\n   * Constructs a component with an optionally supplied config. All subclasses must call the constructor of their\n   * superclass and then merge their configuration into the component's configuration.\n   * @param config the configuration for the component\n   */\n  constructor(config: ComponentConfig = {}) {\n    // Create the configuration for this component\n    this.config = <Config>this.mergeConfig(config, {\n      tag: 'div',\n      id: 'bmpui-id-' + Guid.next(),\n      cssPrefix: 'bmpui',\n      cssClass: 'ui-component',\n      cssClasses: [],\n      hidden: false\n    }, {});\n  }\n\n  /**\n   * Initializes the component, e.g. by applying config settings.\n   * This method must not be called from outside the UI framework.\n   *\n   * This method is automatically called by the {@link UIInstanceManager}. If the component is an inner component of\n   * some component, and thus encapsulated abd managed internally and never directly exposed to the UIManager,\n   * this method must be called from the managing component's {@link #initialize} method.\n   */\n  initialize(): void {\n    this.hidden = this.config.hidden;\n\n    // Hide the component at initialization if it is configured to be hidden\n    if (this.isHidden()) {\n      this.hidden = false; // Set flag to false for the following hide() call to work (hide() checks the flag)\n      this.hide();\n    }\n  }\n\n  /**\n   * Configures the component for the supplied Player and UIInstanceManager. This is the place where all the magic\n   * happens, where components typically subscribe and react to events (on their DOM element, the Player, or the\n   * UIInstanceManager), and basically everything that makes them interactive.\n   * This method is called only once, when the UIManager initializes the UI.\n   *\n   * Subclasses usually overwrite this method to add their own functionality.\n   *\n   * @param player the player which this component controls\n   * @param uimanager the UIInstanceManager that manages this component\n   */\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    this.onShow.subscribe(() => {\n      uimanager.onComponentShow.dispatch(this);\n    });\n    this.onHide.subscribe(() => {\n      uimanager.onComponentHide.dispatch(this);\n    });\n\n    // Track the hovered state of the element\n    this.getDomElement().on('mouseenter', () => {\n      this.onHoverChangedEvent(true);\n    });\n    this.getDomElement().on('mouseleave', () => {\n      this.onHoverChangedEvent(false);\n    });\n  }\n\n  /**\n   * Releases all resources and dependencies that the component holds. Player, DOM, and UIManager events are\n   * automatically removed during release and do not explicitly need to be removed here.\n   * This method is called by the UIManager when it releases the UI.\n   *\n   * Subclasses that need to release resources should override this method and call super.release().\n   */\n  release(): void {\n    // Nothing to do here, override where necessary\n  }\n\n  /**\n   * Generate the DOM element for this component.\n   *\n   * Subclasses usually overwrite this method to extend or replace the DOM element with their own design.\n   */\n  protected toDomElement(): DOM {\n    let element = new DOM(this.config.tag, {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    return element;\n  }\n\n  /**\n   * Returns the DOM element of this component. Creates the DOM element if it does not yet exist.\n   *\n   * Should not be overwritten by subclasses.\n   *\n   * @returns {DOM}\n   */\n  getDomElement(): DOM {\n    if (!this.element) {\n      this.element = this.toDomElement();\n    }\n\n    return this.element;\n  }\n\n  /**\n   * Merges a configuration with a default configuration and a base configuration from the superclass.\n   *\n   * @param config the configuration settings for the components, as usually passed to the constructor\n   * @param defaults a default configuration for settings that are not passed with the configuration\n   * @param base configuration inherited from a superclass\n   * @returns {Config}\n   */\n  protected mergeConfig<Config>(config: Config, defaults: Config, base: Config): Config {\n    // Extend default config with supplied config\n    let merged = Object.assign({}, base, defaults, config);\n\n    // Return the extended config\n    return merged;\n  }\n\n  /**\n   * Helper method that returns a string of all CSS classes of the component.\n   *\n   * @returns {string}\n   */\n  protected getCssClasses(): string {\n    // Merge all CSS classes into single array\n    let flattenedArray = [this.config.cssClass].concat(this.config.cssClasses);\n    // Prefix classes\n    flattenedArray = flattenedArray.map((css) => {\n      return this.prefixCss(css);\n    });\n    // Join array values into a string\n    let flattenedString = flattenedArray.join(' ');\n    // Return trimmed string to prevent whitespace at the end from the join operation\n    return flattenedString.trim();\n  }\n\n  protected prefixCss(cssClassOrId: string): string {\n    return this.config.cssPrefix + '-' + cssClassOrId;\n  }\n\n  /**\n   * Returns the configuration object of the component.\n   * @returns {Config}\n   */\n  public getConfig(): Config {\n    return this.config;\n  }\n\n  /**\n   * Hides the component if shown.\n   * This method basically transfers the component into the hidden state. Actual hiding is done via CSS.\n   */\n  hide() {\n    if (!this.hidden) {\n      this.hidden = true;\n      this.getDomElement().addClass(this.prefixCss(Component.CLASS_HIDDEN));\n      this.onHideEvent();\n    }\n  }\n\n  /**\n   * Shows the component if hidden.\n   */\n  show() {\n    if (this.hidden) {\n      this.getDomElement().removeClass(this.prefixCss(Component.CLASS_HIDDEN));\n      this.hidden = false;\n      this.onShowEvent();\n    }\n  }\n\n  /**\n   * Determines if the component is hidden.\n   * @returns {boolean} true if the component is hidden, else false\n   */\n  isHidden(): boolean {\n    return this.hidden;\n  }\n\n  /**\n   * Determines if the component is shown.\n   * @returns {boolean} true if the component is visible, else false\n   */\n  isShown(): boolean {\n    return !this.isHidden();\n  }\n\n  /**\n   * Toggles the hidden state by hiding the component if it is shown, or showing it if hidden.\n   */\n  toggleHidden() {\n    if (this.isHidden()) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  }\n\n  /**\n   * Determines if the component is currently hovered.\n   * @returns {boolean} true if the component is hovered, else false\n   */\n  isHovered(): boolean {\n    return this.hovered;\n  }\n\n  /**\n   * Fires the onShow event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onShowEvent(): void {\n    this.componentEvents.onShow.dispatch(this);\n  }\n\n  /**\n   * Fires the onHide event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onHideEvent(): void {\n    this.componentEvents.onHide.dispatch(this);\n  }\n\n  /**\n   * Fires the onHoverChanged event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onHoverChangedEvent(hovered: boolean): void {\n    this.hovered = hovered;\n    this.componentEvents.onHoverChanged.dispatch(this, { hovered: hovered });\n  }\n\n  /**\n   * Gets the event that is fired when the component is showing.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   * @returns {Event<Component<Config>, NoArgs>}\n   */\n  get onShow(): Event<Component<Config>, NoArgs> {\n    return this.componentEvents.onShow.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the component is hiding.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   * @returns {Event<Component<Config>, NoArgs>}\n   */\n  get onHide(): Event<Component<Config>, NoArgs> {\n    return this.componentEvents.onHide.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the component's hover-state is changing.\n   * @returns {Event<Component<Config>, ComponentHoverChangedEventArgs>}\n   */\n  get onHoverChanged(): Event<Component<Config>, ComponentHoverChangedEventArgs> {\n    return this.componentEvents.onHoverChanged.getEvent();\n  }\n}","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {ArrayUtils} from '../utils';\n\n/**\n * Configuration interface for a {@link Container}.\n */\nexport interface ContainerConfig extends ComponentConfig {\n  /**\n   * Child components of the container.\n   */\n  components?: Component<ComponentConfig>[];\n}\n\n/**\n * A container component that can contain a collection of child components.\n * Components can be added at construction time through the {@link ContainerConfig#components} setting, or later\n * through the {@link Container#addComponent} method. The UIManager automatically takes care of all components, i.e. it\n * initializes and configures them automatically.\n *\n * In the DOM, the container consists of an outer <div> (that can be configured by the config) and an inner wrapper\n * <div> that contains the components. This double-<div>-structure is often required to achieve many advanced effects\n * in CSS and/or JS, e.g. animations and certain formatting with absolute positioning.\n *\n * DOM example:\n * <code>\n *     <div class='ui-container'>\n *         <div class='container-wrapper'>\n *             ... child components ...\n *         </div>\n *     </div>\n * </code>\n */\nexport class Container<Config extends ContainerConfig> extends Component<ContainerConfig> {\n\n  /**\n   * A reference to the inner element that contains the components of the container.\n   */\n  private innerContainerElement: DOM;\n\n  constructor(config: ContainerConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-container',\n      components: []\n    }, this.config);\n  }\n\n  /**\n   * Adds a child component to the container.\n   * @param component the component to add\n   */\n  addComponent(component: Component<ComponentConfig>) {\n    this.config.components.push(component);\n  }\n\n  /**\n   * Removes a child component from the container.\n   * @param component the component to remove\n   * @returns {boolean} true if the component has been removed, false if it is not contained in this container\n   */\n  removeComponent(component: Component<ComponentConfig>): boolean {\n    return ArrayUtils.remove(this.config.components, component) != null;\n  }\n\n  /**\n   * Gets an array of all child components in this container.\n   * @returns {Component<ComponentConfig>[]}\n   */\n  getComponents(): Component<ComponentConfig>[] {\n    return this.config.components;\n  }\n\n  /**\n   * Removes all child components from the container.\n   */\n  removeComponents(): void {\n    for (let component of this.getComponents()) {\n      this.removeComponent(component);\n    }\n  }\n\n  /**\n   * Updates the DOM of the container with the current components.\n   */\n  protected updateComponents(): void {\n    this.innerContainerElement.empty();\n\n    for (let component of this.config.components) {\n      this.innerContainerElement.append(component.getDomElement());\n    }\n  }\n\n  protected toDomElement(): DOM {\n    // Create the container element (the outer <div>)\n    let containerElement = new DOM(this.config.tag, {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    // Create the inner container element (the inner <div>) that will contain the components\n    let innerContainer = new DOM(this.config.tag, {\n      'class': this.prefixCss('container-wrapper')\n    });\n    this.innerContainerElement = innerContainer;\n\n    this.updateComponents();\n\n    containerElement.append(innerContainer);\n\n    return containerElement;\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {UIUtils} from '../utils';\nimport {Spacer} from './spacer';\n\n/**\n * Configuration interface for the {@link ControlBar}.\n */\nexport interface ControlBarConfig extends ContainerConfig {\n  // nothing yet\n}\n\n/**\n * A container for main player control components, e.g. play toggle button, seek bar, volume control, fullscreen toggle\n * button.\n */\nexport class ControlBar extends Container<ControlBarConfig> {\n\n  constructor(config: ControlBarConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-controlbar',\n      hidden: true,\n    }, <ControlBarConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    // Counts how many components are hovered and block hiding of the control bar\n    let hoverStackCount = 0;\n\n    // Track hover status of child components\n    UIUtils.traverseTree(this, (component) => {\n      // Do not track hover status of child containers or spacers, only of 'real' controls\n      if (component instanceof Container || component instanceof Spacer) {\n        return;\n      }\n\n      // Subscribe hover event and keep a count of the number of hovered children\n      component.onHoverChanged.subscribe((sender, args) => {\n        if (args.hovered) {\n          hoverStackCount++;\n        } else {\n          hoverStackCount--;\n        }\n      });\n    });\n\n    uimanager.onControlsShow.subscribe(() => {\n      this.show();\n    });\n    uimanager.onPreviewControlsHide.subscribe((sender, args) => {\n      // Cancel the hide event if hovered child components block hiding\n      args.cancel = (hoverStackCount > 0);\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      this.hide();\n    });\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {Timeout} from '../timeout';\nimport {Label, LabelConfig} from './label';\nimport {CloseButton} from './closebutton';\nimport {Checkbox} from './checkbox';\n\n/**\n * Configuration interface for a {@link EmbedVideoPanel}.\n */\nexport interface EmbedVideoPanelConfig extends ContainerConfig {\n  /**\n   * The delay in milliseconds after which the embedVideo panel will be hidden when there is no user interaction.\n   * Set to -1 to disable automatic hiding.\n   * Default: 3 seconds (3000)\n   */\n  hideDelay?: number;\n}\n\n/**\n * A panel containing a list of {@link EmbedVideoPanelItem items} that represent labelled embedVideo.\n */\nexport class EmbedVideoPanel extends Container<EmbedVideoPanelConfig> {\n\n  private closeButton: CloseButton;\n  private title: Label<LabelConfig>;\n  private showCommentsCheckbox: Checkbox;\n  private codeField: Label<LabelConfig>;\n\n\n  private hideTimeout: Timeout;\n\n  constructor(config: EmbedVideoPanelConfig) {\n    super(config);\n\n    this.title = new Label({text: 'Embed Video', cssClass: 'ui-embedvideo-panel-title'});\n    this.closeButton = new CloseButton({target: this});\n    this.showCommentsCheckbox = new Checkbox({text: 'Show comments'});\n    this.codeField = new Label({cssClass: 'ui-embedvideo-panel-codefield'});\n\n\n    this.config = this.mergeConfig<EmbedVideoPanelConfig>(config, {\n        cssClass: 'ui-embedvideo-panel',\n        hideDelay: 3000,\n        components: [\n          new Container({\n            cssClass: 'ui-embedvideo-panel-header',\n            components: [\n              this.title,\n              this.closeButton,\n            ]\n          }),\n          this.showCommentsCheckbox,\n          this.codeField\n        ]\n      },\n      this.config\n    )\n    ;\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <EmbedVideoPanelConfig>this.getConfig(); // TODO fix generics type inference\n    let uiconfig = uimanager.getConfig();\n\n    if (config.hideDelay > -1) {\n      this.hideTimeout = new Timeout(config.hideDelay, () => {\n        this.hide();\n      });\n\n      this.onShow.subscribe(() => {\n        // Activate timeout when shown\n        this.hideTimeout.start();\n      });\n      this.getDomElement().on('mousemove', () => {\n        // Reset timeout on interaction\n        this.hideTimeout.reset();\n      });\n      this.getDomElement().on('click', () => {\n        // Reset timeout on interaction\n        this.hideTimeout.reset();\n      });\n      this.onHide.subscribe(() => {\n        // Clear timeout when hidden from outside\n        this.hideTimeout.clear();\n      });\n    };\n\n    let init = () => {\n      if (uiconfig && uiconfig.metadata && uiconfig.metadata.embedVideo) {\n        let ev = uiconfig.metadata.embedVideo\n        if (this.showCommentsCheckbox.isOn && ev.withComments) {\n          this.setEmbedVideo(ev.withComments);\n        } else {\n          this.setEmbedVideo(ev.default);\n        }\n      } else if (player.getConfig().source && player.getConfig().source.embedVideo) {\n        let ev = player.getConfig().source.embedVideo\n        if (this.showCommentsCheckbox.isOn && ev.withComments) {\n          this.setEmbedVideo(ev.withComments);\n        } else {\n          this.setEmbedVideo(ev.default);\n        }\n      }\n    };\n\n    let unload = () => {\n      this.setHtmlCode(null);\n    };\n\n    // Init label\n    init();\n\n    // Reinit label when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, init);\n    // Clear labels when source is unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, unload);\n\n    // update when checkbox is changed\n    this.showCommentsCheckbox.onChange.subscribe(init);\n\n    // update when shown\n    this.onShow.subscribe(init);\n  }\n\n  release(): void {\n    super.release();\n    if (this.hideTimeout) {\n      this.hideTimeout.clear();\n    }\n  }\n\n  setEmbedVideo(htmlCode: string): void {\n    if (htmlCode) {\n      let code = this.toHtmlEntities(htmlCode)\n      this.setHtmlCode(code)\n      this.copyTextToClipboard(htmlCode)\n    } else {\n      this.setHtmlCode(null)\n    }\n  }\n\n  setHtmlCode(code: string): void {\n    this.codeField.setText(code)\n  }\n\n  toHtmlEntities(s: string): string {\n    return s.replace(/./gm, function (s) {\n      return '&#' + s.charCodeAt(0) + ';';\n    });\n  }\n\n  copyTextToClipboard(text: string): void {\n    const textArea = document.createElement('textarea')\n    textArea.value = text\n    document.body.appendChild(textArea)\n    textArea.select()\n    try {\n      document.execCommand('copy')\n    } catch (err) {\n    }\n    document.body.removeChild(textArea)\n  }\n}\n\n","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {EmbedVideoPanel} from './embedvideopanel';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Configuration interface for the {@link EmbedVideoToggleButton}.\n */\nexport interface EmbedVideoToggleButtonConfig extends ToggleButtonConfig {\n  /**\n   * The embedVideo panel whose visibility the button should toggle.\n   */\n  embedVideoPanel: EmbedVideoPanel;\n}\n\n/**\n * A button that toggles visibility of a embedVideo panel.\n */\nexport class EmbedVideoToggleButton extends ToggleButton<EmbedVideoToggleButtonConfig> {\n\n  constructor(config: EmbedVideoToggleButtonConfig) {\n    super(config);\n\n    if (!config.embedVideoPanel) {\n      throw new Error('Required EmbedVideoPanel is missing');\n    }\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-embedvideo-togglebutton',\n      text: 'Embed Video',\n      embedVideoPanel: null\n    }, <EmbedVideoToggleButtonConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <EmbedVideoToggleButtonConfig>this.getConfig(); // TODO fix generics type inference\n    let embedVideoPanel = config.embedVideoPanel;\n\n    this.onClick.subscribe(() => {\n      console.log('onClick hidden:', embedVideoPanel.isHidden())\n      embedVideoPanel.toggleHidden();\n    });\n\n    embedVideoPanel.onShow.subscribe(() => {\n      // Set toggle status to on when the embedVideo panel shows\n      this.on();\n    });\n\n    embedVideoPanel.onHide.subscribe(() => {\n      // Set toggle status to off when the embedVideo panel hides\n      this.off();\n    });\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport ErrorEvent = bitmovin.player.ErrorEvent;\nimport {TvNoiseCanvas} from './tvnoisecanvas';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\nexport interface ErrorMessageTranslator {\n  (error: ErrorEvent): string;\n}\n\nexport interface ErrorMessageMap {\n  [code: number]: string | ErrorMessageTranslator;\n}\n\n/**\n * Configuration interface for the {@link ErrorMessageOverlay}.\n */\nexport interface ErrorMessageOverlayConfig extends ContainerConfig {\n  /**\n   * Allows overwriting of the error messages displayed in the overlay for customization and localization.\n   * This is either a function that receives any {@link ErrorEvent} as parameter and translates error messages,\n   * or a map of error codes that overwrites specific error messages with a plain string or a function that\n   * receives the {@link ErrorEvent} as parameter and returns a customized string.\n   * The translation functions can be used to extract data (e.g. parameters) from the original error message.\n   *\n   * Example 1 (catch-all translation function):\n   * <code>\n   * errorMessageOverlayConfig = {\n   *   messages: function(error) {\n   *     switch (error.code) {\n   *       // Overwrite error 3000 'Unknown error'\n   *       case 3000:\n   *         return 'Houston, we have a problem'\n   *\n   *       // Transform error 3001 'Unsupported manifest format' to uppercase\n   *       case 3001:\n   *         return error.message.toUpperCase();\n   *\n   *       // Customize error 3006 'Could not load manifest, got HTTP status code XXX'\n   *       case 3006:\n   *         var statusCode = error.message.substring(46);\n   *         return 'Manifest loading failed with HTTP error ' + statusCode;\n   *     }\n   *     // Return unmodified error message for all other errors\n   *     return error.message;\n   *   }\n   * };\n   * </code>\n   *\n   * Example 2 (translating specific errors):\n   * <code>\n   * errorMessageOverlayConfig = {\n   *   messages: {\n   *     // Overwrite error 3000 'Unknown error'\n   *     3000: 'Houston, we have a problem',\n   *\n   *     // Transform error 3001 'Unsupported manifest format' to uppercase\n   *     3001: function(error) {\n   *       return error.message.toUpperCase();\n   *     },\n   *\n   *     // Customize error 3006 'Could not load manifest, got HTTP status code XXX'\n   *     3006: function(error) {\n   *       var statusCode = error.message.substring(46);\n   *       return 'Manifest loading failed with HTTP error ' + statusCode;\n   *     }\n   *   }\n   * };\n   * </code>\n   */\n  messages?: ErrorMessageMap | ErrorMessageTranslator;\n}\n\n/**\n * Overlays the player and displays error messages.\n */\nexport class ErrorMessageOverlay extends Container<ErrorMessageOverlayConfig> {\n\n  private errorLabel: Label<LabelConfig>;\n  private tvNoiseBackground: TvNoiseCanvas;\n\n  constructor(config: ErrorMessageOverlayConfig = {}) {\n    super(config);\n\n    this.errorLabel = new Label<LabelConfig>({ cssClass: 'ui-errormessage-label' });\n    this.tvNoiseBackground = new TvNoiseCanvas();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-errormessage-overlay',\n      components: [this.tvNoiseBackground, this.errorLabel],\n      hidden: true\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <ErrorMessageOverlayConfig>this.getConfig();\n\n    player.addEventHandler(player.EVENT.ON_ERROR, (event: ErrorEvent) => {\n      let message = event.message;\n\n      // Process message translations\n      if (config.messages) {\n        if (typeof config.messages === 'function') {\n          // Translation function for all errors\n          message = config.messages(event);\n        } else if (config.messages[event.code]) {\n          // It's not a translation function, so it must be a map of strings or translation functions\n          let customMessage = config.messages[event.code];\n\n          if (typeof customMessage === 'string') {\n            message = customMessage;\n          } else {\n            // The message is a translation function, so we call it\n            message = customMessage(event);\n          }\n        }\n      }\n\n      this.errorLabel.setText(message);\n      this.tvNoiseBackground.start();\n      this.show();\n    });\n\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, (event: PlayerEvent) => {\n      if (this.isShown()) {\n        this.tvNoiseBackground.stop();\n        this.hide();\n      }\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles the player between windowed and fullscreen view.\n */\nexport class FullscreenToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-fullscreentogglebutton',\n      text: 'Fullscreen'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let fullscreenStateHandler = () => {\n      if (player.isFullscreen()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_ENTER, fullscreenStateHandler);\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_EXIT, fullscreenStateHandler);\n\n    this.onClick.subscribe(() => {\n      if (player.isFullscreen()) {\n        player.exitFullscreen();\n      } else {\n        player.enterFullscreen();\n      }\n    });\n\n    // Startup init\n    fullscreenStateHandler();\n  }\n}","import {ToggleButtonConfig} from './togglebutton';\nimport {PlaybackToggleButton} from './playbacktogglebutton';\nimport {DOM} from '../dom';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\n/**\n * A button that overlays the video and toggles between playback and pause.\n */\nexport class HugePlaybackToggleButton extends PlaybackToggleButton {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-hugeplaybacktogglebutton',\n      text: 'Play/Pause'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    // Update button state through API events\n    super.configure(player, uimanager, false);\n\n    let togglePlayback = () => {\n      if (player.isPlaying()) {\n        player.pause('ui-overlay');\n      } else {\n        player.play('ui-overlay');\n      }\n    };\n\n    let toggleFullscreen = () => {\n      if (player.isFullscreen()) {\n        player.exitFullscreen();\n      } else {\n        player.enterFullscreen();\n      }\n    };\n\n    let firstPlay = true;\n    let clickTime = 0;\n    let doubleClickTime = 0;\n\n    /*\n     * YouTube-style toggle button handling\n     *\n     * The goal is to prevent a short pause or playback interval between a click, that toggles playback, and a\n     * double click, that toggles fullscreen. In this naive approach, the first click would e.g. start playback,\n     * the second click would be detected as double click and toggle to fullscreen, and as second normal click stop\n     * playback, which results is a short playback interval with max length of the double click detection\n     * period (usually 500ms).\n     *\n     * To solve this issue, we defer handling of the first click for 200ms, which is almost unnoticeable to the user,\n     * and just toggle playback if no second click (double click) has been registered during this period. If a double\n     * click is registered, we just toggle the fullscreen. In the first 200ms, undesired playback changes thus cannot\n     * happen. If a double click is registered within 500ms, we undo the playback change and switch fullscreen mode.\n     * In the end, this method basically introduces a 200ms observing interval in which playback changes are prevented\n     * if a double click happens.\n     */\n    this.onClick.subscribe(() => {\n      // Directly start playback on first click of the button.\n      // This is a required workaround for mobile browsers where video playback needs to be triggered directly\n      // by the user. A deferred playback start through the timeout below is not considered as user action and\n      // therefore ignored by mobile browsers.\n      if (firstPlay) {\n        // Try to start playback. Then we wait for ON_PLAY and only when it arrives, we disable the firstPlay flag.\n        // If we disable the flag here, onClick was triggered programmatically instead of by a user interaction, and\n        // playback is blocked (e.g. on mobile devices due to the programmatic play() call), we loose the chance to\n        // ever start playback through a user interaction again with this button.\n        togglePlayback();\n        return;\n      }\n\n      let now = Date.now();\n\n      if (now - clickTime < 200) {\n        // We have a double click inside the 200ms interval, just toggle fullscreen mode\n        toggleFullscreen();\n        doubleClickTime = now;\n        return;\n      } else if (now - clickTime < 500) {\n        // We have a double click inside the 500ms interval, undo playback toggle and toggle fullscreen mode\n        toggleFullscreen();\n        togglePlayback();\n        doubleClickTime = now;\n        return;\n      }\n\n      clickTime = now;\n\n      setTimeout(() => {\n        if (Date.now() - doubleClickTime > 200) {\n          // No double click detected, so we toggle playback and wait what happens next\n          togglePlayback();\n        }\n      }, 200);\n    });\n\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      // Playback has really started, we can disable the flag to switch to normal toggle button handling\n      firstPlay = false;\n    });\n\n    // Hide button while initializing a Cast session\n    let castInitializationHandler = (event: PlayerEvent) => {\n      if (event.type === player.EVENT.ON_CAST_START) {\n        // Hide button when session is being initialized\n        this.hide();\n      } else {\n        // Show button when session is established or initialization was aborted\n        this.show();\n      }\n    };\n    player.addEventHandler(player.EVENT.ON_CAST_START, castInitializationHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, castInitializationHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, castInitializationHandler);\n  }\n\n  protected toDomElement(): DOM {\n    let buttonElement = super.toDomElement();\n\n    // Add child that contains the play button image\n    // Setting the image directly on the button does not work together with scaling animations, because the button\n    // can cover the whole video player are and scaling would extend it beyond. By adding an inner element, confined\n    // to the size if the image, it can scale inside the player without overshooting.\n    buttonElement.append(new DOM('div', {\n      'class': this.prefixCss('image')\n    }));\n\n    return buttonElement;\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {DOM} from '../dom';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\n/**\n * A button to play/replay a video.\n */\nexport class HugeReplayButton extends Button<ButtonConfig> {\n\n  constructor(config: ButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-hugereplaybutton',\n      text: 'Replay'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      player.play('ui-overlay');\n    });\n  }\n\n  protected toDomElement(): DOM {\n    let buttonElement = super.toDomElement();\n\n    // Add child that contains the play button image\n    // Setting the image directly on the button does not work together with scaling animations, because the button\n    // can cover the whole video player are and scaling would extend it beyond. By adding an inner element, confined\n    // to the size if the image, it can scale inside the player without overshooting.\n    buttonElement.append(new DOM('div', {\n      'class': this.prefixCss('image')\n    }));\n\n    return buttonElement;\n  }\n}","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {EventDispatcher, Event, NoArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link Label} component.\n */\nexport interface LabelConfig extends ComponentConfig {\n  /**\n   * The text on the label.\n   */\n  text?: string;\n}\n\n/**\n * A simple text label.\n *\n * DOM example:\n * <code>\n *     <span class='ui-label'>...some text...</span>\n * </code>\n */\nexport class Label<Config extends LabelConfig> extends Component<LabelConfig> {\n\n  private text: string;\n\n  private labelEvents = {\n    onClick: new EventDispatcher<Label<Config>, NoArgs>(),\n    onTextChanged: new EventDispatcher<Label<Config>, string>(),\n  };\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-label'\n    }, this.config);\n\n    this.text = this.config.text;\n  }\n\n  protected toDomElement(): DOM {\n    let labelElement = new DOM('span', {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    }).html(this.text);\n\n    labelElement.on('click', () => {\n      this.onClickEvent();\n    });\n\n    return labelElement;\n  }\n\n  /**\n   * Set the text on this label.\n   * @param text\n   */\n  setText(text: string) {\n    this.text = text;\n    this.getDomElement().html(text);\n    this.onTextChangedEvent(text);\n  }\n\n  /**\n   * Gets the text on this label.\n   * @return {string} The text on the label\n   */\n  getText(): string {\n    return this.text;\n  }\n\n  /**\n   * Clears the text on this label.\n   */\n  clearText() {\n    this.getDomElement().html('');\n    this.onTextChangedEvent(null);\n  }\n\n  /**\n   * Tests if the label is empty and does not contain any text.\n   * @return {boolean} True if the label is empty, else false\n   */\n  isEmpty(): boolean {\n    return !this.text;\n  }\n\n  /**\n   * Fires the {@link #onClick} event.\n   * Can be used by subclasses to listen to this event without subscribing an event listener by overwriting the method\n   * and calling the super method.\n   */\n  protected onClickEvent() {\n    this.labelEvents.onClick.dispatch(this);\n  }\n\n  /**\n   * Fires the {@link #onClick} event.\n   * Can be used by subclasses to listen to this event without subscribing an event listener by overwriting the method\n   * and calling the super method.\n   */\n  protected onTextChangedEvent(text: string) {\n    this.labelEvents.onTextChanged.dispatch(this, text);\n  }\n\n  /**\n   * Gets the event that is fired when the label is clicked.\n   * @returns {Event<Label<LabelConfig>, NoArgs>}\n   */\n  get onClick(): Event<Label<LabelConfig>, NoArgs> {\n    return this.labelEvents.onClick.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the text on the label is changed.\n   * @returns {Event<Label<LabelConfig>, string>}\n   */\n  get onTextChanged(): Event<Label<LabelConfig>, string> {\n    return this.labelEvents.onTextChanged.getEvent();\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {EventDispatcher, Event} from '../eventdispatcher';\nimport {ArrayUtils} from '../utils';\n\n/**\n * A map of items (key/value -> label} for a {@link ListSelector} in a {@link ListSelectorConfig}.\n */\nexport interface ListItem {\n  key: string;\n  label: string;\n}\n\n/**\n * Configuration interface for a {@link ListSelector}.\n */\nexport interface ListSelectorConfig extends ComponentConfig {\n  items?: ListItem[];\n}\n\nexport abstract class ListSelector<Config extends ListSelectorConfig> extends Component<ListSelectorConfig> {\n\n  protected items: ListItem[];\n  protected selectedItem: string;\n\n  private listSelectorEvents = {\n    onItemAdded: new EventDispatcher<ListSelector<Config>, string>(),\n    onItemRemoved: new EventDispatcher<ListSelector<Config>, string>(),\n    onItemSelected: new EventDispatcher<ListSelector<Config>, string>()\n  };\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      items: [],\n      cssClass: 'ui-listselector'\n    }, this.config);\n\n    this.items = this.config.items;\n  }\n\n  private getItemIndex(key: string): number {\n    for (let index in this.items) {\n      if (key === this.items[index].key) {\n        return parseInt(index);\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Checks if the specified item is part of this selector.\n   * @param key the key of the item to check\n   * @returns {boolean} true if the item is part of this selector, else false\n   */\n  hasItem(key: string): boolean {\n    return this.getItemIndex(key) > -1;\n  }\n\n  /**\n   * Adds an item to this selector by appending it to the end of the list of items. If an item with the specified\n   * key already exists, it is replaced.\n   * @param key the key of the item to add\n   * @param label the (human-readable) label of the item to add\n   */\n  addItem(key: string, label: string) {\n    this.removeItem(key); // Try to remove key first to get overwrite behavior and avoid duplicate keys\n    this.items.push({ key: key, label: label });\n    this.onItemAddedEvent(key);\n  }\n\n  /**\n   * Removes an item from this selector.\n   * @param key the key of the item to remove\n   * @returns {boolean} true if removal was successful, false if the item is not part of this selector\n   */\n  removeItem(key: string): boolean {\n    let index = this.getItemIndex(key);\n    if (index > -1) {\n      ArrayUtils.remove(this.items, this.items[index]);\n      this.onItemRemovedEvent(key);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Selects an item from the items in this selector.\n   * @param key the key of the item to select\n   * @returns {boolean} true is the selection was successful, false if the selected item is not part of the selector\n   */\n  selectItem(key: string): boolean {\n    if (key === this.selectedItem) {\n      // itemConfig is already selected, suppress any further action\n      return true;\n    }\n\n    let index = this.getItemIndex(key);\n\n    if (index > -1) {\n      this.selectedItem = key;\n      this.onItemSelectedEvent(key);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns the key of the selected item.\n   * @returns {string} the key of the selected item or null if no item is selected\n   */\n  getSelectedItem(): string | null {\n    return this.selectedItem;\n  }\n\n  /**\n   * Removes all items from this selector.\n   */\n  clearItems() {\n    let items = this.items; // local copy for iteration after clear\n    this.items = []; // clear items\n\n    // fire events\n    for (let item of items) {\n      this.onItemRemovedEvent(item.key);\n    }\n  }\n\n  /**\n   * Returns the number of items in this selector.\n   * @returns {number}\n   */\n  itemCount(): number {\n    return Object.keys(this.items).length;\n  }\n\n  protected onItemAddedEvent(key: string) {\n    this.listSelectorEvents.onItemAdded.dispatch(this, key);\n  }\n\n  protected onItemRemovedEvent(key: string) {\n    this.listSelectorEvents.onItemRemoved.dispatch(this, key);\n  }\n\n  protected onItemSelectedEvent(key: string) {\n    this.listSelectorEvents.onItemSelected.dispatch(this, key);\n  }\n\n  /**\n   * Gets the event that is fired when an item is added to the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemAdded(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemAdded.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when an item is removed from the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemRemoved(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemRemoved.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when an item is selected from the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemSelected(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemSelected.getEvent();\n  }\n}","import {LabelConfig, Label} from './label';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Enumerates the types of content that the {@link MetadataLabel} can display.\n */\nexport enum MetadataLabelContent {\n  /**\n   * Title of the data source.\n   */\n  Title,\n  /**\n   * Description fo the data source.\n   */\n  Description,\n}\n\n/**\n * Configuration interface for {@link MetadataLabel}.\n */\nexport interface MetadataLabelConfig extends LabelConfig {\n  /**\n   * The type of content that should be displayed in the label.\n   */\n  content: MetadataLabelContent;\n}\n\n/**\n * A label that can be configured to display certain metadata.\n */\nexport class MetadataLabel extends Label<MetadataLabelConfig> {\n\n  constructor(config: MetadataLabelConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClasses: ['label-metadata', 'label-metadata-' + MetadataLabelContent[config.content].toLowerCase()]\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <MetadataLabelConfig>this.getConfig();\n    let uiconfig = uimanager.getConfig();\n\n    let init = () => {\n      switch (config.content) {\n        case MetadataLabelContent.Title:\n          if (uiconfig && uiconfig.metadata && uiconfig.metadata.title) {\n            this.setText(uiconfig.metadata.title);\n          } else if (player.getConfig().source && player.getConfig().source.title) {\n            this.setText(player.getConfig().source.title);\n          }\n          break;\n        case MetadataLabelContent.Description:\n          if (uiconfig && uiconfig.metadata && uiconfig.metadata.description) {\n            this.setText(uiconfig.metadata.description);\n          } else if (player.getConfig().source && player.getConfig().source.description) {\n            this.setText(player.getConfig().source.description);\n          }\n          break;\n      }\n    };\n\n    let unload = () => {\n      this.setText(null);\n    };\n\n    // Init label\n    init();\n    // Reinit label when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, init);\n    // Clear labels when source is unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, unload);\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles Apple macOS picture-in-picture mode.\n */\nexport class PictureInPictureToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-piptogglebutton',\n      text: 'Picture-in-Picture'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      if (player.isPictureInPictureAvailable()) {\n        if (player.isPictureInPicture()) {\n          player.exitPictureInPicture();\n        } else {\n          player.enterPictureInPicture();\n        }\n      } else {\n        if (console) {\n          console.log('PIP unavailable');\n        }\n      }\n    });\n\n    let pipAvailableHander = () => {\n      if (player.isPictureInPictureAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, pipAvailableHander);\n\n    // Toggle button 'on' state\n    player.addEventHandler(player.EVENT.ON_PICTURE_IN_PICTURE_ENTER, () => {\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_PICTURE_IN_PICTURE_EXIT, () => {\n      this.off();\n    });\n\n    // Startup init\n    pipAvailableHander(); // Hide button if PIP not available\n    if (player.isPictureInPicture()) {\n      this.on();\n    }\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection of different playback speeds.\n */\nexport class PlaybackSpeedSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem('0.25', '0.25x');\n    this.addItem('0.5', '0.5x');\n    this.addItem('1', 'Normal');\n    this.addItem('1.5', '1.5x');\n    this.addItem('2', '2x');\n\n    this.selectItem('1');\n\n\n    this.onItemSelected.subscribe((sender: PlaybackSpeedSelectBox, value: string) => {\n      player.setPlaybackSpeed(parseFloat(value));\n    });\n  }\n}","import {LabelConfig, Label} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {StringUtils, PlayerUtils} from '../utils';\nimport LiveStreamDetectorEventArgs = PlayerUtils.LiveStreamDetectorEventArgs;\n\nexport enum PlaybackTimeLabelMode {\n  CurrentTime,\n  TotalTime,\n  CurrentAndTotalTime,\n}\n\nexport interface PlaybackTimeLabelConfig extends LabelConfig {\n  timeLabelMode?: PlaybackTimeLabelMode;\n  hideInLivePlayback?: boolean;\n}\n\n/**\n * A label that display the current playback time and the total time through {@link PlaybackTimeLabel#setTime setTime}\n * or any string through {@link PlaybackTimeLabel#setText setText}.\n */\nexport class PlaybackTimeLabel extends Label<PlaybackTimeLabelConfig> {\n\n  private timeFormat: string;\n\n  constructor(config: PlaybackTimeLabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <PlaybackTimeLabelConfig>{\n      cssClass: 'ui-playbacktimelabel',\n      timeLabelMode: PlaybackTimeLabelMode.CurrentAndTotalTime,\n      hideInLivePlayback: false,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <PlaybackTimeLabelConfig>this.getConfig();\n    let live = false;\n    let liveCssClass = this.prefixCss('ui-playbacktimelabel-live');\n    let liveEdgeCssClass = this.prefixCss('ui-playbacktimelabel-live-edge');\n    let minWidth = 0;\n\n    let liveClickHandler = () => {\n      player.timeShift(0);\n    };\n\n    let updateLiveState = () => {\n      // Player is playing a live stream when the duration is infinite\n      live = player.isLive();\n\n      // Attach/detach live marker class\n      if (live) {\n        this.getDomElement().addClass(liveCssClass);\n        this.setText('Live');\n        if (config.hideInLivePlayback) {\n          this.hide();\n        }\n        this.onClick.subscribe(liveClickHandler);\n        updateLiveTimeshiftState();\n      } else {\n        this.getDomElement().removeClass(liveCssClass);\n        this.getDomElement().removeClass(liveEdgeCssClass);\n        this.show();\n        this.onClick.unsubscribe(liveClickHandler);\n      }\n    };\n\n    new PlayerUtils.LiveStreamDetector(player).onLiveChanged.subscribe((sender, args: LiveStreamDetectorEventArgs) => {\n      live = args.live;\n      updateLiveState();\n    });\n\n    let updateLiveTimeshiftState = () => {\n      if (player.getTimeShift() === 0) {\n        this.getDomElement().addClass(liveEdgeCssClass);\n      } else {\n        this.getDomElement().removeClass(liveEdgeCssClass);\n      }\n    };\n\n    let playbackTimeHandler = () => {\n      if (!live && player.getDuration() !== Infinity) {\n        this.setTime(player.getCurrentTime(), player.getDuration());\n      }\n\n      // To avoid 'jumping' in the UI by varying label sizes due to non-monospaced fonts,\n      // we gradually increase the min-width with the content to reach a stable size.\n      let width = this.getDomElement().width();\n      if (width > minWidth) {\n        minWidth = width;\n        this.getDomElement().css({\n          'min-width': minWidth + 'px'\n        });\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_TIME_CHANGED, playbackTimeHandler);\n    player.addEventHandler(player.EVENT.ON_SEEKED, playbackTimeHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, playbackTimeHandler);\n\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, updateLiveTimeshiftState);\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, updateLiveTimeshiftState);\n\n    let init = () => {\n      // Reset min-width when a new source is ready (especially for switching VOD/Live modes where the label content\n      // changes)\n      minWidth = 0;\n      this.getDomElement().css({\n        'min-width': null\n      });\n\n      // Set time format depending on source duration\n      this.timeFormat = Math.abs(player.isLive() ? player.getMaxTimeShift() : player.getDuration()) >= 3600 ?\n        StringUtils.FORMAT_HHMMSS : StringUtils.FORMAT_MMSS;\n\n      // Update time after the format has been set\n      playbackTimeHandler();\n    };\n    player.addEventHandler(player.EVENT.ON_READY, init);\n\n    init();\n  }\n\n  /**\n   * Sets the current playback time and total duration.\n   * @param playbackSeconds the current playback time in seconds\n   * @param durationSeconds the total duration in seconds\n   */\n  setTime(playbackSeconds: number, durationSeconds: number) {\n    let currentTime = StringUtils.secondsToTime(playbackSeconds, this.timeFormat);\n    let totalTime = StringUtils.secondsToTime(durationSeconds, this.timeFormat);\n\n    switch ((<PlaybackTimeLabelConfig>this.config).timeLabelMode) {\n      case PlaybackTimeLabelMode.CurrentTime:\n        this.setText(`${currentTime}`);\n        break;\n      case PlaybackTimeLabelMode.TotalTime:\n        this.setText(`${totalTime}`);\n        break;\n      case PlaybackTimeLabelMode.CurrentAndTotalTime:\n        this.setText(`${currentTime} / ${totalTime}`);\n        break;\n    }\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\nimport {PlayerUtils} from '../utils';\nimport TimeShiftAvailabilityChangedArgs = PlayerUtils.TimeShiftAvailabilityChangedArgs;\n\n/**\n * A button that toggles between playback and pause.\n */\nexport class PlaybackToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  private static readonly CLASS_STOPTOGGLE = 'stoptoggle';\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-playbacktogglebutton',\n      text: 'Play/Pause'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager, handleClickEvent: boolean = true): void {\n    super.configure(player, uimanager);\n\n    let isSeeking = false;\n\n    // Handler to update button state based on player state\n    let playbackStateHandler = (event: PlayerEvent) => {\n      // If the UI is currently seeking, playback is temporarily stopped but the buttons should\n      // not reflect that and stay as-is (e.g indicate playback while seeking).\n      if (isSeeking) {\n        return;\n      }\n\n      if (player.isPlaying()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    // Call handler upon these events\n    player.addEventHandler(player.EVENT.ON_PLAY, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_PAUSED, playbackStateHandler);\n    // when playback finishes, player turns to paused mode\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYING, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PAUSED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYBACK_FINISHED, playbackStateHandler);\n\n    // Detect absence of timeshifting on live streams and add tagging class to convert button icons to play/stop\n    new PlayerUtils.TimeShiftAvailabilityDetector(player).onTimeShiftAvailabilityChanged.subscribe(\n      (sender, args: TimeShiftAvailabilityChangedArgs) => {\n        if (!args.timeShiftAvailable) {\n          this.getDomElement().addClass(this.prefixCss(PlaybackToggleButton.CLASS_STOPTOGGLE));\n        } else {\n          this.getDomElement().removeClass(this.prefixCss(PlaybackToggleButton.CLASS_STOPTOGGLE));\n        }\n      }\n    );\n\n    if (handleClickEvent) {\n      // Control player by button events\n      // When a button event triggers a player API call, events are fired which in turn call the event handler\n      // above that updated the button state.\n      this.onClick.subscribe(() => {\n        if (player.isPlaying()) {\n          player.pause('ui-button');\n        } else {\n          player.play('ui-button');\n        }\n      });\n    }\n\n    // Track UI seeking status\n    uimanager.onSeek.subscribe(() => {\n      isSeeking = true;\n    });\n    uimanager.onSeeked.subscribe(() => {\n      isSeeking = false;\n    });\n\n    // Startup init\n    playbackStateHandler(null);\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {HugePlaybackToggleButton} from './hugeplaybacktogglebutton';\n\n/**\n * Overlays the player and displays error messages.\n */\nexport class PlaybackToggleOverlay extends Container<ContainerConfig> {\n\n  private playbackToggleButton: HugePlaybackToggleButton;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.playbackToggleButton = new HugePlaybackToggleButton();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-playbacktoggle-overlay',\n      components: [this.playbackToggleButton]\n    }, this.config);\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\nimport {UIInstanceManager, UIRecommendationConfig} from '../uimanager';\nimport {StringUtils} from '../utils';\nimport {HugeReplayButton} from './hugereplaybutton';\n\n/**\n * Overlays the player and displays recommended videos.\n */\nexport class RecommendationOverlay extends Container<ContainerConfig> {\n\n  private replayButton: HugeReplayButton;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.replayButton = new HugeReplayButton();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-recommendation-overlay',\n      hidden: true,\n      components: [this.replayButton]\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let clearRecommendations = () => {\n      for (let component of this.getComponents()) {\n        if (component instanceof RecommendationItem) {\n          this.removeComponent(component);\n        }\n      }\n      this.updateComponents();\n      this.getDomElement().removeClass(this.prefixCss('recommendations'));\n    };\n\n    let setupRecommendations = () => {\n      clearRecommendations();\n\n      let hasRecommendationsInUiConfig = uimanager.getConfig().recommendations\n        && uimanager.getConfig().recommendations.length > 0;\n      let hasRecommendationsInPlayerConfig = player.getConfig().source && player.getConfig().source.recommendations\n        && player.getConfig().source.recommendations.length > 0;\n\n      // Take markers from the UI config. If no markers defined, try to take them from the player's source config.\n      let recommendations = hasRecommendationsInUiConfig ? uimanager.getConfig().recommendations :\n        hasRecommendationsInPlayerConfig ? player.getConfig().source.recommendations : null;\n\n      // Generate timeline markers from the config if we have markers and if we have a duration\n      // The duration check is for buggy platforms where the duration is not available instantly (Chrome on Android 4.3)\n      if (recommendations) {\n        let index = 1;\n        for (let item of recommendations) {\n          this.addComponent(new RecommendationItem({\n            itemConfig: item,\n            cssClasses: ['recommendation-item-' + (index++)]\n          }));\n        }\n        this.updateComponents(); // create container DOM elements\n\n        this.getDomElement().addClass(this.prefixCss('recommendations'));\n      }\n    };\n\n    // Add recommendation when a source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, setupRecommendations);\n    // Remove recommendations and hide overlay when source is unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, () => {\n      clearRecommendations();\n      this.hide();\n    });\n    // Display recommendations when playback has finished\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, () => {\n      // Dismiss ON_PLAYBACK_FINISHED events at the end of ads\n      // TODO remove this workaround once issue #1278 is solved\n      if (player.isAd()) {\n        return;\n      }\n\n      this.show();\n    });\n    // Hide recommendations when playback starts, e.g. a restart\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      this.hide();\n    });\n\n    // Init on startup\n    setupRecommendations();\n  }\n}\n\n/**\n * Configuration interface for the {@link RecommendationItem}\n */\ninterface RecommendationItemConfig extends ComponentConfig {\n  itemConfig: UIRecommendationConfig;\n}\n\n/**\n * An item of the {@link RecommendationOverlay}. Used only internally in {@link RecommendationOverlay}.\n */\nclass RecommendationItem extends Component<RecommendationItemConfig> {\n\n  constructor(config: RecommendationItemConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-recommendation-item',\n      itemConfig: null // this must be passed in from outside\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    let config = (<RecommendationItemConfig>this.config).itemConfig; // TODO fix generics and get rid of cast\n\n    let itemElement = new DOM('a', {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n      'href': config.url\n    }).css({ 'background-image': `url(${config.thumbnail})` });\n\n    let bgElement = new DOM('div', {\n      'class': this.prefixCss('background')\n    });\n    itemElement.append(bgElement);\n\n    let titleElement = new DOM('span', {\n      'class': this.prefixCss('title')\n    }).append(new DOM('span', {\n      'class': this.prefixCss('innertitle')\n    }).html(config.title));\n    itemElement.append(titleElement);\n\n    let timeElement = new DOM('span', {\n      'class': this.prefixCss('duration')\n    }).append(new DOM('span', {\n      'class': this.prefixCss('innerduration')\n    }).html(config.duration ? StringUtils.secondsToTime(config.duration) : ''));\n    itemElement.append(timeElement);\n\n    return itemElement;\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\nimport {Event, EventDispatcher, NoArgs} from '../eventdispatcher';\nimport {SeekBarLabel} from './seekbarlabel';\nimport {UIInstanceManager, TimelineMarker, SeekPreviewArgs} from '../uimanager';\nimport {Timeout} from '../timeout';\nimport {PlayerUtils} from '../utils';\nimport TimeShiftAvailabilityChangedArgs = PlayerUtils.TimeShiftAvailabilityChangedArgs;\nimport LiveStreamDetectorEventArgs = PlayerUtils.LiveStreamDetectorEventArgs;\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\n/**\n * Configuration interface for the {@link SeekBar} component.\n */\nexport interface SeekBarConfig extends ComponentConfig {\n  /**\n   * The label above the seek position.\n   */\n  label?: SeekBarLabel;\n  /**\n   * Bar will be vertical instead of horizontal if set to true.\n   */\n  vertical?: boolean;\n  /**\n   * The interval in milliseconds in which the playback position on the seek bar will be updated. The shorter the\n   * interval, the smoother it looks and the more resource intense it is. The update interval will be kept as steady\n   * as possible to avoid jitter.\n   * Set to -1 to disable smooth updating and update it on player ON_TIME_CHANGED events instead.\n   * Default: 50 (50ms = 20fps).\n   */\n  smoothPlaybackPositionUpdateIntervalMs?: number;\n}\n\n/**\n * Event argument interface for a seek preview event.\n */\nexport interface SeekPreviewEventArgs extends SeekPreviewArgs {\n  /**\n   * Tells if the seek preview event comes from a scrubbing.\n   */\n  scrubbing: boolean;\n}\n\n/**\n * A seek bar to seek within the player's media. It displays the current playback position, amount of buffed data, seek\n * target, and keeps status about an ongoing seek.\n *\n * The seek bar displays different 'bars':\n *  - the playback position, i.e. the position in the media at which the player current playback pointer is positioned\n *  - the buffer position, which usually is the playback position plus the time span that is already buffered ahead\n *  - the seek position, used to preview to where in the timeline a seek will jump to\n */\nexport class SeekBar extends Component<SeekBarConfig> {\n\n  public static readonly SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED = -1;\n\n  /**\n   * The CSS class that is added to the DOM element while the seek bar is in 'seeking' state.\n   */\n  private static readonly CLASS_SEEKING = 'seeking';\n\n  private seekBar: DOM;\n  private seekBarPlaybackPosition: DOM;\n  private seekBarPlaybackPositionMarker: DOM;\n  private seekBarBufferPosition: DOM;\n  private seekBarSeekPosition: DOM;\n  private seekBarBackdrop: DOM;\n  private seekBarMarkersContainer: DOM;\n\n  private label: SeekBarLabel;\n\n  private timelineMarkers: TimelineMarker[];\n\n  /**\n   * Buffer of the the current playback position. The position must be buffered in case the element\n   * needs to be refreshed with {@link #refreshPlaybackPosition}.\n   * @type {number}\n   */\n  private playbackPositionPercentage = 0;\n\n  private smoothPlaybackPositionUpdater: Timeout;\n\n  // https://hacks.mozilla.org/2013/04/detecting-touch-its-the-why-not-the-how/\n  private touchSupported = ('ontouchstart' in window);\n\n  private seekBarEvents = {\n    /**\n     * Fired when a scrubbing seek operation is started.\n     */\n    onSeek: new EventDispatcher<SeekBar, NoArgs>(),\n    /**\n     * Fired during a scrubbing seek to indicate that the seek preview (i.e. the video frame) should be updated.\n     */\n    onSeekPreview: new EventDispatcher<SeekBar, SeekPreviewEventArgs>(),\n    /**\n     * Fired when a scrubbing seek has finished or when a direct seek is issued.\n     */\n    onSeeked: new EventDispatcher<SeekBar, number>()\n  };\n\n  constructor(config: SeekBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-seekbar',\n      vertical: false,\n      smoothPlaybackPositionUpdateIntervalMs: 50,\n    }, this.config);\n\n    this.label = this.config.label;\n    this.timelineMarkers = [];\n  }\n\n  initialize(): void {\n    super.initialize();\n\n    if (this.hasLabel()) {\n      this.getLabel().initialize();\n    }\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager, configureSeek: boolean = true): void {\n    super.configure(player, uimanager);\n\n    if (!configureSeek) {\n      // The configureSeek flag can be used by subclasses to disable configuration as seek bar. E.g. the volume\n      // slider is reusing this component but adds its own functionality, and does not need the seek functionality.\n      // This is actually a hack, the proper solution would be for both seek bar and volume sliders to extend\n      // a common base slider component and implement their functionality there.\n      return;\n    }\n\n    let playbackNotInitialized = true;\n    let isPlaying = false;\n    let isSeeking = false;\n\n    // Update playback and buffer positions\n    let playbackPositionHandler = (event: PlayerEvent = null, forceUpdate: boolean = false) => {\n      // Once this handler os called, playback has been started and we set the flag to false\n      playbackNotInitialized = false;\n\n      if (isSeeking) {\n        // We caught a seek preview seek, do not update the seekbar\n        return;\n      }\n\n      if (player.isLive()) {\n        if (player.getMaxTimeShift() === 0) {\n          // This case must be explicitly handled to avoid division by zero\n          this.setPlaybackPosition(100);\n        }\n        else {\n          let playbackPositionPercentage = 100 - (100 / player.getMaxTimeShift() * player.getTimeShift());\n          this.setPlaybackPosition(playbackPositionPercentage);\n        }\n\n        // Always show full buffer for live streams\n        this.setBufferPosition(100);\n      }\n      else {\n        let playbackPositionPercentage = 100 / player.getDuration() * player.getCurrentTime();\n\n        let videoBufferLength = player.getVideoBufferLength();\n        let audioBufferLength = player.getAudioBufferLength();\n        // Calculate the buffer length which is the smaller length of the audio and video buffers. If one of these\n        // buffers is not available, we set it's value to MAX_VALUE to make sure that the other real value is taken\n        // as the buffer length.\n        let bufferLength = Math.min(\n          videoBufferLength != null ? videoBufferLength : Number.MAX_VALUE,\n          audioBufferLength != null ? audioBufferLength : Number.MAX_VALUE);\n        // If both buffer lengths are missing, we set the buffer length to zero\n        if (bufferLength === Number.MAX_VALUE) {\n          bufferLength = 0;\n        }\n\n        let bufferPercentage = 100 / player.getDuration() * bufferLength;\n\n        // Update playback position only in paused state or in the initial startup state where player is neither\n        // paused nor playing. Playback updates are handled in the Timeout below.\n        if (this.config.smoothPlaybackPositionUpdateIntervalMs === SeekBar.SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED\n          || forceUpdate || player.isPaused() || (player.isPaused() === player.isPlaying())) {\n          this.setPlaybackPosition(playbackPositionPercentage);\n        }\n\n        this.setBufferPosition(playbackPositionPercentage + bufferPercentage);\n      }\n    };\n\n    // Update seekbar upon these events\n    // init playback position when the player is ready\n    player.addEventHandler(player.EVENT.ON_READY, playbackPositionHandler);\n    // update playback position when it changes\n    player.addEventHandler(player.EVENT.ON_TIME_CHANGED, playbackPositionHandler);\n    // update bufferlevel when buffering is complete\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, playbackPositionHandler);\n    // update playback position when a seek has finished\n    player.addEventHandler(player.EVENT.ON_SEEKED, playbackPositionHandler);\n    // update playback position when a timeshift has finished\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, playbackPositionHandler);\n    // update bufferlevel when a segment has been downloaded\n    player.addEventHandler(player.EVENT.ON_SEGMENT_REQUEST_FINISHED, playbackPositionHandler);\n    // update playback position of Cast playback\n    player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, playbackPositionHandler);\n\n\n    // Seek handling\n    player.addEventHandler(player.EVENT.ON_SEEK, () => {\n      this.setSeeking(true);\n    });\n    player.addEventHandler(player.EVENT.ON_SEEKED, () => {\n      this.setSeeking(false);\n    });\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, () => {\n      this.setSeeking(true);\n    });\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, () => {\n      this.setSeeking(false);\n    });\n\n    let seek = (percentage: number) => {\n      if (player.isLive()) {\n        player.timeShift(player.getMaxTimeShift() - (player.getMaxTimeShift() * (percentage / 100)));\n      } else {\n        player.seek(player.getDuration() * (percentage / 100));\n      }\n    };\n    this.onSeek.subscribe((sender) => {\n      isSeeking = true; // track seeking status so we can catch events from seek preview seeks\n\n      // Notify UI manager of started seek\n      uimanager.onSeek.dispatch(sender);\n\n      // Save current playback state\n      isPlaying = player.isPlaying();\n\n      // Pause playback while seeking\n      if (isPlaying) {\n        player.pause('ui-seek');\n      }\n    });\n    this.onSeekPreview.subscribe((sender: SeekBar, args: SeekPreviewEventArgs) => {\n      // Notify UI manager of seek preview\n      uimanager.onSeekPreview.dispatch(sender, args);\n    });\n    this.onSeekPreview.subscribeRateLimited((sender: SeekBar, args: SeekPreviewEventArgs) => {\n      // Rate-limited scrubbing seek\n      if (args.scrubbing) {\n        seek(args.position);\n      }\n    }, 200);\n    this.onSeeked.subscribe((sender, percentage) => {\n      isSeeking = false;\n\n      // Do the seek\n      seek(percentage);\n\n      // Continue playback after seek if player was playing when seek started\n      if (isPlaying) {\n        player.play('ui-seek');\n      }\n\n      // Notify UI manager of finished seek\n      uimanager.onSeeked.dispatch(sender);\n    });\n\n    if (this.hasLabel()) {\n      // Configure a seekbar label that is internal to the seekbar)\n      this.getLabel().configure(player, uimanager);\n    }\n\n    // Hide seekbar for live sources without timeshift\n    let isLive = false;\n    let hasTimeShift = false;\n    let switchVisibility = (isLive: boolean, hasTimeShift: boolean) => {\n      if (isLive && !hasTimeShift) {\n        this.hide();\n      } else {\n        this.show();\n      }\n      playbackPositionHandler(null, true);\n      this.refreshPlaybackPosition();\n    };\n    new PlayerUtils.LiveStreamDetector(player).onLiveChanged.subscribe((sender, args: LiveStreamDetectorEventArgs) => {\n      isLive = args.live;\n      switchVisibility(isLive, hasTimeShift);\n    });\n    new PlayerUtils.TimeShiftAvailabilityDetector(player).onTimeShiftAvailabilityChanged.subscribe(\n      (sender, args: TimeShiftAvailabilityChangedArgs) => {\n        hasTimeShift = args.timeShiftAvailable;\n        switchVisibility(isLive, hasTimeShift);\n      }\n    );\n\n    // Refresh the playback position when the player resized or the UI is configured. The playback position marker\n    // is positioned absolutely and must therefore be updated when the size of the seekbar changes.\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => {\n      this.refreshPlaybackPosition();\n    });\n    // Additionally, when this code is called, the seekbar is not part of the UI yet and therefore does not have a size,\n    // resulting in a wrong initial position of the marker. Refreshing it once the UI is configured solved this issue.\n    uimanager.onConfigured.subscribe(() => {\n      this.refreshPlaybackPosition();\n    });\n    // It can also happen that the value changes once the player is ready, or when a new source is loaded, so we need\n    // to update on ON_READY too\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      this.refreshPlaybackPosition();\n    });\n\n    // Initialize seekbar\n    playbackPositionHandler(); // Set the playback position\n    this.setBufferPosition(0);\n    this.setSeekPosition(0);\n    if (this.config.smoothPlaybackPositionUpdateIntervalMs !== SeekBar.SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED) {\n      this.configureSmoothPlaybackPositionUpdater(player, uimanager);\n    }\n    this.configureMarkers(player, uimanager);\n  }\n\n  private configureSmoothPlaybackPositionUpdater(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    /*\n     * Playback position update\n     *\n     * We do not update the position directly from the ON_TIME_CHANGED event, because it arrives very jittery and\n     * results in a jittery position indicator since the CSS transition time is statically set.\n     * To work around this issue, we maintain a local playback position that is updated in a stable regular interval\n     * and kept in sync with the player.\n     */\n    let currentTimeSeekBar = 0;\n    let currentTimePlayer = 0;\n    let updateIntervalMs = 50;\n    let currentTimeUpdateDeltaSecs = updateIntervalMs / 1000;\n\n    this.smoothPlaybackPositionUpdater = new Timeout(updateIntervalMs, () => {\n      currentTimeSeekBar += currentTimeUpdateDeltaSecs;\n      currentTimePlayer = player.getCurrentTime();\n\n      // Sync currentTime of seekbar to player\n      let currentTimeDelta = currentTimeSeekBar - currentTimePlayer;\n      // If the delta is larger that 2 secs, directly jump the seekbar to the\n      // player time instead of smoothly fast forwarding/rewinding.\n      if (Math.abs(currentTimeDelta) > 2) {\n        currentTimeSeekBar = currentTimePlayer;\n      }\n      // If currentTimeDelta is negative and below the adjustment threshold,\n      // the player is ahead of the seekbar and we 'fast forward' the seekbar\n      else if (currentTimeDelta <= -currentTimeUpdateDeltaSecs) {\n        currentTimeSeekBar += currentTimeUpdateDeltaSecs;\n      }\n      // If currentTimeDelta is positive and above the adjustment threshold,\n      // the player is behind the seekbar and we 'rewind' the seekbar\n      else if (currentTimeDelta >= currentTimeUpdateDeltaSecs) {\n        currentTimeSeekBar -= currentTimeUpdateDeltaSecs;\n      }\n\n      let playbackPositionPercentage = 100 / player.getDuration() * currentTimeSeekBar;\n      this.setPlaybackPosition(playbackPositionPercentage);\n    }, true);\n\n    let startSmoothPlaybackPositionUpdater = () => {\n      if (!player.isLive()) {\n        currentTimeSeekBar = player.getCurrentTime();\n        this.smoothPlaybackPositionUpdater.start();\n      }\n    };\n\n    let stopSmoothPlaybackPositionUpdater = () => {\n      this.smoothPlaybackPositionUpdater.clear();\n    };\n\n    player.addEventHandler(player.EVENT.ON_PLAY, startSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYING, startSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_PAUSED, stopSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_CAST_PAUSED, stopSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_SEEKED, () => {\n      currentTimeSeekBar = player.getCurrentTime();\n    });\n\n    if (player.isPlaying()) {\n      startSmoothPlaybackPositionUpdater();\n    }\n  }\n\n  private configureMarkers(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let clearMarkers = () => {\n      this.timelineMarkers = [];\n      this.updateMarkers();\n    };\n\n    let setupMarkers = () => {\n      clearMarkers();\n\n      let hasMarkersInUiConfig = uimanager.getConfig().metadata && uimanager.getConfig().metadata.markers\n        && uimanager.getConfig().metadata.markers.length > 0;\n      let hasMarkersInPlayerConfig = player.getConfig().source && player.getConfig().source.markers\n        && player.getConfig().source.markers.length > 0;\n\n      // Take markers from the UI config. If no markers defined, try to take them from the player's source config.\n      let markers = hasMarkersInUiConfig ? uimanager.getConfig().metadata.markers :\n        hasMarkersInPlayerConfig ? player.getConfig().source.markers : null;\n\n      // Generate timeline markers from the config if we have markers and if we have a duration\n      // The duration check is for buggy platforms where the duration is not available instantly (Chrome on Android 4.3)\n      if (markers && player.getDuration() !== Infinity) {\n        for (let o of markers) {\n          let marker = {\n            time: 100 / player.getDuration() * o.time, // convert time to percentage\n            title: o.title,\n            markerType: '' + (o.markerType || 1),\n            comment: o.comment || '',\n            avatar: o.avatar,\n            number: o.number || ''\n          }\n          this.timelineMarkers.push(marker)\n        }\n      }\n\n      // Populate the timeline with the markers\n      this.updateMarkers();\n    };\n\n    // Add markers when a source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, setupMarkers);\n    // Remove markers when unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, clearMarkers);\n\n    // Init markers at startup\n    setupMarkers();\n  }\n\n  release(): void {\n    super.release();\n\n    if (this.smoothPlaybackPositionUpdater) { // object must not necessarily exist, e.g. in volume slider subclass\n      this.smoothPlaybackPositionUpdater.clear();\n    }\n  }\n\n  protected toDomElement(): DOM {\n    if (this.config.vertical) {\n      this.config.cssClasses.push('vertical');\n    }\n\n    let seekBarContainer = new DOM('div', {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    let seekBar = new DOM('div', {\n      'class': this.prefixCss('seekbar')\n    });\n    this.seekBar = seekBar;\n\n    // Indicator that shows the buffer fill level\n    let seekBarBufferLevel = new DOM('div', {\n      'class': this.prefixCss('seekbar-bufferlevel')\n    });\n    this.seekBarBufferPosition = seekBarBufferLevel;\n\n    // Indicator that shows the current playback position\n    let seekBarPlaybackPosition = new DOM('div', {\n      'class': this.prefixCss('seekbar-playbackposition')\n    });\n    this.seekBarPlaybackPosition = seekBarPlaybackPosition;\n\n    // A marker of the current playback position, e.g. a dot or line\n    let seekBarPlaybackPositionMarker = new DOM('div', {\n      'class': this.prefixCss('seekbar-playbackposition-marker')\n    });\n    this.seekBarPlaybackPositionMarker = seekBarPlaybackPositionMarker;\n\n    // Indicator that show where a seek will go to\n    let seekBarSeekPosition = new DOM('div', {\n      'class': this.prefixCss('seekbar-seekposition')\n    });\n    this.seekBarSeekPosition = seekBarSeekPosition;\n\n    // Indicator that shows the full seekbar\n    let seekBarBackdrop = new DOM('div', {\n      'class': this.prefixCss('seekbar-backdrop')\n    });\n    this.seekBarBackdrop = seekBarBackdrop;\n\n    let seekBarChapterMarkersContainer = new DOM('div', {\n      'class': this.prefixCss('seekbar-markers')\n    });\n    this.seekBarMarkersContainer = seekBarChapterMarkersContainer;\n\n    seekBar.append(seekBarBackdrop, seekBarBufferLevel, seekBarSeekPosition,\n      seekBarPlaybackPosition, seekBarChapterMarkersContainer, seekBarPlaybackPositionMarker);\n\n    let seeking = false;\n\n    // Define handler functions so we can attach/remove them later\n    let mouseTouchMoveHandler = (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n      // Avoid propagation to VR handler\n      e.stopPropagation();\n\n      let targetPercentage = 100 * this.getOffset(e);\n      this.setSeekPosition(targetPercentage);\n      this.setPlaybackPosition(targetPercentage);\n      this.onSeekPreviewEvent(targetPercentage, true);\n    };\n    let mouseTouchUpHandler = (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      // Remove handlers, seek operation is finished\n      new DOM(document).off('touchmove mousemove', mouseTouchMoveHandler);\n      new DOM(document).off('touchend mouseup', mouseTouchUpHandler);\n\n      let targetPercentage = 100 * this.getOffset(e);\n      let snappedChapter = this.getMarkerAtPosition(targetPercentage);\n\n      this.setSeeking(false);\n      seeking = false;\n\n      // Fire seeked event\n      this.onSeekedEvent(snappedChapter ? snappedChapter.time : targetPercentage);\n    };\n\n    // A seek always start with a touchstart or mousedown directly on the seekbar.\n    // To track a mouse seek also outside the seekbar (for touch events this works automatically),\n    // so the user does not need to take care that the mouse always stays on the seekbar, we attach the mousemove\n    // and mouseup handlers to the whole document. A seek is triggered when the user lifts the mouse key.\n    // A seek mouse gesture is thus basically a click with a long time frame between down and up events.\n    seekBar.on('touchstart mousedown', (e: MouseEvent | TouchEvent) => {\n      let isTouchEvent = this.touchSupported && e instanceof TouchEvent;\n\n      // Prevent selection of DOM elements (also prevents mousedown if current event is touchstart)\n      e.preventDefault();\n      // Avoid propagation to VR handler\n      e.stopPropagation();\n\n      this.setSeeking(true); // Set seeking class on DOM element\n      seeking = true; // Set seek tracking flag\n\n      // Fire seeked event\n      this.onSeekEvent();\n\n      // Add handler to track the seek operation over the whole document\n      new DOM(document).on(isTouchEvent ? 'touchmove' : 'mousemove', mouseTouchMoveHandler);\n      new DOM(document).on(isTouchEvent ? 'touchend' : 'mouseup', mouseTouchUpHandler);\n    });\n\n    // Display seek target indicator when mouse hovers or finger slides over seekbar\n    seekBar.on('touchmove mousemove', (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      if (seeking) {\n        // During a seek (when mouse is down or touch move active), we need to stop propagation to avoid\n        // the VR viewport reacting to the moves.\n        e.stopPropagation();\n        // Because the stopped propagation inhibits the event on the document, we need to call it from here\n        mouseTouchMoveHandler(e);\n      }\n\n      let position = 100 * this.getOffset(e);\n      this.setSeekPosition(position);\n      this.onSeekPreviewEvent(position, false);\n\n      if (this.hasLabel() && this.getLabel().isHidden()) {\n        this.getLabel().show();\n      }\n    });\n\n    // Hide seek target indicator when mouse or finger leaves seekbar\n    seekBar.on('touchend mouseleave', (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      this.setSeekPosition(0);\n\n      if (this.hasLabel()) {\n        this.getLabel().hide();\n      }\n    });\n\n    seekBarContainer.append(seekBar);\n\n    if (this.label) {\n      seekBarContainer.append(this.label.getDomElement());\n    }\n\n    return seekBarContainer;\n  }\n\n  protected updateMarkers(): void {\n    this.seekBarMarkersContainer.empty();\n\n    for (let marker of this.timelineMarkers) {\n      let className = marker.markerType === '2' ? this.prefixCss('seekbar-marker-typetwo') : this.prefixCss('seekbar-marker')\n\n      let markerDom = new DOM('div', {\n        'class': className,\n        'data-marker-time': String(marker.time),\n        'data-marker-title': String(marker.title),\n      }).css({\n        'width': marker.time + '%',\n      })\n      this.seekBarMarkersContainer.append(markerDom)\n    }\n  }\n\n  protected getMarkerAtPosition(percentage: number): TimelineMarker | null {\n    let snappedMarker: TimelineMarker = null;\n    let snappingRange = 1;\n    if (this.timelineMarkers.length > 0) {\n      for (let marker of this.timelineMarkers) {\n        if (percentage >= marker.time - snappingRange && percentage <= marker.time + snappingRange) {\n          snappedMarker = marker;\n          break;\n        }\n      }\n    }\n\n    return snappedMarker;\n  }\n\n  /**\n   * Gets the horizontal offset of a mouse/touch event point from the left edge of the seek bar.\n   * @param eventPageX the pageX coordinate of an event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1], where 0 is the left edge and 1 is the right edge\n   */\n  private getHorizontalOffset(eventPageX: number): number {\n    let elementOffsetPx = this.seekBar.offset().left;\n    let widthPx = this.seekBar.width();\n    let offsetPx = eventPageX - elementOffsetPx;\n    let offset = 1 / widthPx * offsetPx;\n\n    return this.sanitizeOffset(offset);\n  }\n\n  /**\n   * Gets the vertical offset of a mouse/touch event point from the bottom edge of the seek bar.\n   * @param eventPageY the pageX coordinate of an event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1], where 0 is the bottom edge and 1 is the top edge\n   */\n  private getVerticalOffset(eventPageY: number): number {\n    let elementOffsetPx = this.seekBar.offset().top;\n    let widthPx = this.seekBar.height();\n    let offsetPx = eventPageY - elementOffsetPx;\n    let offset = 1 / widthPx * offsetPx;\n\n    return 1 - this.sanitizeOffset(offset);\n  }\n\n  /**\n   * Gets the mouse or touch event offset for the current configuration (horizontal or vertical).\n   * @param e the event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1]\n   * @see #getHorizontalOffset\n   * @see #getVerticalOffset\n   */\n  private getOffset(e: MouseEvent | TouchEvent): number {\n    if (this.touchSupported && e instanceof TouchEvent) {\n      if (this.config.vertical) {\n        return this.getVerticalOffset(e.type === 'touchend' ? e.changedTouches[0].pageY : e.touches[0].pageY);\n      } else {\n        return this.getHorizontalOffset(e.type === 'touchend' ? e.changedTouches[0].pageX : e.touches[0].pageX);\n      }\n    }\n    else if (e instanceof MouseEvent) {\n      if (this.config.vertical) {\n        return this.getVerticalOffset(e.pageY);\n      } else {\n        return this.getHorizontalOffset(e.pageX);\n      }\n    }\n    else {\n      if (console) {\n        console.warn('invalid event');\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Sanitizes the mouse offset to the range of [0, 1].\n   *\n   * When tracking the mouse outside the seek bar, the offset can be outside the desired range and this method\n   * limits it to the desired range. E.g. a mouse event left of the left edge of a seek bar yields an offset below\n   * zero, but to display the seek target on the seek bar, we need to limit it to zero.\n   *\n   * @param offset the offset to sanitize\n   * @returns {number} the sanitized offset.\n   */\n  private sanitizeOffset(offset: number) {\n    // Since we track mouse moves over the whole document, the target can be outside the seek range,\n    // and we need to limit it to the [0, 1] range.\n    if (offset < 0) {\n      offset = 0;\n    } else if (offset > 1) {\n      offset = 1;\n    }\n\n    return offset;\n  }\n\n  /**\n   * Sets the position of the playback position indicator.\n   * @param percent a number between 0 and 100 as returned by the player\n   */\n  setPlaybackPosition(percent: number) {\n    this.playbackPositionPercentage = percent;\n\n    // Set position of the bar\n    this.setPosition(this.seekBarPlaybackPosition, percent);\n\n    // Set position of the marker\n    let px = (this.config.vertical ? this.seekBar.height() : this.seekBar.width()) / 100 * percent;\n    if (this.config.vertical) {\n      px = this.seekBar.height() - px;\n    }\n    let style = this.config.vertical ?\n      // -ms-transform required for IE9\n      { 'transform': 'translateY(' + px + 'px)', '-ms-transform': 'translateY(' + px + 'px)' } :\n      { 'transform': 'translateX(' + px + 'px)', '-ms-transform': 'translateX(' + px + 'px)' };\n    this.seekBarPlaybackPositionMarker.css(style);\n  }\n\n  /**\n   * Refreshes the playback position. Can be used by subclasses to refresh the position when\n   * the size of the component changes.\n   */\n  protected refreshPlaybackPosition() {\n    this.setPlaybackPosition(this.playbackPositionPercentage);\n  }\n\n  /**\n   * Sets the position until which media is buffered.\n   * @param percent a number between 0 and 100\n   */\n  setBufferPosition(percent: number) {\n    this.setPosition(this.seekBarBufferPosition, percent);\n  }\n\n  /**\n   * Sets the position where a seek, if executed, would jump to.\n   * @param percent a number between 0 and 100\n   */\n  setSeekPosition(percent: number) {\n    this.setPosition(this.seekBarSeekPosition, percent);\n  }\n\n  /**\n   * Set the actual position (width or height) of a DOM element that represent a bar in the seek bar.\n   * @param element the element to set the position for\n   * @param percent a number between 0 and 100\n   */\n  private setPosition(element: DOM, percent: number) {\n    let scale = percent / 100;\n    let style = this.config.vertical ?\n      // -ms-transform required for IE9\n      { 'transform': 'scaleY(' + scale + ')', '-ms-transform': 'scaleY(' + scale + ')' } :\n      { 'transform': 'scaleX(' + scale + ')', '-ms-transform': 'scaleX(' + scale + ')' };\n    element.css(style);\n  }\n\n  /**\n   * Puts the seek bar into or out of seeking state by adding/removing a class to the DOM element. This can be used\n   * to adjust the styling while seeking.\n   *\n   * @param seeking should be true when entering seek state, false when exiting the seek state\n   */\n  setSeeking(seeking: boolean) {\n    if (seeking) {\n      this.getDomElement().addClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n    } else {\n      this.getDomElement().removeClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n    }\n  }\n\n  /**\n   * Checks if the seek bar is currently in the seek state.\n   * @returns {boolean} true if in seek state, else false\n   */\n  isSeeking(): boolean {\n    return this.getDomElement().hasClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n  }\n\n  /**\n   * Checks if the seek bar has a {@link SeekBarLabel}.\n   * @returns {boolean} true if the seek bar has a label, else false\n   */\n  hasLabel(): boolean {\n    return this.label != null;\n  }\n\n  /**\n   * Gets the label of this seek bar.\n   * @returns {SeekBarLabel} the label if this seek bar has a label, else null\n   */\n  getLabel(): SeekBarLabel | null {\n    return this.label;\n  }\n\n  protected onSeekEvent() {\n    this.seekBarEvents.onSeek.dispatch(this);\n  }\n\n  protected onSeekPreviewEvent(percentage: number, scrubbing: boolean) {\n    let snappedMarker = this.getMarkerAtPosition(percentage);\n\n    if (this.label) {\n      this.label.getDomElement().css({\n        'left': (snappedMarker ? snappedMarker.time : percentage) + '%'\n      });\n    }\n\n    this.seekBarEvents.onSeekPreview.dispatch(this, {\n      scrubbing: scrubbing,\n      position: percentage,\n      marker: snappedMarker,\n    });\n  }\n\n  protected onSeekedEvent(percentage: number) {\n    this.seekBarEvents.onSeeked.dispatch(this, percentage);\n  }\n\n  /**\n   * Gets the event that is fired when a scrubbing seek operation is started.\n   * @returns {Event<SeekBar, NoArgs>}\n   */\n  get onSeek(): Event<SeekBar, NoArgs> {\n    return this.seekBarEvents.onSeek.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired during a scrubbing seek (to indicate that the seek preview, i.e. the video frame,\n   * should be updated), or during a normal seek preview when the seek bar is hovered (and the seek target,\n   * i.e. the seek bar label, should be updated).\n   * @returns {Event<SeekBar, SeekPreviewEventArgs>}\n   */\n  get onSeekPreview(): Event<SeekBar, SeekPreviewEventArgs> {\n    return this.seekBarEvents.onSeekPreview.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when a scrubbing seek has finished or when a direct seek is issued.\n   * @returns {Event<SeekBar, number>}\n   */\n  get onSeeked(): Event<SeekBar, number> {\n    return this.seekBarEvents.onSeeked.getEvent();\n  }\n\n\n  protected onShowEvent(): void {\n    super.onShowEvent();\n\n    // Refresh the position of the playback position when the seek bar becomes visible. To correctly set the position,\n    // the DOM element must be fully initialized an have its size calculated, because the position is set as an absolute\n    // value calculated from the size. This required size is not known when it is hidden.\n    // For such cases, we refresh the position here in onShow because here it is guaranteed that the component knows\n    // its size and can set the position correctly.\n    this.refreshPlaybackPosition();\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {Label, LabelConfig} from './label';\nimport {Component, ComponentConfig} from './component';\nimport {UIInstanceManager, SeekPreviewArgs} from '../uimanager';\nimport {StringUtils} from '../utils';\n\n/**\n * Configuration interface for a {@link SeekBarLabel}.\n */\nexport interface SeekBarLabelConfig extends ContainerConfig {\n  // nothing yet\n}\n\n/**\n * A label for a {@link SeekBar} that can display the seek target time, a thumbnail, and title (e.g. chapter title).\n */\nexport class SeekBarLabel extends Container<SeekBarLabelConfig> {\n\n  private timeLabel: Label<LabelConfig>;\n  private titleLabel: Label<LabelConfig>;\n  private numberLabel: Label<LabelConfig>;\n  private commentLabel: Label<LabelConfig>;\n  private avatarLabel: Label<LabelConfig>;\n  private thumbnail: Component<ComponentConfig>;\n  private metadata: Component<ComponentConfig>;\n\n  private timeFormat: string;\n\n  constructor(config: SeekBarLabelConfig = {}) {\n    super(config);\n\n    this.timeLabel = new Label({cssClasses: ['seekbar-label-time']});\n    this.titleLabel = new Label({cssClasses: ['seekbar-label-title']});\n    this.commentLabel = new Label({cssClasses: ['seekbar-label-comment']});\n    this.numberLabel = new Label({cssClasses: ['seekbar-label-number']});\n    this.avatarLabel = new Label({cssClasses: ['seekbar-label-avatar']});\n    this.thumbnail = new Component({cssClasses: ['seekbar-thumbnail']});\n    this.metadata = new Container({\n      components: [\n        new Container({\n          components: [\n            this.avatarLabel,\n            this.titleLabel,\n            this.numberLabel],\n          cssClass: 'seekbar-label-metadata-title',\n        }),\n        new Container({\n          components: [\n            this.commentLabel,\n            this.timeLabel],\n          cssClass: 'seekbar-label-metadata-content',\n        }),\n      ],\n      cssClass: 'seekbar-label-metadata'\n    });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-seekbar-label',\n      components: [new Container({\n        components: [\n          this.thumbnail,\n          this.metadata\n        ],\n        cssClass: 'seekbar-label-inner',\n      })],\n      hidden: true\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    uimanager.onSeekPreview.subscribe((sender, args: SeekPreviewArgs) => {\n      if (player.isLive()) {\n        let time = player.getMaxTimeShift() - player.getMaxTimeShift() * (args.position / 100);\n        this.setTime(time);\n      } else {\n        let percentage = 0;\n        if (args.marker) {\n          this.setTitleText(args.marker.title);\n          this.setSmashcutData(args.marker);\n          this.setTime(args.marker.time);\n          this.setThumbnail(null);\n          this.setBackground(true);\n        } else {\n          percentage = args.position;\n          this.setTitleText(null);\n          this.setSmashcutData(null);\n          let time = player.getDuration() * (percentage / 100);\n          this.setTime(time);\n          this.setThumbnail(player.getThumb(time));\n          this.setBackground(false);\n        }\n      }\n    });\n\n    let init = () => {\n      // Set time format depending on source duration\n      this.timeFormat = Math.abs(player.isLive() ? player.getMaxTimeShift() : player.getDuration()) >= 3600 ?\n        StringUtils.FORMAT_HHMMSS : StringUtils.FORMAT_MMSS;\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, init);\n    init();\n  }\n\n  /**\n   * Sets arbitrary text on the label.\n   * @param text the text to show on the label\n   */\n  setText(text: string) {\n    this.timeLabel.setText(text);\n  }\n\n  /**\n   * Sets a time to be displayed on the label.\n   * @param seconds the time in seconds to display on the label\n   */\n  setTime(seconds: number) {\n    this.setText(StringUtils.secondsToTime(seconds, this.timeFormat));\n  }\n\n  /**\n   * Sets the text on the title label.\n   * @param text the text to show on the label\n   */\n  setTitleText(text: string) {\n    this.titleLabel.setText(text);\n  }\n\n  setSmashcutData(marker: any) {\n    if (marker) {\n      this.commentLabel.setText(marker.comment);\n      this.numberLabel.setText(marker.number);\n      this.avatarLabel.setText(marker.avatar);\n    } else {\n      this.commentLabel.setText(null);\n      this.numberLabel.setText(null);\n      this.avatarLabel.setText(null);\n    }\n  }\n\n  /**\n   * Sets or removes a thumbnail on the label.\n   * @param thumbnail the thumbnail to display on the label or null to remove a displayed thumbnail\n   */\n  setThumbnail(thumbnail: bitmovin.player.Thumbnail = null) {\n    let thumbnailElement = this.thumbnail.getDomElement();\n\n    if (thumbnail == null) {\n      thumbnailElement.css({\n        'background-image': null,\n        'display': 'null',\n        'width': 'null',\n        'height': 'null'\n      });\n    }\n    else {\n      thumbnailElement.css({\n        'display': 'inherit',\n        'background-image': `url(${thumbnail.url})`,\n        'width': thumbnail.w + 'px',\n        'height': thumbnail.h + 'px',\n        'background-position': `-${thumbnail.x}px -${thumbnail.y}px`\n      });\n    }\n  }\n\n  setBackground(onOff: boolean) {\n    let metadataElement = this.metadata.getDomElement();\n\n    if (onOff) {\n      metadataElement.css({\n        'background': '#000'\n      });\n    }\n    else {\n      metadataElement.css({\n        'background': 'initial'\n      });\n    }\n  }\n}","import {ListSelector, ListSelectorConfig} from './listselector';\nimport {DOM} from '../dom';\n\n/**\n * A simple select box providing the possibility to select a single item out of a list of available items.\n *\n * DOM example:\n * <code>\n *     <select class='ui-selectbox'>\n *         <option value='key'>label</option>\n *         ...\n *     </select>\n * </code>\n */\nexport class SelectBox extends ListSelector<ListSelectorConfig> {\n\n  private selectElement: DOM;\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-selectbox'\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    let selectElement = new DOM('select', {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    this.selectElement = selectElement;\n    this.updateDomItems();\n\n    selectElement.on('change', () => {\n      let value = selectElement.val();\n      this.onItemSelectedEvent(value, false);\n    });\n\n    return selectElement;\n  }\n\n  protected updateDomItems(selectedValue: string = null) {\n    // Delete all children\n    this.selectElement.empty();\n\n    // Add updated children\n    for (let item of this.items) {\n      let optionElement = new DOM('option', {\n        'value': item.key\n      }).html(item.label);\n\n      if (item.key === selectedValue + '') { // convert selectedValue to string to catch 'null'/null case\n        optionElement.attr('selected', 'selected');\n      }\n\n      this.selectElement.append(optionElement);\n    }\n  }\n\n  protected onItemAddedEvent(value: string) {\n    super.onItemAddedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemRemovedEvent(value: string) {\n    super.onItemRemovedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemSelectedEvent(value: string, updateDomItems: boolean = true) {\n    super.onItemSelectedEvent(value);\n    if (updateDomItems) {\n      this.updateDomItems(value);\n    }\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {SelectBox} from './selectbox';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {VideoQualitySelectBox} from './videoqualityselectbox';\nimport {AudioQualitySelectBox} from './audioqualityselectbox';\nimport {Timeout} from '../timeout';\nimport {Event, EventDispatcher, NoArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link SettingsPanel}.\n */\nexport interface SettingsPanelConfig extends ContainerConfig {\n  /**\n   * The delay in milliseconds after which the settings panel will be hidden when there is no user interaction.\n   * Set to -1 to disable automatic hiding.\n   * Default: 3 seconds (3000)\n   */\n  hideDelay?: number;\n}\n\n/**\n * A panel containing a list of {@link SettingsPanelItem items} that represent labelled settings.\n */\nexport class SettingsPanel extends Container<SettingsPanelConfig> {\n\n  private static readonly CLASS_LAST = 'last';\n\n  private settingsPanelEvents = {\n    onSettingsStateChanged: new EventDispatcher<SettingsPanel, NoArgs>()\n  };\n\n  private hideTimeout: Timeout;\n\n  constructor(config: SettingsPanelConfig) {\n    super(config);\n\n    this.config = this.mergeConfig<SettingsPanelConfig>(config, {\n      cssClass: 'ui-settings-panel',\n      hideDelay: 3000\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <SettingsPanelConfig>this.getConfig(); // TODO fix generics type inference\n\n    if (config.hideDelay > -1) {\n      this.hideTimeout = new Timeout(config.hideDelay, () => {\n        this.hide();\n      });\n\n      this.onShow.subscribe(() => {\n        // Activate timeout when shown\n        this.hideTimeout.start();\n      });\n      this.getDomElement().on('mousemove', () => {\n        // Reset timeout on interaction\n        this.hideTimeout.reset();\n      });\n      this.onHide.subscribe(() => {\n        // Clear timeout when hidden from outside\n        this.hideTimeout.clear();\n      });\n    }\n\n    // Fire event when the state of a settings-item has changed\n    let settingsStateChangedHandler = () => {\n      this.onSettingsStateChangedEvent();\n\n      // Attach marker class to last visible item\n      let lastShownItem = null;\n      for (let component of this.getItems()) {\n        if (component instanceof SettingsPanelItem) {\n          component.getDomElement().removeClass(this.prefixCss(SettingsPanel.CLASS_LAST));\n          if (component.isShown()) {\n            lastShownItem = component;\n          }\n        }\n      }\n      if (lastShownItem) {\n        lastShownItem.getDomElement().addClass(this.prefixCss(SettingsPanel.CLASS_LAST));\n      }\n    };\n    for (let component of this.getItems()) {\n      if (component instanceof SettingsPanelItem) {\n        component.onActiveChanged.subscribe(settingsStateChangedHandler);\n      }\n    }\n  }\n\n  release(): void {\n    super.release();\n    if (this.hideTimeout) {\n      this.hideTimeout.clear();\n    }\n  }\n\n  /**\n   * Checks if there are active settings within this settings panel. An active setting is a setting that is visible\n   * and enabled, which the user can interact with.\n   * @returns {boolean} true if there are active settings, false if the panel is functionally empty to a user\n   */\n  hasActiveSettings(): boolean {\n    for (let component of this.getItems()) {\n      if (component.isActive()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private getItems(): SettingsPanelItem[] {\n    return <SettingsPanelItem[]>this.config.components;\n  }\n\n  protected onSettingsStateChangedEvent() {\n    this.settingsPanelEvents.onSettingsStateChanged.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when one or more {@link SettingsPanelItem items} have changed state.\n   * @returns {Event<SettingsPanel, NoArgs>}\n   */\n  get onSettingsStateChanged(): Event<SettingsPanel, NoArgs> {\n    return this.settingsPanelEvents.onSettingsStateChanged.getEvent();\n  }\n}\n\n/**\n * An item for a {@link SettingsPanel}, containing a {@link Label} and a component that configures a setting.\n * Supported setting components: {@link SelectBox}\n */\nexport class SettingsPanelItem extends Container<ContainerConfig> {\n\n  private label: Label<LabelConfig>;\n  private setting: SelectBox;\n\n  private settingsPanelItemEvents = {\n    onActiveChanged: new EventDispatcher<SettingsPanelItem, NoArgs>()\n  };\n\n  constructor(label: string, selectBox: SelectBox, config: ContainerConfig = {}) {\n    super(config);\n\n    this.label = new Label({ text: label });\n    this.setting = selectBox;\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-settings-panel-item',\n      components: [this.label, this.setting]\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let handleConfigItemChanged = () => {\n      // The minimum number of items that must be available for the setting to be displayed\n      // By default, at least two items must be available, else a selection is not possible\n      let minItemsToDisplay = 2;\n      // Audio/video quality select boxes contain an additional 'auto' mode, which in combination with a single\n      // available quality also does not make sense\n      if (this.setting instanceof VideoQualitySelectBox || this.setting instanceof AudioQualitySelectBox) {\n        minItemsToDisplay = 3;\n      }\n\n      // Hide the setting if no meaningful choice is available\n      if (this.setting.itemCount() < minItemsToDisplay) {\n        this.hide();\n      } else {\n        this.show();\n      }\n\n      // Visibility might have changed and therefore the active state might have changed so we fire the event\n      // TODO fire only when state has really changed (e.g. check if visibility has really changed)\n      this.onActiveChangedEvent();\n    };\n\n    this.setting.onItemAdded.subscribe(handleConfigItemChanged);\n    this.setting.onItemRemoved.subscribe(handleConfigItemChanged);\n\n    // Initialize hidden state\n    handleConfigItemChanged();\n  }\n\n  /**\n   * Checks if this settings panel item is active, i.e. visible and enabled and a user can interact with it.\n   * @returns {boolean} true if the panel is active, else false\n   */\n  isActive(): boolean {\n    return this.isShown();\n  }\n\n  protected onActiveChangedEvent() {\n    this.settingsPanelItemEvents.onActiveChanged.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the 'active' state of this item changes.\n   * @see #isActive\n   * @returns {Event<SettingsPanelItem, NoArgs>}\n   */\n  get onActiveChanged(): Event<SettingsPanelItem, NoArgs> {\n    return this.settingsPanelItemEvents.onActiveChanged.getEvent();\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {SettingsPanel} from './settingspanel';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Configuration interface for the {@link SettingsToggleButton}.\n */\nexport interface SettingsToggleButtonConfig extends ToggleButtonConfig {\n  /**\n   * The settings panel whose visibility the button should toggle.\n   */\n  settingsPanel: SettingsPanel;\n\n  /**\n   * Decides if the button should be automatically hidden when the settings panel does not contain any active settings.\n   * Default: true\n   */\n  autoHideWhenNoActiveSettings?: boolean;\n}\n\n/**\n * A button that toggles visibility of a settings panel.\n */\nexport class SettingsToggleButton extends ToggleButton<SettingsToggleButtonConfig> {\n\n  constructor(config: SettingsToggleButtonConfig) {\n    super(config);\n\n    if (!config.settingsPanel) {\n      throw new Error('Required SettingsPanel is missing');\n    }\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-settingstogglebutton',\n      text: 'Settings',\n      settingsPanel: null,\n      autoHideWhenNoActiveSettings: true\n    }, <SettingsToggleButtonConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <SettingsToggleButtonConfig>this.getConfig(); // TODO fix generics type inference\n    let settingsPanel = config.settingsPanel;\n\n    this.onClick.subscribe(() => {\n      settingsPanel.toggleHidden();\n    });\n    settingsPanel.onShow.subscribe(() => {\n      // Set toggle status to on when the settings panel shows\n      this.on();\n    });\n    settingsPanel.onHide.subscribe(() => {\n      // Set toggle status to off when the settings panel hides\n      this.off();\n    });\n\n    // Handle automatic hiding of the button if there are no settings for the user to interact with\n    if (config.autoHideWhenNoActiveSettings) {\n      // Setup handler to show/hide button when the settings change\n      let settingsPanelItemsChangedHandler = () => {\n        if (settingsPanel.hasActiveSettings()) {\n          if (this.isHidden()) {\n            this.show();\n          }\n        } else {\n          if (this.isShown()) {\n            this.hide();\n          }\n        }\n      };\n      // Wire the handler to the event\n      settingsPanel.onSettingsStateChanged.subscribe(settingsPanelItemsChangedHandler);\n      // Call handler for first init at startup\n      settingsPanelItemsChangedHandler();\n    }\n  }\n}","import {Component, ComponentConfig} from './component';\n\n/**\n * A dummy component that just reserves some space and does nothing else.\n */\nexport class Spacer extends Component<ComponentConfig> {\n\n  constructor(config: ComponentConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-spacer',\n    }, this.config);\n  }\n\n\n  protected onShowEvent(): void {\n    // disable event firing by overwriting and not calling super\n  }\n\n  protected onHideEvent(): void {\n    // disable event firing by overwriting and not calling super\n  }\n\n  protected onHoverChangedEvent(hovered: boolean): void {\n    // disable event firing by overwriting and not calling super\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport SubtitleCueEvent = bitmovin.player.SubtitleCueEvent;\nimport {Label, LabelConfig} from './label';\nimport {ComponentConfig, Component} from './component';\nimport {ControlBar} from './controlbar';\n\n/**\n * Overlays the player to display subtitles.\n */\nexport class SubtitleOverlay extends Container<ContainerConfig> {\n\n  private static readonly CLASS_CONTROLBAR_VISIBLE = 'controlbar-visible';\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitle-overlay',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let subtitleManager = new ActiveSubtitleManager();\n\n    player.addEventHandler(player.EVENT.ON_CUE_ENTER, (event: SubtitleCueEvent) => {\n      let labelToAdd = subtitleManager.cueEnter(event);\n\n      this.addComponent(labelToAdd);\n      this.updateComponents();\n\n      this.show();\n    });\n    player.addEventHandler(player.EVENT.ON_CUE_EXIT, (event: SubtitleCueEvent) => {\n      let labelToRemove = subtitleManager.cueExit(event);\n\n      this.removeComponent(labelToRemove);\n      this.updateComponents();\n\n      if (!subtitleManager.hasCues) {\n        this.hide();\n      }\n    });\n\n    let subtitleClearHandler = () => {\n      this.hide();\n      subtitleManager.clear();\n      this.removeComponents();\n      this.updateComponents();\n    };\n\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_CHANGED, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_SEEK, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, subtitleClearHandler);\n\n    uimanager.onComponentShow.subscribe((component: Component<ComponentConfig>) => {\n      if (component instanceof ControlBar) {\n        this.getDomElement().addClass(this.prefixCss(SubtitleOverlay.CLASS_CONTROLBAR_VISIBLE));\n      }\n    });\n    uimanager.onComponentHide.subscribe((component: Component<ComponentConfig>) => {\n      if (component instanceof ControlBar) {\n        this.getDomElement().removeClass(this.prefixCss(SubtitleOverlay.CLASS_CONTROLBAR_VISIBLE));\n      }\n    });\n\n    // Init\n    subtitleClearHandler();\n  }\n}\n\ninterface ActiveSubtitleCue {\n  event: SubtitleCueEvent;\n  label: SubtitleLabel;\n}\n\ninterface ActiveSubtitleCueMap {\n  [id: string]: ActiveSubtitleCue;\n}\n\nclass SubtitleLabel extends Label<LabelConfig> {\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitle-label'\n    }, this.config);\n  }\n}\n\nclass ActiveSubtitleManager {\n\n  private activeSubtitleCueMap: ActiveSubtitleCueMap;\n\n  constructor() {\n    this.activeSubtitleCueMap = {};\n  }\n\n  /**\n   * Calculates a unique ID for a subtitle cue, which is needed to associate an ON_CUE_ENTER with its ON_CUE_EXIT\n   * event so we can remove the correct subtitle in ON_CUE_EXIT when multiple subtitles are active at the same time.\n   * The start time plus the text should make a unique identifier, and in the only case where a collision\n   * can happen, two similar texts will displayed at a similar time so it does not matter which one we delete.\n   * The start time should always be known, because it is required to schedule the ON_CUE_ENTER event. The end time\n   * must not necessarily be known and therefore cannot be used for the ID.\n   * @param event\n   * @return {string}\n   */\n  private static calculateId(event: SubtitleCueEvent): string {\n    return event.start + event.text;\n  }\n\n  /**\n   * Adds a subtitle cue to the manager and returns the label that should be added to the subtitle overlay.\n   * @param event\n   * @return {SubtitleLabel}\n   */\n  cueEnter(event: SubtitleCueEvent): SubtitleLabel {\n    let id = ActiveSubtitleManager.calculateId(event);\n\n    let label = new SubtitleLabel({\n      // Prefer the HTML subtitle text if set, else use the plain text\n      text: event.html || event.text\n    });\n\n    this.activeSubtitleCueMap[id] = { event, label };\n\n    return label;\n  }\n\n  /**\n   * Removes the subtitle cue from the manager and returns the label that should be removed from the subtitle overlay.\n   * @param event\n   * @return {SubtitleLabel}\n   */\n  cueExit(event: SubtitleCueEvent): SubtitleLabel {\n    let id = ActiveSubtitleManager.calculateId(event);\n    let activeSubtitleCue = this.activeSubtitleCueMap[id];\n    delete this.activeSubtitleCueMap[id];\n    return activeSubtitleCue.label;\n  }\n\n  /**\n   * Returns the number of active subtitle cues.\n   * @return {number}\n   */\n  get cueCount(): number {\n    return Object.keys(this.activeSubtitleCueMap).length;\n  }\n\n  /**\n   * Returns true if there are active subtitle cues, else false.\n   * @return {boolean}\n   */\n  get hasCues(): boolean {\n    return this.cueCount > 0;\n  }\n\n  /**\n   * Removes all subtitle cues from the manager.\n   */\n  clear(): void {\n    this.activeSubtitleCueMap = {};\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\nimport SubtitleAddedEvent = bitmovin.player.SubtitleAddedEvent;\nimport SubtitleChangedEvent = bitmovin.player.SubtitleChangedEvent;\nimport SubtitleRemovedEvent = bitmovin.player.SubtitleRemovedEvent;\n\n/**\n * A select box providing a selection between available subtitle and caption tracks.\n */\nexport class SubtitleSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let getLabel = (id: string) => {\n      switch (id) {\n        case 'off' :\n          return 'Off'\n        case 'en' :\n          return 'English'\n        case 'fr' :\n          return 'Francais'\n        case 'de' :\n          return 'Deutsch'\n        case 'es' :\n          return 'Espaniol'\n        default:\n          return id\n      }\n    }\n\n    let updateSubtitles = () => {\n      this.clearItems();\n\n      for (let subtitle of player.getAvailableSubtitles()) {\n        this.addItem(subtitle.id, getLabel(subtitle.label));\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: SubtitleSelectBox, value: string) => {\n      player.setSubtitle(value === 'null' ? null : value);\n    });\n\n    // React to API events\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_ADDED, (event: SubtitleAddedEvent) => {\n      this.addItem(event.subtitle.id, event.subtitle.label);\n    });\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_CHANGED, (event: SubtitleChangedEvent) => {\n      this.selectItem(event.targetSubtitle.id);\n    });\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_REMOVED, (event: SubtitleRemovedEvent) => {\n      this.removeItem(event.subtitleId);\n    });\n\n    // Update subtitles when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateSubtitles);\n    // Update subtitles when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateSubtitles);\n\n    // Populate subtitles at startup\n    updateSubtitles();\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {MetadataLabel, MetadataLabelContent} from './metadatalabel';\n\n/**\n * Configuration interface for a {@link TitleBar}.\n */\nexport interface TitleBarConfig extends ContainerConfig {\n  /**\n   * Specifies if the title bar should stay hidden when no metadata label contains any text. Does not make a lot\n   * of sense if the title bar contains other components than just MetadataLabels (like in the default configuration).\n   * Default: false\n   */\n  keepHiddenWithoutMetadata?: boolean;\n}\n\n/**\n * Displays a title bar containing a label with the title of the video.\n */\nexport class TitleBar extends Container<TitleBarConfig> {\n\n  constructor(config: TitleBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-titlebar',\n      hidden: true,\n      components: [\n        new MetadataLabel({ content: MetadataLabelContent.Title }),\n        new MetadataLabel({ content: MetadataLabelContent.Description })\n      ],\n      keepHiddenWithoutMetadata: false,\n    }, <TitleBarConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <TitleBarConfig>this.getConfig();\n    let shouldBeShown = !this.isHidden();\n    let hasMetadataText = true; // Flag to track if any metadata label contains text\n\n    let checkMetadataTextAndUpdateVisibility = () => {\n      hasMetadataText = false;\n\n      // Iterate through metadata labels and check if at least one of them contains text\n      for (let component of this.getComponents()) {\n        if (component instanceof MetadataLabel) {\n          if (!component.isEmpty()) {\n            hasMetadataText = true;\n            break;\n          }\n        }\n      }\n\n      if (this.isShown()) {\n        // Hide a visible titlebar if it does not contain any text and the hidden flag is set\n        if (config.keepHiddenWithoutMetadata && !hasMetadataText) {\n          this.hide();\n        }\n      } else if (shouldBeShown) {\n        // Show a hidden titlebar if it should actually be shown\n        this.show();\n      }\n    };\n\n    // Listen to text change events to update the hasMetadataText flag when the metadata dynamically changes\n    for (let component of this.getComponents()) {\n      if (component instanceof MetadataLabel) {\n        component.onTextChanged.subscribe(checkMetadataTextAndUpdateVisibility);\n      }\n    }\n\n    uimanager.onControlsShow.subscribe(() => {\n      shouldBeShown = true;\n      if (!(config.keepHiddenWithoutMetadata && !hasMetadataText)) {\n        this.show();\n      }\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      shouldBeShown = false;\n      this.hide();\n    });\n\n    // init\n    checkMetadataTextAndUpdateVisibility();\n  }\n}","import {Button, ButtonConfig} from './button';\nimport {NoArgs, EventDispatcher, Event} from '../eventdispatcher';\n\n/**\n * Configuration interface for a toggle button component.\n */\nexport interface ToggleButtonConfig extends ButtonConfig {\n  /**\n   * The text on the button.\n   */\n  text?: string;\n}\n\n/**\n * A button that can be toggled between 'on' and 'off' states.\n */\nexport class ToggleButton<Config extends ToggleButtonConfig> extends Button<ToggleButtonConfig> {\n\n  private static readonly CLASS_ON = 'on';\n  private static readonly CLASS_OFF = 'off';\n\n  private onState: boolean;\n\n  private toggleButtonEvents = {\n    onToggle: new EventDispatcher<ToggleButton<Config>, NoArgs>(),\n    onToggleOn: new EventDispatcher<ToggleButton<Config>, NoArgs>(),\n    onToggleOff: new EventDispatcher<ToggleButton<Config>, NoArgs>()\n  };\n\n  constructor(config: ToggleButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-togglebutton'\n    }, this.config);\n  }\n\n  /**\n   * Toggles the button to the 'on' state.\n   */\n  on() {\n    if (this.isOff()) {\n      this.onState = true;\n      this.getDomElement().removeClass(this.prefixCss(ToggleButton.CLASS_OFF));\n      this.getDomElement().addClass(this.prefixCss(ToggleButton.CLASS_ON));\n\n      this.onToggleEvent();\n      this.onToggleOnEvent();\n    }\n  }\n\n  /**\n   * Toggles the button to the 'off' state.\n   */\n  off() {\n    if (this.isOn()) {\n      this.onState = false;\n      this.getDomElement().removeClass(this.prefixCss(ToggleButton.CLASS_ON));\n      this.getDomElement().addClass(this.prefixCss(ToggleButton.CLASS_OFF));\n\n      this.onToggleEvent();\n      this.onToggleOffEvent();\n    }\n  }\n\n  /**\n   * Toggle the button 'on' if it is 'off', or 'off' if it is 'on'.\n   */\n  toggle() {\n    if (this.isOn()) {\n      this.off();\n    } else {\n      this.on();\n    }\n  }\n\n  /**\n   * Checks if the toggle button is in the 'on' state.\n   * @returns {boolean} true if button is 'on', false if 'off'\n   */\n  isOn(): boolean {\n    return this.onState;\n  }\n\n  /**\n   * Checks if the toggle button is in the 'off' state.\n   * @returns {boolean} true if button is 'off', false if 'on'\n   */\n  isOff(): boolean {\n    return !this.isOn();\n  }\n\n  protected onClickEvent() {\n    super.onClickEvent();\n\n    // Fire the toggle event together with the click event\n    // (they are technically the same, only the semantics are different)\n    this.onToggleEvent();\n  }\n\n  protected onToggleEvent() {\n    this.toggleButtonEvents.onToggle.dispatch(this);\n  }\n\n  protected onToggleOnEvent() {\n    this.toggleButtonEvents.onToggleOn.dispatch(this);\n  }\n\n  protected onToggleOffEvent() {\n    this.toggleButtonEvents.onToggleOff.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggle(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggle.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled 'on'.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggleOn(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggleOn.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled 'off'.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggleOff(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggleOff.getEvent();\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\n\n/**\n * Animated analog TV static noise.\n */\nexport class TvNoiseCanvas extends Component<ComponentConfig> {\n\n  private canvas: DOM;\n\n  private canvasElement: HTMLCanvasElement;\n  private canvasContext: CanvasRenderingContext2D;\n  private canvasWidth = 160;\n  private canvasHeight = 90;\n  private interferenceHeight = 50;\n  private lastFrameUpdate: number = 0;\n  private frameInterval: number = 60;\n  private useAnimationFrame: boolean = !!window.requestAnimationFrame;\n  private noiseAnimationWindowPos: number;\n  private frameUpdateHandlerId: number;\n\n  constructor(config: ComponentConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-tvnoisecanvas'\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    return this.canvas = new DOM('canvas', { 'class': this.getCssClasses() });\n  }\n\n  start(): void {\n    this.canvasElement = <HTMLCanvasElement>this.canvas.getElements()[0];\n    this.canvasContext = this.canvasElement.getContext('2d');\n    this.noiseAnimationWindowPos = -this.canvasHeight;\n    this.lastFrameUpdate = 0;\n\n    this.canvasElement.width = this.canvasWidth;\n    this.canvasElement.height = this.canvasHeight;\n\n    this.renderFrame();\n  }\n\n  stop(): void {\n    if (this.useAnimationFrame) {\n      cancelAnimationFrame(this.frameUpdateHandlerId);\n    } else {\n      clearTimeout(this.frameUpdateHandlerId);\n    }\n  }\n\n  private renderFrame(): void {\n    // This code has been copied from the player controls.js and simplified\n\n    if (this.lastFrameUpdate + this.frameInterval > new Date().getTime()) {\n      // It's too early to render the next frame\n      this.scheduleNextRender();\n      return;\n    }\n\n    let currentPixelOffset;\n    let canvasWidth = this.canvasWidth;\n    let canvasHeight = this.canvasHeight;\n\n    // Create texture\n    let noiseImage = this.canvasContext.createImageData(canvasWidth, canvasHeight);\n\n    // Fill texture with noise\n    for (let y = 0; y < canvasHeight; y++) {\n      for (let x = 0; x < canvasWidth; x++) {\n        currentPixelOffset = (canvasWidth * y * 4) + x * 4;\n        noiseImage.data[currentPixelOffset] = Math.random() * 255;\n        if (y < this.noiseAnimationWindowPos || y > this.noiseAnimationWindowPos + this.interferenceHeight) {\n          noiseImage.data[currentPixelOffset] *= 0.85;\n        }\n        noiseImage.data[currentPixelOffset + 1] = noiseImage.data[currentPixelOffset];\n        noiseImage.data[currentPixelOffset + 2] = noiseImage.data[currentPixelOffset];\n        noiseImage.data[currentPixelOffset + 3] = 50;\n      }\n    }\n\n    // Put texture onto canvas\n    this.canvasContext.putImageData(noiseImage, 0, 0);\n\n    this.lastFrameUpdate = new Date().getTime();\n    this.noiseAnimationWindowPos += 7;\n    if (this.noiseAnimationWindowPos > canvasHeight) {\n      this.noiseAnimationWindowPos = -canvasHeight;\n    }\n\n    this.scheduleNextRender();\n  }\n\n  private scheduleNextRender(): void {\n    if (this.useAnimationFrame) {\n      this.frameUpdateHandlerId = window.requestAnimationFrame(this.renderFrame.bind(this));\n    } else {\n      this.frameUpdateHandlerId = setTimeout(this.renderFrame.bind(this), this.frameInterval);\n    }\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {DOM} from '../dom';\nimport {Timeout} from '../timeout';\nimport {PlayerUtils} from '../utils';\nimport PlayerResizeEvent = bitmovin.player.PlayerResizeEvent;\nimport {CancelEventArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link UIContainer}.\n */\nexport interface UIContainerConfig extends ContainerConfig {\n  /**\n   * The delay in milliseconds after which the control bar will be hidden when there is no user interaction.\n   * Default: 5 seconds (5000)\n   */\n  hideDelay?: number;\n}\n\n/**\n * The base container that contains all of the UI. The UIContainer is passed to the {@link UIManager} to build and\n * setup the UI.\n */\nexport class UIContainer extends Container<UIContainerConfig> {\n\n  private static readonly STATE_PREFIX = 'player-state-';\n\n  private static readonly FULLSCREEN = 'fullscreen';\n  private static readonly BUFFERING = 'buffering';\n  private static readonly REMOTE_CONTROL = 'remote-control';\n  private static readonly CONTROLS_SHOWN = 'controls-shown';\n  private static readonly CONTROLS_HIDDEN = 'controls-hidden';\n\n  private uiHideTimeout: Timeout;\n\n  constructor(config: UIContainerConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <UIContainerConfig>{\n      cssClass: 'ui-uicontainer',\n      hideDelay: 5000,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.configureUIShowHide(player, uimanager);\n    this.configurePlayerStates(player, uimanager);\n  }\n\n  private configureUIShowHide(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let container = this.getDomElement();\n    let config = <UIContainerConfig>this.getConfig();\n\n    let isUiShown = false;\n    let isSeeking = false;\n    let isFirstTouch = true;\n\n    let showUi = () => {\n      if (!isUiShown) {\n        // Let subscribers know that they should reveal themselves\n        uimanager.onControlsShow.dispatch(this);\n        isUiShown = true;\n      }\n      // Don't trigger timeout while seeking (it will be triggered once the seek is finished) or casting\n      if (!isSeeking && !player.isCasting()) {\n        this.uiHideTimeout.start();\n      }\n    };\n\n    let hideUi = () => {\n      // Hide the UI only if it is shown, and if not casting\n      if (isUiShown && !player.isCasting()) {\n        // Issue a preview event to check if we are good to hide the controls\n        let previewHideEventArgs = <CancelEventArgs>{};\n        uimanager.onPreviewControlsHide.dispatch(this, previewHideEventArgs);\n\n        if (!previewHideEventArgs.cancel) {\n          // If the preview wasn't canceled, let subscribers know that they should now hide themselves\n          uimanager.onControlsHide.dispatch(this);\n          isUiShown = false;\n        } else {\n          // If the hide preview was canceled, continue to show UI\n          showUi();\n        }\n      }\n    };\n\n    // Timeout to defer UI hiding by the configured delay time\n    this.uiHideTimeout = new Timeout(config.hideDelay, hideUi);\n\n    // On touch displays, the first touch reveals the UI\n    container.on('touchend', (e) => {\n      if (!isUiShown) {\n        // Only if the UI is hidden, we prevent other actions (except for the first touch) and reveal the UI instead.\n        // The first touch is not prevented to let other listeners receive the event and trigger an initial action, e.g.\n        // the huge playback button can directly start playback instead of requiring a double tap which 1. reveals\n        // the UI and 2. starts playback.\n        if (isFirstTouch) {\n          isFirstTouch = false;\n        } else {\n          e.preventDefault();\n        }\n        showUi();\n      }\n    });\n    // When the mouse enters, we show the UI\n    container.on('mouseenter', () => {\n      showUi();\n    });\n    // When the mouse moves within, we show the UI\n    container.on('mousemove', () => {\n      showUi();\n    });\n    // When the mouse leaves, we can prepare to hide the UI, except a seek is going on\n    container.on('mouseleave', () => {\n      // When a seek is going on, the seek scrub pointer may exit the UI area while still seeking, and we do not hide\n      // the UI in such cases\n      if (!isSeeking) {\n        this.uiHideTimeout.start();\n      }\n    });\n\n    uimanager.onSeek.subscribe(() => {\n      this.uiHideTimeout.clear(); // Don't hide UI while a seek is in progress\n      isSeeking = true;\n    });\n    uimanager.onSeeked.subscribe(() => {\n      isSeeking = false;\n      this.uiHideTimeout.start(); // Re-enable UI hide timeout after a seek\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      showUi(); // Show UI when a Cast session has started (UI will then stay permanently on during the session)\n    });\n  }\n\n  private configurePlayerStates(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let container = this.getDomElement();\n\n    // Convert player states into CSS class names\n    let stateClassNames = <any>[];\n    for (let state in PlayerUtils.PlayerState) {\n      if (isNaN(Number(state))) {\n        let enumName = PlayerUtils.PlayerState[<any>PlayerUtils.PlayerState[state]];\n        stateClassNames[PlayerUtils.PlayerState[state]] =\n          this.prefixCss(UIContainer.STATE_PREFIX + enumName.toLowerCase());\n      }\n    }\n\n    let removeStates = () => {\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.IDLE]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PREPARED]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PLAYING]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PAUSED]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.FINISHED]);\n    };\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PREPARED]);\n    });\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PLAYING]);\n    });\n    player.addEventHandler(player.EVENT.ON_PAUSED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PAUSED]);\n    });\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.FINISHED]);\n    });\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.IDLE]);\n    });\n    // Init in current player state\n    container.addClass(stateClassNames[PlayerUtils.getState(player)]);\n\n    // Fullscreen marker class\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_ENTER, () => {\n      container.addClass(this.prefixCss(UIContainer.FULLSCREEN));\n    });\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_EXIT, () => {\n      container.removeClass(this.prefixCss(UIContainer.FULLSCREEN));\n    });\n    // Init fullscreen state\n    if (player.isFullscreen()) {\n      container.addClass(this.prefixCss(UIContainer.FULLSCREEN));\n    }\n\n    // Buffering marker class\n    player.addEventHandler(player.EVENT.ON_STALL_STARTED, () => {\n      container.addClass(this.prefixCss(UIContainer.BUFFERING));\n    });\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, () => {\n      container.removeClass(this.prefixCss(UIContainer.BUFFERING));\n    });\n    // Init buffering state\n    if (player.isStalled()) {\n      container.addClass(this.prefixCss(UIContainer.BUFFERING));\n    }\n\n    // RemoteControl marker class\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      container.addClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, () => {\n      container.removeClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    });\n    // Init RemoteControl state\n    if (player.isCasting()) {\n      container.addClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    }\n\n    // Controls visibility marker class\n    uimanager.onControlsShow.subscribe(() => {\n      container.removeClass(this.prefixCss(UIContainer.CONTROLS_HIDDEN));\n      container.addClass(this.prefixCss(UIContainer.CONTROLS_SHOWN));\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      container.removeClass(this.prefixCss(UIContainer.CONTROLS_SHOWN));\n      container.addClass(this.prefixCss(UIContainer.CONTROLS_HIDDEN));\n    });\n\n    // Layout size classes\n    let updateLayoutSizeClasses = (width: number, height: number) => {\n      container.removeClass(this.prefixCss('layout-max-width-400'));\n      container.removeClass(this.prefixCss('layout-max-width-600'));\n      container.removeClass(this.prefixCss('layout-max-width-800'));\n      container.removeClass(this.prefixCss('layout-max-width-1200'));\n\n      if (width <= 400) {\n        container.addClass(this.prefixCss('layout-max-width-400'));\n      } else if (width <= 600) {\n        container.addClass(this.prefixCss('layout-max-width-600'));\n      } else if (width <= 800) {\n        container.addClass(this.prefixCss('layout-max-width-800'));\n      } else if (width <= 1200) {\n        container.addClass(this.prefixCss('layout-max-width-1200'));\n      }\n    };\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, (e: PlayerResizeEvent) => {\n      // Convert strings (with \"px\" suffix) to ints\n      let width = Math.round(Number(e.width.substring(0, e.width.length - 2)));\n      let height = Math.round(Number(e.height.substring(0, e.height.length - 2)));\n\n      updateLayoutSizeClasses(width, height);\n    });\n\n    // Init layout state\n    updateLayoutSizeClasses(new DOM(player.getFigure()).width(), new DOM(player.getFigure()).height());\n  }\n\n  release(): void {\n    super.release();\n    this.uiHideTimeout.clear();\n  }\n\n  protected toDomElement(): DOM {\n    let container = super.toDomElement();\n\n    // Detect flexbox support (not supported in IE9)\n    if (document && typeof document.createElement('p').style.flex !== 'undefined') {\n      container.addClass(this.prefixCss('flexbox'));\n    } else {\n      container.addClass(this.prefixCss('no-flexbox'));\n    }\n\n    return container;\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between 'auto' and the available video qualities.\n */\nexport class VideoQualitySelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let updateVideoQualities = () => {\n      let videoQualities = player.getAvailableVideoQualities();\n\n      this.clearItems();\n\n      // Add entry for automatic quality switching (default setting)\n      this.addItem('Auto', 'Auto');\n\n      // Add video qualities\n      for (let videoQuality of videoQualities) {\n        this.addItem(videoQuality.id, videoQuality.label);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: VideoQualitySelectBox, value: string) => {\n      player.setVideoQuality(value);\n    });\n\n    // Update qualities when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateVideoQualities);\n    // Update qualities when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateVideoQualities);\n    // Update quality selection when quality is changed (from outside)\n    player.addEventHandler(player.EVENT.ON_VIDEO_DOWNLOAD_QUALITY_CHANGE, () => {\n      let data = player.getDownloadedVideoData();\n      this.selectItem(data.isAuto ? 'Auto' : data.id);\n    });\n\n    // Populate qualities at startup\n    updateVideoQualities();\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {VolumeSlider} from './volumeslider';\nimport {VolumeToggleButton} from './volumetogglebutton';\nimport {UIInstanceManager} from '../uimanager';\nimport {Timeout} from '../timeout';\n\n/**\n * Configuration interface for a {@link VolumeControlButton}.\n */\nexport interface VolumeControlButtonConfig extends ContainerConfig {\n  /**\n   * The delay after which the volume slider will be hidden when there is no user interaction.\n   * Care must be taken that the delay is long enough so users can reach the slider from the toggle button, e.g. by\n   * mouse movement. If the delay is too short, the sliders disappears before the mouse pointer has reached it and\n   * the user is not able to use it.\n   * Default: 500ms\n   */\n  hideDelay?: number;\n  /**\n   * Specifies if the volume slider should be vertically or horizontally aligned.\n   * Default: true\n   */\n  vertical?: boolean;\n}\n\n/**\n * A composite volume control that consists of and internally manages a volume control button that can be used\n * for muting, and a (depending on the CSS style, e.g. slide-out) volume control bar.\n */\nexport class VolumeControlButton extends Container<VolumeControlButtonConfig> {\n\n  private volumeToggleButton: VolumeToggleButton;\n  private volumeSlider: VolumeSlider;\n\n  private volumeSliderHideTimeout: Timeout;\n\n  constructor(config: VolumeControlButtonConfig = {}) {\n    super(config);\n\n    this.volumeToggleButton = new VolumeToggleButton();\n    this.volumeSlider = new VolumeSlider({\n      vertical: config.vertical != null ? config.vertical : true,\n      hidden: true\n    });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-volumecontrolbutton',\n      components: [this.volumeToggleButton, this.volumeSlider],\n      hideDelay: 500\n    }, <VolumeControlButtonConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let volumeToggleButton = this.getVolumeToggleButton();\n    let volumeSlider = this.getVolumeSlider();\n\n    this.volumeSliderHideTimeout = new Timeout((<VolumeControlButtonConfig>this.getConfig()).hideDelay, () => {\n      volumeSlider.hide();\n    });\n\n    /*\n     * Volume Slider visibility handling\n     *\n     * The volume slider shall be visible while the user hovers the mute toggle button, while the user hovers the\n     * volume slider, and while the user slides the volume slider. If none of these situations are true, the slider\n     * shall disappear.\n     */\n    let volumeSliderHovered = false;\n    volumeToggleButton.getDomElement().on('mouseenter', () => {\n      // Show volume slider when mouse enters the button area\n      if (volumeSlider.isHidden()) {\n        volumeSlider.show();\n      }\n      // Avoid hiding of the slider when button is hovered\n      this.volumeSliderHideTimeout.clear();\n    });\n    volumeToggleButton.getDomElement().on('mouseleave', () => {\n      // Hide slider delayed when button is left\n      this.volumeSliderHideTimeout.reset();\n    });\n    volumeSlider.getDomElement().on('mouseenter', () => {\n      // When the slider is entered, cancel the hide timeout activated by leaving the button\n      this.volumeSliderHideTimeout.clear();\n      volumeSliderHovered = true;\n    });\n    volumeSlider.getDomElement().on('mouseleave', () => {\n      // When mouse leaves the slider, only hide it if there is no slide operation in progress\n      if (volumeSlider.isSeeking()) {\n        this.volumeSliderHideTimeout.clear();\n      } else {\n        this.volumeSliderHideTimeout.reset();\n      }\n      volumeSliderHovered = false;\n    });\n    volumeSlider.onSeeked.subscribe(() => {\n      // When a slide operation is done and the slider not hovered (mouse outside slider), hide slider delayed\n      if (!volumeSliderHovered) {\n        this.volumeSliderHideTimeout.reset();\n      }\n    });\n  }\n\n  release(): void {\n    super.release();\n    this.volumeSliderHideTimeout.clear();\n  }\n\n  /**\n   * Provides access to the internally managed volume toggle button.\n   * @returns {VolumeToggleButton}\n   */\n  getVolumeToggleButton(): VolumeToggleButton {\n    return this.volumeToggleButton;\n  }\n\n  /**\n   * Provides access to the internally managed volume silder.\n   * @returns {VolumeSlider}\n   */\n  getVolumeSlider(): VolumeSlider {\n    return this.volumeSlider;\n  }\n}","import {SeekBar, SeekBarConfig} from './seekbar';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Configuration interface for the {@link VolumeSlider} component.\n */\nexport interface VolumeSliderConfig extends SeekBarConfig {\n  /**\n   * Specifies if the volume slider should be automatically hidden when volume control is prohibited by the\n   * browser or platform. This currently only applies to iOS.\n   * Default: true\n   */\n  hideIfVolumeControlProhibited: boolean;\n}\n\n/**\n * A simple volume slider component to adjust the player's volume setting.\n */\nexport class VolumeSlider extends SeekBar {\n\n  constructor(config: SeekBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <VolumeSliderConfig>{\n      cssClass: 'ui-volumeslider',\n      hideIfVolumeControlProhibited: true,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager, false);\n\n    let config = <VolumeSliderConfig>this.getConfig();\n\n    if (config.hideIfVolumeControlProhibited && !this.detectVolumeControlAvailability(player)) {\n      this.hide();\n\n      // We can just return from here, because the user will never interact with the control and any configured\n      // functionality would only eat resources for no reason.\n      return;\n    }\n\n    let volumeChangeHandler = () => {\n      if (player.isMuted()) {\n        this.setPlaybackPosition(0);\n        this.setBufferPosition(0);\n      } else {\n        this.setPlaybackPosition(player.getVolume());\n\n        this.setBufferPosition(player.getVolume());\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_VOLUME_CHANGED, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_MUTED, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_UNMUTED, volumeChangeHandler);\n\n    this.onSeekPreview.subscribe((sender, args) => {\n      if (args.scrubbing) {\n        player.setVolume(args.position);\n      }\n    });\n    this.onSeeked.subscribe((sender, percentage) => {\n      player.setVolume(percentage);\n    });\n\n    // Update the volume slider marker when the player resized, a source is loaded and player is ready,\n    // or the UI is configured. Check the seekbar for a detailed description.\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => {\n      this.refreshPlaybackPosition();\n    });\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      this.refreshPlaybackPosition();\n    });\n    uimanager.onConfigured.subscribe(() => {\n      this.refreshPlaybackPosition();\n    });\n\n    // Init volume bar\n    volumeChangeHandler();\n  }\n\n  private detectVolumeControlAvailability(player: bitmovin.player.Player): boolean {\n    // Store current player state so we can restore it later\n    let volume = player.getVolume();\n    let muted = player.isMuted();\n    let playing = player.isPlaying();\n\n    /*\n     * \"On iOS devices, the audio level is always under the users physical control. The volume property is not\n     * settable in JavaScript. Reading the volume property always returns 1.\"\n     * https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html\n     *\n     * Our player API returns a volume range of [0, 100] so we need to check for 100 instead of 1.\n     */\n\n    // Only if the volume is 100, there's the possibility we are on a volume-control-restricted iOS device\n    if (volume === 100) {\n      // We set the volume to zero (that's the only value that does not unmute a muted player!)\n      player.setVolume(0);\n      // Then we check if the value is still 100\n      if (player.getVolume() === 100) {\n        // If the volume stayed at 100, we're on a volume-control-restricted device\n        return false;\n      } else {\n        // We can control volume, so we must restore the previous player state\n        player.setVolume(volume);\n        if (muted) {\n          player.mute();\n        }\n        if (playing) {\n          // The volume restore above pauses autoplay on mobile devices (e.g. Android) so we need to resume playback\n          // (We cannot check isPaused() here because it is not set when playback is prohibited by the mobile platform)\n          player.play();\n        }\n        return true;\n      }\n    } else {\n      // Volume is not 100, so we're definitely not on a volume-control-restricted iOS device\n      return true;\n    }\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles audio muting.\n */\nexport class VolumeToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-volumetogglebutton',\n      text: 'Volume/Mute'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let muteStateHandler = () => {\n      if (player.isMuted()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    let volumeLevelHandler = () => {\n      // Toggle low class to display low volume icon below 50% volume\n      if (player.getVolume() < 50) {\n        this.getDomElement().addClass(this.prefixCss('low'));\n      } else {\n        this.getDomElement().removeClass(this.prefixCss('low'));\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_MUTED, muteStateHandler);\n    player.addEventHandler(player.EVENT.ON_UNMUTED, muteStateHandler);\n    player.addEventHandler(player.EVENT.ON_VOLUME_CHANGED, volumeLevelHandler);\n\n    this.onClick.subscribe(() => {\n      if (player.isMuted()) {\n        player.unmute();\n      } else {\n        player.mute();\n      }\n    });\n\n    // Startup init\n    muteStateHandler();\n    volumeLevelHandler();\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles the video view between normal/mono and VR/stereo.\n */\nexport class VRToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-vrtogglebutton',\n      text: 'VR'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let isVRConfigured = () => {\n      // VR availability cannot be checked through getVRStatus() because it is asynchronously populated and not\n      // available at UI initialization. As an alternative, we check the VR settings in the config.\n      // TODO use getVRStatus() through isVRStereoAvailable() once the player has been rewritten and the status is\n      // available in ON_READY\n      let config = player.getConfig();\n      return config.source && config.source.vr && config.source.vr.contentType !== 'none';\n    };\n\n    let isVRStereoAvailable = () => {\n      return player.getVRStatus().contentType !== 'none';\n    };\n\n    let vrStateHandler = () => {\n      if (isVRConfigured() && isVRStereoAvailable()) {\n        this.show(); // show button in case it is hidden\n\n        if (player.getVRStatus().isStereo) {\n          this.on();\n        } else {\n          this.off();\n        }\n      } else {\n        this.hide(); // hide button if no stereo mode available\n      }\n    };\n\n    let vrButtonVisibilityHandler = () => {\n      if (isVRConfigured()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_VR_MODE_CHANGED, vrStateHandler);\n    player.addEventHandler(player.EVENT.ON_VR_STEREO_CHANGED, vrStateHandler);\n    player.addEventHandler(player.EVENT.ON_VR_ERROR, vrStateHandler);\n    // Hide button when VR source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, vrButtonVisibilityHandler);\n    // Show button when a new source is loaded and it's VR\n    player.addEventHandler(player.EVENT.ON_READY, vrButtonVisibilityHandler);\n\n    this.onClick.subscribe(() => {\n      if (!isVRStereoAvailable()) {\n        if (console) {\n          console.log('No VR content');\n        }\n      } else {\n        if (player.getVRStatus().isStereo) {\n          player.setVRStereo(false);\n        } else {\n          player.setVRStereo(true);\n        }\n      }\n    });\n\n    // Set startup visibility\n    vrButtonVisibilityHandler();\n  }\n}","import {ClickOverlay, ClickOverlayConfig} from './clickoverlay';\n\n/**\n * Configuration interface for a {@link ClickOverlay}.\n */\nexport interface WatermarkConfig extends ClickOverlayConfig {\n  // nothing yet\n}\n\n/**\n * A watermark overlay with a clickable logo.\n */\nexport class Watermark extends ClickOverlay {\n\n  constructor(config: WatermarkConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-watermark',\n      url: 'http://bitmovin.com'\n    }, <WatermarkConfig>this.config);\n  }\n}","export interface Offset {\n  left: number;\n  top: number;\n}\n\n/**\n * Simple DOM manipulation and DOM element event handling modeled after jQuery (as replacement for jQuery).\n *\n * Like jQuery, DOM operates on single elements and lists of elements. For example: creating an element returns a DOM\n * instance with a single element, selecting elements returns a DOM instance with zero, one, or many elements. Similar\n * to jQuery, setters usually affect all elements, while getters operate on only the first element.\n * Also similar to jQuery, most methods (except getters) return the DOM instance facilitating easy chaining of method\n * calls.\n *\n * Built with the help of: http://youmightnotneedjquery.com/\n */\nexport class DOM {\n\n  private document: Document;\n\n  /**\n   * The list of elements that the instance wraps. Take care that not all methods can operate on the whole list,\n   * getters usually just work on the first element.\n   */\n  private elements: HTMLElement[];\n\n  /**\n   * Creates a DOM element.\n   * @param tagName the tag name of the DOM element\n   * @param attributes a list of attributes of the element\n   */\n  constructor(tagName: string, attributes: {[name: string]: string});\n  /**\n   * Selects all elements from the DOM that match the specified selector.\n   * @param selector the selector to match DOM elements with\n   */\n  constructor(selector: string);\n  /**\n   * Wraps a plain HTMLElement with a DOM instance.\n   * @param element the HTMLElement to wrap with DOM\n   */\n  constructor(element: HTMLElement);\n  /**\n   * Wraps a list of plain HTMLElements with a DOM instance.\n   * @param element the HTMLElements to wrap with DOM\n   */\n  constructor(elements: HTMLElement[]);\n  /**\n   * Wraps the document with a DOM instance. Useful to attach event listeners to the document.\n   * @param document the document to wrap\n   */\n  constructor(document: Document);\n  constructor(something: string | HTMLElement | HTMLElement[] | Document, attributes?: {[name: string]: string}) {\n    this.document = document; // Set the global document to the local document field\n\n    if (something instanceof Array) {\n      if (something.length > 0 && something[0] instanceof HTMLElement) {\n        let elements = something;\n        this.elements = elements;\n      }\n    }\n    else if (something instanceof HTMLElement) {\n      let element = something;\n      this.elements = [element];\n    }\n    else if (something instanceof Document) {\n      // When a document is passed in, we do not do anything with it, but by setting this.elements to null\n      // we give the event handling method a means to detect if the events should be registered on the document\n      // instead of elements.\n      this.elements = null;\n    }\n    else if (attributes) {\n      let tagName = something;\n      let element = document.createElement(tagName);\n\n      for (let attributeName in attributes) {\n        let attributeValue = attributes[attributeName];\n        element.setAttribute(attributeName, attributeValue);\n      }\n\n      this.elements = [element];\n    }\n    else {\n      let selector = something;\n      this.elements = this.findChildElements(selector);\n    }\n  }\n\n  /**\n   * Gets the number of elements that this DOM instance currently holds.\n   * @returns {number} the number of elements\n   */\n  get length(): number {\n    return this.elements ? this.elements.length : 0;\n  }\n\n  /**\n   * Gets the HTML elements that this DOM instance currently holds.\n   * @returns {HTMLElement[]} the raw HTML elements\n   */\n  getElements(): HTMLElement[] {\n    return this.elements;\n  }\n\n  /**\n   * A shortcut method for iterating all elements. Shorts this.elements.forEach(...) to this.forEach(...).\n   * @param handler the handler to execute an operation on an element\n   */\n  private forEach(handler: (element: HTMLElement) => void): void {\n    this.elements.forEach((element) => {\n      handler(element);\n    });\n  }\n\n  private findChildElementsOfElement(element: HTMLElement | Document, selector: string): HTMLElement[] {\n    let childElements = element.querySelectorAll(selector);\n\n    // Convert NodeList to Array\n    // https://toddmotto.com/a-comprehensive-dive-into-nodelists-arrays-converting-nodelists-and-understanding-the-dom/\n    return [].slice.call(childElements);\n  }\n\n  private findChildElements(selector: string): HTMLElement[] {\n    let allChildElements = <HTMLElement[]>[];\n\n    if (this.elements) {\n      this.forEach((element) => {\n        allChildElements = allChildElements.concat(this.findChildElementsOfElement(element, selector));\n      });\n    }\n    else {\n      return this.findChildElementsOfElement(document, selector);\n    }\n\n    return allChildElements;\n  }\n\n  /**\n   * Finds all child elements of all elements matching the supplied selector.\n   * @param selector the selector to match with child elements\n   * @returns {DOM} a new DOM instance representing all matched children\n   */\n  find(selector: string): DOM {\n    let allChildElements = this.findChildElements(selector);\n    return new DOM(allChildElements);\n  }\n\n  /**\n   * Returns a string of the inner HTML content of the first element.\n   */\n  html(): string;\n  /**\n   * Sets the inner HTML content of all elements.\n   * @param content a string of plain text or HTML markup\n   */\n  html(content: string): DOM;\n  html(content?: string): string | DOM {\n    if (arguments.length > 0) {\n      return this.setHtml(content);\n    }\n    else {\n      return this.getHtml();\n    }\n  }\n\n  private getHtml(): string | null {\n    return this.elements[0].innerHTML;\n  }\n\n  private setHtml(content: string): DOM {\n    if (content === undefined || content == null) {\n      // Set to empty string to avoid innerHTML getting set to 'undefined' (all browsers) or 'null' (IE9)\n      content = '';\n    }\n\n    this.forEach((element) => {\n      element.innerHTML = content;\n    });\n\n    return this;\n  }\n\n  /**\n   * Clears the inner HTML of all elements (deletes all children).\n   * @returns {DOM}\n   */\n  empty(): DOM {\n    this.forEach((element) => {\n      element.innerHTML = '';\n    });\n    return this;\n  }\n\n  /**\n   * Returns the current value of the first form element, e.g. the selected value of a select box or the text if an\n   * input field.\n   * @returns {string} the value of a form element\n   */\n  val(): string {\n    let element = this.elements[0];\n\n    if (element instanceof HTMLSelectElement || element instanceof HTMLInputElement) {\n      return element.value;\n    }\n    else {\n      // TODO add support for missing form elements\n      throw new Error(`val() not supported for ${typeof element}`);\n    }\n  }\n\n  /**\n   * Returns the value of an attribute on the first element.\n   * @param attribute\n   */\n  attr(attribute: string): string | null;\n  /**\n   * Sets an attribute on all elements.\n   * @param attribute the name of the attribute\n   * @param value the value of the attribute\n   */\n  attr(attribute: string, value: string): DOM;\n  attr(attribute: string, value?: string): string | null | DOM {\n    if (arguments.length > 1) {\n      return this.setAttr(attribute, value);\n    }\n    else {\n      return this.getAttr(attribute);\n    }\n  }\n\n  private getAttr(attribute: string): string | null {\n    return this.elements[0].getAttribute(attribute);\n  }\n\n  private setAttr(attribute: string, value: string): DOM {\n    this.forEach((element) => {\n      element.setAttribute(attribute, value);\n    });\n    return this;\n  }\n\n  /**\n   * Returns the value of a data element on the first element.\n   * @param dataAttribute the name of the data attribute without the 'data-' prefix\n   */\n  data(dataAttribute: string): string | null;\n  /**\n   * Sets a data attribute on all elements.\n   * @param dataAttribute the name of the data attribute without the 'data-' prefix\n   * @param value the value of the data attribute\n   */\n  data(dataAttribute: string, value: string): DOM;\n  data(dataAttribute: string, value?: string): string | null | DOM {\n    if (arguments.length > 1) {\n      return this.setData(dataAttribute, value);\n    }\n    else {\n      return this.getData(dataAttribute);\n    }\n  }\n\n  private getData(dataAttribute: string): string | null {\n    return this.elements[0].getAttribute('data-' + dataAttribute);\n  }\n\n  private setData(dataAttribute: string, value: string): DOM {\n    this.forEach((element) => {\n      element.setAttribute('data-' + dataAttribute, value);\n    });\n    return this;\n  }\n\n  /**\n   * Appends one or more DOM elements as children to all elements.\n   * @param childElements the chrild elements to append\n   * @returns {DOM}\n   */\n  append(...childElements: DOM[]): DOM {\n    this.forEach((element) => {\n      childElements.forEach((childElement) => {\n        childElement.elements.forEach((_, index) => {\n          element.appendChild(childElement.elements[index]);\n        });\n      });\n    });\n    return this;\n  }\n\n  /**\n   * Removes all elements from the DOM.\n   */\n  remove(): void {\n    this.forEach((element) => {\n      let parent = element.parentNode;\n      if (parent) {\n        parent.removeChild(element);\n      }\n    });\n  }\n\n  /**\n   * Returns the offset of the first element from the document's top left corner.\n   * @returns {Offset}\n   */\n  offset(): Offset {\n    let element = this.elements[0];\n    let elementRect = element.getBoundingClientRect();\n    let htmlRect = document.body.parentElement.getBoundingClientRect();\n\n    // Virtual viewport scroll handling (e.g. pinch zoomed viewports in mobile browsers or desktop Chrome/Edge)\n    // 'normal' zooms and virtual viewport zooms (aka layout viewport) result in different\n    // element.getBoundingClientRect() results:\n    //  - with normal scrolls, the clientRect decreases with an increase in scroll(Top|Left)/page(X|Y)Offset\n    //  - with pinch zoom scrolls, the clientRect stays the same while scroll/pageOffset changes\n    // This means, that the combination of clientRect + scroll/pageOffset does not work to calculate the offset\n    // from the document's upper left origin when pinch zoom is used.\n    // To work around this issue, we do not use scroll/pageOffset but get the clientRect of the html element and\n    // subtract it from the element's rect, which always results in the offset from the document origin.\n    // NOTE: the current way of offset calculation was implemented specifically to track event positions on the\n    // seek bar, and it might break compatibility with jQuery's offset() method. If this ever turns out to be a\n    // problem, this method should be reverted to the old version and the offset calculation moved to the seek bar.\n\n    return {\n      top: elementRect.top - htmlRect.top,\n      left: elementRect.left - htmlRect.left\n    };\n  }\n\n  /**\n   * Returns the width of the first element.\n   * @returns {number} the width of the first element\n   */\n  width(): number {\n    // TODO check if this is the same as jQuery's width() (probably not)\n    return this.elements[0].offsetWidth;\n  }\n\n  /**\n   * Returns the height of the first element.\n   * @returns {number} the height of the first element\n   */\n  height(): number {\n    // TODO check if this is the same as jQuery's height() (probably not)\n    return this.elements[0].offsetHeight;\n  }\n\n  /**\n   * Attaches an event handler to one or more events on all elements.\n   * @param eventName the event name (or multiple names separated by space) to listen to\n   * @param eventHandler the event handler to call when the event fires\n   * @returns {DOM}\n   */\n  on(eventName: string, eventHandler: EventListenerOrEventListenerObject): DOM {\n    let events = eventName.split(' ');\n\n    events.forEach((event) => {\n      if (this.elements == null) {\n        this.document.addEventListener(event, eventHandler);\n      }\n      else {\n        this.forEach((element) => {\n          element.addEventListener(event, eventHandler);\n        });\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Removes an event handler from one or more events on all elements.\n   * @param eventName the event name (or multiple names separated by space) to remove the handler from\n   * @param eventHandler the event handler to remove\n   * @returns {DOM}\n   */\n  off(eventName: string, eventHandler: EventListenerOrEventListenerObject): DOM {\n    let events = eventName.split(' ');\n\n    events.forEach((event) => {\n      if (this.elements == null) {\n        this.document.removeEventListener(event, eventHandler);\n      }\n      else {\n        this.forEach((element) => {\n          element.removeEventListener(event, eventHandler);\n        });\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds the specified class(es) to all elements.\n   * @param className the class(es) to add, multiple classes separated by space\n   * @returns {DOM}\n   */\n  addClass(className: string): DOM {\n    this.forEach((element) => {\n      if (element.classList) {\n        element.classList.add(className);\n      }\n      else {\n        element.className += ' ' + className;\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Removed the specified class(es) from all elements.\n   * @param className the class(es) to remove, multiple classes separated by space\n   * @returns {DOM}\n   */\n  removeClass(className: string): DOM {\n    this.forEach((element) => {\n      if (element.classList) {\n        element.classList.remove(className);\n      }\n      else {\n        element.className = element.className.replace(\n          new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Checks if any of the elements has the specified class.\n   * @param className the class name to check\n   * @returns {boolean} true if one of the elements has the class attached, else if no element has it attached\n   */\n  hasClass(className: string): boolean {\n    let hasClass = false;\n\n    this.forEach((element) => {\n      if (element.classList) {\n        if (element.classList.contains(className)) {\n          // Since we are inside a handler, we can't just 'return true'. Instead, we save it to a variable\n          // and return it at the end of the function body.\n          hasClass = true;\n        }\n      }\n      else {\n        if (new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className)) {\n          // See comment above\n          hasClass = true;\n        }\n      }\n    });\n\n    return hasClass;\n  }\n\n  /**\n   * Returns the value of a CSS property of the first element.\n   * @param propertyName the name of the CSS property to retrieve the value of\n   */\n  css(propertyName: string): string | null;\n  /**\n   * Sets the value of a CSS property on all elements.\n   * @param propertyName the name of the CSS property to set the value for\n   * @param value the value to set for the given CSS property\n   */\n  css(propertyName: string, value: string): DOM;\n  /**\n   * Sets a collection of CSS properties and their values on all elements.\n   * @param propertyValueCollection an object containing pairs of property names and their values\n   */\n  css(propertyValueCollection: {[propertyName: string]: string}): DOM;\n  css(propertyNameOrCollection: string | {[propertyName: string]: string}, value?: string): string | null | DOM {\n    if (typeof propertyNameOrCollection === 'string') {\n      let propertyName = propertyNameOrCollection;\n\n      if (arguments.length === 2) {\n        return this.setCss(propertyName, value);\n      }\n      else {\n        return this.getCss(propertyName);\n      }\n    }\n    else {\n      let propertyValueCollection = propertyNameOrCollection;\n      return this.setCssCollection(propertyValueCollection);\n    }\n  }\n\n  private getCss(propertyName: string): string | null {\n    return getComputedStyle(this.elements[0])[<any>propertyName];\n  }\n\n  private setCss(propertyName: string, value: string): DOM {\n    this.forEach((element) => {\n      // <any> cast to resolve TS7015: http://stackoverflow.com/a/36627114/370252\n      element.style[<any>propertyName] = value;\n    });\n    return this;\n  }\n\n  private setCssCollection(ruleValueCollection: {[ruleName: string]: string}): DOM {\n    this.forEach((element) => {\n      // http://stackoverflow.com/a/34490573/370252\n      Object.assign(element.style, ruleValueCollection);\n    });\n\n    return this;\n  }\n}\n","import {ArrayUtils} from './utils';\n/**\n * Function interface for event listeners on the {@link EventDispatcher}.\n */\nexport interface EventListener<Sender, Args> {\n  (sender: Sender, args: Args): void;\n}\n\n/**\n * Empty type for creating {@link EventDispatcher event dispatchers} that do not carry any arguments.\n */\nexport interface NoArgs {\n}\n\n/**\n * Event args for an event that can be canceled.\n */\nexport interface CancelEventArgs extends NoArgs {\n  /**\n   * Gets or sets a flag whether the event should be canceled.\n   */\n  cancel?: boolean;\n}\n\n/**\n * Public interface that represents an event. Can be used to subscribe to and unsubscribe from events.\n */\nexport interface Event<Sender, Args> {\n  /**\n   * Subscribes an event listener to this event dispatcher.\n   * @param listener the listener to add\n   */\n  subscribe(listener: EventListener<Sender, Args>): void;\n\n  /**\n   * Subscribes an event listener to this event dispatcher that is only called once.\n   * @param listener the listener to add\n   */\n  subscribeOnce(listener: EventListener<Sender, Args>): void;\n\n  /**\n   * Subscribes an event listener to this event dispatcher that will be called at a limited rate with a minimum\n   * interval of the specified milliseconds.\n   * @param listener the listener to add\n   * @param rateMs the rate in milliseconds to which calling of the listeners should be limited\n   */\n  subscribeRateLimited(listener: EventListener<Sender, Args>, rateMs: number): void;\n\n  /**\n   * Unsubscribes a subscribed event listener from this dispatcher.\n   * @param listener the listener to remove\n   * @returns {boolean} true if the listener was successfully unsubscribed, false if it isn't subscribed on this\n   *   dispatcher\n   */\n  unsubscribe(listener: EventListener<Sender, Args>): boolean;\n}\n\n/**\n * Event dispatcher to subscribe and trigger events. Each event should have its own dispatcher.\n */\nexport class EventDispatcher<Sender, Args> implements Event<Sender, Args> {\n\n  private listeners: EventListenerWrapper<Sender, Args>[] = [];\n\n  constructor() {\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribe(listener: EventListener<Sender, Args>) {\n    this.listeners.push(new EventListenerWrapper(listener));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribeOnce(listener: EventListener<Sender, Args>) {\n    this.listeners.push(new EventListenerWrapper(listener, true));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribeRateLimited(listener: EventListener<Sender, Args>, rateMs: number) {\n    this.listeners.push(new RateLimitedEventListenerWrapper(listener, rateMs));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  unsubscribe(listener: EventListener<Sender, Args>): boolean {\n    // Iterate through listeners, compare with parameter, and remove if found\n    for (let i = 0; i < this.listeners.length; i++) {\n      let subscribedListener = this.listeners[i];\n      if (subscribedListener.listener === listener) {\n        ArrayUtils.remove(this.listeners, subscribedListener);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Removes all listeners from this dispatcher.\n   */\n  unsubscribeAll(): void {\n    this.listeners = [];\n  }\n\n  /**\n   * Dispatches an event to all subscribed listeners.\n   * @param sender the source of the event\n   * @param args the arguments for the event\n   */\n  dispatch(sender: Sender, args: Args = null) {\n    let listenersToRemove = [];\n\n    // Call every listener\n    for (let listener of this.listeners) {\n      listener.fire(sender, args);\n\n      if (listener.isOnce()) {\n        listenersToRemove.push(listener);\n      }\n    }\n\n    // Remove one-time listener\n    for (let listenerToRemove of listenersToRemove) {\n      ArrayUtils.remove(this.listeners, listenerToRemove);\n    }\n  }\n\n  /**\n   * Returns the event that this dispatcher manages and on which listeners can subscribe and unsubscribe event handlers.\n   * @returns {Event}\n   */\n  getEvent(): Event<Sender, Args> {\n    // For now, just cast the event dispatcher to the event interface. At some point in the future when the\n    // codebase grows, it might make sense to split the dispatcher into separate dispatcher and event classes.\n    return <Event<Sender, Args>>this;\n  }\n}\n\n/**\n * A basic event listener wrapper to manage listeners within the {@link EventDispatcher}. This is a 'private' class\n * for internal dispatcher use and it is therefore not exported.\n */\nclass EventListenerWrapper<Sender, Args> {\n\n  private eventListener: EventListener<Sender, Args>;\n  private once: boolean;\n\n  constructor(listener: EventListener<Sender, Args>, once: boolean = false) {\n    this.eventListener = listener;\n    this.once = once;\n  }\n\n  /**\n   * Returns the wrapped event listener.\n   * @returns {EventListener<Sender, Args>}\n   */\n  get listener(): EventListener<Sender, Args> {\n    return this.eventListener;\n  }\n\n  /**\n   * Fires the wrapped event listener with the given arguments.\n   * @param sender\n   * @param args\n   */\n  fire(sender: Sender, args: Args) {\n    this.eventListener(sender, args);\n  }\n\n  /**\n   * Checks if this listener is scheduled to be called only once.\n   * @returns {boolean} once if true\n   */\n  isOnce(): boolean {\n    return this.once;\n  }\n}\n\n/**\n * Extends the basic {@link EventListenerWrapper} with rate-limiting functionality.\n */\nclass RateLimitedEventListenerWrapper<Sender, Args> extends EventListenerWrapper<Sender, Args> {\n\n  private rateMs: number;\n  private rateLimitingEventListener: EventListener<Sender, Args>;\n\n  private lastFireTime: number;\n\n  constructor(listener: EventListener<Sender, Args>, rateMs: number) {\n    super(listener); // sets the event listener sink\n\n    this.rateMs = rateMs;\n    this.lastFireTime = 0;\n\n    // Wrap the event listener with an event listener that does the rate-limiting\n    this.rateLimitingEventListener = (sender: Sender, args: Args) => {\n      if (Date.now() - this.lastFireTime > this.rateMs) {\n        // Only if enough time since the previous call has passed, call the\n        // actual event listener and record the current time\n        this.fireSuper(sender, args);\n        this.lastFireTime = Date.now();\n      }\n    };\n  }\n\n  private fireSuper(sender: Sender, args: Args) {\n    // Fire the actual external event listener\n    super.fire(sender, args);\n  }\n\n  fire(sender: Sender, args: Args) {\n    // Fire the internal rate-limiting listener instead of the external event listener\n    this.rateLimitingEventListener(sender, args);\n  }\n}","export namespace Guid {\n\n  let guid = 1;\n\n  export function next() {\n    return guid++;\n  }\n}\n","/// <reference path='player.d.ts' />\nimport {UIManager, UIInstanceManager} from './uimanager';\nimport {Button} from './components/button';\nimport {ControlBar} from './components/controlbar';\nimport {FullscreenToggleButton} from './components/fullscreentogglebutton';\nimport {HugePlaybackToggleButton} from './components/hugeplaybacktogglebutton';\nimport {PlaybackTimeLabel, PlaybackTimeLabelMode} from './components/playbacktimelabel';\nimport {PlaybackToggleButton} from './components/playbacktogglebutton';\nimport {SeekBar} from './components/seekbar';\nimport {SelectBox} from './components/selectbox';\nimport {SettingsPanel, SettingsPanelItem} from './components/settingspanel';\nimport {SettingsToggleButton} from './components/settingstogglebutton';\nimport {ToggleButton} from './components/togglebutton';\nimport {VideoQualitySelectBox} from './components/videoqualityselectbox';\nimport {VolumeToggleButton} from './components/volumetogglebutton';\nimport {VRToggleButton} from './components/vrtogglebutton';\nimport {Watermark} from './components/watermark';\nimport {UIContainer} from './components/uicontainer';\nimport {Container} from './components/container';\nimport {Label} from './components/label';\nimport {AudioQualitySelectBox} from './components/audioqualityselectbox';\nimport {AudioTrackSelectBox} from './components/audiotrackselectbox';\nimport {CastStatusOverlay} from './components/caststatusoverlay';\nimport {CastToggleButton} from './components/casttogglebutton';\nimport {Component} from './components/component';\nimport {ErrorMessageOverlay} from './components/errormessageoverlay';\nimport {RecommendationOverlay} from './components/recommendationoverlay';\nimport {SeekBarLabel} from './components/seekbarlabel';\nimport {SubtitleOverlay} from './components/subtitleoverlay';\nimport {SubtitleSelectBox} from './components/subtitleselectbox';\nimport {TitleBar} from './components/titlebar';\nimport {VolumeControlButton} from './components/volumecontrolbutton';\nimport {ClickOverlay} from './components/clickoverlay';\nimport {AdSkipButton} from './components/adskipbutton';\nimport {AdMessageLabel} from './components/admessagelabel';\nimport {AdClickOverlay} from './components/adclickoverlay';\nimport {PlaybackSpeedSelectBox} from './components/playbackspeedselectbox';\nimport {HugeReplayButton} from './components/hugereplaybutton';\nimport {BufferingOverlay} from './components/bufferingoverlay';\nimport {CastUIContainer} from './components/castuicontainer';\nimport {PlaybackToggleOverlay} from './components/playbacktoggleoverlay';\nimport {CloseButton} from './components/closebutton';\nimport {MetadataLabel, MetadataLabelContent} from './components/metadatalabel';\nimport {AirPlayToggleButton} from './components/airplaytogglebutton';\nimport {VolumeSlider} from './components/volumeslider';\nimport {PictureInPictureToggleButton} from './components/pictureinpicturetogglebutton';\nimport {Spacer} from './components/spacer';\nimport {ArrayUtils, StringUtils, PlayerUtils, UIUtils, BrowserUtils} from './utils';\n\n// Object.assign polyfill for ES5/IE9\n// https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nif (typeof Object.assign !== 'function') {\n  Object.assign = function(target: any) {\n    'use strict';\n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    target = Object(target);\n    for (let index = 1; index < arguments.length; index++) {\n      let source = arguments[index];\n      if (source != null) {\n        for (let key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n    }\n    return target;\n  };\n}\n\n// Expose classes to window\n(window as any).bitmovin.playerui = {\n  // Management\n  UIManager,\n  UIInstanceManager,\n  // Utils\n  ArrayUtils,\n  StringUtils,\n  PlayerUtils,\n  UIUtils,\n  BrowserUtils,\n  // Components\n  AdClickOverlay,\n  AdMessageLabel,\n  AdSkipButton,\n  AirPlayToggleButton,\n  AudioQualitySelectBox,\n  AudioTrackSelectBox,\n  BufferingOverlay,\n  Button,\n  CastStatusOverlay,\n  CastToggleButton,\n  CastUIContainer,\n  ClickOverlay,\n  CloseButton,\n  Component,\n  Container,\n  ControlBar,\n  ErrorMessageOverlay,\n  FullscreenToggleButton,\n  HugePlaybackToggleButton,\n  HugeReplayButton,\n  Label,\n  MetadataLabel,\n  MetadataLabelContent,\n  PictureInPictureToggleButton,\n  PlaybackSpeedSelectBox,\n  PlaybackTimeLabel,\n  PlaybackTimeLabelMode,\n  PlaybackToggleButton,\n  PlaybackToggleOverlay,\n  RecommendationOverlay,\n  SeekBar,\n  SeekBarLabel,\n  SelectBox,\n  SettingsPanel,\n  SettingsPanelItem,\n  SettingsToggleButton,\n  Spacer,\n  SubtitleOverlay,\n  SubtitleSelectBox,\n  TitleBar,\n  ToggleButton,\n  UIContainer,\n  VideoQualitySelectBox,\n  VolumeControlButton,\n  VolumeSlider,\n  VolumeToggleButton,\n  VRToggleButton,\n  Watermark,\n};","// TODO change to internal (not exported) class, how to use in other files?\n/**\n * Executes a callback after a specified amount of time,\n * optionally repeatedly until stopped. When delay is <= 0\n * the timeout is disabled\n */\nexport class Timeout {\n\n  private delay: number;\n  private callback: () => void;\n  private repeat: boolean;\n  private timeoutHandle: number;\n\n  /**\n   * Creates a new timeout callback handler.\n   * @param delay the delay in milliseconds after which the callback should be executed\n   * @param callback the callback to execute after the delay time\n   * @param repeat if true, call the callback repeatedly in delay intervals\n   */\n  constructor(delay: number, callback: () => void, repeat: boolean = false) {\n    this.delay = delay;\n    this.callback = callback;\n    this.repeat = repeat;\n    this.timeoutHandle = 0;\n  }\n\n  /**\n   * Starts the timeout and calls the callback when the timeout delay has passed.\n   * @returns {Timeout} the current timeout (so the start call can be chained to the constructor)\n   */\n  start(): this {\n    this.reset();\n    return this;\n  }\n\n  /**\n   * Clears the timeout. The callback will not be called if clear is called during the timeout.\n   */\n  clear(): void {\n    clearTimeout(this.timeoutHandle);\n  }\n\n  /**\n   * Resets the passed timeout delay to zero. Can be used to defer the calling of the callback.\n   */\n  reset(): void {\n    let lastScheduleTime = 0;\n    let delayAdjust = 0;\n\n    this.clear();\n\n    let internalCallback = () => {\n      this.callback();\n\n      if (this.repeat) {\n        let now = Date.now();\n\n        // The time of one iteration from scheduling to executing the callback (usually a bit longer than the delay\n        // time)\n        let delta = now - lastScheduleTime;\n\n        // Calculate the delay adjustment for the next schedule to keep a steady delay interval over time\n        delayAdjust = this.delay - delta + delayAdjust;\n\n        lastScheduleTime = now;\n\n        // Schedule next execution by the adjusted delay\n        this.timeoutHandle = setTimeout(internalCallback, this.delay + delayAdjust);\n      }\n    };\n\n    lastScheduleTime = Date.now();\n    if (this.delay > 0) {\n      this.timeoutHandle = setTimeout(internalCallback, this.delay);\n    }\n  }\n}","import {UIContainer} from './components/uicontainer';\nimport {DOM} from './dom';\nimport {Component, ComponentConfig} from './components/component';\nimport {Container} from './components/container';\nimport {PlaybackToggleButton} from './components/playbacktogglebutton';\nimport {FullscreenToggleButton} from './components/fullscreentogglebutton';\nimport {VRToggleButton} from './components/vrtogglebutton';\nimport {VolumeToggleButton} from './components/volumetogglebutton';\nimport {SeekBar} from './components/seekbar';\nimport {PlaybackTimeLabel, PlaybackTimeLabelMode} from './components/playbacktimelabel';\nimport {ControlBar} from './components/controlbar';\nimport {NoArgs, EventDispatcher, CancelEventArgs} from './eventdispatcher';\nimport {EmbedVideoToggleButton} from './components/embedvideotogglebutton';\nimport {EmbedVideoPanel} from './components/embedvideopanel';\nimport {SettingsToggleButton} from './components/settingstogglebutton';\nimport {SettingsPanel, SettingsPanelItem} from './components/settingspanel';\nimport {VideoQualitySelectBox} from './components/videoqualityselectbox';\nimport {Watermark} from './components/watermark';\nimport {AudioQualitySelectBox} from './components/audioqualityselectbox';\nimport {AudioTrackSelectBox} from './components/audiotrackselectbox';\nimport {SeekBarLabel} from './components/seekbarlabel';\nimport {VolumeSlider} from './components/volumeslider';\nimport {SubtitleSelectBox} from './components/subtitleselectbox';\nimport {SubtitleOverlay} from './components/subtitleoverlay';\nimport {VolumeControlButton} from './components/volumecontrolbutton';\nimport {CastToggleButton} from './components/casttogglebutton';\nimport {CastStatusOverlay} from './components/caststatusoverlay';\nimport {ErrorMessageOverlay} from './components/errormessageoverlay';\nimport {TitleBar} from './components/titlebar';\nimport Player = bitmovin.player.Player;\nimport {RecommendationOverlay} from './components/recommendationoverlay';\nimport {AdMessageLabel} from './components/admessagelabel';\nimport {AdSkipButton} from './components/adskipbutton';\nimport {AdClickOverlay} from './components/adclickoverlay';\nimport EVENT = bitmovin.player.EVENT;\nimport PlayerEventCallback = bitmovin.player.PlayerEventCallback;\nimport AdStartedEvent = bitmovin.player.AdStartedEvent;\nimport {ArrayUtils, UIUtils, BrowserUtils} from './utils';\nimport {PlaybackSpeedSelectBox} from './components/playbackspeedselectbox';\nimport {BufferingOverlay} from './components/bufferingoverlay';\nimport {CastUIContainer} from './components/castuicontainer';\nimport {PlaybackToggleOverlay} from './components/playbacktoggleoverlay';\nimport {CloseButton} from './components/closebutton';\nimport {MetadataLabel, MetadataLabelContent} from './components/metadatalabel';\nimport {Label} from './components/label';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\nimport {AirPlayToggleButton} from './components/airplaytogglebutton';\nimport {PictureInPictureToggleButton} from './components/pictureinpicturetogglebutton';\nimport {Spacer} from './components/spacer';\n\n\nexport interface UIRecommendationConfig {\n  title: string;\n  url: string;\n  thumbnail?: string;\n  duration?: number;\n}\n\nexport interface UIEmbedVideoConfig {\n  default: string;\n  withComments?: string;\n}\n\nexport interface TimelineMarker {\n  time: number;\n  title?: string;\n  markerType?: string;\n  comment?: string;\n  avatar?: string;\n  number?: string;\n}\n\nexport interface UIConfig {\n  metadata?: {\n    title?: string;\n    description?: string;\n    markers?: TimelineMarker[];\n    embedVideo?: UIEmbedVideoConfig;\n  };\n  recommendations?: UIRecommendationConfig[];\n}\n\n/**\n * The context that will be passed to a {@link UIConditionResolver} to determine if it's conditions fulfil the context.\n */\nexport interface UIConditionContext {\n  isAd: boolean;\n  isAdWithUI: boolean;\n  isFullscreen: boolean;\n  isMobile: boolean;\n  documentWidth: number;\n  width: number;\n}\n\n/**\n * Resolves the conditions of its associated UI in a {@link UIVariant} upon a {@link UIConditionContext} and decides\n * if the UI should be displayed. If it returns true, the UI is a candidate for display; if it returns false, it will\n * not be displayed in the given context.\n */\nexport interface UIConditionResolver {\n  (context: UIConditionContext): boolean;\n}\n\n/**\n * Associates a UI instance with an optional {@link UIConditionResolver} that determines if the UI should be displayed.\n */\nexport interface UIVariant {\n  ui: UIContainer;\n  condition?: UIConditionResolver;\n}\n\nexport class UIManager {\n\n  private player: Player;\n  private playerElement: DOM;\n  private uiVariants: UIVariant[];\n  private uiInstanceManagers: InternalUIInstanceManager[];\n  private currentUi: InternalUIInstanceManager;\n  private config: UIConfig;\n  private managerPlayerWrapper: PlayerWrapper;\n\n  /**\n   * Creates a UI manager with a single UI variant that will be permanently shown.\n   * @param player the associated player of this UI\n   * @param ui the UI to add to the player\n   * @param config optional UI configuration\n   */\n  constructor(player: Player, ui: UIContainer, config?: UIConfig);\n  /**\n   * Creates a UI manager with a list of UI variants that will be dynamically selected and switched according to\n   * the context of the UI.\n   *\n   * Every time the UI context changes, the conditions of the UI variants will be sequentially resolved and the first\n   * UI, whose condition evaluates to true, will be selected and displayed. The last variant in the list might omit the\n   * condition resolver and will be selected as default/fallback UI when all other conditions fail. If there is no\n   * fallback UI and all conditions fail, no UI will be displayed.\n   *\n   * @param player the associated player of this UI\n   * @param uiVariants a list of UI variants that will be dynamically switched\n   * @param config optional UI configuration\n   */\n  constructor(player: Player, uiVariants: UIVariant[], config?: UIConfig);\n  constructor(player: Player, playerUiOrUiVariants: UIContainer | UIVariant[], config: UIConfig = {}) {\n    if (playerUiOrUiVariants instanceof UIContainer) {\n      // Single-UI constructor has been called, transform arguments to UIVariant[] signature\n      let playerUi = <UIContainer>playerUiOrUiVariants;\n      let adsUi = null;\n\n      let uiVariants = [];\n\n      // Add the ads UI if defined\n      if (adsUi) {\n        uiVariants.push({\n          ui: adsUi,\n          condition: (context: UIConditionContext) => {\n            return context.isAdWithUI;\n          },\n        });\n      }\n\n      // Add the default player UI\n      uiVariants.push({ui: playerUi});\n\n      this.uiVariants = uiVariants;\n    }\n    else {\n      // Default constructor (UIVariant[]) has been called\n      this.uiVariants = <UIVariant[]>playerUiOrUiVariants;\n    }\n\n    this.player = player;\n    this.config = config;\n    this.managerPlayerWrapper = new PlayerWrapper(player);\n    this.playerElement = new DOM(player.getFigure());\n\n    // Create UI instance managers for the UI variants\n    // The instance managers map to the corresponding UI variants by their array index\n    this.uiInstanceManagers = [];\n    let uiVariantsWithoutCondition = [];\n    for (let uiVariant of this.uiVariants) {\n      if (uiVariant.condition == null) {\n        // Collect variants without conditions for error checking\n        uiVariantsWithoutCondition.push(uiVariant);\n      }\n      // Create the instance manager for a UI variant\n      this.uiInstanceManagers.push(new InternalUIInstanceManager(player, uiVariant.ui, this.config));\n    }\n    // Make sure that there is only one UI variant without a condition\n    // It does not make sense to have multiple variants without condition, because only the first one in the list\n    // (the one with the lowest index) will ever be selected.\n    if (uiVariantsWithoutCondition.length > 1) {\n      throw Error('Too many UIs without a condition: You cannot have more than one default UI');\n    }\n    // Make sure that the default UI variant, if defined, is at the end of the list (last index)\n    // If it comes earlier, the variants with conditions that come afterwards will never be selected because the\n    // default variant without a condition always evaluates to 'true'\n    if (uiVariantsWithoutCondition.length > 0\n      && uiVariantsWithoutCondition[0] !== this.uiVariants[this.uiVariants.length - 1]) {\n      throw Error('Invalid UI variant order: the default UI (without condition) must be at the end of the list');\n    }\n\n    let adStartedEvent: AdStartedEvent = null; // keep the event stored here during ad playback\n    let isMobile = BrowserUtils.isMobile;\n\n    // Dynamically select a UI variant that matches the current UI condition.\n    let resolveUiVariant = (event: PlayerEvent) => {\n      // Make sure that the ON_AD_STARTED event data is persisted through ad playback in case other events happen\n      // in the meantime, e.g. player resize. We need to store this data because there is no other way to find out\n      // ad details (e.g. the ad client) while an ad is playing.\n      // Existing event data signals that an ad is currently active. We cannot use player.isAd() because it returns\n      // true on ad start and also on ad end events, which is problematic.\n      if (event != null) {\n        switch (event.type) {\n          // When the ad starts, we store the event data\n          case player.EVENT.ON_AD_STARTED:\n            adStartedEvent = <AdStartedEvent>event;\n            break;\n          // When the ad ends, we delete the event data\n          case player.EVENT.ON_AD_FINISHED:\n          case player.EVENT.ON_AD_SKIPPED:\n          case player.EVENT.ON_AD_ERROR:\n            adStartedEvent = null;\n        }\n      }\n\n      // Detect if an ad has started\n      let ad = adStartedEvent != null;\n      let adWithUI = ad && adStartedEvent.clientType === 'vast';\n\n      // Determine the current context for which the UI variant will be resolved\n      let context: UIConditionContext = {\n        isAd: ad,\n        isAdWithUI: adWithUI,\n        isFullscreen: this.player.isFullscreen(),\n        isMobile: isMobile,\n        width: this.playerElement.width(),\n        documentWidth: document.body.clientWidth,\n      };\n\n      let nextUi: InternalUIInstanceManager = null;\n      let uiVariantChanged = false;\n\n      // Select new UI variant\n      // If no variant condition is fulfilled, we switch to *no* UI\n      for (let uiVariant of this.uiVariants) {\n        if (uiVariant.condition == null || uiVariant.condition(context) === true) {\n          nextUi = this.uiInstanceManagers[this.uiVariants.indexOf(uiVariant)];\n          break;\n        }\n      }\n\n      // Determine if the UI variant is changing\n      if (nextUi !== this.currentUi) {\n        uiVariantChanged = true;\n        // console.log('switched from ', this.currentUi ? this.currentUi.getUI() : 'none',\n        //   ' to ', nextUi ? nextUi.getUI() : 'none');\n      }\n\n      // Only if the UI variant is changing, we need to do some stuff. Else we just leave everything as-is.\n      if (uiVariantChanged) {\n        // Hide the currently active UI variant\n        if (this.currentUi) {\n          this.currentUi.getUI().hide();\n        }\n\n        // Assign the new UI variant as current UI\n        this.currentUi = nextUi;\n\n        // When we switch to a different UI instance, there's some additional stuff to manage. If we do not switch\n        // to an instance, we're done here.\n        if (this.currentUi != null) {\n          // Add the UI to the DOM (and configure it) the first time it is selected\n          if (!this.currentUi.isConfigured()) {\n            this.addUi(this.currentUi);\n          }\n\n          // If this is an ad UI, we need to relay the saved ON_AD_STARTED event data so ad components can configure\n          // themselves for the current ad.\n          if (context.isAd) {\n            /* Relay the ON_AD_STARTED event to the ads UI\n             *\n             * Because the ads UI is initialized in the ON_AD_STARTED handler, i.e. when the ON_AD_STARTED event has\n             * already been fired, components in the ads UI that listen for the ON_AD_STARTED event never receive it.\n             * Since this can break functionality of components that rely on this event, we relay the event to the\n             * ads UI components with the following call.\n             */\n            this.currentUi.getWrappedPlayer().fireEventInUI(this.player.EVENT.ON_AD_STARTED, adStartedEvent);\n          }\n\n          this.currentUi.getUI().show();\n        }\n      }\n    };\n\n    // Listen to the following events to trigger UI variant resolution\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_STARTED, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_FINISHED, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_SKIPPED, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_ERROR, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_PLAYER_RESIZE, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_FULLSCREEN_ENTER, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_FULLSCREEN_EXIT, resolveUiVariant);\n\n    // Initialize the UI\n    resolveUiVariant(null);\n  }\n\n  getConfig(): UIConfig {\n    return this.config;\n  }\n\n  private addUi(ui: InternalUIInstanceManager): void {\n    let dom = ui.getUI().getDomElement();\n    ui.configureControls();\n    /* Append the UI DOM after configuration to avoid CSS transitions at initialization\n     * Example: Components are hidden during configuration and these hides may trigger CSS transitions that are\n     * undesirable at this time. */\n\n    /* Append ui to parent instead of player */\n    let parentElement = new DOM(this.playerElement.getElements()[0].parentElement);\n    parentElement.addClass('smashcut-custom-ui-bitmovin-player-holder');\n    parentElement.append(dom);\n\n    // Fire onConfigured after UI DOM elements are successfully added. When fired immediately, the DOM elements\n    // might not be fully configured and e.g. do not have a size.\n    // https://swizec.com/blog/how-to-properly-wait-for-dom-elements-to-show-up-in-modern-browsers/swizec/6663\n    if (window.requestAnimationFrame) {\n      requestAnimationFrame(() => {\n        ui.onConfigured.dispatch(ui.getUI());\n      });\n    } else {\n      // IE9 fallback\n      setTimeout(() => {\n        ui.onConfigured.dispatch(ui.getUI());\n      }, 0);\n    }\n  }\n\n  private releaseUi(ui: InternalUIInstanceManager): void {\n    ui.releaseControls();\n    ui.getUI().getDomElement().remove();\n    ui.clearEventHandlers();\n  }\n\n  release(): void {\n    for (let uiInstanceManager of this.uiInstanceManagers) {\n      this.releaseUi(uiInstanceManager);\n    }\n    this.managerPlayerWrapper.clearEventHandlers();\n  }\n}\n\nexport namespace UIManager.Factory {\n\n  export function buildDefaultUI(player: Player, config: UIConfig = {}): UIManager {\n    return UIManager.Factory.buildModernUI(player, config);\n  }\n\n  export function buildDefaultSmallScreenUI(player: Player, config: UIConfig = {}): UIManager {\n    return UIManager.Factory.buildModernSmallScreenUI(player, config);\n  }\n\n  export function buildDefaultCastReceiverUI(player: Player, config: UIConfig = {}): UIManager {\n    return UIManager.Factory.buildModernCastReceiverUI(player, config);\n  }\n\n  function smashcutUi() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let embedVideoPanel = new EmbedVideoPanel({\n      hidden: true\n    });\n\n    let controlBarTop = new Container({\n      cssClasses: ['controlbar-top'],\n      components: [\n        new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n        new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n      ]\n    });\n\n    let controlBarMiddle = new Container({\n      cssClasses: ['controlbar-middle'],\n      components: [\n        new SeekBar({label: new SeekBarLabel()}),\n      ]\n    });\n\n    let controlBarBottom = new Container({\n      cssClasses: ['controlbar-bottom'],\n      components: [\n        new Spacer(),\n        new VolumeSlider(),\n        new VolumeToggleButton(),\n        new SettingsToggleButton({settingsPanel: settingsPanel}),\n        new EmbedVideoToggleButton({embedVideoPanel: embedVideoPanel}),\n        new FullscreenToggleButton(),\n      ]\n    });\n\n\n    let controlBar = new ControlBar({\n      components: [\n        new PlaybackToggleButton(),\n        new Container({\n          cssClasses: ['controlbar-inner'],\n          components: [\n            settingsPanel,\n            embedVideoPanel,\n            controlBarTop,\n            controlBarMiddle,\n            controlBarBottom,\n          ]\n        })\n      ]\n    });\n\n    return new UIContainer({\n      hideDelay: 0,\n      cssClasses: ['ui-skin-modern ui-skin-smashcut'],\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new PlaybackToggleOverlay(),\n        controlBar,\n        new TitleBar(),\n        new RecommendationOverlay(),\n        new ErrorMessageOverlay()\n      ]\n    });\n  }\n\n  function modernUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBar = new ControlBar({\n      components: [\n        settingsPanel,\n        new Container({\n          components: [\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n            new SeekBar({label: new SeekBarLabel()}),\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n          ],\n          cssClasses: ['controlbar-top']\n        }),\n        new Container({\n          components: [\n            new PlaybackToggleButton(),\n            new VolumeToggleButton(),\n            new VolumeSlider(),\n            new Spacer(),\n            new PictureInPictureToggleButton(),\n            new AirPlayToggleButton(),\n            new CastToggleButton(),\n            new VRToggleButton(),\n            new SettingsToggleButton({settingsPanel: settingsPanel}),\n            new FullscreenToggleButton(),\n          ],\n          cssClasses: ['controlbar-bottom']\n        }),\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new PlaybackToggleOverlay(),\n        new CastStatusOverlay(),\n        controlBar,\n        new TitleBar(),\n        new RecommendationOverlay(),\n        new Watermark(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-modern']\n    });\n  }\n\n  function modernAdsUI() {\n    return new UIContainer({\n      components: [\n        new BufferingOverlay(),\n        new AdClickOverlay(),\n        new PlaybackToggleOverlay(),\n        new Container({\n          components: [\n            new AdMessageLabel({text: 'Ad: {remainingTime} secs'}),\n            new AdSkipButton()\n          ],\n          cssClass: 'ui-ads-status'\n        }),\n        new ControlBar({\n          components: [\n            new Container({\n              components: [\n                new PlaybackToggleButton(),\n                new VolumeToggleButton(),\n                new VolumeSlider(),\n                new Spacer(),\n                new FullscreenToggleButton(),\n              ],\n              cssClasses: ['controlbar-bottom']\n            }),\n          ]\n        })\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-ads']\n    });\n  }\n\n  function modernSmallScreenUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true,\n      hideDelay: -1,\n    });\n    settingsPanel.addComponent(new CloseButton({target: settingsPanel}));\n\n    let controlBar = new ControlBar({\n      components: [\n        new Container({\n          components: [\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n            new SeekBar({label: new SeekBarLabel()}),\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n          ],\n          cssClasses: ['controlbar-top']\n        }),\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        controlBar,\n        new TitleBar({\n          components: [\n            new MetadataLabel({content: MetadataLabelContent.Title}),\n            new CastToggleButton(),\n            /*new VRToggleButton(),*/\n            new SettingsToggleButton({settingsPanel: settingsPanel}),\n            new FullscreenToggleButton(),\n          ]\n        }),\n        settingsPanel,\n        new RecommendationOverlay(),\n        new Watermark(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-smallscreen']\n    });\n  }\n\n  function modernSmallScreenAdsUI() {\n    return new UIContainer({\n      components: [\n        new BufferingOverlay(),\n        new AdClickOverlay(),\n        new PlaybackToggleOverlay(),\n        new TitleBar({\n          components: [\n            // dummy label with no content to move buttons to the right\n            new Label({cssClass: 'label-metadata-title'}),\n            new FullscreenToggleButton(),\n          ]\n        }),\n        new Container({\n          components: [\n            new AdMessageLabel({text: 'Ad: {remainingTime} secs'}),\n            new AdSkipButton()\n          ],\n          cssClass: 'ui-ads-status'\n        }),\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-ads', 'ui-skin-smallscreen']\n    });\n  }\n\n  function modernCastReceiverUI() {\n    let controlBar = new ControlBar({\n      components: [\n        new Container({\n          components: [\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n            new SeekBar({smoothPlaybackPositionUpdateIntervalMs: -1}),\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n          ],\n          cssClasses: ['controlbar-top']\n        }),\n      ]\n    });\n\n    return new CastUIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        controlBar,\n        new TitleBar({keepHiddenWithoutMetadata: true}),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-cast-receiver']\n    });\n  }\n\n  export function buildModernUI(player: Player, config: UIConfig = {}): UIManager {\n    // show smallScreen UI only on mobile/handheld devices\n    let smallScreenSwitchWidth = 600;\n\n    return new UIManager(player, [{\n      ui: modernSmallScreenAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isMobile && context.documentWidth < smallScreenSwitchWidth && context.isAdWithUI;\n      }\n    }, {\n      ui: modernAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isAdWithUI;\n      }\n    }, {\n      ui: modernSmallScreenUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isMobile && context.documentWidth < smallScreenSwitchWidth;\n      }\n    }, {\n      ui: smashcutUi()\n    }], config);\n  }\n\n  export function buildModernSmallScreenUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, [{\n      ui: modernSmallScreenAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isAdWithUI;\n      }\n    }, {\n      ui: modernSmallScreenUI()\n    }], config);\n  }\n\n  export function buildModernCastReceiverUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, modernCastReceiverUI(), config);\n  }\n\n  function legacyUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBar = new ControlBar({\n      components: [\n        settingsPanel,\n        new PlaybackToggleButton(),\n        new SeekBar({label: new SeekBarLabel()}),\n        new PlaybackTimeLabel(),\n        new VRToggleButton(),\n        new VolumeControlButton(),\n        new SettingsToggleButton({settingsPanel: settingsPanel}),\n        new CastToggleButton(),\n        new FullscreenToggleButton()\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        new RecommendationOverlay(),\n        controlBar,\n        new TitleBar(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-legacy']\n    });\n  }\n\n  function legacyAdsUI() {\n    return new UIContainer({\n      components: [\n        new AdClickOverlay(),\n        new ControlBar({\n          components: [\n            new PlaybackToggleButton(),\n            new AdMessageLabel(),\n            new VolumeControlButton(),\n            new FullscreenToggleButton()\n          ]\n        }),\n        new AdSkipButton()\n      ], cssClasses: ['ui-skin-legacy', 'ui-skin-ads']\n    });\n  }\n\n  function legacyCastReceiverUI() {\n    let controlBar = new ControlBar({\n      components: [\n        new SeekBar(),\n        new PlaybackTimeLabel(),\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        controlBar,\n        new TitleBar(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-legacy', 'ui-skin-cast-receiver']\n    });\n  }\n\n  function legacyTestUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBar = new ControlBar({\n      components: [settingsPanel,\n        new PlaybackToggleButton(),\n        new SeekBar({label: new SeekBarLabel()}),\n        new PlaybackTimeLabel(),\n        new VRToggleButton(),\n        new VolumeToggleButton(),\n        new VolumeSlider(),\n        new VolumeControlButton(),\n        new VolumeControlButton({vertical: false}),\n        new SettingsToggleButton({settingsPanel: settingsPanel}),\n        new CastToggleButton(),\n        new FullscreenToggleButton()\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        new RecommendationOverlay(),\n        controlBar,\n        new TitleBar(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-legacy']\n    });\n  }\n\n  export function buildLegacyUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, [{\n      ui: legacyAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isAdWithUI;\n      }\n    }, {\n      ui: legacyUI()\n    }], config);\n  }\n\n  export function buildLegacyCastReceiverUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, legacyCastReceiverUI(), config);\n  }\n\n  export function buildLegacyTestUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, legacyTestUI(), config);\n  }\n}\n\nexport interface SeekPreviewArgs extends NoArgs {\n  /**\n   * The timeline position in percent where the event originates from.\n   */\n  position: number;\n  /**\n   * The timeline marker associated with the current position, if existing.\n   */\n  marker?: TimelineMarker;\n}\n\n/**\n * Encapsulates functionality to manage a UI instance. Used by the {@link UIManager} to manage multiple UI instances.\n */\nexport class UIInstanceManager {\n  private playerWrapper: PlayerWrapper;\n  private ui: UIContainer;\n  private config: UIConfig;\n\n  private events = {\n    onConfigured: new EventDispatcher<UIContainer, NoArgs>(),\n    onSeek: new EventDispatcher<SeekBar, NoArgs>(),\n    onSeekPreview: new EventDispatcher<SeekBar, SeekPreviewArgs>(),\n    onSeeked: new EventDispatcher<SeekBar, NoArgs>(),\n    onComponentShow: new EventDispatcher<Component<ComponentConfig>, NoArgs>(),\n    onComponentHide: new EventDispatcher<Component<ComponentConfig>, NoArgs>(),\n    onControlsShow: new EventDispatcher<UIContainer, NoArgs>(),\n    onPreviewControlsHide: new EventDispatcher<UIContainer, CancelEventArgs>(),\n    onControlsHide: new EventDispatcher<UIContainer, NoArgs>(),\n  };\n\n  constructor(player: Player, ui: UIContainer, config: UIConfig = {}) {\n    this.playerWrapper = new PlayerWrapper(player);\n    this.ui = ui;\n    this.config = config;\n  }\n\n  getConfig(): UIConfig {\n    return this.config;\n  }\n\n  getUI(): UIContainer {\n    return this.ui;\n  }\n\n  getPlayer(): Player {\n    return this.playerWrapper.getPlayer();\n  }\n\n  /**\n   * Fires when the UI is fully configured and added to the DOM.\n   * @returns {EventDispatcher}\n   */\n  get onConfigured(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onConfigured;\n  }\n\n  /**\n   * Fires when a seek starts.\n   * @returns {EventDispatcher}\n   */\n  get onSeek(): EventDispatcher<SeekBar, NoArgs> {\n    return this.events.onSeek;\n  }\n\n  /**\n   * Fires when the seek timeline is scrubbed.\n   * @returns {EventDispatcher}\n   */\n  get onSeekPreview(): EventDispatcher<SeekBar, SeekPreviewArgs> {\n    return this.events.onSeekPreview;\n  }\n\n  /**\n   * Fires when a seek is finished.\n   * @returns {EventDispatcher}\n   */\n  get onSeeked(): EventDispatcher<SeekBar, NoArgs> {\n    return this.events.onSeeked;\n  }\n\n  /**\n   * Fires when a component is showing.\n   * @returns {EventDispatcher}\n   */\n  get onComponentShow(): EventDispatcher<Component<ComponentConfig>, NoArgs> {\n    return this.events.onComponentShow;\n  }\n\n  /**\n   * Fires when a component is hiding.\n   * @returns {EventDispatcher}\n   */\n  get onComponentHide(): EventDispatcher<Component<ComponentConfig>, NoArgs> {\n    return this.events.onComponentHide;\n  }\n\n  /**\n   * Fires when the UI controls are showing.\n   * @returns {EventDispatcher}\n   */\n  get onControlsShow(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onControlsShow;\n  }\n\n  /**\n   * Fires before the UI controls are hiding to check if they are allowed to hide.\n   * @returns {EventDispatcher}\n   */\n  get onPreviewControlsHide(): EventDispatcher<UIContainer, CancelEventArgs> {\n    return this.events.onPreviewControlsHide;\n  }\n\n  /**\n   * Fires when the UI controls are hiding.\n   * @returns {EventDispatcher}\n   */\n  get onControlsHide(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onControlsHide;\n  }\n\n  protected clearEventHandlers(): void {\n    this.playerWrapper.clearEventHandlers();\n\n    let events = <any>this.events; // avoid TS7017\n    for (let event in events) {\n      let dispatcher = <EventDispatcher<Object, Object>>events[event];\n      dispatcher.unsubscribeAll();\n    }\n  }\n}\n\n/**\n * Extends the {@link UIInstanceManager} for internal use in the {@link UIManager} and provides access to functionality\n * that components receiving a reference to the {@link UIInstanceManager} should not have access to.\n */\nclass InternalUIInstanceManager extends UIInstanceManager {\n\n  private configured: boolean;\n  private released: boolean;\n\n  getWrappedPlayer(): WrappedPlayer {\n    // TODO find a non-hacky way to provide the WrappedPlayer to the UIManager without exporting it\n    // getPlayer() actually returns the WrappedPlayer but its return type is set to Player so the WrappedPlayer does\n    // not need to be exported\n    return <WrappedPlayer>this.getPlayer();\n  }\n\n  configureControls(): void {\n    this.configureControlsTree(this.getUI());\n    this.configured = true;\n  }\n\n  isConfigured(): boolean {\n    return this.configured;\n  }\n\n  private configureControlsTree(component: Component<ComponentConfig>) {\n    let configuredComponents: Component<ComponentConfig>[] = [];\n\n    UIUtils.traverseTree(component, (component) => {\n      // First, check if we have already configured a component, and throw an error if we did. Multiple configuration\n      // of the same component leads to unexpected UI behavior. Also, a component that is in the UI tree multiple\n      // times hints at a wrong UI structure.\n      // We could just skip configuration in such a case and not throw an exception, but enforcing a clean UI tree\n      // seems like the better choice.\n      for (let configuredComponent of configuredComponents) {\n        if (configuredComponent === component) {\n          // Write the component to the console to simplify identification of the culprit\n          // (e.g. by inspecting the config)\n          if (console) {\n            console.error('Circular reference in UI tree', component);\n          }\n\n          // Additionally throw an error, because this case must not happen and leads to unexpected UI behavior.\n          throw Error('Circular reference in UI tree: ' + component.constructor.name);\n        }\n      }\n\n      component.initialize();\n      component.configure(this.getPlayer(), this);\n      configuredComponents.push(component);\n    });\n  }\n\n  releaseControls(): void {\n    // Do not call release methods if the components have never been configured; this can result in exceptions\n    if (this.configured) {\n      this.releaseControlsTree(this.getUI());\n      this.configured = false;\n    }\n    this.released = true;\n  }\n\n  isReleased(): boolean {\n    return this.released;\n  }\n\n  private releaseControlsTree(component: Component<ComponentConfig>) {\n    component.release();\n\n    if (component instanceof Container) {\n      for (let childComponent of component.getComponents()) {\n        this.releaseControlsTree(childComponent);\n      }\n    }\n  }\n\n  clearEventHandlers(): void {\n    super.clearEventHandlers();\n  }\n}\n\n/**\n * Extended interface of the {@link Player} for use in the UI.\n */\ninterface WrappedPlayer extends Player {\n  /**\n   * Fires an event on the player that targets all handlers in the UI but never enters the real player.\n   * @param event the event to fire\n   * @param data data to send with the event\n   */\n  fireEventInUI(event: EVENT, data: {}): void;\n}\n\n/**\n * Wraps the player to track event handlers and provide a simple method to remove all registered event\n * handlers from the player.\n */\nclass PlayerWrapper {\n\n  private player: Player;\n  private wrapper: WrappedPlayer;\n\n  private eventHandlers: { [eventType: string]: PlayerEventCallback[]; } = {};\n\n  constructor(player: Player) {\n    this.player = player;\n\n    // Collect all public API methods of the player\n    let methods = <any[]>[];\n    for (let member in player) {\n      if (typeof (<any>player)[member] === 'function') {\n        methods.push(member);\n      }\n    }\n\n    // Create wrapper object and add function wrappers for all API methods that do nothing but calling the base method\n    // on the player\n    let wrapper = <any>{};\n    for (let member of methods) {\n      wrapper[member] = function () {\n        // console.log('called ' + member); // track method calls on the player\n        return (<any>player)[member].apply(player, arguments);\n      };\n    }\n\n    // Collect all public properties of the player and add it to the wrapper\n    for (let member in player) {\n      if (typeof (<any>player)[member] !== 'function') {\n        wrapper[member] = (<any>player)[member];\n      }\n    }\n\n    // Explicitly add a wrapper method for 'addEventHandler' that adds added event handlers to the event list\n    wrapper.addEventHandler = (eventType: EVENT, callback: PlayerEventCallback) => {\n      player.addEventHandler(eventType, callback);\n\n      if (!this.eventHandlers[eventType]) {\n        this.eventHandlers[eventType] = [];\n      }\n\n      this.eventHandlers[eventType].push(callback);\n\n      return wrapper;\n    };\n\n    // Explicitly add a wrapper method for 'removeEventHandler' that removes removed event handlers from the event list\n    wrapper.removeEventHandler = (eventType: EVENT, callback: PlayerEventCallback) => {\n      player.removeEventHandler(eventType, callback);\n\n      if (this.eventHandlers[eventType]) {\n        ArrayUtils.remove(this.eventHandlers[eventType], callback);\n      }\n\n      return wrapper;\n    };\n\n    wrapper.fireEventInUI = (event: EVENT, data: {}) => {\n      if (this.eventHandlers[event]) { // check if there are handlers for this event registered\n        // Extend the data object with default values to convert it to a {@link PlayerEvent} object.\n        let playerEventData = <PlayerEvent>Object.assign({}, {\n          timestamp: Date.now(),\n          type: event,\n          // Add a marker property so the UI can detect UI-internal player events\n          uiSourced: true,\n        }, data);\n\n        // Execute the registered callbacks\n        for (let callback of this.eventHandlers[event]) {\n          callback(playerEventData);\n        }\n      }\n    };\n\n    this.wrapper = <WrappedPlayer>wrapper;\n  }\n\n  /**\n   * Returns a wrapped player object that can be used on place of the normal player object.\n   * @returns {WrappedPlayer} a wrapped player\n   */\n  getPlayer(): WrappedPlayer {\n    return this.wrapper;\n  }\n\n  /**\n   * Clears all registered event handlers from the player that were added through the wrapped player.\n   */\n  clearEventHandlers(): void {\n    for (let eventType in this.eventHandlers) {\n      for (let callback of this.eventHandlers[eventType]) {\n        this.player.removeEventHandler(eventType, callback);\n      }\n    }\n  }\n}\n","import {EventDispatcher, Event, NoArgs} from './eventdispatcher';\nimport {Component, ComponentConfig} from './components/component';\nimport {Container} from './components/container';\n\nexport namespace ArrayUtils {\n  /**\n   * Removes an item from an array.\n   * @param array the array that may contain the item to remove\n   * @param item the item to remove from the array\n   * @returns {any} the removed item or null if it wasn't part of the array\n   */\n  export function remove<T>(array: T[], item: T): T | null {\n    let index = array.indexOf(item);\n\n    if (index > -1) {\n      return array.splice(index, 1)[0];\n    } else {\n      return null;\n    }\n  }\n}\n\nexport namespace StringUtils {\n\n  export let FORMAT_HHMMSS: string = 'hh:mm:ss';\n  export let FORMAT_MMSS: string = 'mm:ss';\n\n  /**\n   * Formats a number of seconds into a time string with the pattern hh:mm:ss.\n   *\n   * @param totalSeconds the total number of seconds to format to string\n   * @param format the time format to output (default: hh:mm:ss)\n   * @returns {string} the formatted time string\n   */\n  export function secondsToTime(totalSeconds: number, format: string = FORMAT_HHMMSS): string {\n    let isNegative = totalSeconds < 0;\n\n    if (isNegative) {\n      // If the time is negative, we make it positive for the calculation below\n      // (else we'd get all negative numbers) and reattach the negative sign later.\n      totalSeconds = -totalSeconds;\n    }\n\n    // Split into separate time parts\n    let hours = Math.floor(totalSeconds / 3600);\n    let minutes = Math.floor(totalSeconds / 60) - hours * 60;\n    let seconds = Math.floor(totalSeconds) % 60;\n\n    return (isNegative ? '-' : '') + format\n        .replace('hh', leftPadWithZeros(hours, 2))\n        .replace('mm', leftPadWithZeros(minutes, 2))\n        .replace('ss', leftPadWithZeros(seconds, 2));\n  }\n\n  /**\n   * Converts a number to a string and left-pads it with zeros to the specified length.\n   * Example: leftPadWithZeros(123, 5) => '00123'\n   *\n   * @param num the number to convert to string and pad with zeros\n   * @param length the desired length of the padded string\n   * @returns {string} the padded number as string\n   */\n  function leftPadWithZeros(num: number | string, length: number): string {\n    let text = num + '';\n    let padding = '0000000000'.substr(0, length - text.length);\n    return padding + text;\n  }\n\n  /**\n   * Fills out placeholders in an ad message.\n   *\n   * Has the placeholders '{remainingTime[formatString]}', '{playedTime[formatString]}' and\n   * '{adDuration[formatString]}', which are replaced by the remaining time until the ad can be skipped, the current\n   * time or the ad duration. The format string is optional. If not specified, the placeholder is replaced by the time\n   * in seconds. If specified, it must be of the following format:\n   * - %d - Inserts the time as an integer.\n   * - %0Nd - Inserts the time as an integer with leading zeroes, if the length of the time string is smaller than N.\n   * - %f - Inserts the time as a float.\n   * - %0Nf - Inserts the time as a float with leading zeroes.\n   * - %.Mf - Inserts the time as a float with M decimal places. Can be combined with %0Nf, e.g. %04.2f (the time\n   * 10.123\n   * would be printed as 0010.12).\n   * - %hh:mm:ss\n   * - %mm:ss\n   *\n   * @param adMessage an ad message with optional placeholders to fill\n   * @param skipOffset if specified, {remainingTime} will be filled with the remaining time until the ad can be skipped\n   * @param player the player to get the time data from\n   * @returns {string} the ad message with filled placeholders\n   */\n  export function replaceAdMessagePlaceholders(adMessage: string, skipOffset: number, player: bitmovin.player.Player) {\n    let adMessagePlaceholderRegex = new RegExp(\n      '\\\\{(remainingTime|playedTime|adDuration)(}|%((0[1-9]\\\\d*(\\\\.\\\\d+(d|f)|d|f)|\\\\.\\\\d+f|d|f)|hh:mm:ss|mm:ss)})',\n      'g'\n    );\n\n    return adMessage.replace(adMessagePlaceholderRegex, (formatString) => {\n      let time = 0;\n      if (formatString.indexOf('remainingTime') > -1) {\n        if (skipOffset) {\n          time = Math.ceil(skipOffset - player.getCurrentTime());\n        } else {\n          time = player.getDuration() - player.getCurrentTime();\n        }\n      } else if (formatString.indexOf('playedTime') > -1) {\n        time = player.getCurrentTime();\n      } else if (formatString.indexOf('adDuration') > -1) {\n        time = player.getDuration();\n      }\n      return formatNumber(time, formatString);\n    });\n  }\n\n  function formatNumber(time: number, format: string) {\n    let formatStringValidationRegex = /%((0[1-9]\\d*(\\.\\d+(d|f)|d|f)|\\.\\d+f|d|f)|hh:mm:ss|mm:ss)/;\n    let leadingZeroesRegex = /(%0[1-9]\\d*)(?=(\\.\\d+f|f|d))/;\n    let decimalPlacesRegex = /\\.\\d*(?=f)/;\n\n    if (!formatStringValidationRegex.test(format)) {\n      // If the format is invalid, we set a default fallback format\n      format = '%d';\n    }\n\n    // Determine the number of leading zeros\n    let leadingZeroes = 0;\n    let leadingZeroesMatches = format.match(leadingZeroesRegex);\n    if (leadingZeroesMatches) {\n      leadingZeroes = parseInt(leadingZeroesMatches[0].substring(2));\n    }\n\n    // Determine the number of decimal places\n    let numDecimalPlaces = null;\n    let decimalPlacesMatches = format.match(decimalPlacesRegex);\n    if (decimalPlacesMatches && !isNaN(parseInt(decimalPlacesMatches[0].substring(1)))) {\n      numDecimalPlaces = parseInt(decimalPlacesMatches[0].substring(1));\n      if (numDecimalPlaces > 20) {\n        numDecimalPlaces = 20;\n      }\n    }\n\n    // Float format\n    if (format.indexOf('f') > -1) {\n      let timeString = '';\n\n      if (numDecimalPlaces !== null) {\n        // Apply fixed number of decimal places\n        timeString = time.toFixed(numDecimalPlaces);\n      } else {\n        timeString = '' + time;\n      }\n\n      // Apply leading zeros\n      if (timeString.indexOf('.') > -1) {\n        return leftPadWithZeros(timeString, timeString.length + (leadingZeroes - timeString.indexOf('.')));\n      } else {\n        return leftPadWithZeros(timeString, leadingZeroes);\n      }\n\n    }\n    // Time format\n    else if (format.indexOf(':') > -1) {\n      let totalSeconds = Math.ceil(time);\n\n      // hh:mm:ss format\n      if (format.indexOf('hh') > -1) {\n        return secondsToTime(totalSeconds);\n      }\n      // mm:ss format\n      else {\n        let minutes = Math.floor(totalSeconds / 60);\n        let seconds = totalSeconds % 60;\n\n        return leftPadWithZeros(minutes, 2) + ':' + leftPadWithZeros(seconds, 2);\n      }\n    }\n    // Integer format\n    else {\n      return leftPadWithZeros(Math.ceil(time), leadingZeroes);\n    }\n  }\n}\n\nexport namespace PlayerUtils {\n\n  import Player = bitmovin.player.Player;\n\n  export enum PlayerState {\n    IDLE,\n    PREPARED,\n    PLAYING,\n    PAUSED,\n    FINISHED,\n  }\n\n  export function isSourceLoaded(player: Player): boolean {\n    return player.getConfig().source !== undefined;\n  }\n\n  export function isTimeShiftAvailable(player: Player): boolean {\n    return player.isLive() && player.getMaxTimeShift() !== 0;\n  }\n\n  export function getState(player: Player): PlayerState {\n    if (player.hasEnded()) {\n      return PlayerState.FINISHED;\n    } else if (player.isPlaying()) {\n      return PlayerState.PLAYING;\n    } else if (player.isPaused()) {\n      return PlayerState.PAUSED;\n    } else if (isSourceLoaded(player)) {\n      return PlayerState.PREPARED;\n    } else {\n      return PlayerState.IDLE;\n    }\n  }\n\n  export interface TimeShiftAvailabilityChangedArgs extends NoArgs {\n    timeShiftAvailable: boolean;\n  }\n\n  export class TimeShiftAvailabilityDetector {\n\n    private timeShiftAvailabilityChangedEvent = new EventDispatcher<Player, TimeShiftAvailabilityChangedArgs>();\n\n    constructor(player: Player) {\n      let timeShiftAvailable: boolean = undefined;\n\n      let timeShiftDetector = () => {\n        if (player.isLive()) {\n          let timeShiftAvailableNow = PlayerUtils.isTimeShiftAvailable(player);\n\n          // When the availability changes, we fire the event\n          if (timeShiftAvailableNow !== timeShiftAvailable) {\n            this.timeShiftAvailabilityChangedEvent.dispatch(player, { timeShiftAvailable: timeShiftAvailableNow });\n            timeShiftAvailable = timeShiftAvailableNow;\n          }\n        }\n      };\n      // Try to detect timeshift availability in ON_READY, which works for DASH streams\n      player.addEventHandler(player.EVENT.ON_READY, timeShiftDetector);\n      // With HLS/NativePlayer streams, getMaxTimeShift can be 0 before the buffer fills, so we need to additionally\n      // check timeshift availability in ON_TIME_CHANGED\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, timeShiftDetector);\n    }\n\n    get onTimeShiftAvailabilityChanged(): Event<Player, TimeShiftAvailabilityChangedArgs> {\n      return this.timeShiftAvailabilityChangedEvent.getEvent();\n    }\n  }\n\n  export interface LiveStreamDetectorEventArgs extends NoArgs {\n    live: boolean;\n  }\n\n  /**\n   * Detects changes of the stream type, i.e. changes of the return value of the player#isLive method.\n   * Normally, a stream cannot change its type during playback, it's either VOD or live. Due to bugs on some\n   * platforms or browsers, it can still change. It is therefore unreliable to just check #isLive and this detector\n   * should be used as a workaround instead.\n   *\n   * Known cases:\n   *\n   * - HLS VOD on Android 4.3\n   * Video duration is initially 'Infinity' and only gets available after playback starts, so streams are wrongly\n   * reported as 'live' before playback (the live-check in the player checks for infinite duration).\n   */\n  export class LiveStreamDetector {\n\n    private liveChangedEvent = new EventDispatcher<Player, LiveStreamDetectorEventArgs>();\n\n    constructor(player: Player) {\n      let live: boolean = undefined;\n\n      let liveDetector = () => {\n        let liveNow = player.isLive();\n\n        // Compare current to previous live state flag and fire event when it changes. Since we initialize the flag\n        // with undefined, there is always at least an initial event fired that tells listeners the live state.\n        if (liveNow !== live) {\n          this.liveChangedEvent.dispatch(player, { live: liveNow });\n          live = liveNow;\n        }\n      };\n      // Initialize when player is ready\n      player.addEventHandler(player.EVENT.ON_READY, liveDetector);\n      // Re-evaluate when playback starts\n      player.addEventHandler(player.EVENT.ON_PLAY, liveDetector);\n\n      // HLS live detection workaround for Android:\n      // Also re-evaluate during playback, because that is when the live flag might change.\n      // (Doing it only in Android Chrome saves unnecessary overhead on other plattforms)\n      if (BrowserUtils.isAndroid && BrowserUtils.isChrome) {\n        player.addEventHandler(player.EVENT.ON_TIME_CHANGED, liveDetector);\n      }\n    }\n\n    get onLiveChanged(): Event<Player, LiveStreamDetectorEventArgs> {\n      return this.liveChangedEvent.getEvent();\n    }\n  }\n}\n\nexport namespace UIUtils {\n  export interface TreeTraversalCallback {\n    (component: Component<ComponentConfig>, parent?: Component<ComponentConfig>): void;\n  }\n\n  export function traverseTree(component: Component<ComponentConfig>, visit: TreeTraversalCallback): void {\n    let recursiveTreeWalker = (component: Component<ComponentConfig>, parent?: Component<ComponentConfig>) => {\n      visit(component, parent);\n\n      // If the current component is a container, visit it's children\n      if (component instanceof Container) {\n        for (let childComponent of component.getComponents()) {\n          recursiveTreeWalker(childComponent, component);\n        }\n      }\n    };\n\n    // Walk and configure the component tree\n    recursiveTreeWalker(component);\n  }\n}\n\nexport namespace BrowserUtils {\n\n  // isMobile only needs to be evaluated once (it cannot change during a browser session)\n  // Mobile detection according to Mozilla recommendation: \"In summary, we recommend looking for the string Mobi\n  // anywhere in the User Agent to detect a mobile device.\"\n  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent\n  export const isMobile = navigator && navigator.userAgent && /Mobi/.test(navigator.userAgent);\n\n  export const isChrome = navigator && navigator.userAgent && /Chrome/.test(navigator.userAgent);\n\n  export const isAndroid = navigator && navigator.userAgent && /Android/.test(navigator.userAgent);\n}"]}