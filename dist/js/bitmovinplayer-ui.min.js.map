{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/ts/components/adclickoverlay.ts","src/ts/components/admessagelabel.ts","src/ts/components/adskipbutton.ts","src/ts/components/airplaytogglebutton.ts","src/ts/components/audioqualityselectbox.ts","src/ts/components/audiotrackselectbox.ts","src/ts/components/bufferingoverlay.ts","src/ts/components/button.ts","src/ts/components/caststatusoverlay.ts","src/ts/components/casttogglebutton.ts","src/ts/components/castuicontainer.ts","src/ts/components/clickoverlay.ts","src/ts/components/closebutton.ts","src/ts/components/component.ts","src/ts/components/container.ts","src/ts/components/controlbar.ts","src/ts/components/errormessageoverlay.ts","src/ts/components/fullscreentogglebutton.ts","src/ts/components/hugeplaybacktogglebutton.ts","src/ts/components/hugereplaybutton.ts","src/ts/components/label.ts","src/ts/components/listselector.ts","src/ts/components/metadatalabel.ts","src/ts/components/pictureinpicturetogglebutton.ts","src/ts/components/playbackspeedselectbox.ts","src/ts/components/playbacktimelabel.ts","src/ts/components/playbacktogglebutton.ts","src/ts/components/playbacktoggleoverlay.ts","src/ts/components/recommendationoverlay.ts","src/ts/components/seekbar.ts","src/ts/components/seekbarlabel.ts","src/ts/components/selectbox.ts","src/ts/components/settingspanel.ts","src/ts/components/settingstogglebutton.ts","src/ts/components/spacer.ts","src/ts/components/subtitleoverlay.ts","src/ts/components/subtitleselectbox.ts","src/ts/components/titlebar.ts","src/ts/components/togglebutton.ts","src/ts/components/tvnoisecanvas.ts","src/ts/components/uicontainer.ts","src/ts/components/videoqualityselectbox.ts","src/ts/components/volumecontrolbutton.ts","src/ts/components/volumeslider.ts","src/ts/components/volumetogglebutton.ts","src/ts/components/vrtogglebutton.ts","src/ts/components/watermark.ts","src/ts/dom.ts","src/ts/eventdispatcher.ts","src/ts/guid.ts","src/ts/main.ts","src/ts/timeout.ts","src/ts/uimanager.ts","src/ts/utils.ts"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","clickoverlay_1","AdClickOverlay","_super","__extends","prototype","configure","player","uimanager","_this","this","clickThroughUrl","clickThroughEnabled","getConfig","advertising","hasOwnProperty","addEventHandler","EVENT","ON_AD_STARTED","event","setUrl","adFinishedHandler","ON_AD_FINISHED","ON_AD_SKIPPED","ON_AD_ERROR","onClick","subscribe","pause","fireEvent","ON_AD_CLICKED","ClickOverlay","label_1","utils_1","AdMessageLabel","config","mergeConfig","cssClass","text","updateMessageHandler","setText","StringUtils","replaceAdMessagePlaceholders","adStartHandler","adMessage","ON_TIME_CHANGED","ON_CAST_TIME_UPDATED","adEndHandler","removeEventHandler","Label","button_1","AdSkipButton","skipMessage","countdown","skip","adEvent","updateSkipMessageHandler","skipOffset","show","hide","getCurrentTime","skipAd","Button","togglebutton_1","AirPlayToggleButton","isAirplayAvailable","showAirplayTargetPicker","console","log","airPlayAvailableHandler","ON_AIRPLAY_AVAILABLE","ToggleButton","selectbox_1","AudioQualitySelectBox","updateAudioQualities","audioQualities","getAvailableAudioQualities","clearItems","addItem","_i","audioQualities_1","audioQuality","id","label","onItemSelected","sender","value","setAudioQuality","ON_AUDIO_CHANGED","ON_SOURCE_UNLOADED","ON_READY","ON_AUDIO_DOWNLOAD_QUALITY_CHANGE","data","getDownloadedAudioData","selectItem","isAuto","SelectBox","AudioTrackSelectBox","updateAudioTracks","audioTracks","getAvailableAudio","audioTracks_1","audioTrack","setAudio","audioTrackHandler","currentAudioTrack","getAudio","container_1","component_1","timeout_1","BufferingOverlay","indicators","Component","tag","hidden","components","showDelayMs","overlayShowTimeout","Timeout","showOverlay","start","hideOverlay","clear","ON_STALL_STARTED","ON_STALL_ENDED","isStalled","Container","dom_1","eventdispatcher_1","buttonEvents","EventDispatcher","toDomElement","buttonElement","DOM","type","class","getCssClasses","append","prefixCss","html","on","onClickEvent","getDomElement","find","dispatch","Object","defineProperty","getEvent","CastStatusOverlay","statusLabel","ON_CAST_WAITING_FOR_DEVICE","castDeviceName","castPayload","deviceName","ON_CAST_STARTED","ON_CAST_STOPPED","CastToggleButton","isCastAvailable","isCasting","castStop","castVideo","castAvailableHander","ON_CAST_AVAILABLE","off","uicontainer_1","CastUIContainer","isUiShown","hideUi","onControlsHide","castUiHideTimeout","hideDelay","showUi","onControlsShow","showUiPermanently","showUiWithTimeout","showUiAfterSeek","isPlaying","ON_SOURCE_LOADED","ON_PLAY","ON_PAUSED","ON_SEEK","ON_SEEKED","release","UIContainer","initialize","url","element","window","open","getUrl","undefined","CloseButton","target","guid_1","componentEvents","onShow","onHide","onHoverChanged","Guid","next","cssPrefix","cssClasses","isHidden","onComponentShow","onComponentHide","onHoverChangedEvent","defaults","base","assign","flattenedArray","concat","map","css","join","trim","cssClassOrId","addClass","CLASS_HIDDEN","onHideEvent","removeClass","onShowEvent","isShown","toggleHidden","isHovered","hovered","addComponent","component","push","removeComponent","ArrayUtils","remove","getComponents","removeComponents","_a","updateComponents","innerContainerElement","empty","containerElement","innerContainer","spacer_1","ControlBar","hoverStackCount","UIUtils","traverseTree","Spacer","args","onPreviewControlsHide","cancel","tvnoisecanvas_1","ErrorMessageOverlay","errorLabel","tvNoiseBackground","TvNoiseCanvas","ON_ERROR","message","messages","customMessage","stop","FullscreenToggleButton","fullscreenStateHandler","isFullscreen","ON_FULLSCREEN_ENTER","ON_FULLSCREEN_EXIT","exitFullscreen","enterFullscreen","playbacktogglebutton_1","HugePlaybackToggleButton","togglePlayback","play","toggleFullscreen","firstPlay","clickTime","doubleClickTime","now","Date","setTimeout","castInitializationHandler","ON_CAST_START","PlaybackToggleButton","HugeReplayButton","labelEvents","onTextChanged","labelElement","onTextChangedEvent","getText","clearText","isEmpty","ListSelector","listSelectorEvents","onItemAdded","onItemRemoved","items","getItemIndex","key","index","parseInt","hasItem","removeItem","onItemAddedEvent","onItemRemovedEvent","selectedItem","onItemSelectedEvent","getSelectedItem","items_1","item","itemCount","keys","MetadataLabelContent","MetadataLabel","content","toLowerCase","uiconfig","init","Title","metadata","title","source","Description","description","unload","PictureInPictureToggleButton","isPictureInPictureAvailable","isPictureInPicture","exitPictureInPicture","enterPictureInPicture","pipAvailableHander","ON_PICTURE_IN_PICTURE_ENTER","ON_PICTURE_IN_PICTURE_EXIT","PlaybackSpeedSelectBox","setPlaybackSpeed","parseFloat","PlaybackTimeLabelMode","PlaybackTimeLabel","timeLabelMode","CurrentAndTotalTime","hideInLivePlayback","live","liveCssClass","liveEdgeCssClass","minWidth","liveClickHandler","timeShift","updateLiveState","isLive","updateLiveTimeshiftState","unsubscribe","PlayerUtils","LiveStreamDetector","onLiveChanged","getTimeShift","playbackTimeHandler","getDuration","Infinity","setTime","width","min-width","ON_TIME_SHIFT","ON_TIME_SHIFTED","timeFormat","Math","abs","getMaxTimeShift","FORMAT_HHMMSS","FORMAT_MMSS","playbackSeconds","durationSeconds","currentTime","secondsToTime","totalTime","CurrentTime","TotalTime","handleClickEvent","isSeeking","playbackStateHandler","ON_PLAYBACK_FINISHED","ON_CAST_PLAYING","ON_CAST_PAUSED","ON_CAST_PLAYBACK_FINISHED","TimeShiftAvailabilityDetector","onTimeShiftAvailabilityChanged","timeShiftAvailable","CLASS_STOPTOGGLE","onSeek","onSeeked","hugeplaybacktogglebutton_1","PlaybackToggleOverlay","playbackToggleButton","hugereplaybutton_1","RecommendationOverlay","replayButton","clearRecommendations","RecommendationItem","setupRecommendations","hasRecommendationsInUiConfig","recommendations","hasRecommendationsInPlayerConfig","recommendations_1","itemConfig","isAd","itemElement","href","background-image","thumbnail","bgElement","titleElement","timeElement","duration","SeekBar","playbackPositionPercentage","touchSupported","seekBarEvents","onSeekPreview","vertical","smoothPlaybackPositionUpdateIntervalMs","timelineMarkers","hasLabel","getLabel","configureSeek","playbackNotInitialized","playbackPositionHandler","forceUpdate","setPlaybackPosition","setBufferPosition","videoBufferLength","getVideoBufferLength","audioBufferLength","getAudioBufferLength","bufferLength","min","Number","MAX_VALUE","bufferPercentage","SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED","isPaused","ON_SEGMENT_REQUEST_FINISHED","setSeeking","seek","percentage","subscribeRateLimited","scrubbing","position","hasTimeShift","switchVisibility","refreshPlaybackPosition","ON_PLAYER_RESIZE","onConfigured","setSeekPosition","configureSmoothPlaybackPositionUpdater","configureMarkers","currentTimeSeekBar","currentTimePlayer","smoothPlaybackPositionUpdater","updateIntervalMs","currentTimeDelta","startSmoothPlaybackPositionUpdater","stopSmoothPlaybackPositionUpdater","clearMarkers","updateMarkers","setupMarkers","hasMarkersInUiConfig","markers","hasMarkersInPlayerConfig","markers_1","marker","time","markerType","comment","avatar","number","seekBarContainer","seekBar","seekBarBufferLevel","seekBarBufferPosition","seekBarPlaybackPosition","seekBarPlaybackPositionMarker","seekBarSeekPosition","seekBarBackdrop","seekBarChapterMarkersContainer","seekBarMarkersContainer","seeking","mouseTouchMoveHandler","preventDefault","stopPropagation","targetPercentage","getOffset","onSeekPreviewEvent","mouseTouchUpHandler","document","snappedChapter","getMarkerAtPosition","onSeekedEvent","isTouchEvent","TouchEvent","onSeekEvent","className","markerDom","data-marker-time","String","data-marker-title","snappedMarker","getHorizontalOffset","eventPageX","elementOffsetPx","offset","left","widthPx","offsetPx","sanitizeOffset","getVerticalOffset","eventPageY","top","height","changedTouches","pageY","touches","pageX","MouseEvent","warn","percent","setPosition","px","style","transform","-ms-transform","scale","CLASS_SEEKING","hasClass","SeekBarLabel","timeLabel","titleLabel","commentLabel","numberLabel","avatarLabel","setTitleText","setSmashcutData","setThumbnail","setBackground","getThumb","seconds","thumbnailElement","display","w","h","background-position","x","y","onOff","metadataElement","background","listselector_1","selectElement","updateDomItems","val","selectedValue","optionElement","attr","videoqualityselectbox_1","audioqualityselectbox_1","SettingsPanel","settingsPanelEvents","onSettingsStateChanged","hideTimeout","reset","settingsStateChangedHandler","onSettingsStateChangedEvent","lastShownItem","getItems","SettingsPanelItem","CLASS_LAST","onActiveChanged","hasActiveSettings","isActive","selectBox","settingsPanelItemEvents","setting","handleConfigItemChanged","minItemsToDisplay","VideoQualitySelectBox","onActiveChangedEvent","SettingsToggleButton","settingsPanel","autoHideWhenNoActiveSettings","settingsPanelItemsChangedHandler","controlbar_1","SubtitleOverlay","subtitleManager","ActiveSubtitleManager","ON_CUE_ENTER","labelToAdd","cueEnter","ON_CUE_EXIT","labelToRemove","cueExit","hasCues","subtitleClearHandler","ON_SUBTITLE_CHANGED","CLASS_CONTROLBAR_VISIBLE","SubtitleLabel","activeSubtitleCueMap","calculateId","activeSubtitleCue","cueCount","SubtitleSelectBox","updateSubtitles","getAvailableSubtitles","subtitle","setSubtitle","ON_SUBTITLE_ADDED","targetSubtitle","ON_SUBTITLE_REMOVED","subtitleId","metadatalabel_1","TitleBar","keepHiddenWithoutMetadata","shouldBeShown","hasMetadataText","checkMetadataTextAndUpdateVisibility","toggleButtonEvents","onToggle","onToggleOn","onToggleOff","isOff","onState","CLASS_OFF","CLASS_ON","onToggleEvent","onToggleOnEvent","isOn","onToggleOffEvent","toggle","canvasWidth","canvasHeight","interferenceHeight","lastFrameUpdate","frameInterval","useAnimationFrame","requestAnimationFrame","canvas","canvasElement","getElements","canvasContext","getContext","noiseAnimationWindowPos","renderFrame","cancelAnimationFrame","frameUpdateHandlerId","clearTimeout","getTime","scheduleNextRender","currentPixelOffset","noiseImage","createImageData","random","putImageData","bind","configureUIShowHide","configurePlayerStates","container","isFirstTouch","uiHideTimeout","previewHideEventArgs","stateClassNames","state","PlayerState","isNaN","enumName","STATE_PREFIX","removeStates","IDLE","PREPARED","PLAYING","PAUSED","FINISHED","getState","FULLSCREEN","BUFFERING","REMOTE_CONTROL","CONTROLS_HIDDEN","CONTROLS_SHOWN","updateLayoutSizeClasses","round","substring","getFigure","createElement","flex","updateVideoQualities","videoQualities","getAvailableVideoQualities","videoQualities_1","videoQuality","setVideoQuality","ON_VIDEO_DOWNLOAD_QUALITY_CHANGE","getDownloadedVideoData","volumeslider_1","volumetogglebutton_1","VolumeControlButton","volumeToggleButton","VolumeToggleButton","volumeSlider","VolumeSlider","getVolumeToggleButton","getVolumeSlider","volumeSliderHideTimeout","volumeSliderHovered","seekbar_1","hideIfVolumeControlProhibited","detectVolumeControlAvailability","volumeChangeHandler","isMuted","getVolume","ON_VOLUME_CHANGED","ON_MUTED","ON_UNMUTED","setVolume","volume","muted","playing","mute","muteStateHandler","volumeLevelHandler","unmute","VRToggleButton","isVRConfigured","vr","contentType","isVRStereoAvailable","getVRStatus","vrStateHandler","isStereo","vrButtonVisibilityHandler","ON_VR_MODE_CHANGED","ON_VR_STEREO_CHANGED","ON_VR_ERROR","setVRStereo","Watermark","something","attributes","Array","HTMLElement","elements","Document","tagName","attributeName","attributeValue","setAttribute","selector","findChildElements","forEach","handler","findChildElementsOfElement","childElements","querySelectorAll","slice","allChildElements","arguments","setHtml","getHtml","innerHTML","HTMLSelectElement","HTMLInputElement","attribute","setAttr","getAttr","getAttribute","dataAttribute","setData","getData","childElement","_","appendChild","parent","parentNode","removeChild","elementRect","getBoundingClientRect","htmlRect","body","parentElement","offsetWidth","offsetHeight","eventName","eventHandler","split","addEventListener","removeEventListener","classList","add","replace","RegExp","contains","test","propertyNameOrCollection","propertyName","setCss","getCss","propertyValueCollection","setCssCollection","getComputedStyle","ruleValueCollection","listeners","listener","EventListenerWrapper","subscribeOnce","rateMs","RateLimitedEventListenerWrapper","subscribedListener","unsubscribeAll","listenersToRemove","fire","isOnce","_b","listenersToRemove_1","listenerToRemove","once","eventListener","lastFireTime","rateLimitingEventListener","fireSuper","guid","uimanager_1","fullscreentogglebutton_1","playbacktimelabel_1","settingspanel_1","settingstogglebutton_1","vrtogglebutton_1","watermark_1","audiotrackselectbox_1","caststatusoverlay_1","casttogglebutton_1","errormessageoverlay_1","recommendationoverlay_1","seekbarlabel_1","subtitleoverlay_1","subtitleselectbox_1","titlebar_1","volumecontrolbutton_1","adskipbutton_1","admessagelabel_1","adclickoverlay_1","playbackspeedselectbox_1","bufferingoverlay_1","castuicontainer_1","playbacktoggleoverlay_1","closebutton_1","airplaytogglebutton_1","pictureinpicturetogglebutton_1","TypeError","bitmovin","playerui","UIManager","UIInstanceManager","BrowserUtils","delay","callback","repeat","timeoutHandle","lastScheduleTime","delayAdjust","internalCallback","delta","playerUiOrUiVariants","playerUi","uiVariants","ui","managerPlayerWrapper","PlayerWrapper","playerElement","uiInstanceManagers","uiVariantsWithoutCondition","uiVariant","condition","InternalUIInstanceManager","adStartedEvent","isMobile","resolveUiVariant","ad","adWithUI","clientType","context","isAdWithUI","documentWidth","clientWidth","nextUi","uiVariantChanged","indexOf","currentUi","getUI","isConfigured","addUi","getWrappedPlayer","fireEventInUI","getPlayer","dom","configureControls","releaseUi","releaseControls","clearEventHandlers","uiInstanceManager","Factory","buildDefaultUI","buildModernUI","buildDefaultSmallScreenUI","buildModernSmallScreenUI","buildDefaultCastReceiverUI","buildModernCastReceiverUI","smashcutUi","controlBarTop","controlBarMiddle","controlBarBottom","controlBar","modernAdsUI","modernSmallScreenUI","modernSmallScreenAdsUI","modernCastReceiverUI","legacyUI","legacyAdsUI","legacyCastReceiverUI","legacyTestUI","buildLegacyUI","buildLegacyCastReceiverUI","buildLegacyTestUI","events","playerWrapper","event_1","configureControlsTree","configured","configuredComponents","configuredComponents_1","error","constructor","name","releaseControlsTree","released","isReleased","childComponent","eventHandlers","methods","member","wrapper","methods_1","apply","eventType","playerEventData","timestamp","uiSourced","array","splice","totalSeconds","format","isNegative","hours","floor","minutes","leftPadWithZeros","num","substr","adMessagePlaceholderRegex","formatString","ceil","formatNumber","formatStringValidationRegex","leadingZeroes","leadingZeroesMatches","match","numDecimalPlaces","decimalPlacesMatches","timeString","toFixed","isSourceLoaded","isTimeShiftAvailable","hasEnded","timeShiftAvailabilityChangedEvent","timeShiftDetector","timeShiftAvailableNow","liveChangedEvent","liveDetector","liveNow","isAndroid","isChrome","visit","recursiveTreeWalker","navigator","userAgent"],"mappings":"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","file":"bitmovinplayer-ui.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import {ClickOverlay} from './clickoverlay';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A simple click capture overlay for clickThroughUrls of ads.\n */\nexport class AdClickOverlay extends ClickOverlay {\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let clickThroughUrl = <string>null;\n    let clickThroughEnabled = !player.getConfig().advertising\n      || !player.getConfig().advertising.hasOwnProperty('clickThroughEnabled')\n      || player.getConfig().advertising.clickThroughEnabled;\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, (event: bitmovin.player.AdStartedEvent) => {\n      clickThroughUrl = event.clickThroughUrl;\n\n      if (clickThroughEnabled) {\n        this.setUrl(clickThroughUrl);\n      } else {\n        // If click-through is disabled, we set the url to null to avoid it open\n        this.setUrl(null);\n      }\n    });\n\n    // Clear click-through URL when ad has finished\n    let adFinishedHandler = () => {\n      this.setUrl(null);\n    };\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adFinishedHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adFinishedHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adFinishedHandler);\n\n    this.onClick.subscribe(() => {\n      // Pause the ad when overlay is clicked\n      player.pause('ui-content-click');\n\n      // Notify the player of the clicked ad\n      player.fireEvent(player.EVENT.ON_AD_CLICKED, {\n        clickThroughUrl: clickThroughUrl\n      });\n    });\n  }\n}","import {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {StringUtils} from '../utils';\n\n/**\n * A label that displays a message about a running ad, optionally with a countdown.\n */\nexport class AdMessageLabel extends Label<LabelConfig> {\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-label-ad-message',\n      text: 'This ad will end in {remainingTime} seconds.'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let text = this.getConfig().text;\n\n    let updateMessageHandler = () => {\n      this.setText(StringUtils.replaceAdMessagePlaceholders(text, null, player));\n    };\n\n    let adStartHandler = (event: bitmovin.player.AdStartedEvent) => {\n      text = event.adMessage || text;\n      updateMessageHandler();\n\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, updateMessageHandler);\n      player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateMessageHandler);\n    };\n\n    let adEndHandler = () => {\n      player.removeEventHandler(player.EVENT.ON_TIME_CHANGED, updateMessageHandler);\n      player.removeEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateMessageHandler);\n    };\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, adStartHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adEndHandler);\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {UIInstanceManager} from '../uimanager';\nimport SkipMessage = bitmovin.player.SkipMessage;\nimport {StringUtils} from '../utils';\n\n/**\n * Configuration interface for the {@link AdSkipButton}.\n */\nexport interface AdSkipButtonConfig extends ButtonConfig {\n  skipMessage?: SkipMessage;\n}\n\n/**\n * A button that is displayed during ads and can be used to skip the ad.\n */\nexport class AdSkipButton extends Button<AdSkipButtonConfig> {\n\n  constructor(config: AdSkipButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <AdSkipButtonConfig>{\n      cssClass: 'ui-button-ad-skip',\n      skipMessage: {\n        countdown: 'Skip ad in {remainingTime}',\n        skip: 'Skip ad'\n      }\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <AdSkipButtonConfig>this.getConfig(); // TODO get rid of generic cast\n    let skipMessage = config.skipMessage;\n    let adEvent = <bitmovin.player.AdStartedEvent>null;\n\n    let updateSkipMessageHandler = () => {\n      // Display this button only if ad is skippable\n      if (adEvent.skipOffset) {\n        this.show();\n      } else {\n        this.hide();\n      }\n\n      // Update the skip message on the button\n      if (player.getCurrentTime() < adEvent.skipOffset) {\n        this.setText(\n          StringUtils.replaceAdMessagePlaceholders(config.skipMessage.countdown, adEvent.skipOffset, player));\n      } else {\n        this.setText(config.skipMessage.skip);\n      }\n    };\n\n    let adStartHandler = (event: bitmovin.player.AdStartedEvent) => {\n      adEvent = event;\n      skipMessage = adEvent.skipMessage || skipMessage;\n      updateSkipMessageHandler();\n\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, updateSkipMessageHandler);\n      player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateSkipMessageHandler);\n    };\n\n    let adEndHandler = () => {\n      player.removeEventHandler(player.EVENT.ON_TIME_CHANGED, updateSkipMessageHandler);\n      player.removeEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateSkipMessageHandler);\n    };\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, adStartHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adEndHandler);\n\n    this.onClick.subscribe(() => {\n      // Try to skip the ad (this only works if it is skippable so we don't need to take extra care of that here)\n      player.skipAd();\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles Apple AirPlay.\n */\nexport class AirPlayToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-airplaytogglebutton',\n      text: 'Apple AirPlay'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      if (player.isAirplayAvailable()) {\n        player.showAirplayTargetPicker();\n      } else {\n        if (console) {\n          console.log('AirPlay unavailable');\n        }\n      }\n    });\n\n    let airPlayAvailableHandler = () => {\n      if (player.isAirplayAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_AIRPLAY_AVAILABLE, airPlayAvailableHandler);\n\n    // Startup init\n    airPlayAvailableHandler(); // Hide button if AirPlay is not available\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between 'auto' and the available audio qualities.\n */\nexport class AudioQualitySelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let updateAudioQualities = () => {\n      let audioQualities = player.getAvailableAudioQualities();\n\n      this.clearItems();\n\n      // Add entry for automatic quality switching (default setting)\n      this.addItem('auto', 'auto');\n\n      // Add audio qualities\n      for (let audioQuality of audioQualities) {\n        this.addItem(audioQuality.id, audioQuality.label);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: AudioQualitySelectBox, value: string) => {\n      player.setAudioQuality(value);\n    });\n\n    // Update qualities when audio track has changed\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, updateAudioQualities);\n    // Update qualities when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateAudioQualities);\n    // Update qualities when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateAudioQualities);\n    // Update quality selection when quality is changed (from outside)\n    player.addEventHandler(player.EVENT.ON_AUDIO_DOWNLOAD_QUALITY_CHANGE, () => {\n      let data = player.getDownloadedAudioData();\n      this.selectItem(data.isAuto ? 'auto' : data.id);\n    });\n\n    // Populate qualities at startup\n    updateAudioQualities();\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between available audio tracks (e.g. different languages).\n */\nexport class AudioTrackSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let updateAudioTracks = () => {\n      let audioTracks = player.getAvailableAudio();\n\n      this.clearItems();\n\n      // Add audio tracks\n      for (let audioTrack of audioTracks) {\n        this.addItem(audioTrack.id, audioTrack.label);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: AudioTrackSelectBox, value: string) => {\n      player.setAudio(value);\n    });\n\n    let audioTrackHandler = () => {\n      let currentAudioTrack = player.getAudio();\n\n      // HLS streams don't always provide this, so we have to check\n      if (currentAudioTrack) {\n        this.selectItem(currentAudioTrack.id);\n      }\n    };\n\n    // Update selection when selected track has changed\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, audioTrackHandler);\n    // Update tracks when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateAudioTracks);\n    // Update tracks when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateAudioTracks);\n\n    // Populate tracks at startup\n    updateAudioTracks();\n\n    // When `playback.audioLanguage` is set, the `ON_AUDIO_CHANGED` event for that change is triggered before the\n    // UI is created. Therefore we need to set the audio track on configure.\n    audioTrackHandler();\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {Component, ComponentConfig} from './component';\nimport {Timeout} from '../timeout';\n\n/**\n * Configuration interface for the {@link BufferingOverlay} component.\n */\nexport interface BufferingOverlayConfig extends ContainerConfig {\n  /**\n   * Delay in milliseconds after which the buffering overlay will be displayed. Useful to bypass short stalls without\n   * displaying the overlay. Set to 0 to display the overlay instantly.\n   * Default: 1000ms (1 second)\n   */\n  showDelayMs?: number;\n}\n\n/**\n * Overlays the player and displays a buffering indicator.\n */\nexport class BufferingOverlay extends Container<BufferingOverlayConfig> {\n\n  private indicators: Component<ComponentConfig>[];\n\n  constructor(config: BufferingOverlayConfig = {}) {\n    super(config);\n\n    this.indicators = [\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n    ];\n\n    this.config = this.mergeConfig(config, <BufferingOverlayConfig>{\n      cssClass: 'ui-buffering-overlay',\n      hidden: true,\n      components: this.indicators,\n      showDelayMs: 1000,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <BufferingOverlayConfig>this.getConfig();\n\n    let overlayShowTimeout = new Timeout(config.showDelayMs, () => {\n      this.show();\n    });\n\n    let showOverlay = () => {\n      overlayShowTimeout.start();\n    };\n\n    let hideOverlay = () => {\n      overlayShowTimeout.clear();\n      this.hide();\n    };\n\n    player.addEventHandler(player.EVENT.ON_STALL_STARTED, showOverlay);\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, hideOverlay);\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, hideOverlay);\n\n    // Show overlay if player is already stalled at init\n    if (player.isStalled()) {\n      this.show();\n    }\n  }\n}\n","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {EventDispatcher, NoArgs, Event} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link Button} component.\n */\nexport interface ButtonConfig extends ComponentConfig {\n  /**\n   * The text on the button.\n   */\n  text?: string;\n}\n\n/**\n * A simple clickable button.\n */\nexport class Button<Config extends ButtonConfig> extends Component<ButtonConfig> {\n\n  private buttonEvents = {\n    onClick: new EventDispatcher<Button<Config>, NoArgs>()\n  };\n\n  constructor(config: ButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-button'\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    // Create the button element with the text label\n    let buttonElement = new DOM('button', {\n      'type': 'button',\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    }).append(new DOM('span', {\n      'class': this.prefixCss('label')\n    }).html(this.config.text));\n\n    // Listen for the click event on the button element and trigger the corresponding event on the button component\n    buttonElement.on('click', () => {\n      this.onClickEvent();\n    });\n\n    return buttonElement;\n  }\n\n  /**\n   * Sets text on the label of the button.\n   * @param text the text to put into the label of the button\n   */\n  setText(text: string): void {\n    this.getDomElement().find('.' + this.prefixCss('label')).html(text);\n  }\n\n  protected onClickEvent() {\n    this.buttonEvents.onClick.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the button is clicked.\n   * @returns {Event<Button<Config>, NoArgs>}\n   */\n  get onClick(): Event<Button<Config>, NoArgs> {\n    return this.buttonEvents.onClick.getEvent();\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport CastWaitingForDeviceEvent = bitmovin.player.CastWaitingForDeviceEvent;\nimport CastStartedEvent = bitmovin.player.CastStartedEvent;\n\n/**\n * Overlays the player and displays the status of a Cast session.\n */\nexport class CastStatusOverlay extends Container<ContainerConfig> {\n\n  private statusLabel: Label<LabelConfig>;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.statusLabel = new Label<LabelConfig>({ cssClass: 'ui-cast-status-label' });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-cast-status-overlay',\n      components: [this.statusLabel],\n      hidden: true\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    player.addEventHandler(player.EVENT.ON_CAST_WAITING_FOR_DEVICE,\n      (event: CastWaitingForDeviceEvent) => {\n        this.show();\n        // Get device name and update status text while connecting\n        let castDeviceName = event.castPayload.deviceName;\n        this.statusLabel.setText(`Connecting to <strong>${castDeviceName}</strong>...`);\n      });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, (event: CastStartedEvent) => {\n      // Session is started or resumed\n      // For cases when a session is resumed, we do not receive the previous events and therefore show the status panel\n      // here too\n      this.show();\n      let castDeviceName = event.deviceName;\n      this.statusLabel.setText(`Playing on <strong>${castDeviceName}</strong>`);\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, (event) => {\n      // Cast session gone, hide the status panel\n      this.hide();\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles casting to a Cast receiver.\n */\nexport class CastToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-casttogglebutton',\n      text: 'Google Cast'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      if (player.isCastAvailable()) {\n        if (player.isCasting()) {\n          player.castStop();\n        } else {\n          player.castVideo();\n        }\n      } else {\n        if (console) {\n          console.log('Cast unavailable');\n        }\n      }\n    });\n\n    let castAvailableHander = () => {\n      if (player.isCastAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_CAST_AVAILABLE, castAvailableHander);\n\n    // Toggle button 'on' state\n    player.addEventHandler(player.EVENT.ON_CAST_WAITING_FOR_DEVICE, () => {\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      // When a session is resumed, there is no ON_CAST_START event, so we also need to toggle here for such cases\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, () => {\n      this.off();\n    });\n\n    // Startup init\n    castAvailableHander(); // Hide button if Cast not available\n    if (player.isCasting()) {\n      this.on();\n    }\n  }\n}","import {UIContainer, UIContainerConfig} from './uicontainer';\nimport {UIInstanceManager} from '../uimanager';\nimport {Timeout} from '../timeout';\n\n/**\n * The base container for Cast receivers that contains all of the UI and takes care that the UI is shown on\n * certain playback events.\n */\nexport class CastUIContainer extends UIContainer {\n\n  private castUiHideTimeout: Timeout;\n\n  constructor(config: UIContainerConfig) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <UIContainerConfig>this.getConfig();\n\n    /*\n     * Show UI on Cast devices at certain playback events\n     *\n     * Since a Cast receiver does not have a direct HCI, we show the UI on certain playback events to give the user\n     * a chance to see on the screen what's going on, e.g. on play/pause or a seek the UI is shown and the user can\n     * see the current time and position on the seek bar.\n     * The UI is shown permanently while playback is paused, otherwise hides automatically after the configured\n     * hide delay time.\n     */\n\n    let isUiShown = false;\n\n    let hideUi = () => {\n      uimanager.onControlsHide.dispatch(this);\n      isUiShown = false;\n    };\n\n    this.castUiHideTimeout = new Timeout(config.hideDelay, hideUi);\n\n    let showUi = () => {\n      if (!isUiShown) {\n        uimanager.onControlsShow.dispatch(this);\n        isUiShown = true;\n      }\n    };\n\n    let showUiPermanently = () => {\n      showUi();\n      this.castUiHideTimeout.clear();\n    };\n\n    let showUiWithTimeout = () => {\n      showUi();\n      this.castUiHideTimeout.start();\n    };\n\n    let showUiAfterSeek = () => {\n      if (player.isPlaying()) {\n        showUiWithTimeout();\n      } else {\n        showUiPermanently();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_PLAY, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_PAUSED, showUiPermanently);\n    player.addEventHandler(player.EVENT.ON_SEEK, showUiPermanently);\n    player.addEventHandler(player.EVENT.ON_SEEKED, showUiAfterSeek);\n  }\n\n  release(): void {\n    super.release();\n    this.castUiHideTimeout.clear();\n  }\n}","import {Button, ButtonConfig} from './button';\n\n/**\n * Configuration interface for a {@link ClickOverlay}.\n */\nexport interface ClickOverlayConfig extends ButtonConfig {\n  /**\n   * The url to open when the overlay is clicked. Set to null to disable the click handler.\n   */\n  url?: string;\n}\n\n/**\n * A click overlay that opens an url in a new tab if clicked.\n */\nexport class ClickOverlay extends Button<ClickOverlayConfig> {\n\n  constructor(config: ClickOverlayConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-clickoverlay'\n    }, <ClickOverlayConfig>this.config);\n  }\n\n  initialize(): void {\n    super.initialize();\n\n    this.setUrl((<ClickOverlayConfig>this.config).url);\n    let element = this.getDomElement();\n    element.on('click', () => {\n      if (element.data('url')) {\n        window.open(element.data('url'), '_blank');\n      }\n    });\n  }\n\n  /**\n   * Gets the URL that should be followed when the watermark is clicked.\n   * @returns {string} the watermark URL\n   */\n  getUrl(): string {\n    return this.getDomElement().data('url');\n  }\n\n  setUrl(url: string): void {\n    if (url === undefined || url == null) {\n      url = '';\n    }\n    this.getDomElement().data('url', url);\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {UIInstanceManager} from '../uimanager';\nimport {Component, ComponentConfig} from './component';\n\n/**\n * Configuration interface for the {@link CloseButton}.\n */\nexport interface CloseButtonConfig extends ButtonConfig {\n  /**\n   * The component that should be closed when the button is clicked.\n   */\n  target: Component<ComponentConfig>;\n}\n\n/**\n * A button that closes (hides) a configured component.\n */\nexport class CloseButton extends Button<CloseButtonConfig> {\n\n  constructor(config: CloseButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-closebutton',\n      text: 'Close'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <CloseButtonConfig>this.getConfig();\n\n    this.onClick.subscribe(() => {\n      config.target.hide();\n    });\n  }\n}","import {Guid} from '../guid';\nimport {DOM} from '../dom';\nimport {EventDispatcher, NoArgs, Event} from '../eventdispatcher';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Base configuration interface for a component.\n * Should be extended by components that want to add additional configuration options.\n */\nexport interface ComponentConfig {\n  /**\n   * The HTML tag name of the component.\n   * Default: 'div'\n   */\n  tag?: string;\n  /**\n   * The HTML ID of the component.\n   * Default: automatically generated with pattern 'ui-id-{guid}'.\n   */\n  id?: string;\n\n  /**\n   * A prefix to prepend all CSS classes with.\n   */\n  cssPrefix?: string;\n\n  /**\n   * The CSS classes of the component. This is usually the class from where the component takes its styling.\n   */\n  cssClass?: string; // 'class' is a reserved keyword, so we need to make the name more complicated\n\n  /**\n   * Additional CSS classes of the component.\n   */\n  cssClasses?: string[];\n\n  /**\n   * Specifies if the component should be hidden at startup.\n   * Default: false\n   */\n  hidden?: boolean;\n}\n\nexport interface ComponentHoverChangedEventArgs extends NoArgs {\n  /**\n   * True is the component is hovered, else false.\n   */\n  hovered: boolean;\n}\n\n/**\n * The base class of the UI framework.\n * Each component must extend this class and optionally the config interface.\n */\nexport class Component<Config extends ComponentConfig> {\n\n  /**\n   * The classname that is attached to the element when it is in the hidden state.\n   * @type {string}\n   */\n  private static readonly CLASS_HIDDEN = 'hidden';\n\n  /**\n   * Configuration object of this component.\n   */\n  protected config: Config;\n\n  /**\n   * The component's DOM element.\n   */\n  private element: DOM;\n\n  /**\n   * Flag that keeps track of the hidden state.\n   */\n  private hidden: boolean;\n\n  /**\n   * Flag that keeps track of the hover state.\n   */\n  private hovered: boolean;\n\n  /**\n   * The list of events that this component offers. These events should always be private and only directly\n   * accessed from within the implementing component.\n   *\n   * Because TypeScript does not support private properties with the same name on different class hierarchy levels\n   * (i.e. superclass and subclass cannot contain a private property with the same name), the default naming\n   * convention for the event list of a component that should be followed by subclasses is the concatenation of the\n   * camel-cased class name + 'Events' (e.g. SubClass extends Component => subClassEvents).\n   * See {@link #componentEvents} for an example.\n   *\n   * Event properties should be named in camel case with an 'on' prefix and in the present tense. Async events may\n   * have a start event (when the operation starts) in the present tense, and must have an end event (when the\n   * operation ends) in the past tense (or present tense in special cases (e.g. onStart/onStarted or onPlay/onPlaying).\n   * See {@link #componentEvents#onShow} for an example.\n   *\n   * Each event should be accompanied with a protected method named by the convention eventName + 'Event'\n   * (e.g. onStartEvent), that actually triggers the event by calling {@link EventDispatcher#dispatch dispatch} and\n   * passing a reference to the component as first parameter. Components should always trigger their events with these\n   * methods. Implementing this pattern gives subclasses means to directly listen to the events by overriding the\n   * method (and saving the overhead of passing a handler to the event dispatcher) and more importantly to trigger\n   * these events without having access to the private event list.\n   * See {@link #onShow} for an example.\n   *\n   * To provide external code the possibility to listen to this component's events (subscribe, unsubscribe, etc.),\n   * each event should also be accompanied by a public getter function with the same name as the event's property,\n   * that returns the {@link Event} obtained from the event dispatcher by calling {@link EventDispatcher#getEvent}.\n   * See {@link #onShow} for an example.\n   *\n   * Full example for an event representing an example action in a example component:\n   *\n   * <code>\n   * // Define an example component class with an example event\n   * class ExampleComponent extends Component<ComponentConfig> {\n     *\n     *     private exampleComponentEvents = {\n     *         onExampleAction: new EventDispatcher<ExampleComponent, NoArgs>()\n     *     }\n     *\n     *     // constructor and other stuff...\n     *\n     *     protected onExampleActionEvent() {\n     *        this.exampleComponentEvents.onExampleAction.dispatch(this);\n     *    }\n     *\n     *    get onExampleAction(): Event<ExampleComponent, NoArgs> {\n     *        return this.exampleComponentEvents.onExampleAction.getEvent();\n     *    }\n     * }\n   *\n   * // Create an instance of the component somewhere\n   * var exampleComponentInstance = new ExampleComponent();\n   *\n   * // Subscribe to the example event on the component\n   * exampleComponentInstance.onExampleAction.subscribe(function (sender: ExampleComponent) {\n     *     console.log('onExampleAction of ' + sender + ' has fired!');\n     * });\n   * </code>\n   */\n  private componentEvents = {\n    onShow: new EventDispatcher<Component<Config>, NoArgs>(),\n    onHide: new EventDispatcher<Component<Config>, NoArgs>(),\n    onHoverChanged: new EventDispatcher<Component<Config>, ComponentHoverChangedEventArgs>(),\n  };\n\n  /**\n   * Constructs a component with an optionally supplied config. All subclasses must call the constructor of their\n   * superclass and then merge their configuration into the component's configuration.\n   * @param config the configuration for the component\n   */\n  constructor(config: ComponentConfig = {}) {\n    // Create the configuration for this component\n    this.config = <Config>this.mergeConfig(config, {\n      tag: 'div',\n      id: 'bmpui-id-' + Guid.next(),\n      cssPrefix: 'bmpui',\n      cssClass: 'ui-component',\n      cssClasses: [],\n      hidden: false\n    }, {});\n  }\n\n  /**\n   * Initializes the component, e.g. by applying config settings.\n   * This method must not be called from outside the UI framework.\n   *\n   * This method is automatically called by the {@link UIInstanceManager}. If the component is an inner component of\n   * some component, and thus encapsulated abd managed internally and never directly exposed to the UIManager,\n   * this method must be called from the managing component's {@link #initialize} method.\n   */\n  initialize(): void {\n    this.hidden = this.config.hidden;\n\n    // Hide the component at initialization if it is configured to be hidden\n    if (this.isHidden()) {\n      this.hidden = false; // Set flag to false for the following hide() call to work (hide() checks the flag)\n      this.hide();\n    }\n  }\n\n  /**\n   * Configures the component for the supplied Player and UIInstanceManager. This is the place where all the magic\n   * happens, where components typically subscribe and react to events (on their DOM element, the Player, or the\n   * UIInstanceManager), and basically everything that makes them interactive.\n   * This method is called only once, when the UIManager initializes the UI.\n   *\n   * Subclasses usually overwrite this method to add their own functionality.\n   *\n   * @param player the player which this component controls\n   * @param uimanager the UIInstanceManager that manages this component\n   */\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    this.onShow.subscribe(() => {\n      uimanager.onComponentShow.dispatch(this);\n    });\n    this.onHide.subscribe(() => {\n      uimanager.onComponentHide.dispatch(this);\n    });\n\n    // Track the hovered state of the element\n    this.getDomElement().on('mouseenter', () => {\n      this.onHoverChangedEvent(true);\n    });\n    this.getDomElement().on('mouseleave', () => {\n      this.onHoverChangedEvent(false);\n    });\n  }\n\n  /**\n   * Releases all resources and dependencies that the component holds. Player, DOM, and UIManager events are\n   * automatically removed during release and do not explicitly need to be removed here.\n   * This method is called by the UIManager when it releases the UI.\n   *\n   * Subclasses that need to release resources should override this method and call super.release().\n   */\n  release(): void {\n    // Nothing to do here, override where necessary\n  }\n\n  /**\n   * Generate the DOM element for this component.\n   *\n   * Subclasses usually overwrite this method to extend or replace the DOM element with their own design.\n   */\n  protected toDomElement(): DOM {\n    let element = new DOM(this.config.tag, {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    return element;\n  }\n\n  /**\n   * Returns the DOM element of this component. Creates the DOM element if it does not yet exist.\n   *\n   * Should not be overwritten by subclasses.\n   *\n   * @returns {DOM}\n   */\n  getDomElement(): DOM {\n    if (!this.element) {\n      this.element = this.toDomElement();\n    }\n\n    return this.element;\n  }\n\n  /**\n   * Merges a configuration with a default configuration and a base configuration from the superclass.\n   *\n   * @param config the configuration settings for the components, as usually passed to the constructor\n   * @param defaults a default configuration for settings that are not passed with the configuration\n   * @param base configuration inherited from a superclass\n   * @returns {Config}\n   */\n  protected mergeConfig<Config>(config: Config, defaults: Config, base: Config): Config {\n    // Extend default config with supplied config\n    let merged = Object.assign({}, base, defaults, config);\n\n    // Return the extended config\n    return merged;\n  }\n\n  /**\n   * Helper method that returns a string of all CSS classes of the component.\n   *\n   * @returns {string}\n   */\n  protected getCssClasses(): string {\n    // Merge all CSS classes into single array\n    let flattenedArray = [this.config.cssClass].concat(this.config.cssClasses);\n    // Prefix classes\n    flattenedArray = flattenedArray.map((css) => {\n      return this.prefixCss(css);\n    });\n    // Join array values into a string\n    let flattenedString = flattenedArray.join(' ');\n    // Return trimmed string to prevent whitespace at the end from the join operation\n    return flattenedString.trim();\n  }\n\n  protected prefixCss(cssClassOrId: string): string {\n    return this.config.cssPrefix + '-' + cssClassOrId;\n  }\n\n  /**\n   * Returns the configuration object of the component.\n   * @returns {Config}\n   */\n  public getConfig(): Config {\n    return this.config;\n  }\n\n  /**\n   * Hides the component if shown.\n   * This method basically transfers the component into the hidden state. Actual hiding is done via CSS.\n   */\n  hide() {\n    if (!this.hidden) {\n      this.hidden = true;\n      this.getDomElement().addClass(this.prefixCss(Component.CLASS_HIDDEN));\n      this.onHideEvent();\n    }\n  }\n\n  /**\n   * Shows the component if hidden.\n   */\n  show() {\n    if (this.hidden) {\n      this.getDomElement().removeClass(this.prefixCss(Component.CLASS_HIDDEN));\n      this.hidden = false;\n      this.onShowEvent();\n    }\n  }\n\n  /**\n   * Determines if the component is hidden.\n   * @returns {boolean} true if the component is hidden, else false\n   */\n  isHidden(): boolean {\n    return this.hidden;\n  }\n\n  /**\n   * Determines if the component is shown.\n   * @returns {boolean} true if the component is visible, else false\n   */\n  isShown(): boolean {\n    return !this.isHidden();\n  }\n\n  /**\n   * Toggles the hidden state by hiding the component if it is shown, or showing it if hidden.\n   */\n  toggleHidden() {\n    if (this.isHidden()) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  }\n\n  /**\n   * Determines if the component is currently hovered.\n   * @returns {boolean} true if the component is hovered, else false\n   */\n  isHovered(): boolean {\n    return this.hovered;\n  }\n\n  /**\n   * Fires the onShow event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onShowEvent(): void {\n    this.componentEvents.onShow.dispatch(this);\n  }\n\n  /**\n   * Fires the onHide event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onHideEvent(): void {\n    this.componentEvents.onHide.dispatch(this);\n  }\n\n  /**\n   * Fires the onHoverChanged event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onHoverChangedEvent(hovered: boolean): void {\n    this.hovered = hovered;\n    this.componentEvents.onHoverChanged.dispatch(this, { hovered: hovered });\n  }\n\n  /**\n   * Gets the event that is fired when the component is showing.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   * @returns {Event<Component<Config>, NoArgs>}\n   */\n  get onShow(): Event<Component<Config>, NoArgs> {\n    return this.componentEvents.onShow.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the component is hiding.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   * @returns {Event<Component<Config>, NoArgs>}\n   */\n  get onHide(): Event<Component<Config>, NoArgs> {\n    return this.componentEvents.onHide.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the component's hover-state is changing.\n   * @returns {Event<Component<Config>, ComponentHoverChangedEventArgs>}\n   */\n  get onHoverChanged(): Event<Component<Config>, ComponentHoverChangedEventArgs> {\n    return this.componentEvents.onHoverChanged.getEvent();\n  }\n}","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {ArrayUtils} from '../utils';\n\n/**\n * Configuration interface for a {@link Container}.\n */\nexport interface ContainerConfig extends ComponentConfig {\n  /**\n   * Child components of the container.\n   */\n  components?: Component<ComponentConfig>[];\n}\n\n/**\n * A container component that can contain a collection of child components.\n * Components can be added at construction time through the {@link ContainerConfig#components} setting, or later\n * through the {@link Container#addComponent} method. The UIManager automatically takes care of all components, i.e. it\n * initializes and configures them automatically.\n *\n * In the DOM, the container consists of an outer <div> (that can be configured by the config) and an inner wrapper\n * <div> that contains the components. This double-<div>-structure is often required to achieve many advanced effects\n * in CSS and/or JS, e.g. animations and certain formatting with absolute positioning.\n *\n * DOM example:\n * <code>\n *     <div class='ui-container'>\n *         <div class='container-wrapper'>\n *             ... child components ...\n *         </div>\n *     </div>\n * </code>\n */\nexport class Container<Config extends ContainerConfig> extends Component<ContainerConfig> {\n\n  /**\n   * A reference to the inner element that contains the components of the container.\n   */\n  private innerContainerElement: DOM;\n\n  constructor(config: ContainerConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-container',\n      components: []\n    }, this.config);\n  }\n\n  /**\n   * Adds a child component to the container.\n   * @param component the component to add\n   */\n  addComponent(component: Component<ComponentConfig>) {\n    this.config.components.push(component);\n  }\n\n  /**\n   * Removes a child component from the container.\n   * @param component the component to remove\n   * @returns {boolean} true if the component has been removed, false if it is not contained in this container\n   */\n  removeComponent(component: Component<ComponentConfig>): boolean {\n    return ArrayUtils.remove(this.config.components, component) != null;\n  }\n\n  /**\n   * Gets an array of all child components in this container.\n   * @returns {Component<ComponentConfig>[]}\n   */\n  getComponents(): Component<ComponentConfig>[] {\n    return this.config.components;\n  }\n\n  /**\n   * Removes all child components from the container.\n   */\n  removeComponents(): void {\n    for (let component of this.getComponents()) {\n      this.removeComponent(component);\n    }\n  }\n\n  /**\n   * Updates the DOM of the container with the current components.\n   */\n  protected updateComponents(): void {\n    this.innerContainerElement.empty();\n\n    for (let component of this.config.components) {\n      this.innerContainerElement.append(component.getDomElement());\n    }\n  }\n\n  protected toDomElement(): DOM {\n    // Create the container element (the outer <div>)\n    let containerElement = new DOM(this.config.tag, {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    // Create the inner container element (the inner <div>) that will contain the components\n    let innerContainer = new DOM(this.config.tag, {\n      'class': this.prefixCss('container-wrapper')\n    });\n    this.innerContainerElement = innerContainer;\n\n    this.updateComponents();\n\n    containerElement.append(innerContainer);\n\n    return containerElement;\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {UIUtils} from '../utils';\nimport {Spacer} from './spacer';\n\n/**\n * Configuration interface for the {@link ControlBar}.\n */\nexport interface ControlBarConfig extends ContainerConfig {\n  // nothing yet\n}\n\n/**\n * A container for main player control components, e.g. play toggle button, seek bar, volume control, fullscreen toggle\n * button.\n */\nexport class ControlBar extends Container<ControlBarConfig> {\n\n  constructor(config: ControlBarConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-controlbar',\n      hidden: true,\n    }, <ControlBarConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    // Counts how many components are hovered and block hiding of the control bar\n    let hoverStackCount = 0;\n\n    // Track hover status of child components\n    UIUtils.traverseTree(this, (component) => {\n      // Do not track hover status of child containers or spacers, only of 'real' controls\n      if (component instanceof Container || component instanceof Spacer) {\n        return;\n      }\n\n      // Subscribe hover event and keep a count of the number of hovered children\n      component.onHoverChanged.subscribe((sender, args) => {\n        if (args.hovered) {\n          hoverStackCount++;\n        } else {\n          hoverStackCount--;\n        }\n      });\n    });\n\n    uimanager.onControlsShow.subscribe(() => {\n      this.show();\n    });\n    uimanager.onPreviewControlsHide.subscribe((sender, args) => {\n      // Cancel the hide event if hovered child components block hiding\n      args.cancel = (hoverStackCount > 0);\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      this.hide();\n    });\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport ErrorEvent = bitmovin.player.ErrorEvent;\nimport {TvNoiseCanvas} from './tvnoisecanvas';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\nexport interface ErrorMessageTranslator {\n  (error: ErrorEvent): string;\n}\n\nexport interface ErrorMessageMap {\n  [code: number]: string | ErrorMessageTranslator;\n}\n\n/**\n * Configuration interface for the {@link ErrorMessageOverlay}.\n */\nexport interface ErrorMessageOverlayConfig extends ContainerConfig {\n  /**\n   * Allows overwriting of the error messages displayed in the overlay for customization and localization.\n   * This is either a function that receives any {@link ErrorEvent} as parameter and translates error messages,\n   * or a map of error codes that overwrites specific error messages with a plain string or a function that\n   * receives the {@link ErrorEvent} as parameter and returns a customized string.\n   * The translation functions can be used to extract data (e.g. parameters) from the original error message.\n   *\n   * Example 1 (catch-all translation function):\n   * <code>\n   * errorMessageOverlayConfig = {\n   *   messages: function(error) {\n   *     switch (error.code) {\n   *       // Overwrite error 3000 'Unknown error'\n   *       case 3000:\n   *         return 'Houston, we have a problem'\n   *\n   *       // Transform error 3001 'Unsupported manifest format' to uppercase\n   *       case 3001:\n   *         return error.message.toUpperCase();\n   *\n   *       // Customize error 3006 'Could not load manifest, got HTTP status code XXX'\n   *       case 3006:\n   *         var statusCode = error.message.substring(46);\n   *         return 'Manifest loading failed with HTTP error ' + statusCode;\n   *     }\n   *     // Return unmodified error message for all other errors\n   *     return error.message;\n   *   }\n   * };\n   * </code>\n   *\n   * Example 2 (translating specific errors):\n   * <code>\n   * errorMessageOverlayConfig = {\n   *   messages: {\n   *     // Overwrite error 3000 'Unknown error'\n   *     3000: 'Houston, we have a problem',\n   *\n   *     // Transform error 3001 'Unsupported manifest format' to uppercase\n   *     3001: function(error) {\n   *       return error.message.toUpperCase();\n   *     },\n   *\n   *     // Customize error 3006 'Could not load manifest, got HTTP status code XXX'\n   *     3006: function(error) {\n   *       var statusCode = error.message.substring(46);\n   *       return 'Manifest loading failed with HTTP error ' + statusCode;\n   *     }\n   *   }\n   * };\n   * </code>\n   */\n  messages?: ErrorMessageMap | ErrorMessageTranslator;\n}\n\n/**\n * Overlays the player and displays error messages.\n */\nexport class ErrorMessageOverlay extends Container<ErrorMessageOverlayConfig> {\n\n  private errorLabel: Label<LabelConfig>;\n  private tvNoiseBackground: TvNoiseCanvas;\n\n  constructor(config: ErrorMessageOverlayConfig = {}) {\n    super(config);\n\n    this.errorLabel = new Label<LabelConfig>({ cssClass: 'ui-errormessage-label' });\n    this.tvNoiseBackground = new TvNoiseCanvas();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-errormessage-overlay',\n      components: [this.tvNoiseBackground, this.errorLabel],\n      hidden: true\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <ErrorMessageOverlayConfig>this.getConfig();\n\n    player.addEventHandler(player.EVENT.ON_ERROR, (event: ErrorEvent) => {\n      let message = event.message;\n\n      // Process message translations\n      if (config.messages) {\n        if (typeof config.messages === 'function') {\n          // Translation function for all errors\n          message = config.messages(event);\n        } else if (config.messages[event.code]) {\n          // It's not a translation function, so it must be a map of strings or translation functions\n          let customMessage = config.messages[event.code];\n\n          if (typeof customMessage === 'string') {\n            message = customMessage;\n          } else {\n            // The message is a translation function, so we call it\n            message = customMessage(event);\n          }\n        }\n      }\n\n      this.errorLabel.setText(message);\n      this.tvNoiseBackground.start();\n      this.show();\n    });\n\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, (event: PlayerEvent) => {\n      if (this.isShown()) {\n        this.tvNoiseBackground.stop();\n        this.hide();\n      }\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles the player between windowed and fullscreen view.\n */\nexport class FullscreenToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-fullscreentogglebutton',\n      text: 'Fullscreen'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let fullscreenStateHandler = () => {\n      if (player.isFullscreen()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_ENTER, fullscreenStateHandler);\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_EXIT, fullscreenStateHandler);\n\n    this.onClick.subscribe(() => {\n      if (player.isFullscreen()) {\n        player.exitFullscreen();\n      } else {\n        player.enterFullscreen();\n      }\n    });\n\n    // Startup init\n    fullscreenStateHandler();\n  }\n}","import {ToggleButtonConfig} from './togglebutton';\nimport {PlaybackToggleButton} from './playbacktogglebutton';\nimport {DOM} from '../dom';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\n/**\n * A button that overlays the video and toggles between playback and pause.\n */\nexport class HugePlaybackToggleButton extends PlaybackToggleButton {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-hugeplaybacktogglebutton',\n      text: 'Play/Pause'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    // Update button state through API events\n    super.configure(player, uimanager, false);\n\n    let togglePlayback = () => {\n      if (player.isPlaying()) {\n        player.pause('ui-overlay');\n      } else {\n        player.play('ui-overlay');\n      }\n    };\n\n    let toggleFullscreen = () => {\n      if (player.isFullscreen()) {\n        player.exitFullscreen();\n      } else {\n        player.enterFullscreen();\n      }\n    };\n\n    let firstPlay = true;\n    let clickTime = 0;\n    let doubleClickTime = 0;\n\n    /*\n     * YouTube-style toggle button handling\n     *\n     * The goal is to prevent a short pause or playback interval between a click, that toggles playback, and a\n     * double click, that toggles fullscreen. In this naive approach, the first click would e.g. start playback,\n     * the second click would be detected as double click and toggle to fullscreen, and as second normal click stop\n     * playback, which results is a short playback interval with max length of the double click detection\n     * period (usually 500ms).\n     *\n     * To solve this issue, we defer handling of the first click for 200ms, which is almost unnoticeable to the user,\n     * and just toggle playback if no second click (double click) has been registered during this period. If a double\n     * click is registered, we just toggle the fullscreen. In the first 200ms, undesired playback changes thus cannot\n     * happen. If a double click is registered within 500ms, we undo the playback change and switch fullscreen mode.\n     * In the end, this method basically introduces a 200ms observing interval in which playback changes are prevented\n     * if a double click happens.\n     */\n    this.onClick.subscribe(() => {\n      // Directly start playback on first click of the button.\n      // This is a required workaround for mobile browsers where video playback needs to be triggered directly\n      // by the user. A deferred playback start through the timeout below is not considered as user action and\n      // therefore ignored by mobile browsers.\n      if (firstPlay) {\n        // Try to start playback. Then we wait for ON_PLAY and only when it arrives, we disable the firstPlay flag.\n        // If we disable the flag here, onClick was triggered programmatically instead of by a user interaction, and\n        // playback is blocked (e.g. on mobile devices due to the programmatic play() call), we loose the chance to\n        // ever start playback through a user interaction again with this button.\n        togglePlayback();\n        return;\n      }\n\n      let now = Date.now();\n\n      if (now - clickTime < 200) {\n        // We have a double click inside the 200ms interval, just toggle fullscreen mode\n        toggleFullscreen();\n        doubleClickTime = now;\n        return;\n      } else if (now - clickTime < 500) {\n        // We have a double click inside the 500ms interval, undo playback toggle and toggle fullscreen mode\n        toggleFullscreen();\n        togglePlayback();\n        doubleClickTime = now;\n        return;\n      }\n\n      clickTime = now;\n\n      setTimeout(() => {\n        if (Date.now() - doubleClickTime > 200) {\n          // No double click detected, so we toggle playback and wait what happens next\n          togglePlayback();\n        }\n      }, 200);\n    });\n\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      // Playback has really started, we can disable the flag to switch to normal toggle button handling\n      firstPlay = false;\n    });\n\n    // Hide button while initializing a Cast session\n    let castInitializationHandler = (event: PlayerEvent) => {\n      if (event.type === player.EVENT.ON_CAST_START) {\n        // Hide button when session is being initialized\n        this.hide();\n      } else {\n        // Show button when session is established or initialization was aborted\n        this.show();\n      }\n    };\n    player.addEventHandler(player.EVENT.ON_CAST_START, castInitializationHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, castInitializationHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, castInitializationHandler);\n  }\n\n  protected toDomElement(): DOM {\n    let buttonElement = super.toDomElement();\n\n    // Add child that contains the play button image\n    // Setting the image directly on the button does not work together with scaling animations, because the button\n    // can cover the whole video player are and scaling would extend it beyond. By adding an inner element, confined\n    // to the size if the image, it can scale inside the player without overshooting.\n    buttonElement.append(new DOM('div', {\n      'class': this.prefixCss('image')\n    }));\n\n    return buttonElement;\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {DOM} from '../dom';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\n/**\n * A button to play/replay a video.\n */\nexport class HugeReplayButton extends Button<ButtonConfig> {\n\n  constructor(config: ButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-hugereplaybutton',\n      text: 'Replay'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      player.play('ui-overlay');\n    });\n  }\n\n  protected toDomElement(): DOM {\n    let buttonElement = super.toDomElement();\n\n    // Add child that contains the play button image\n    // Setting the image directly on the button does not work together with scaling animations, because the button\n    // can cover the whole video player are and scaling would extend it beyond. By adding an inner element, confined\n    // to the size if the image, it can scale inside the player without overshooting.\n    buttonElement.append(new DOM('div', {\n      'class': this.prefixCss('image')\n    }));\n\n    return buttonElement;\n  }\n}","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {EventDispatcher, Event, NoArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link Label} component.\n */\nexport interface LabelConfig extends ComponentConfig {\n  /**\n   * The text on the label.\n   */\n  text?: string;\n}\n\n/**\n * A simple text label.\n *\n * DOM example:\n * <code>\n *     <span class='ui-label'>...some text...</span>\n * </code>\n */\nexport class Label<Config extends LabelConfig> extends Component<LabelConfig> {\n\n  private text: string;\n\n  private labelEvents = {\n    onClick: new EventDispatcher<Label<Config>, NoArgs>(),\n    onTextChanged: new EventDispatcher<Label<Config>, string>(),\n  };\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-label'\n    }, this.config);\n\n    this.text = this.config.text;\n  }\n\n  protected toDomElement(): DOM {\n    let labelElement = new DOM('span', {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    }).html(this.text);\n\n    labelElement.on('click', () => {\n      this.onClickEvent();\n    });\n\n    return labelElement;\n  }\n\n  /**\n   * Set the text on this label.\n   * @param text\n   */\n  setText(text: string) {\n    this.text = text;\n    this.getDomElement().html(text);\n    this.onTextChangedEvent(text);\n  }\n\n  /**\n   * Gets the text on this label.\n   * @return {string} The text on the label\n   */\n  getText(): string {\n    return this.text;\n  }\n\n  /**\n   * Clears the text on this label.\n   */\n  clearText() {\n    this.getDomElement().html('');\n    this.onTextChangedEvent(null);\n  }\n\n  /**\n   * Tests if the label is empty and does not contain any text.\n   * @return {boolean} True if the label is empty, else false\n   */\n  isEmpty(): boolean {\n    return !this.text;\n  }\n\n  /**\n   * Fires the {@link #onClick} event.\n   * Can be used by subclasses to listen to this event without subscribing an event listener by overwriting the method\n   * and calling the super method.\n   */\n  protected onClickEvent() {\n    this.labelEvents.onClick.dispatch(this);\n  }\n\n  /**\n   * Fires the {@link #onClick} event.\n   * Can be used by subclasses to listen to this event without subscribing an event listener by overwriting the method\n   * and calling the super method.\n   */\n  protected onTextChangedEvent(text: string) {\n    this.labelEvents.onTextChanged.dispatch(this, text);\n  }\n\n  /**\n   * Gets the event that is fired when the label is clicked.\n   * @returns {Event<Label<LabelConfig>, NoArgs>}\n   */\n  get onClick(): Event<Label<LabelConfig>, NoArgs> {\n    return this.labelEvents.onClick.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the text on the label is changed.\n   * @returns {Event<Label<LabelConfig>, string>}\n   */\n  get onTextChanged(): Event<Label<LabelConfig>, string> {\n    return this.labelEvents.onTextChanged.getEvent();\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {EventDispatcher, Event} from '../eventdispatcher';\nimport {ArrayUtils} from '../utils';\n\n/**\n * A map of items (key/value -> label} for a {@link ListSelector} in a {@link ListSelectorConfig}.\n */\nexport interface ListItem {\n  key: string;\n  label: string;\n}\n\n/**\n * Configuration interface for a {@link ListSelector}.\n */\nexport interface ListSelectorConfig extends ComponentConfig {\n  items?: ListItem[];\n}\n\nexport abstract class ListSelector<Config extends ListSelectorConfig> extends Component<ListSelectorConfig> {\n\n  protected items: ListItem[];\n  protected selectedItem: string;\n\n  private listSelectorEvents = {\n    onItemAdded: new EventDispatcher<ListSelector<Config>, string>(),\n    onItemRemoved: new EventDispatcher<ListSelector<Config>, string>(),\n    onItemSelected: new EventDispatcher<ListSelector<Config>, string>()\n  };\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      items: [],\n      cssClass: 'ui-listselector'\n    }, this.config);\n\n    this.items = this.config.items;\n  }\n\n  private getItemIndex(key: string): number {\n    for (let index in this.items) {\n      if (key === this.items[index].key) {\n        return parseInt(index);\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Checks if the specified item is part of this selector.\n   * @param key the key of the item to check\n   * @returns {boolean} true if the item is part of this selector, else false\n   */\n  hasItem(key: string): boolean {\n    return this.getItemIndex(key) > -1;\n  }\n\n  /**\n   * Adds an item to this selector by appending it to the end of the list of items. If an item with the specified\n   * key already exists, it is replaced.\n   * @param key the key of the item to add\n   * @param label the (human-readable) label of the item to add\n   */\n  addItem(key: string, label: string) {\n    this.removeItem(key); // Try to remove key first to get overwrite behavior and avoid duplicate keys\n    this.items.push({ key: key, label: label });\n    this.onItemAddedEvent(key);\n  }\n\n  /**\n   * Removes an item from this selector.\n   * @param key the key of the item to remove\n   * @returns {boolean} true if removal was successful, false if the item is not part of this selector\n   */\n  removeItem(key: string): boolean {\n    let index = this.getItemIndex(key);\n    if (index > -1) {\n      ArrayUtils.remove(this.items, this.items[index]);\n      this.onItemRemovedEvent(key);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Selects an item from the items in this selector.\n   * @param key the key of the item to select\n   * @returns {boolean} true is the selection was successful, false if the selected item is not part of the selector\n   */\n  selectItem(key: string): boolean {\n    if (key === this.selectedItem) {\n      // itemConfig is already selected, suppress any further action\n      return true;\n    }\n\n    let index = this.getItemIndex(key);\n\n    if (index > -1) {\n      this.selectedItem = key;\n      this.onItemSelectedEvent(key);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns the key of the selected item.\n   * @returns {string} the key of the selected item or null if no item is selected\n   */\n  getSelectedItem(): string | null {\n    return this.selectedItem;\n  }\n\n  /**\n   * Removes all items from this selector.\n   */\n  clearItems() {\n    let items = this.items; // local copy for iteration after clear\n    this.items = []; // clear items\n\n    // fire events\n    for (let item of items) {\n      this.onItemRemovedEvent(item.key);\n    }\n  }\n\n  /**\n   * Returns the number of items in this selector.\n   * @returns {number}\n   */\n  itemCount(): number {\n    return Object.keys(this.items).length;\n  }\n\n  protected onItemAddedEvent(key: string) {\n    this.listSelectorEvents.onItemAdded.dispatch(this, key);\n  }\n\n  protected onItemRemovedEvent(key: string) {\n    this.listSelectorEvents.onItemRemoved.dispatch(this, key);\n  }\n\n  protected onItemSelectedEvent(key: string) {\n    this.listSelectorEvents.onItemSelected.dispatch(this, key);\n  }\n\n  /**\n   * Gets the event that is fired when an item is added to the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemAdded(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemAdded.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when an item is removed from the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemRemoved(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemRemoved.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when an item is selected from the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemSelected(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemSelected.getEvent();\n  }\n}","import {LabelConfig, Label} from './label';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Enumerates the types of content that the {@link MetadataLabel} can display.\n */\nexport enum MetadataLabelContent {\n  /**\n   * Title of the data source.\n   */\n  Title,\n  /**\n   * Description fo the data source.\n   */\n  Description,\n}\n\n/**\n * Configuration interface for {@link MetadataLabel}.\n */\nexport interface MetadataLabelConfig extends LabelConfig {\n  /**\n   * The type of content that should be displayed in the label.\n   */\n  content: MetadataLabelContent;\n}\n\n/**\n * A label that can be configured to display certain metadata.\n */\nexport class MetadataLabel extends Label<MetadataLabelConfig> {\n\n  constructor(config: MetadataLabelConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClasses: ['label-metadata', 'label-metadata-' + MetadataLabelContent[config.content].toLowerCase()]\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <MetadataLabelConfig>this.getConfig();\n    let uiconfig = uimanager.getConfig();\n\n    let init = () => {\n      switch (config.content) {\n        case MetadataLabelContent.Title:\n          if (uiconfig && uiconfig.metadata && uiconfig.metadata.title) {\n            this.setText(uiconfig.metadata.title);\n          } else if (player.getConfig().source && player.getConfig().source.title) {\n            this.setText(player.getConfig().source.title);\n          }\n          break;\n        case MetadataLabelContent.Description:\n          if (uiconfig && uiconfig.metadata && uiconfig.metadata.description) {\n            this.setText(uiconfig.metadata.description);\n          } else if (player.getConfig().source && player.getConfig().source.description) {\n            this.setText(player.getConfig().source.description);\n          }\n          break;\n      }\n    };\n\n    let unload = () => {\n      this.setText(null);\n    };\n\n    // Init label\n    init();\n    // Reinit label when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, init);\n    // Clear labels when source is unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, unload);\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles Apple macOS picture-in-picture mode.\n */\nexport class PictureInPictureToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-piptogglebutton',\n      text: 'Picture-in-Picture'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      if (player.isPictureInPictureAvailable()) {\n        if (player.isPictureInPicture()) {\n          player.exitPictureInPicture();\n        } else {\n          player.enterPictureInPicture();\n        }\n      } else {\n        if (console) {\n          console.log('PIP unavailable');\n        }\n      }\n    });\n\n    let pipAvailableHander = () => {\n      if (player.isPictureInPictureAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, pipAvailableHander);\n\n    // Toggle button 'on' state\n    player.addEventHandler(player.EVENT.ON_PICTURE_IN_PICTURE_ENTER, () => {\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_PICTURE_IN_PICTURE_EXIT, () => {\n      this.off();\n    });\n\n    // Startup init\n    pipAvailableHander(); // Hide button if PIP not available\n    if (player.isPictureInPicture()) {\n      this.on();\n    }\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection of different playback speeds.\n */\nexport class PlaybackSpeedSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem('0.25', '0.25x');\n    this.addItem('0.5', '0.5x');\n    this.addItem('1', 'Normal');\n    this.addItem('1.5', '1.5x');\n    this.addItem('2', '2x');\n\n    this.selectItem('1');\n\n\n    this.onItemSelected.subscribe((sender: PlaybackSpeedSelectBox, value: string) => {\n      player.setPlaybackSpeed(parseFloat(value));\n    });\n  }\n}","import {LabelConfig, Label} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {StringUtils, PlayerUtils} from '../utils';\nimport LiveStreamDetectorEventArgs = PlayerUtils.LiveStreamDetectorEventArgs;\n\nexport enum PlaybackTimeLabelMode {\n  CurrentTime,\n  TotalTime,\n  CurrentAndTotalTime,\n}\n\nexport interface PlaybackTimeLabelConfig extends LabelConfig {\n  timeLabelMode?: PlaybackTimeLabelMode;\n  hideInLivePlayback?: boolean;\n}\n\n/**\n * A label that display the current playback time and the total time through {@link PlaybackTimeLabel#setTime setTime}\n * or any string through {@link PlaybackTimeLabel#setText setText}.\n */\nexport class PlaybackTimeLabel extends Label<PlaybackTimeLabelConfig> {\n\n  private timeFormat: string;\n\n  constructor(config: PlaybackTimeLabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <PlaybackTimeLabelConfig>{\n      cssClass: 'ui-playbacktimelabel',\n      timeLabelMode: PlaybackTimeLabelMode.CurrentAndTotalTime,\n      hideInLivePlayback: false,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <PlaybackTimeLabelConfig>this.getConfig();\n    let live = false;\n    let liveCssClass = this.prefixCss('ui-playbacktimelabel-live');\n    let liveEdgeCssClass = this.prefixCss('ui-playbacktimelabel-live-edge');\n    let minWidth = 0;\n\n    let liveClickHandler = () => {\n      player.timeShift(0);\n    };\n\n    let updateLiveState = () => {\n      // Player is playing a live stream when the duration is infinite\n      live = player.isLive();\n\n      // Attach/detach live marker class\n      if (live) {\n        this.getDomElement().addClass(liveCssClass);\n        this.setText('Live');\n        if (config.hideInLivePlayback) {\n          this.hide();\n        }\n        this.onClick.subscribe(liveClickHandler);\n        updateLiveTimeshiftState();\n      } else {\n        this.getDomElement().removeClass(liveCssClass);\n        this.getDomElement().removeClass(liveEdgeCssClass);\n        this.show();\n        this.onClick.unsubscribe(liveClickHandler);\n      }\n    };\n\n    new PlayerUtils.LiveStreamDetector(player).onLiveChanged.subscribe((sender, args: LiveStreamDetectorEventArgs) => {\n      live = args.live;\n      updateLiveState();\n    });\n\n    let updateLiveTimeshiftState = () => {\n      if (player.getTimeShift() === 0) {\n        this.getDomElement().addClass(liveEdgeCssClass);\n      } else {\n        this.getDomElement().removeClass(liveEdgeCssClass);\n      }\n    };\n\n    let playbackTimeHandler = () => {\n      if (!live && player.getDuration() !== Infinity) {\n        this.setTime(player.getCurrentTime(), player.getDuration());\n      }\n\n      // To avoid 'jumping' in the UI by varying label sizes due to non-monospaced fonts,\n      // we gradually increase the min-width with the content to reach a stable size.\n      let width = this.getDomElement().width();\n      if (width > minWidth) {\n        minWidth = width;\n        this.getDomElement().css({\n          'min-width': minWidth + 'px'\n        });\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_TIME_CHANGED, playbackTimeHandler);\n    player.addEventHandler(player.EVENT.ON_SEEKED, playbackTimeHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, playbackTimeHandler);\n\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, updateLiveTimeshiftState);\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, updateLiveTimeshiftState);\n\n    let init = () => {\n      // Reset min-width when a new source is ready (especially for switching VOD/Live modes where the label content\n      // changes)\n      minWidth = 0;\n      this.getDomElement().css({\n        'min-width': null\n      });\n\n      // Set time format depending on source duration\n      this.timeFormat = Math.abs(player.isLive() ? player.getMaxTimeShift() : player.getDuration()) >= 3600 ?\n        StringUtils.FORMAT_HHMMSS : StringUtils.FORMAT_MMSS;\n\n      // Update time after the format has been set\n      playbackTimeHandler();\n    };\n    player.addEventHandler(player.EVENT.ON_READY, init);\n\n    init();\n  }\n\n  /**\n   * Sets the current playback time and total duration.\n   * @param playbackSeconds the current playback time in seconds\n   * @param durationSeconds the total duration in seconds\n   */\n  setTime(playbackSeconds: number, durationSeconds: number) {\n    let currentTime = StringUtils.secondsToTime(playbackSeconds, this.timeFormat);\n    let totalTime = StringUtils.secondsToTime(durationSeconds, this.timeFormat);\n\n    switch ((<PlaybackTimeLabelConfig>this.config).timeLabelMode) {\n      case PlaybackTimeLabelMode.CurrentTime:\n        this.setText(`${currentTime}`);\n        break;\n      case PlaybackTimeLabelMode.TotalTime:\n        this.setText(`${totalTime}`);\n        break;\n      case PlaybackTimeLabelMode.CurrentAndTotalTime:\n        this.setText(`${currentTime} / ${totalTime}`);\n        break;\n    }\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\nimport {PlayerUtils} from '../utils';\nimport TimeShiftAvailabilityChangedArgs = PlayerUtils.TimeShiftAvailabilityChangedArgs;\n\n/**\n * A button that toggles between playback and pause.\n */\nexport class PlaybackToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  private static readonly CLASS_STOPTOGGLE = 'stoptoggle';\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-playbacktogglebutton',\n      text: 'Play/Pause'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager, handleClickEvent: boolean = true): void {\n    super.configure(player, uimanager);\n\n    let isSeeking = false;\n\n    // Handler to update button state based on player state\n    let playbackStateHandler = (event: PlayerEvent) => {\n      // If the UI is currently seeking, playback is temporarily stopped but the buttons should\n      // not reflect that and stay as-is (e.g indicate playback while seeking).\n      if (isSeeking) {\n        return;\n      }\n\n      if (player.isPlaying()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    // Call handler upon these events\n    player.addEventHandler(player.EVENT.ON_PLAY, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_PAUSED, playbackStateHandler);\n    // when playback finishes, player turns to paused mode\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYING, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PAUSED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYBACK_FINISHED, playbackStateHandler);\n\n    // Detect absence of timeshifting on live streams and add tagging class to convert button icons to play/stop\n    new PlayerUtils.TimeShiftAvailabilityDetector(player).onTimeShiftAvailabilityChanged.subscribe(\n      (sender, args: TimeShiftAvailabilityChangedArgs) => {\n        if (!args.timeShiftAvailable) {\n          this.getDomElement().addClass(this.prefixCss(PlaybackToggleButton.CLASS_STOPTOGGLE));\n        } else {\n          this.getDomElement().removeClass(this.prefixCss(PlaybackToggleButton.CLASS_STOPTOGGLE));\n        }\n      }\n    );\n\n    if (handleClickEvent) {\n      // Control player by button events\n      // When a button event triggers a player API call, events are fired which in turn call the event handler\n      // above that updated the button state.\n      this.onClick.subscribe(() => {\n        if (player.isPlaying()) {\n          player.pause('ui-button');\n        } else {\n          player.play('ui-button');\n        }\n      });\n    }\n\n    // Track UI seeking status\n    uimanager.onSeek.subscribe(() => {\n      isSeeking = true;\n    });\n    uimanager.onSeeked.subscribe(() => {\n      isSeeking = false;\n    });\n\n    // Startup init\n    playbackStateHandler(null);\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {HugePlaybackToggleButton} from './hugeplaybacktogglebutton';\n\n/**\n * Overlays the player and displays error messages.\n */\nexport class PlaybackToggleOverlay extends Container<ContainerConfig> {\n\n  private playbackToggleButton: HugePlaybackToggleButton;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.playbackToggleButton = new HugePlaybackToggleButton();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-playbacktoggle-overlay',\n      components: [this.playbackToggleButton]\n    }, this.config);\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\nimport {UIInstanceManager, UIRecommendationConfig} from '../uimanager';\nimport {StringUtils} from '../utils';\nimport {HugeReplayButton} from './hugereplaybutton';\n\n/**\n * Overlays the player and displays recommended videos.\n */\nexport class RecommendationOverlay extends Container<ContainerConfig> {\n\n  private replayButton: HugeReplayButton;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.replayButton = new HugeReplayButton();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-recommendation-overlay',\n      hidden: true,\n      components: [this.replayButton]\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let clearRecommendations = () => {\n      for (let component of this.getComponents()) {\n        if (component instanceof RecommendationItem) {\n          this.removeComponent(component);\n        }\n      }\n      this.updateComponents();\n      this.getDomElement().removeClass(this.prefixCss('recommendations'));\n    };\n\n    let setupRecommendations = () => {\n      clearRecommendations();\n\n      let hasRecommendationsInUiConfig = uimanager.getConfig().recommendations\n        && uimanager.getConfig().recommendations.length > 0;\n      let hasRecommendationsInPlayerConfig = player.getConfig().source && player.getConfig().source.recommendations\n        && player.getConfig().source.recommendations.length > 0;\n\n      // Take markers from the UI config. If no markers defined, try to take them from the player's source config.\n      let recommendations = hasRecommendationsInUiConfig ? uimanager.getConfig().recommendations :\n        hasRecommendationsInPlayerConfig ? player.getConfig().source.recommendations : null;\n\n      // Generate timeline markers from the config if we have markers and if we have a duration\n      // The duration check is for buggy platforms where the duration is not available instantly (Chrome on Android 4.3)\n      if (recommendations) {\n        let index = 1;\n        for (let item of recommendations) {\n          this.addComponent(new RecommendationItem({\n            itemConfig: item,\n            cssClasses: ['recommendation-item-' + (index++)]\n          }));\n        }\n        this.updateComponents(); // create container DOM elements\n\n        this.getDomElement().addClass(this.prefixCss('recommendations'));\n      }\n    };\n\n    // Add recommendation when a source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, setupRecommendations);\n    // Remove recommendations and hide overlay when source is unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, () => {\n      clearRecommendations();\n      this.hide();\n    });\n    // Display recommendations when playback has finished\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, () => {\n      // Dismiss ON_PLAYBACK_FINISHED events at the end of ads\n      // TODO remove this workaround once issue #1278 is solved\n      if (player.isAd()) {\n        return;\n      }\n\n      this.show();\n    });\n    // Hide recommendations when playback starts, e.g. a restart\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      this.hide();\n    });\n\n    // Init on startup\n    setupRecommendations();\n  }\n}\n\n/**\n * Configuration interface for the {@link RecommendationItem}\n */\ninterface RecommendationItemConfig extends ComponentConfig {\n  itemConfig: UIRecommendationConfig;\n}\n\n/**\n * An item of the {@link RecommendationOverlay}. Used only internally in {@link RecommendationOverlay}.\n */\nclass RecommendationItem extends Component<RecommendationItemConfig> {\n\n  constructor(config: RecommendationItemConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-recommendation-item',\n      itemConfig: null // this must be passed in from outside\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    let config = (<RecommendationItemConfig>this.config).itemConfig; // TODO fix generics and get rid of cast\n\n    let itemElement = new DOM('a', {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n      'href': config.url\n    }).css({ 'background-image': `url(${config.thumbnail})` });\n\n    let bgElement = new DOM('div', {\n      'class': this.prefixCss('background')\n    });\n    itemElement.append(bgElement);\n\n    let titleElement = new DOM('span', {\n      'class': this.prefixCss('title')\n    }).append(new DOM('span', {\n      'class': this.prefixCss('innertitle')\n    }).html(config.title));\n    itemElement.append(titleElement);\n\n    let timeElement = new DOM('span', {\n      'class': this.prefixCss('duration')\n    }).append(new DOM('span', {\n      'class': this.prefixCss('innerduration')\n    }).html(config.duration ? StringUtils.secondsToTime(config.duration) : ''));\n    itemElement.append(timeElement);\n\n    return itemElement;\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\nimport {Event, EventDispatcher, NoArgs} from '../eventdispatcher';\nimport {SeekBarLabel} from './seekbarlabel';\nimport {UIInstanceManager, TimelineMarker, SeekPreviewArgs} from '../uimanager';\nimport {Timeout} from '../timeout';\nimport {PlayerUtils} from '../utils';\nimport TimeShiftAvailabilityChangedArgs = PlayerUtils.TimeShiftAvailabilityChangedArgs;\nimport LiveStreamDetectorEventArgs = PlayerUtils.LiveStreamDetectorEventArgs;\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\n/**\n * Configuration interface for the {@link SeekBar} component.\n */\nexport interface SeekBarConfig extends ComponentConfig {\n  /**\n   * The label above the seek position.\n   */\n  label?: SeekBarLabel;\n  /**\n   * Bar will be vertical instead of horizontal if set to true.\n   */\n  vertical?: boolean;\n  /**\n   * The interval in milliseconds in which the playback position on the seek bar will be updated. The shorter the\n   * interval, the smoother it looks and the more resource intense it is. The update interval will be kept as steady\n   * as possible to avoid jitter.\n   * Set to -1 to disable smooth updating and update it on player ON_TIME_CHANGED events instead.\n   * Default: 50 (50ms = 20fps).\n   */\n  smoothPlaybackPositionUpdateIntervalMs?: number;\n}\n\n/**\n * Event argument interface for a seek preview event.\n */\nexport interface SeekPreviewEventArgs extends SeekPreviewArgs {\n  /**\n   * Tells if the seek preview event comes from a scrubbing.\n   */\n  scrubbing: boolean;\n}\n\n/**\n * A seek bar to seek within the player's media. It displays the current playback position, amount of buffed data, seek\n * target, and keeps status about an ongoing seek.\n *\n * The seek bar displays different 'bars':\n *  - the playback position, i.e. the position in the media at which the player current playback pointer is positioned\n *  - the buffer position, which usually is the playback position plus the time span that is already buffered ahead\n *  - the seek position, used to preview to where in the timeline a seek will jump to\n */\nexport class SeekBar extends Component<SeekBarConfig> {\n\n  public static readonly SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED = -1;\n\n  /**\n   * The CSS class that is added to the DOM element while the seek bar is in 'seeking' state.\n   */\n  private static readonly CLASS_SEEKING = 'seeking';\n\n  private seekBar: DOM;\n  private seekBarPlaybackPosition: DOM;\n  private seekBarPlaybackPositionMarker: DOM;\n  private seekBarBufferPosition: DOM;\n  private seekBarSeekPosition: DOM;\n  private seekBarBackdrop: DOM;\n  private seekBarMarkersContainer: DOM;\n\n  private label: SeekBarLabel;\n\n  private timelineMarkers: TimelineMarker[];\n\n  /**\n   * Buffer of the the current playback position. The position must be buffered in case the element\n   * needs to be refreshed with {@link #refreshPlaybackPosition}.\n   * @type {number}\n   */\n  private playbackPositionPercentage = 0;\n\n  private smoothPlaybackPositionUpdater: Timeout;\n\n  // https://hacks.mozilla.org/2013/04/detecting-touch-its-the-why-not-the-how/\n  private touchSupported = ('ontouchstart' in window);\n\n  private seekBarEvents = {\n    /**\n     * Fired when a scrubbing seek operation is started.\n     */\n    onSeek: new EventDispatcher<SeekBar, NoArgs>(),\n    /**\n     * Fired during a scrubbing seek to indicate that the seek preview (i.e. the video frame) should be updated.\n     */\n    onSeekPreview: new EventDispatcher<SeekBar, SeekPreviewEventArgs>(),\n    /**\n     * Fired when a scrubbing seek has finished or when a direct seek is issued.\n     */\n    onSeeked: new EventDispatcher<SeekBar, number>()\n  };\n\n  constructor(config: SeekBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-seekbar',\n      vertical: false,\n      smoothPlaybackPositionUpdateIntervalMs: 50,\n    }, this.config);\n\n    this.label = this.config.label;\n    this.timelineMarkers = [];\n  }\n\n  initialize(): void {\n    super.initialize();\n\n    if (this.hasLabel()) {\n      this.getLabel().initialize();\n    }\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager, configureSeek: boolean = true): void {\n    super.configure(player, uimanager);\n\n    if (!configureSeek) {\n      // The configureSeek flag can be used by subclasses to disable configuration as seek bar. E.g. the volume\n      // slider is reusing this component but adds its own functionality, and does not need the seek functionality.\n      // This is actually a hack, the proper solution would be for both seek bar and volume sliders to extend\n      // a common base slider component and implement their functionality there.\n      return;\n    }\n\n    let playbackNotInitialized = true;\n    let isPlaying = false;\n    let isSeeking = false;\n\n    // Update playback and buffer positions\n    let playbackPositionHandler = (event: PlayerEvent = null, forceUpdate: boolean = false) => {\n      // Once this handler os called, playback has been started and we set the flag to false\n      playbackNotInitialized = false;\n\n      if (isSeeking) {\n        // We caught a seek preview seek, do not update the seekbar\n        return;\n      }\n\n      if (player.isLive()) {\n        if (player.getMaxTimeShift() === 0) {\n          // This case must be explicitly handled to avoid division by zero\n          this.setPlaybackPosition(100);\n        }\n        else {\n          let playbackPositionPercentage = 100 - (100 / player.getMaxTimeShift() * player.getTimeShift());\n          this.setPlaybackPosition(playbackPositionPercentage);\n        }\n\n        // Always show full buffer for live streams\n        this.setBufferPosition(100);\n      }\n      else {\n        let playbackPositionPercentage = 100 / player.getDuration() * player.getCurrentTime();\n\n        let videoBufferLength = player.getVideoBufferLength();\n        let audioBufferLength = player.getAudioBufferLength();\n        // Calculate the buffer length which is the smaller length of the audio and video buffers. If one of these\n        // buffers is not available, we set it's value to MAX_VALUE to make sure that the other real value is taken\n        // as the buffer length.\n        let bufferLength = Math.min(\n          videoBufferLength != null ? videoBufferLength : Number.MAX_VALUE,\n          audioBufferLength != null ? audioBufferLength : Number.MAX_VALUE);\n        // If both buffer lengths are missing, we set the buffer length to zero\n        if (bufferLength === Number.MAX_VALUE) {\n          bufferLength = 0;\n        }\n\n        let bufferPercentage = 100 / player.getDuration() * bufferLength;\n\n        // Update playback position only in paused state or in the initial startup state where player is neither\n        // paused nor playing. Playback updates are handled in the Timeout below.\n        if (this.config.smoothPlaybackPositionUpdateIntervalMs === SeekBar.SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED\n          || forceUpdate || player.isPaused() || (player.isPaused() === player.isPlaying())) {\n          this.setPlaybackPosition(playbackPositionPercentage);\n        }\n\n        this.setBufferPosition(playbackPositionPercentage + bufferPercentage);\n      }\n    };\n\n    // Update seekbar upon these events\n    // init playback position when the player is ready\n    player.addEventHandler(player.EVENT.ON_READY, playbackPositionHandler);\n    // update playback position when it changes\n    player.addEventHandler(player.EVENT.ON_TIME_CHANGED, playbackPositionHandler);\n    // update bufferlevel when buffering is complete\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, playbackPositionHandler);\n    // update playback position when a seek has finished\n    player.addEventHandler(player.EVENT.ON_SEEKED, playbackPositionHandler);\n    // update playback position when a timeshift has finished\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, playbackPositionHandler);\n    // update bufferlevel when a segment has been downloaded\n    player.addEventHandler(player.EVENT.ON_SEGMENT_REQUEST_FINISHED, playbackPositionHandler);\n    // update playback position of Cast playback\n    player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, playbackPositionHandler);\n\n\n    // Seek handling\n    player.addEventHandler(player.EVENT.ON_SEEK, () => {\n      this.setSeeking(true);\n    });\n    player.addEventHandler(player.EVENT.ON_SEEKED, () => {\n      this.setSeeking(false);\n    });\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, () => {\n      this.setSeeking(true);\n    });\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, () => {\n      this.setSeeking(false);\n    });\n\n    let seek = (percentage: number) => {\n      if (player.isLive()) {\n        player.timeShift(player.getMaxTimeShift() - (player.getMaxTimeShift() * (percentage / 100)));\n      } else {\n        player.seek(player.getDuration() * (percentage / 100));\n      }\n    };\n    this.onSeek.subscribe((sender) => {\n      isSeeking = true; // track seeking status so we can catch events from seek preview seeks\n\n      // Notify UI manager of started seek\n      uimanager.onSeek.dispatch(sender);\n\n      // Save current playback state\n      isPlaying = player.isPlaying();\n\n      // Pause playback while seeking\n      if (isPlaying) {\n        player.pause('ui-seek');\n      }\n    });\n    this.onSeekPreview.subscribe((sender: SeekBar, args: SeekPreviewEventArgs) => {\n      // Notify UI manager of seek preview\n      uimanager.onSeekPreview.dispatch(sender, args);\n    });\n    this.onSeekPreview.subscribeRateLimited((sender: SeekBar, args: SeekPreviewEventArgs) => {\n      // Rate-limited scrubbing seek\n      if (args.scrubbing) {\n        seek(args.position);\n      }\n    }, 200);\n    this.onSeeked.subscribe((sender, percentage) => {\n      isSeeking = false;\n\n      // Do the seek\n      seek(percentage);\n\n      // Continue playback after seek if player was playing when seek started\n      if (isPlaying) {\n        player.play('ui-seek');\n      }\n\n      // Notify UI manager of finished seek\n      uimanager.onSeeked.dispatch(sender);\n    });\n\n    if (this.hasLabel()) {\n      // Configure a seekbar label that is internal to the seekbar)\n      this.getLabel().configure(player, uimanager);\n    }\n\n    // Hide seekbar for live sources without timeshift\n    let isLive = false;\n    let hasTimeShift = false;\n    let switchVisibility = (isLive: boolean, hasTimeShift: boolean) => {\n      if (isLive && !hasTimeShift) {\n        this.hide();\n      } else {\n        this.show();\n      }\n      playbackPositionHandler(null, true);\n      this.refreshPlaybackPosition();\n    };\n    new PlayerUtils.LiveStreamDetector(player).onLiveChanged.subscribe((sender, args: LiveStreamDetectorEventArgs) => {\n      isLive = args.live;\n      switchVisibility(isLive, hasTimeShift);\n    });\n    new PlayerUtils.TimeShiftAvailabilityDetector(player).onTimeShiftAvailabilityChanged.subscribe(\n      (sender, args: TimeShiftAvailabilityChangedArgs) => {\n        hasTimeShift = args.timeShiftAvailable;\n        switchVisibility(isLive, hasTimeShift);\n      }\n    );\n\n    // Refresh the playback position when the player resized or the UI is configured. The playback position marker\n    // is positioned absolutely and must therefore be updated when the size of the seekbar changes.\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => {\n      this.refreshPlaybackPosition();\n    });\n    // Additionally, when this code is called, the seekbar is not part of the UI yet and therefore does not have a size,\n    // resulting in a wrong initial position of the marker. Refreshing it once the UI is configured solved this issue.\n    uimanager.onConfigured.subscribe(() => {\n      this.refreshPlaybackPosition();\n    });\n    // It can also happen that the value changes once the player is ready, or when a new source is loaded, so we need\n    // to update on ON_READY too\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      this.refreshPlaybackPosition();\n    });\n\n    // Initialize seekbar\n    playbackPositionHandler(); // Set the playback position\n    this.setBufferPosition(0);\n    this.setSeekPosition(0);\n    if (this.config.smoothPlaybackPositionUpdateIntervalMs !== SeekBar.SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED) {\n      this.configureSmoothPlaybackPositionUpdater(player, uimanager);\n    }\n    this.configureMarkers(player, uimanager);\n  }\n\n  private configureSmoothPlaybackPositionUpdater(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    /*\n     * Playback position update\n     *\n     * We do not update the position directly from the ON_TIME_CHANGED event, because it arrives very jittery and\n     * results in a jittery position indicator since the CSS transition time is statically set.\n     * To work around this issue, we maintain a local playback position that is updated in a stable regular interval\n     * and kept in sync with the player.\n     */\n    let currentTimeSeekBar = 0;\n    let currentTimePlayer = 0;\n    let updateIntervalMs = 50;\n    let currentTimeUpdateDeltaSecs = updateIntervalMs / 1000;\n\n    this.smoothPlaybackPositionUpdater = new Timeout(updateIntervalMs, () => {\n      currentTimeSeekBar += currentTimeUpdateDeltaSecs;\n      currentTimePlayer = player.getCurrentTime();\n\n      // Sync currentTime of seekbar to player\n      let currentTimeDelta = currentTimeSeekBar - currentTimePlayer;\n      // If the delta is larger that 2 secs, directly jump the seekbar to the\n      // player time instead of smoothly fast forwarding/rewinding.\n      if (Math.abs(currentTimeDelta) > 2) {\n        currentTimeSeekBar = currentTimePlayer;\n      }\n      // If currentTimeDelta is negative and below the adjustment threshold,\n      // the player is ahead of the seekbar and we 'fast forward' the seekbar\n      else if (currentTimeDelta <= -currentTimeUpdateDeltaSecs) {\n        currentTimeSeekBar += currentTimeUpdateDeltaSecs;\n      }\n      // If currentTimeDelta is positive and above the adjustment threshold,\n      // the player is behind the seekbar and we 'rewind' the seekbar\n      else if (currentTimeDelta >= currentTimeUpdateDeltaSecs) {\n        currentTimeSeekBar -= currentTimeUpdateDeltaSecs;\n      }\n\n      let playbackPositionPercentage = 100 / player.getDuration() * currentTimeSeekBar;\n      this.setPlaybackPosition(playbackPositionPercentage);\n    }, true);\n\n    let startSmoothPlaybackPositionUpdater = () => {\n      if (!player.isLive()) {\n        currentTimeSeekBar = player.getCurrentTime();\n        this.smoothPlaybackPositionUpdater.start();\n      }\n    };\n\n    let stopSmoothPlaybackPositionUpdater = () => {\n      this.smoothPlaybackPositionUpdater.clear();\n    };\n\n    player.addEventHandler(player.EVENT.ON_PLAY, startSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYING, startSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_PAUSED, stopSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_CAST_PAUSED, stopSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_SEEKED, () => {\n      currentTimeSeekBar = player.getCurrentTime();\n    });\n\n    if (player.isPlaying()) {\n      startSmoothPlaybackPositionUpdater();\n    }\n  }\n\n  private configureMarkers(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let clearMarkers = () => {\n      this.timelineMarkers = [];\n      this.updateMarkers();\n    };\n\n    let setupMarkers = () => {\n      clearMarkers();\n\n      let hasMarkersInUiConfig = uimanager.getConfig().metadata && uimanager.getConfig().metadata.markers\n        && uimanager.getConfig().metadata.markers.length > 0;\n      let hasMarkersInPlayerConfig = player.getConfig().source && player.getConfig().source.markers\n        && player.getConfig().source.markers.length > 0;\n\n      // Take markers from the UI config. If no markers defined, try to take them from the player's source config.\n      let markers = hasMarkersInUiConfig ? uimanager.getConfig().metadata.markers :\n        hasMarkersInPlayerConfig ? player.getConfig().source.markers : null;\n\n      // Generate timeline markers from the config if we have markers and if we have a duration\n      // The duration check is for buggy platforms where the duration is not available instantly (Chrome on Android 4.3)\n      if (markers && player.getDuration() !== Infinity) {\n        for (let o of markers) {\n          let marker = {\n            time: 100 / player.getDuration() * o.time, // convert time to percentage\n            title: o.title,\n            markerType: '' + (o.markerType || 1),\n            comment: o.comment || '',\n            avatar: o.avatar,\n            number: o.number || ''\n          }\n          this.timelineMarkers.push(marker)\n        }\n      }\n\n      // Populate the timeline with the markers\n      this.updateMarkers();\n    };\n\n    // Add markers when a source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, setupMarkers);\n    // Remove markers when unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, clearMarkers);\n\n    // Init markers at startup\n    setupMarkers();\n  }\n\n  release(): void {\n    super.release();\n\n    if (this.smoothPlaybackPositionUpdater) { // object must not necessarily exist, e.g. in volume slider subclass\n      this.smoothPlaybackPositionUpdater.clear();\n    }\n  }\n\n  protected toDomElement(): DOM {\n    if (this.config.vertical) {\n      this.config.cssClasses.push('vertical');\n    }\n\n    let seekBarContainer = new DOM('div', {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    let seekBar = new DOM('div', {\n      'class': this.prefixCss('seekbar')\n    });\n    this.seekBar = seekBar;\n\n    // Indicator that shows the buffer fill level\n    let seekBarBufferLevel = new DOM('div', {\n      'class': this.prefixCss('seekbar-bufferlevel')\n    });\n    this.seekBarBufferPosition = seekBarBufferLevel;\n\n    // Indicator that shows the current playback position\n    let seekBarPlaybackPosition = new DOM('div', {\n      'class': this.prefixCss('seekbar-playbackposition')\n    });\n    this.seekBarPlaybackPosition = seekBarPlaybackPosition;\n\n    // A marker of the current playback position, e.g. a dot or line\n    let seekBarPlaybackPositionMarker = new DOM('div', {\n      'class': this.prefixCss('seekbar-playbackposition-marker')\n    });\n    this.seekBarPlaybackPositionMarker = seekBarPlaybackPositionMarker;\n\n    // Indicator that show where a seek will go to\n    let seekBarSeekPosition = new DOM('div', {\n      'class': this.prefixCss('seekbar-seekposition')\n    });\n    this.seekBarSeekPosition = seekBarSeekPosition;\n\n    // Indicator that shows the full seekbar\n    let seekBarBackdrop = new DOM('div', {\n      'class': this.prefixCss('seekbar-backdrop')\n    });\n    this.seekBarBackdrop = seekBarBackdrop;\n\n    let seekBarChapterMarkersContainer = new DOM('div', {\n      'class': this.prefixCss('seekbar-markers')\n    });\n    this.seekBarMarkersContainer = seekBarChapterMarkersContainer;\n\n    seekBar.append(seekBarBackdrop, seekBarBufferLevel, seekBarSeekPosition,\n      seekBarPlaybackPosition, seekBarChapterMarkersContainer, seekBarPlaybackPositionMarker);\n\n    let seeking = false;\n\n    // Define handler functions so we can attach/remove them later\n    let mouseTouchMoveHandler = (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n      // Avoid propagation to VR handler\n      e.stopPropagation();\n\n      let targetPercentage = 100 * this.getOffset(e);\n      this.setSeekPosition(targetPercentage);\n      this.setPlaybackPosition(targetPercentage);\n      this.onSeekPreviewEvent(targetPercentage, true);\n    };\n    let mouseTouchUpHandler = (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      // Remove handlers, seek operation is finished\n      new DOM(document).off('touchmove mousemove', mouseTouchMoveHandler);\n      new DOM(document).off('touchend mouseup', mouseTouchUpHandler);\n\n      let targetPercentage = 100 * this.getOffset(e);\n      let snappedChapter = this.getMarkerAtPosition(targetPercentage);\n\n      this.setSeeking(false);\n      seeking = false;\n\n      // Fire seeked event\n      this.onSeekedEvent(snappedChapter ? snappedChapter.time : targetPercentage);\n    };\n\n    // A seek always start with a touchstart or mousedown directly on the seekbar.\n    // To track a mouse seek also outside the seekbar (for touch events this works automatically),\n    // so the user does not need to take care that the mouse always stays on the seekbar, we attach the mousemove\n    // and mouseup handlers to the whole document. A seek is triggered when the user lifts the mouse key.\n    // A seek mouse gesture is thus basically a click with a long time frame between down and up events.\n    seekBar.on('touchstart mousedown', (e: MouseEvent | TouchEvent) => {\n      let isTouchEvent = this.touchSupported && e instanceof TouchEvent;\n\n      // Prevent selection of DOM elements (also prevents mousedown if current event is touchstart)\n      e.preventDefault();\n      // Avoid propagation to VR handler\n      e.stopPropagation();\n\n      this.setSeeking(true); // Set seeking class on DOM element\n      seeking = true; // Set seek tracking flag\n\n      // Fire seeked event\n      this.onSeekEvent();\n\n      // Add handler to track the seek operation over the whole document\n      new DOM(document).on(isTouchEvent ? 'touchmove' : 'mousemove', mouseTouchMoveHandler);\n      new DOM(document).on(isTouchEvent ? 'touchend' : 'mouseup', mouseTouchUpHandler);\n    });\n\n    // Display seek target indicator when mouse hovers or finger slides over seekbar\n    seekBar.on('touchmove mousemove', (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      if (seeking) {\n        // During a seek (when mouse is down or touch move active), we need to stop propagation to avoid\n        // the VR viewport reacting to the moves.\n        e.stopPropagation();\n        // Because the stopped propagation inhibits the event on the document, we need to call it from here\n        mouseTouchMoveHandler(e);\n      }\n\n      let position = 100 * this.getOffset(e);\n      this.setSeekPosition(position);\n      this.onSeekPreviewEvent(position, false);\n\n      if (this.hasLabel() && this.getLabel().isHidden()) {\n        this.getLabel().show();\n      }\n    });\n\n    // Hide seek target indicator when mouse or finger leaves seekbar\n    seekBar.on('touchend mouseleave', (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      this.setSeekPosition(0);\n\n      if (this.hasLabel()) {\n        this.getLabel().hide();\n      }\n    });\n\n    seekBarContainer.append(seekBar);\n\n    if (this.label) {\n      seekBarContainer.append(this.label.getDomElement());\n    }\n\n    return seekBarContainer;\n  }\n\n  protected updateMarkers(): void {\n    this.seekBarMarkersContainer.empty();\n\n    for (let marker of this.timelineMarkers) {\n      let className = marker.markerType === '2' ? this.prefixCss('seekbar-marker-typetwo') : this.prefixCss('seekbar-marker')\n\n      let markerDom = new DOM('div', {\n        'class': className,\n        'data-marker-time': String(marker.time),\n        'data-marker-title': String(marker.title),\n      }).css({\n        'width': marker.time + '%',\n      })\n      this.seekBarMarkersContainer.append(markerDom)\n    }\n  }\n\n  protected getMarkerAtPosition(percentage: number): TimelineMarker | null {\n    let snappedMarker: TimelineMarker = null;\n    let snappingRange = 1;\n    if (this.timelineMarkers.length > 0) {\n      for (let marker of this.timelineMarkers) {\n        if (percentage >= marker.time - snappingRange && percentage <= marker.time + snappingRange) {\n          snappedMarker = marker;\n          break;\n        }\n      }\n    }\n\n    return snappedMarker;\n  }\n\n  /**\n   * Gets the horizontal offset of a mouse/touch event point from the left edge of the seek bar.\n   * @param eventPageX the pageX coordinate of an event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1], where 0 is the left edge and 1 is the right edge\n   */\n  private getHorizontalOffset(eventPageX: number): number {\n    let elementOffsetPx = this.seekBar.offset().left;\n    let widthPx = this.seekBar.width();\n    let offsetPx = eventPageX - elementOffsetPx;\n    let offset = 1 / widthPx * offsetPx;\n\n    return this.sanitizeOffset(offset);\n  }\n\n  /**\n   * Gets the vertical offset of a mouse/touch event point from the bottom edge of the seek bar.\n   * @param eventPageY the pageX coordinate of an event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1], where 0 is the bottom edge and 1 is the top edge\n   */\n  private getVerticalOffset(eventPageY: number): number {\n    let elementOffsetPx = this.seekBar.offset().top;\n    let widthPx = this.seekBar.height();\n    let offsetPx = eventPageY - elementOffsetPx;\n    let offset = 1 / widthPx * offsetPx;\n\n    return 1 - this.sanitizeOffset(offset);\n  }\n\n  /**\n   * Gets the mouse or touch event offset for the current configuration (horizontal or vertical).\n   * @param e the event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1]\n   * @see #getHorizontalOffset\n   * @see #getVerticalOffset\n   */\n  private getOffset(e: MouseEvent | TouchEvent): number {\n    if (this.touchSupported && e instanceof TouchEvent) {\n      if (this.config.vertical) {\n        return this.getVerticalOffset(e.type === 'touchend' ? e.changedTouches[0].pageY : e.touches[0].pageY);\n      } else {\n        return this.getHorizontalOffset(e.type === 'touchend' ? e.changedTouches[0].pageX : e.touches[0].pageX);\n      }\n    }\n    else if (e instanceof MouseEvent) {\n      if (this.config.vertical) {\n        return this.getVerticalOffset(e.pageY);\n      } else {\n        return this.getHorizontalOffset(e.pageX);\n      }\n    }\n    else {\n      if (console) {\n        console.warn('invalid event');\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Sanitizes the mouse offset to the range of [0, 1].\n   *\n   * When tracking the mouse outside the seek bar, the offset can be outside the desired range and this method\n   * limits it to the desired range. E.g. a mouse event left of the left edge of a seek bar yields an offset below\n   * zero, but to display the seek target on the seek bar, we need to limit it to zero.\n   *\n   * @param offset the offset to sanitize\n   * @returns {number} the sanitized offset.\n   */\n  private sanitizeOffset(offset: number) {\n    // Since we track mouse moves over the whole document, the target can be outside the seek range,\n    // and we need to limit it to the [0, 1] range.\n    if (offset < 0) {\n      offset = 0;\n    } else if (offset > 1) {\n      offset = 1;\n    }\n\n    return offset;\n  }\n\n  /**\n   * Sets the position of the playback position indicator.\n   * @param percent a number between 0 and 100 as returned by the player\n   */\n  setPlaybackPosition(percent: number) {\n    this.playbackPositionPercentage = percent;\n\n    // Set position of the bar\n    this.setPosition(this.seekBarPlaybackPosition, percent);\n\n    // Set position of the marker\n    let px = (this.config.vertical ? this.seekBar.height() : this.seekBar.width()) / 100 * percent;\n    if (this.config.vertical) {\n      px = this.seekBar.height() - px;\n    }\n    let style = this.config.vertical ?\n      // -ms-transform required for IE9\n      { 'transform': 'translateY(' + px + 'px)', '-ms-transform': 'translateY(' + px + 'px)' } :\n      { 'transform': 'translateX(' + px + 'px)', '-ms-transform': 'translateX(' + px + 'px)' };\n    this.seekBarPlaybackPositionMarker.css(style);\n  }\n\n  /**\n   * Refreshes the playback position. Can be used by subclasses to refresh the position when\n   * the size of the component changes.\n   */\n  protected refreshPlaybackPosition() {\n    this.setPlaybackPosition(this.playbackPositionPercentage);\n  }\n\n  /**\n   * Sets the position until which media is buffered.\n   * @param percent a number between 0 and 100\n   */\n  setBufferPosition(percent: number) {\n    this.setPosition(this.seekBarBufferPosition, percent);\n  }\n\n  /**\n   * Sets the position where a seek, if executed, would jump to.\n   * @param percent a number between 0 and 100\n   */\n  setSeekPosition(percent: number) {\n    this.setPosition(this.seekBarSeekPosition, percent);\n  }\n\n  /**\n   * Set the actual position (width or height) of a DOM element that represent a bar in the seek bar.\n   * @param element the element to set the position for\n   * @param percent a number between 0 and 100\n   */\n  private setPosition(element: DOM, percent: number) {\n    let scale = percent / 100;\n    let style = this.config.vertical ?\n      // -ms-transform required for IE9\n      { 'transform': 'scaleY(' + scale + ')', '-ms-transform': 'scaleY(' + scale + ')' } :\n      { 'transform': 'scaleX(' + scale + ')', '-ms-transform': 'scaleX(' + scale + ')' };\n    element.css(style);\n  }\n\n  /**\n   * Puts the seek bar into or out of seeking state by adding/removing a class to the DOM element. This can be used\n   * to adjust the styling while seeking.\n   *\n   * @param seeking should be true when entering seek state, false when exiting the seek state\n   */\n  setSeeking(seeking: boolean) {\n    if (seeking) {\n      this.getDomElement().addClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n    } else {\n      this.getDomElement().removeClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n    }\n  }\n\n  /**\n   * Checks if the seek bar is currently in the seek state.\n   * @returns {boolean} true if in seek state, else false\n   */\n  isSeeking(): boolean {\n    return this.getDomElement().hasClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n  }\n\n  /**\n   * Checks if the seek bar has a {@link SeekBarLabel}.\n   * @returns {boolean} true if the seek bar has a label, else false\n   */\n  hasLabel(): boolean {\n    return this.label != null;\n  }\n\n  /**\n   * Gets the label of this seek bar.\n   * @returns {SeekBarLabel} the label if this seek bar has a label, else null\n   */\n  getLabel(): SeekBarLabel | null {\n    return this.label;\n  }\n\n  protected onSeekEvent() {\n    this.seekBarEvents.onSeek.dispatch(this);\n  }\n\n  protected onSeekPreviewEvent(percentage: number, scrubbing: boolean) {\n    let snappedMarker = this.getMarkerAtPosition(percentage);\n\n    if (this.label) {\n      this.label.getDomElement().css({\n        'left': (snappedMarker ? snappedMarker.time : percentage) + '%'\n      });\n    }\n\n    this.seekBarEvents.onSeekPreview.dispatch(this, {\n      scrubbing: scrubbing,\n      position: percentage,\n      marker: snappedMarker,\n    });\n  }\n\n  protected onSeekedEvent(percentage: number) {\n    this.seekBarEvents.onSeeked.dispatch(this, percentage);\n  }\n\n  /**\n   * Gets the event that is fired when a scrubbing seek operation is started.\n   * @returns {Event<SeekBar, NoArgs>}\n   */\n  get onSeek(): Event<SeekBar, NoArgs> {\n    return this.seekBarEvents.onSeek.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired during a scrubbing seek (to indicate that the seek preview, i.e. the video frame,\n   * should be updated), or during a normal seek preview when the seek bar is hovered (and the seek target,\n   * i.e. the seek bar label, should be updated).\n   * @returns {Event<SeekBar, SeekPreviewEventArgs>}\n   */\n  get onSeekPreview(): Event<SeekBar, SeekPreviewEventArgs> {\n    return this.seekBarEvents.onSeekPreview.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when a scrubbing seek has finished or when a direct seek is issued.\n   * @returns {Event<SeekBar, number>}\n   */\n  get onSeeked(): Event<SeekBar, number> {\n    return this.seekBarEvents.onSeeked.getEvent();\n  }\n\n\n  protected onShowEvent(): void {\n    super.onShowEvent();\n\n    // Refresh the position of the playback position when the seek bar becomes visible. To correctly set the position,\n    // the DOM element must be fully initialized an have its size calculated, because the position is set as an absolute\n    // value calculated from the size. This required size is not known when it is hidden.\n    // For such cases, we refresh the position here in onShow because here it is guaranteed that the component knows\n    // its size and can set the position correctly.\n    this.refreshPlaybackPosition();\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {Label, LabelConfig} from './label';\nimport {Component, ComponentConfig} from './component';\nimport {UIInstanceManager, SeekPreviewArgs} from '../uimanager';\nimport {StringUtils} from '../utils';\n\n/**\n * Configuration interface for a {@link SeekBarLabel}.\n */\nexport interface SeekBarLabelConfig extends ContainerConfig {\n  // nothing yet\n}\n\n/**\n * A label for a {@link SeekBar} that can display the seek target time, a thumbnail, and title (e.g. chapter title).\n */\nexport class SeekBarLabel extends Container<SeekBarLabelConfig> {\n\n  private timeLabel: Label<LabelConfig>;\n  private titleLabel: Label<LabelConfig>;\n  private numberLabel: Label<LabelConfig>;\n  private commentLabel: Label<LabelConfig>;\n  private avatarLabel: Label<LabelConfig>;\n  private thumbnail: Component<ComponentConfig>;\n  private metadata: Component<ComponentConfig>;\n\n  private timeFormat: string;\n\n  constructor(config: SeekBarLabelConfig = {}) {\n    super(config);\n\n    this.timeLabel = new Label({cssClasses: ['seekbar-label-time']});\n    this.titleLabel = new Label({cssClasses: ['seekbar-label-title']});\n    this.commentLabel = new Label({cssClasses: ['seekbar-label-comment']});\n    this.numberLabel = new Label({cssClasses: ['seekbar-label-number']});\n    this.avatarLabel = new Label({cssClasses: ['seekbar-label-avatar']});\n    this.thumbnail = new Component({cssClasses: ['seekbar-thumbnail']});\n    this.metadata = new Container({\n      components: [\n        new Container({\n          components: [\n            this.avatarLabel,\n            this.titleLabel,\n            this.numberLabel],\n          cssClass: 'seekbar-label-metadata-title',\n        }),\n        new Container({\n          components: [\n            this.commentLabel,\n            this.timeLabel],\n          cssClass: 'seekbar-label-metadata-content',\n        }),\n      ],\n      cssClass: 'seekbar-label-metadata'\n    });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-seekbar-label',\n      components: [new Container({\n        components: [\n          this.thumbnail,\n          this.metadata\n        ],\n        cssClass: 'seekbar-label-inner',\n      })],\n      hidden: true\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    uimanager.onSeekPreview.subscribe((sender, args: SeekPreviewArgs) => {\n      if (player.isLive()) {\n        let time = player.getMaxTimeShift() - player.getMaxTimeShift() * (args.position / 100);\n        this.setTime(time);\n      } else {\n        let percentage = 0;\n        if (args.marker) {\n          this.setTitleText(args.marker.title);\n          this.setSmashcutData(args.marker);\n          this.setTime(args.marker.time);\n          this.setThumbnail(null);\n          this.setBackground(true);\n        } else {\n          percentage = args.position;\n          this.setTitleText(null);\n          this.setSmashcutData(null);\n          let time = player.getDuration() * (percentage / 100);\n          this.setTime(time);\n          this.setThumbnail(player.getThumb(time));\n          this.setBackground(false);\n        }\n      }\n    });\n\n    let init = () => {\n      // Set time format depending on source duration\n      this.timeFormat = Math.abs(player.isLive() ? player.getMaxTimeShift() : player.getDuration()) >= 3600 ?\n        StringUtils.FORMAT_HHMMSS : StringUtils.FORMAT_MMSS;\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, init);\n    init();\n  }\n\n  /**\n   * Sets arbitrary text on the label.\n   * @param text the text to show on the label\n   */\n  setText(text: string) {\n    this.timeLabel.setText(text);\n  }\n\n  /**\n   * Sets a time to be displayed on the label.\n   * @param seconds the time in seconds to display on the label\n   */\n  setTime(seconds: number) {\n    this.setText(StringUtils.secondsToTime(seconds, this.timeFormat));\n  }\n\n  /**\n   * Sets the text on the title label.\n   * @param text the text to show on the label\n   */\n  setTitleText(text: string) {\n    this.titleLabel.setText(text);\n  }\n\n  setSmashcutData(marker: any) {\n    if (marker) {\n      this.commentLabel.setText(marker.comment);\n      this.numberLabel.setText(marker.number);\n      this.avatarLabel.setText(marker.avatar);\n    } else {\n      this.commentLabel.setText(null);\n      this.numberLabel.setText(null);\n      this.avatarLabel.setText(null);\n    }\n  }\n\n  /**\n   * Sets or removes a thumbnail on the label.\n   * @param thumbnail the thumbnail to display on the label or null to remove a displayed thumbnail\n   */\n  setThumbnail(thumbnail: bitmovin.player.Thumbnail = null) {\n    let thumbnailElement = this.thumbnail.getDomElement();\n\n    if (thumbnail == null) {\n      thumbnailElement.css({\n        'background-image': null,\n        'display': 'null',\n        'width': 'null',\n        'height': 'null'\n      });\n    }\n    else {\n      thumbnailElement.css({\n        'display': 'inherit',\n        'background-image': `url(${thumbnail.url})`,\n        'width': thumbnail.w + 'px',\n        'height': thumbnail.h + 'px',\n        'background-position': `-${thumbnail.x}px -${thumbnail.y}px`\n      });\n    }\n  }\n\n  setBackground(onOff: boolean) {\n    let metadataElement = this.metadata.getDomElement();\n\n    if (onOff) {\n      metadataElement.css({\n        'background': '#000'\n      });\n    }\n    else {\n      metadataElement.css({\n        'background': 'initial'\n      });\n    }\n  }\n}","import {ListSelector, ListSelectorConfig} from './listselector';\nimport {DOM} from '../dom';\n\n/**\n * A simple select box providing the possibility to select a single item out of a list of available items.\n *\n * DOM example:\n * <code>\n *     <select class='ui-selectbox'>\n *         <option value='key'>label</option>\n *         ...\n *     </select>\n * </code>\n */\nexport class SelectBox extends ListSelector<ListSelectorConfig> {\n\n  private selectElement: DOM;\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-selectbox'\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    let selectElement = new DOM('select', {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    this.selectElement = selectElement;\n    this.updateDomItems();\n\n    selectElement.on('change', () => {\n      let value = selectElement.val();\n      this.onItemSelectedEvent(value, false);\n    });\n\n    return selectElement;\n  }\n\n  protected updateDomItems(selectedValue: string = null) {\n    // Delete all children\n    this.selectElement.empty();\n\n    // Add updated children\n    for (let item of this.items) {\n      let optionElement = new DOM('option', {\n        'value': item.key\n      }).html(item.label);\n\n      if (item.key === selectedValue + '') { // convert selectedValue to string to catch 'null'/null case\n        optionElement.attr('selected', 'selected');\n      }\n\n      this.selectElement.append(optionElement);\n    }\n  }\n\n  protected onItemAddedEvent(value: string) {\n    super.onItemAddedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemRemovedEvent(value: string) {\n    super.onItemRemovedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemSelectedEvent(value: string, updateDomItems: boolean = true) {\n    super.onItemSelectedEvent(value);\n    if (updateDomItems) {\n      this.updateDomItems(value);\n    }\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {SelectBox} from './selectbox';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {VideoQualitySelectBox} from './videoqualityselectbox';\nimport {AudioQualitySelectBox} from './audioqualityselectbox';\nimport {Timeout} from '../timeout';\nimport {Event, EventDispatcher, NoArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link SettingsPanel}.\n */\nexport interface SettingsPanelConfig extends ContainerConfig {\n  /**\n   * The delay in milliseconds after which the settings panel will be hidden when there is no user interaction.\n   * Set to -1 to disable automatic hiding.\n   * Default: 3 seconds (3000)\n   */\n  hideDelay?: number;\n}\n\n/**\n * A panel containing a list of {@link SettingsPanelItem items} that represent labelled settings.\n */\nexport class SettingsPanel extends Container<SettingsPanelConfig> {\n\n  private static readonly CLASS_LAST = 'last';\n\n  private settingsPanelEvents = {\n    onSettingsStateChanged: new EventDispatcher<SettingsPanel, NoArgs>()\n  };\n\n  private hideTimeout: Timeout;\n\n  constructor(config: SettingsPanelConfig) {\n    super(config);\n\n    this.config = this.mergeConfig<SettingsPanelConfig>(config, {\n      cssClass: 'ui-settings-panel',\n      hideDelay: 3000\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <SettingsPanelConfig>this.getConfig(); // TODO fix generics type inference\n\n    if (config.hideDelay > -1) {\n      this.hideTimeout = new Timeout(config.hideDelay, () => {\n        this.hide();\n      });\n\n      this.onShow.subscribe(() => {\n        // Activate timeout when shown\n        this.hideTimeout.start();\n      });\n      this.getDomElement().on('mousemove', () => {\n        // Reset timeout on interaction\n        this.hideTimeout.reset();\n      });\n      this.onHide.subscribe(() => {\n        // Clear timeout when hidden from outside\n        this.hideTimeout.clear();\n      });\n    }\n\n    // Fire event when the state of a settings-item has changed\n    let settingsStateChangedHandler = () => {\n      this.onSettingsStateChangedEvent();\n\n      // Attach marker class to last visible item\n      let lastShownItem = null;\n      for (let component of this.getItems()) {\n        if (component instanceof SettingsPanelItem) {\n          component.getDomElement().removeClass(this.prefixCss(SettingsPanel.CLASS_LAST));\n          if (component.isShown()) {\n            lastShownItem = component;\n          }\n        }\n      }\n      if (lastShownItem) {\n        lastShownItem.getDomElement().addClass(this.prefixCss(SettingsPanel.CLASS_LAST));\n      }\n    };\n    for (let component of this.getItems()) {\n      if (component instanceof SettingsPanelItem) {\n        component.onActiveChanged.subscribe(settingsStateChangedHandler);\n      }\n    }\n  }\n\n  release(): void {\n    super.release();\n    if (this.hideTimeout) {\n      this.hideTimeout.clear();\n    }\n  }\n\n  /**\n   * Checks if there are active settings within this settings panel. An active setting is a setting that is visible\n   * and enabled, which the user can interact with.\n   * @returns {boolean} true if there are active settings, false if the panel is functionally empty to a user\n   */\n  hasActiveSettings(): boolean {\n    for (let component of this.getItems()) {\n      if (component.isActive()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private getItems(): SettingsPanelItem[] {\n    return <SettingsPanelItem[]>this.config.components;\n  }\n\n  protected onSettingsStateChangedEvent() {\n    this.settingsPanelEvents.onSettingsStateChanged.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when one or more {@link SettingsPanelItem items} have changed state.\n   * @returns {Event<SettingsPanel, NoArgs>}\n   */\n  get onSettingsStateChanged(): Event<SettingsPanel, NoArgs> {\n    return this.settingsPanelEvents.onSettingsStateChanged.getEvent();\n  }\n}\n\n/**\n * An item for a {@link SettingsPanel}, containing a {@link Label} and a component that configures a setting.\n * Supported setting components: {@link SelectBox}\n */\nexport class SettingsPanelItem extends Container<ContainerConfig> {\n\n  private label: Label<LabelConfig>;\n  private setting: SelectBox;\n\n  private settingsPanelItemEvents = {\n    onActiveChanged: new EventDispatcher<SettingsPanelItem, NoArgs>()\n  };\n\n  constructor(label: string, selectBox: SelectBox, config: ContainerConfig = {}) {\n    super(config);\n\n    this.label = new Label({ text: label });\n    this.setting = selectBox;\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-settings-panel-item',\n      components: [this.label, this.setting]\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let handleConfigItemChanged = () => {\n      // The minimum number of items that must be available for the setting to be displayed\n      // By default, at least two items must be available, else a selection is not possible\n      let minItemsToDisplay = 2;\n      // Audio/video quality select boxes contain an additional 'auto' mode, which in combination with a single\n      // available quality also does not make sense\n      if (this.setting instanceof VideoQualitySelectBox || this.setting instanceof AudioQualitySelectBox) {\n        minItemsToDisplay = 3;\n      }\n\n      // Hide the setting if no meaningful choice is available\n      if (this.setting.itemCount() < minItemsToDisplay) {\n        this.hide();\n      } else {\n        this.show();\n      }\n\n      // Visibility might have changed and therefore the active state might have changed so we fire the event\n      // TODO fire only when state has really changed (e.g. check if visibility has really changed)\n      this.onActiveChangedEvent();\n    };\n\n    this.setting.onItemAdded.subscribe(handleConfigItemChanged);\n    this.setting.onItemRemoved.subscribe(handleConfigItemChanged);\n\n    // Initialize hidden state\n    handleConfigItemChanged();\n  }\n\n  /**\n   * Checks if this settings panel item is active, i.e. visible and enabled and a user can interact with it.\n   * @returns {boolean} true if the panel is active, else false\n   */\n  isActive(): boolean {\n    return this.isShown();\n  }\n\n  protected onActiveChangedEvent() {\n    this.settingsPanelItemEvents.onActiveChanged.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the 'active' state of this item changes.\n   * @see #isActive\n   * @returns {Event<SettingsPanelItem, NoArgs>}\n   */\n  get onActiveChanged(): Event<SettingsPanelItem, NoArgs> {\n    return this.settingsPanelItemEvents.onActiveChanged.getEvent();\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {SettingsPanel} from './settingspanel';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Configuration interface for the {@link SettingsToggleButton}.\n */\nexport interface SettingsToggleButtonConfig extends ToggleButtonConfig {\n  /**\n   * The settings panel whose visibility the button should toggle.\n   */\n  settingsPanel: SettingsPanel;\n\n  /**\n   * Decides if the button should be automatically hidden when the settings panel does not contain any active settings.\n   * Default: true\n   */\n  autoHideWhenNoActiveSettings?: boolean;\n}\n\n/**\n * A button that toggles visibility of a settings panel.\n */\nexport class SettingsToggleButton extends ToggleButton<SettingsToggleButtonConfig> {\n\n  constructor(config: SettingsToggleButtonConfig) {\n    super(config);\n\n    if (!config.settingsPanel) {\n      throw new Error('Required SettingsPanel is missing');\n    }\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-settingstogglebutton',\n      text: 'Settings',\n      settingsPanel: null,\n      autoHideWhenNoActiveSettings: true\n    }, <SettingsToggleButtonConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <SettingsToggleButtonConfig>this.getConfig(); // TODO fix generics type inference\n    let settingsPanel = config.settingsPanel;\n\n    this.onClick.subscribe(() => {\n      settingsPanel.toggleHidden();\n    });\n    settingsPanel.onShow.subscribe(() => {\n      // Set toggle status to on when the settings panel shows\n      this.on();\n    });\n    settingsPanel.onHide.subscribe(() => {\n      // Set toggle status to off when the settings panel hides\n      this.off();\n    });\n\n    // Handle automatic hiding of the button if there are no settings for the user to interact with\n    if (config.autoHideWhenNoActiveSettings) {\n      // Setup handler to show/hide button when the settings change\n      let settingsPanelItemsChangedHandler = () => {\n        if (settingsPanel.hasActiveSettings()) {\n          if (this.isHidden()) {\n            this.show();\n          }\n        } else {\n          if (this.isShown()) {\n            this.hide();\n          }\n        }\n      };\n      // Wire the handler to the event\n      settingsPanel.onSettingsStateChanged.subscribe(settingsPanelItemsChangedHandler);\n      // Call handler for first init at startup\n      settingsPanelItemsChangedHandler();\n    }\n  }\n}","import {Component, ComponentConfig} from './component';\n\n/**\n * A dummy component that just reserves some space and does nothing else.\n */\nexport class Spacer extends Component<ComponentConfig> {\n\n  constructor(config: ComponentConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-spacer',\n    }, this.config);\n  }\n\n\n  protected onShowEvent(): void {\n    // disable event firing by overwriting and not calling super\n  }\n\n  protected onHideEvent(): void {\n    // disable event firing by overwriting and not calling super\n  }\n\n  protected onHoverChangedEvent(hovered: boolean): void {\n    // disable event firing by overwriting and not calling super\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport SubtitleCueEvent = bitmovin.player.SubtitleCueEvent;\nimport {Label, LabelConfig} from './label';\nimport {ComponentConfig, Component} from './component';\nimport {ControlBar} from './controlbar';\n\n/**\n * Overlays the player to display subtitles.\n */\nexport class SubtitleOverlay extends Container<ContainerConfig> {\n\n  private static readonly CLASS_CONTROLBAR_VISIBLE = 'controlbar-visible';\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitle-overlay',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let subtitleManager = new ActiveSubtitleManager();\n\n    player.addEventHandler(player.EVENT.ON_CUE_ENTER, (event: SubtitleCueEvent) => {\n      let labelToAdd = subtitleManager.cueEnter(event);\n\n      this.addComponent(labelToAdd);\n      this.updateComponents();\n\n      this.show();\n    });\n    player.addEventHandler(player.EVENT.ON_CUE_EXIT, (event: SubtitleCueEvent) => {\n      let labelToRemove = subtitleManager.cueExit(event);\n\n      this.removeComponent(labelToRemove);\n      this.updateComponents();\n\n      if (!subtitleManager.hasCues) {\n        this.hide();\n      }\n    });\n\n    let subtitleClearHandler = () => {\n      this.hide();\n      subtitleManager.clear();\n      this.removeComponents();\n      this.updateComponents();\n    };\n\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_CHANGED, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_SEEK, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, subtitleClearHandler);\n\n    uimanager.onComponentShow.subscribe((component: Component<ComponentConfig>) => {\n      if (component instanceof ControlBar) {\n        this.getDomElement().addClass(this.prefixCss(SubtitleOverlay.CLASS_CONTROLBAR_VISIBLE));\n      }\n    });\n    uimanager.onComponentHide.subscribe((component: Component<ComponentConfig>) => {\n      if (component instanceof ControlBar) {\n        this.getDomElement().removeClass(this.prefixCss(SubtitleOverlay.CLASS_CONTROLBAR_VISIBLE));\n      }\n    });\n\n    // Init\n    subtitleClearHandler();\n  }\n}\n\ninterface ActiveSubtitleCue {\n  event: SubtitleCueEvent;\n  label: SubtitleLabel;\n}\n\ninterface ActiveSubtitleCueMap {\n  [id: string]: ActiveSubtitleCue;\n}\n\nclass SubtitleLabel extends Label<LabelConfig> {\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitle-label'\n    }, this.config);\n  }\n}\n\nclass ActiveSubtitleManager {\n\n  private activeSubtitleCueMap: ActiveSubtitleCueMap;\n\n  constructor() {\n    this.activeSubtitleCueMap = {};\n  }\n\n  /**\n   * Calculates a unique ID for a subtitle cue, which is needed to associate an ON_CUE_ENTER with its ON_CUE_EXIT\n   * event so we can remove the correct subtitle in ON_CUE_EXIT when multiple subtitles are active at the same time.\n   * The start time plus the text should make a unique identifier, and in the only case where a collision\n   * can happen, two similar texts will displayed at a similar time so it does not matter which one we delete.\n   * The start time should always be known, because it is required to schedule the ON_CUE_ENTER event. The end time\n   * must not necessarily be known and therefore cannot be used for the ID.\n   * @param event\n   * @return {string}\n   */\n  private static calculateId(event: SubtitleCueEvent): string {\n    return event.start + event.text;\n  }\n\n  /**\n   * Adds a subtitle cue to the manager and returns the label that should be added to the subtitle overlay.\n   * @param event\n   * @return {SubtitleLabel}\n   */\n  cueEnter(event: SubtitleCueEvent): SubtitleLabel {\n    let id = ActiveSubtitleManager.calculateId(event);\n\n    let label = new SubtitleLabel({\n      // Prefer the HTML subtitle text if set, else use the plain text\n      text: event.html || event.text\n    });\n\n    this.activeSubtitleCueMap[id] = { event, label };\n\n    return label;\n  }\n\n  /**\n   * Removes the subtitle cue from the manager and returns the label that should be removed from the subtitle overlay.\n   * @param event\n   * @return {SubtitleLabel}\n   */\n  cueExit(event: SubtitleCueEvent): SubtitleLabel {\n    let id = ActiveSubtitleManager.calculateId(event);\n    let activeSubtitleCue = this.activeSubtitleCueMap[id];\n    delete this.activeSubtitleCueMap[id];\n    return activeSubtitleCue.label;\n  }\n\n  /**\n   * Returns the number of active subtitle cues.\n   * @return {number}\n   */\n  get cueCount(): number {\n    return Object.keys(this.activeSubtitleCueMap).length;\n  }\n\n  /**\n   * Returns true if there are active subtitle cues, else false.\n   * @return {boolean}\n   */\n  get hasCues(): boolean {\n    return this.cueCount > 0;\n  }\n\n  /**\n   * Removes all subtitle cues from the manager.\n   */\n  clear(): void {\n    this.activeSubtitleCueMap = {};\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\nimport SubtitleAddedEvent = bitmovin.player.SubtitleAddedEvent;\nimport SubtitleChangedEvent = bitmovin.player.SubtitleChangedEvent;\nimport SubtitleRemovedEvent = bitmovin.player.SubtitleRemovedEvent;\n\n/**\n * A select box providing a selection between available subtitle and caption tracks.\n */\nexport class SubtitleSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let updateSubtitles = () => {\n      this.clearItems();\n\n      for (let subtitle of player.getAvailableSubtitles()) {\n        this.addItem(subtitle.id, subtitle.label);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: SubtitleSelectBox, value: string) => {\n      player.setSubtitle(value === 'null' ? null : value);\n    });\n\n    // React to API events\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_ADDED, (event: SubtitleAddedEvent) => {\n      this.addItem(event.subtitle.id, event.subtitle.label);\n    });\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_CHANGED, (event: SubtitleChangedEvent) => {\n      this.selectItem(event.targetSubtitle.id);\n    });\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_REMOVED, (event: SubtitleRemovedEvent) => {\n      this.removeItem(event.subtitleId);\n    });\n\n    // Update subtitles when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateSubtitles);\n    // Update subtitles when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateSubtitles);\n\n    // Populate subtitles at startup\n    updateSubtitles();\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {MetadataLabel, MetadataLabelContent} from './metadatalabel';\n\n/**\n * Configuration interface for a {@link TitleBar}.\n */\nexport interface TitleBarConfig extends ContainerConfig {\n  /**\n   * Specifies if the title bar should stay hidden when no metadata label contains any text. Does not make a lot\n   * of sense if the title bar contains other components than just MetadataLabels (like in the default configuration).\n   * Default: false\n   */\n  keepHiddenWithoutMetadata?: boolean;\n}\n\n/**\n * Displays a title bar containing a label with the title of the video.\n */\nexport class TitleBar extends Container<TitleBarConfig> {\n\n  constructor(config: TitleBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-titlebar',\n      hidden: true,\n      components: [\n        new MetadataLabel({ content: MetadataLabelContent.Title }),\n        new MetadataLabel({ content: MetadataLabelContent.Description })\n      ],\n      keepHiddenWithoutMetadata: false,\n    }, <TitleBarConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <TitleBarConfig>this.getConfig();\n    let shouldBeShown = !this.isHidden();\n    let hasMetadataText = true; // Flag to track if any metadata label contains text\n\n    let checkMetadataTextAndUpdateVisibility = () => {\n      hasMetadataText = false;\n\n      // Iterate through metadata labels and check if at least one of them contains text\n      for (let component of this.getComponents()) {\n        if (component instanceof MetadataLabel) {\n          if (!component.isEmpty()) {\n            hasMetadataText = true;\n            break;\n          }\n        }\n      }\n\n      if (this.isShown()) {\n        // Hide a visible titlebar if it does not contain any text and the hidden flag is set\n        if (config.keepHiddenWithoutMetadata && !hasMetadataText) {\n          this.hide();\n        }\n      } else if (shouldBeShown) {\n        // Show a hidden titlebar if it should actually be shown\n        this.show();\n      }\n    };\n\n    // Listen to text change events to update the hasMetadataText flag when the metadata dynamically changes\n    for (let component of this.getComponents()) {\n      if (component instanceof MetadataLabel) {\n        component.onTextChanged.subscribe(checkMetadataTextAndUpdateVisibility);\n      }\n    }\n\n    uimanager.onControlsShow.subscribe(() => {\n      shouldBeShown = true;\n      if (!(config.keepHiddenWithoutMetadata && !hasMetadataText)) {\n        this.show();\n      }\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      shouldBeShown = false;\n      this.hide();\n    });\n\n    // init\n    checkMetadataTextAndUpdateVisibility();\n  }\n}","import {Button, ButtonConfig} from './button';\nimport {NoArgs, EventDispatcher, Event} from '../eventdispatcher';\n\n/**\n * Configuration interface for a toggle button component.\n */\nexport interface ToggleButtonConfig extends ButtonConfig {\n  /**\n   * The text on the button.\n   */\n  text?: string;\n}\n\n/**\n * A button that can be toggled between 'on' and 'off' states.\n */\nexport class ToggleButton<Config extends ToggleButtonConfig> extends Button<ToggleButtonConfig> {\n\n  private static readonly CLASS_ON = 'on';\n  private static readonly CLASS_OFF = 'off';\n\n  private onState: boolean;\n\n  private toggleButtonEvents = {\n    onToggle: new EventDispatcher<ToggleButton<Config>, NoArgs>(),\n    onToggleOn: new EventDispatcher<ToggleButton<Config>, NoArgs>(),\n    onToggleOff: new EventDispatcher<ToggleButton<Config>, NoArgs>()\n  };\n\n  constructor(config: ToggleButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-togglebutton'\n    }, this.config);\n  }\n\n  /**\n   * Toggles the button to the 'on' state.\n   */\n  on() {\n    if (this.isOff()) {\n      this.onState = true;\n      this.getDomElement().removeClass(this.prefixCss(ToggleButton.CLASS_OFF));\n      this.getDomElement().addClass(this.prefixCss(ToggleButton.CLASS_ON));\n\n      this.onToggleEvent();\n      this.onToggleOnEvent();\n    }\n  }\n\n  /**\n   * Toggles the button to the 'off' state.\n   */\n  off() {\n    if (this.isOn()) {\n      this.onState = false;\n      this.getDomElement().removeClass(this.prefixCss(ToggleButton.CLASS_ON));\n      this.getDomElement().addClass(this.prefixCss(ToggleButton.CLASS_OFF));\n\n      this.onToggleEvent();\n      this.onToggleOffEvent();\n    }\n  }\n\n  /**\n   * Toggle the button 'on' if it is 'off', or 'off' if it is 'on'.\n   */\n  toggle() {\n    if (this.isOn()) {\n      this.off();\n    } else {\n      this.on();\n    }\n  }\n\n  /**\n   * Checks if the toggle button is in the 'on' state.\n   * @returns {boolean} true if button is 'on', false if 'off'\n   */\n  isOn(): boolean {\n    return this.onState;\n  }\n\n  /**\n   * Checks if the toggle button is in the 'off' state.\n   * @returns {boolean} true if button is 'off', false if 'on'\n   */\n  isOff(): boolean {\n    return !this.isOn();\n  }\n\n  protected onClickEvent() {\n    super.onClickEvent();\n\n    // Fire the toggle event together with the click event\n    // (they are technically the same, only the semantics are different)\n    this.onToggleEvent();\n  }\n\n  protected onToggleEvent() {\n    this.toggleButtonEvents.onToggle.dispatch(this);\n  }\n\n  protected onToggleOnEvent() {\n    this.toggleButtonEvents.onToggleOn.dispatch(this);\n  }\n\n  protected onToggleOffEvent() {\n    this.toggleButtonEvents.onToggleOff.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggle(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggle.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled 'on'.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggleOn(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggleOn.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled 'off'.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggleOff(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggleOff.getEvent();\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\n\n/**\n * Animated analog TV static noise.\n */\nexport class TvNoiseCanvas extends Component<ComponentConfig> {\n\n  private canvas: DOM;\n\n  private canvasElement: HTMLCanvasElement;\n  private canvasContext: CanvasRenderingContext2D;\n  private canvasWidth = 160;\n  private canvasHeight = 90;\n  private interferenceHeight = 50;\n  private lastFrameUpdate: number = 0;\n  private frameInterval: number = 60;\n  private useAnimationFrame: boolean = !!window.requestAnimationFrame;\n  private noiseAnimationWindowPos: number;\n  private frameUpdateHandlerId: number;\n\n  constructor(config: ComponentConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-tvnoisecanvas'\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    return this.canvas = new DOM('canvas', { 'class': this.getCssClasses() });\n  }\n\n  start(): void {\n    this.canvasElement = <HTMLCanvasElement>this.canvas.getElements()[0];\n    this.canvasContext = this.canvasElement.getContext('2d');\n    this.noiseAnimationWindowPos = -this.canvasHeight;\n    this.lastFrameUpdate = 0;\n\n    this.canvasElement.width = this.canvasWidth;\n    this.canvasElement.height = this.canvasHeight;\n\n    this.renderFrame();\n  }\n\n  stop(): void {\n    if (this.useAnimationFrame) {\n      cancelAnimationFrame(this.frameUpdateHandlerId);\n    } else {\n      clearTimeout(this.frameUpdateHandlerId);\n    }\n  }\n\n  private renderFrame(): void {\n    // This code has been copied from the player controls.js and simplified\n\n    if (this.lastFrameUpdate + this.frameInterval > new Date().getTime()) {\n      // It's too early to render the next frame\n      this.scheduleNextRender();\n      return;\n    }\n\n    let currentPixelOffset;\n    let canvasWidth = this.canvasWidth;\n    let canvasHeight = this.canvasHeight;\n\n    // Create texture\n    let noiseImage = this.canvasContext.createImageData(canvasWidth, canvasHeight);\n\n    // Fill texture with noise\n    for (let y = 0; y < canvasHeight; y++) {\n      for (let x = 0; x < canvasWidth; x++) {\n        currentPixelOffset = (canvasWidth * y * 4) + x * 4;\n        noiseImage.data[currentPixelOffset] = Math.random() * 255;\n        if (y < this.noiseAnimationWindowPos || y > this.noiseAnimationWindowPos + this.interferenceHeight) {\n          noiseImage.data[currentPixelOffset] *= 0.85;\n        }\n        noiseImage.data[currentPixelOffset + 1] = noiseImage.data[currentPixelOffset];\n        noiseImage.data[currentPixelOffset + 2] = noiseImage.data[currentPixelOffset];\n        noiseImage.data[currentPixelOffset + 3] = 50;\n      }\n    }\n\n    // Put texture onto canvas\n    this.canvasContext.putImageData(noiseImage, 0, 0);\n\n    this.lastFrameUpdate = new Date().getTime();\n    this.noiseAnimationWindowPos += 7;\n    if (this.noiseAnimationWindowPos > canvasHeight) {\n      this.noiseAnimationWindowPos = -canvasHeight;\n    }\n\n    this.scheduleNextRender();\n  }\n\n  private scheduleNextRender(): void {\n    if (this.useAnimationFrame) {\n      this.frameUpdateHandlerId = window.requestAnimationFrame(this.renderFrame.bind(this));\n    } else {\n      this.frameUpdateHandlerId = setTimeout(this.renderFrame.bind(this), this.frameInterval);\n    }\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {DOM} from '../dom';\nimport {Timeout} from '../timeout';\nimport {PlayerUtils} from '../utils';\nimport PlayerResizeEvent = bitmovin.player.PlayerResizeEvent;\nimport {CancelEventArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link UIContainer}.\n */\nexport interface UIContainerConfig extends ContainerConfig {\n  /**\n   * The delay in milliseconds after which the control bar will be hidden when there is no user interaction.\n   * Default: 5 seconds (5000)\n   */\n  hideDelay?: number;\n}\n\n/**\n * The base container that contains all of the UI. The UIContainer is passed to the {@link UIManager} to build and\n * setup the UI.\n */\nexport class UIContainer extends Container<UIContainerConfig> {\n\n  private static readonly STATE_PREFIX = 'player-state-';\n\n  private static readonly FULLSCREEN = 'fullscreen';\n  private static readonly BUFFERING = 'buffering';\n  private static readonly REMOTE_CONTROL = 'remote-control';\n  private static readonly CONTROLS_SHOWN = 'controls-shown';\n  private static readonly CONTROLS_HIDDEN = 'controls-hidden';\n\n  private uiHideTimeout: Timeout;\n\n  constructor(config: UIContainerConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <UIContainerConfig>{\n      cssClass: 'ui-uicontainer',\n      hideDelay: 5000,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.configureUIShowHide(player, uimanager);\n    this.configurePlayerStates(player, uimanager);\n  }\n\n  private configureUIShowHide(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let container = this.getDomElement();\n    let config = <UIContainerConfig>this.getConfig();\n\n    let isUiShown = false;\n    let isSeeking = false;\n    let isFirstTouch = true;\n\n    let showUi = () => {\n      if (!isUiShown) {\n        // Let subscribers know that they should reveal themselves\n        uimanager.onControlsShow.dispatch(this);\n        isUiShown = true;\n      }\n      // Don't trigger timeout while seeking (it will be triggered once the seek is finished) or casting\n      if (!isSeeking && !player.isCasting()) {\n        this.uiHideTimeout.start();\n      }\n    };\n\n    let hideUi = () => {\n      // Hide the UI only if it is shown, and if not casting\n      if (isUiShown && !player.isCasting()) {\n        // Issue a preview event to check if we are good to hide the controls\n        let previewHideEventArgs = <CancelEventArgs>{};\n        uimanager.onPreviewControlsHide.dispatch(this, previewHideEventArgs);\n\n        if (!previewHideEventArgs.cancel) {\n          // If the preview wasn't canceled, let subscribers know that they should now hide themselves\n          uimanager.onControlsHide.dispatch(this);\n          isUiShown = false;\n        } else {\n          // If the hide preview was canceled, continue to show UI\n          showUi();\n        }\n      }\n    };\n\n    // Timeout to defer UI hiding by the configured delay time\n    this.uiHideTimeout = new Timeout(config.hideDelay, hideUi);\n\n    // On touch displays, the first touch reveals the UI\n    container.on('touchend', (e) => {\n      if (!isUiShown) {\n        // Only if the UI is hidden, we prevent other actions (except for the first touch) and reveal the UI instead.\n        // The first touch is not prevented to let other listeners receive the event and trigger an initial action, e.g.\n        // the huge playback button can directly start playback instead of requiring a double tap which 1. reveals\n        // the UI and 2. starts playback.\n        if (isFirstTouch) {\n          isFirstTouch = false;\n        } else {\n          e.preventDefault();\n        }\n        showUi();\n      }\n    });\n    // When the mouse enters, we show the UI\n    container.on('mouseenter', () => {\n      showUi();\n    });\n    // When the mouse moves within, we show the UI\n    container.on('mousemove', () => {\n      showUi();\n    });\n    // When the mouse leaves, we can prepare to hide the UI, except a seek is going on\n    container.on('mouseleave', () => {\n      // When a seek is going on, the seek scrub pointer may exit the UI area while still seeking, and we do not hide\n      // the UI in such cases\n      if (!isSeeking) {\n        this.uiHideTimeout.start();\n      }\n    });\n\n    uimanager.onSeek.subscribe(() => {\n      this.uiHideTimeout.clear(); // Don't hide UI while a seek is in progress\n      isSeeking = true;\n    });\n    uimanager.onSeeked.subscribe(() => {\n      isSeeking = false;\n      this.uiHideTimeout.start(); // Re-enable UI hide timeout after a seek\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      showUi(); // Show UI when a Cast session has started (UI will then stay permanently on during the session)\n    });\n  }\n\n  private configurePlayerStates(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let container = this.getDomElement();\n\n    // Convert player states into CSS class names\n    let stateClassNames = <any>[];\n    for (let state in PlayerUtils.PlayerState) {\n      if (isNaN(Number(state))) {\n        let enumName = PlayerUtils.PlayerState[<any>PlayerUtils.PlayerState[state]];\n        stateClassNames[PlayerUtils.PlayerState[state]] =\n          this.prefixCss(UIContainer.STATE_PREFIX + enumName.toLowerCase());\n      }\n    }\n\n    let removeStates = () => {\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.IDLE]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PREPARED]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PLAYING]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PAUSED]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.FINISHED]);\n    };\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PREPARED]);\n    });\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PLAYING]);\n    });\n    player.addEventHandler(player.EVENT.ON_PAUSED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PAUSED]);\n    });\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.FINISHED]);\n    });\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.IDLE]);\n    });\n    // Init in current player state\n    container.addClass(stateClassNames[PlayerUtils.getState(player)]);\n\n    // Fullscreen marker class\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_ENTER, () => {\n      container.addClass(this.prefixCss(UIContainer.FULLSCREEN));\n    });\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_EXIT, () => {\n      container.removeClass(this.prefixCss(UIContainer.FULLSCREEN));\n    });\n    // Init fullscreen state\n    if (player.isFullscreen()) {\n      container.addClass(this.prefixCss(UIContainer.FULLSCREEN));\n    }\n\n    // Buffering marker class\n    player.addEventHandler(player.EVENT.ON_STALL_STARTED, () => {\n      container.addClass(this.prefixCss(UIContainer.BUFFERING));\n    });\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, () => {\n      container.removeClass(this.prefixCss(UIContainer.BUFFERING));\n    });\n    // Init buffering state\n    if (player.isStalled()) {\n      container.addClass(this.prefixCss(UIContainer.BUFFERING));\n    }\n\n    // RemoteControl marker class\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      container.addClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, () => {\n      container.removeClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    });\n    // Init RemoteControl state\n    if (player.isCasting()) {\n      container.addClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    }\n\n    // Controls visibility marker class\n    uimanager.onControlsShow.subscribe(() => {\n      container.removeClass(this.prefixCss(UIContainer.CONTROLS_HIDDEN));\n      container.addClass(this.prefixCss(UIContainer.CONTROLS_SHOWN));\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      container.removeClass(this.prefixCss(UIContainer.CONTROLS_SHOWN));\n      container.addClass(this.prefixCss(UIContainer.CONTROLS_HIDDEN));\n    });\n\n    // Layout size classes\n    let updateLayoutSizeClasses = (width: number, height: number) => {\n      container.removeClass(this.prefixCss('layout-max-width-400'));\n      container.removeClass(this.prefixCss('layout-max-width-600'));\n      container.removeClass(this.prefixCss('layout-max-width-800'));\n      container.removeClass(this.prefixCss('layout-max-width-1200'));\n\n      if (width <= 400) {\n        container.addClass(this.prefixCss('layout-max-width-400'));\n      } else if (width <= 600) {\n        container.addClass(this.prefixCss('layout-max-width-600'));\n      } else if (width <= 800) {\n        container.addClass(this.prefixCss('layout-max-width-800'));\n      } else if (width <= 1200) {\n        container.addClass(this.prefixCss('layout-max-width-1200'));\n      }\n    };\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, (e: PlayerResizeEvent) => {\n      // Convert strings (with \"px\" suffix) to ints\n      let width = Math.round(Number(e.width.substring(0, e.width.length - 2)));\n      let height = Math.round(Number(e.height.substring(0, e.height.length - 2)));\n\n      updateLayoutSizeClasses(width, height);\n    });\n\n    // Init layout state\n    updateLayoutSizeClasses(new DOM(player.getFigure()).width(), new DOM(player.getFigure()).height());\n  }\n\n  release(): void {\n    super.release();\n    this.uiHideTimeout.clear();\n  }\n\n  protected toDomElement(): DOM {\n    let container = super.toDomElement();\n\n    // Detect flexbox support (not supported in IE9)\n    if (document && typeof document.createElement('p').style.flex !== 'undefined') {\n      container.addClass(this.prefixCss('flexbox'));\n    } else {\n      container.addClass(this.prefixCss('no-flexbox'));\n    }\n\n    return container;\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between 'auto' and the available video qualities.\n */\nexport class VideoQualitySelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let updateVideoQualities = () => {\n      let videoQualities = player.getAvailableVideoQualities();\n\n      this.clearItems();\n\n      // Add entry for automatic quality switching (default setting)\n      this.addItem('auto', 'auto');\n\n      // Add video qualities\n      for (let videoQuality of videoQualities) {\n        this.addItem(videoQuality.id, videoQuality.label);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: VideoQualitySelectBox, value: string) => {\n      player.setVideoQuality(value);\n    });\n\n    // Update qualities when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateVideoQualities);\n    // Update qualities when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateVideoQualities);\n    // Update quality selection when quality is changed (from outside)\n    player.addEventHandler(player.EVENT.ON_VIDEO_DOWNLOAD_QUALITY_CHANGE, () => {\n      let data = player.getDownloadedVideoData();\n      this.selectItem(data.isAuto ? 'auto' : data.id);\n    });\n\n    // Populate qualities at startup\n    updateVideoQualities();\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {VolumeSlider} from './volumeslider';\nimport {VolumeToggleButton} from './volumetogglebutton';\nimport {UIInstanceManager} from '../uimanager';\nimport {Timeout} from '../timeout';\n\n/**\n * Configuration interface for a {@link VolumeControlButton}.\n */\nexport interface VolumeControlButtonConfig extends ContainerConfig {\n  /**\n   * The delay after which the volume slider will be hidden when there is no user interaction.\n   * Care must be taken that the delay is long enough so users can reach the slider from the toggle button, e.g. by\n   * mouse movement. If the delay is too short, the sliders disappears before the mouse pointer has reached it and\n   * the user is not able to use it.\n   * Default: 500ms\n   */\n  hideDelay?: number;\n  /**\n   * Specifies if the volume slider should be vertically or horizontally aligned.\n   * Default: true\n   */\n  vertical?: boolean;\n}\n\n/**\n * A composite volume control that consists of and internally manages a volume control button that can be used\n * for muting, and a (depending on the CSS style, e.g. slide-out) volume control bar.\n */\nexport class VolumeControlButton extends Container<VolumeControlButtonConfig> {\n\n  private volumeToggleButton: VolumeToggleButton;\n  private volumeSlider: VolumeSlider;\n\n  private volumeSliderHideTimeout: Timeout;\n\n  constructor(config: VolumeControlButtonConfig = {}) {\n    super(config);\n\n    this.volumeToggleButton = new VolumeToggleButton();\n    this.volumeSlider = new VolumeSlider({\n      vertical: config.vertical != null ? config.vertical : true,\n      hidden: true\n    });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-volumecontrolbutton',\n      components: [this.volumeToggleButton, this.volumeSlider],\n      hideDelay: 500\n    }, <VolumeControlButtonConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let volumeToggleButton = this.getVolumeToggleButton();\n    let volumeSlider = this.getVolumeSlider();\n\n    this.volumeSliderHideTimeout = new Timeout((<VolumeControlButtonConfig>this.getConfig()).hideDelay, () => {\n      volumeSlider.hide();\n    });\n\n    /*\n     * Volume Slider visibility handling\n     *\n     * The volume slider shall be visible while the user hovers the mute toggle button, while the user hovers the\n     * volume slider, and while the user slides the volume slider. If none of these situations are true, the slider\n     * shall disappear.\n     */\n    let volumeSliderHovered = false;\n    volumeToggleButton.getDomElement().on('mouseenter', () => {\n      // Show volume slider when mouse enters the button area\n      if (volumeSlider.isHidden()) {\n        volumeSlider.show();\n      }\n      // Avoid hiding of the slider when button is hovered\n      this.volumeSliderHideTimeout.clear();\n    });\n    volumeToggleButton.getDomElement().on('mouseleave', () => {\n      // Hide slider delayed when button is left\n      this.volumeSliderHideTimeout.reset();\n    });\n    volumeSlider.getDomElement().on('mouseenter', () => {\n      // When the slider is entered, cancel the hide timeout activated by leaving the button\n      this.volumeSliderHideTimeout.clear();\n      volumeSliderHovered = true;\n    });\n    volumeSlider.getDomElement().on('mouseleave', () => {\n      // When mouse leaves the slider, only hide it if there is no slide operation in progress\n      if (volumeSlider.isSeeking()) {\n        this.volumeSliderHideTimeout.clear();\n      } else {\n        this.volumeSliderHideTimeout.reset();\n      }\n      volumeSliderHovered = false;\n    });\n    volumeSlider.onSeeked.subscribe(() => {\n      // When a slide operation is done and the slider not hovered (mouse outside slider), hide slider delayed\n      if (!volumeSliderHovered) {\n        this.volumeSliderHideTimeout.reset();\n      }\n    });\n  }\n\n  release(): void {\n    super.release();\n    this.volumeSliderHideTimeout.clear();\n  }\n\n  /**\n   * Provides access to the internally managed volume toggle button.\n   * @returns {VolumeToggleButton}\n   */\n  getVolumeToggleButton(): VolumeToggleButton {\n    return this.volumeToggleButton;\n  }\n\n  /**\n   * Provides access to the internally managed volume silder.\n   * @returns {VolumeSlider}\n   */\n  getVolumeSlider(): VolumeSlider {\n    return this.volumeSlider;\n  }\n}","import {SeekBar, SeekBarConfig} from './seekbar';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Configuration interface for the {@link VolumeSlider} component.\n */\nexport interface VolumeSliderConfig extends SeekBarConfig {\n  /**\n   * Specifies if the volume slider should be automatically hidden when volume control is prohibited by the\n   * browser or platform. This currently only applies to iOS.\n   * Default: true\n   */\n  hideIfVolumeControlProhibited: boolean;\n}\n\n/**\n * A simple volume slider component to adjust the player's volume setting.\n */\nexport class VolumeSlider extends SeekBar {\n\n  constructor(config: SeekBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <VolumeSliderConfig>{\n      cssClass: 'ui-volumeslider',\n      hideIfVolumeControlProhibited: true,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager, false);\n\n    let config = <VolumeSliderConfig>this.getConfig();\n\n    if (config.hideIfVolumeControlProhibited && !this.detectVolumeControlAvailability(player)) {\n      this.hide();\n\n      // We can just return from here, because the user will never interact with the control and any configured\n      // functionality would only eat resources for no reason.\n      return;\n    }\n\n    let volumeChangeHandler = () => {\n      if (player.isMuted()) {\n        this.setPlaybackPosition(0);\n        this.setBufferPosition(0);\n      } else {\n        this.setPlaybackPosition(player.getVolume());\n\n        this.setBufferPosition(player.getVolume());\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_VOLUME_CHANGED, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_MUTED, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_UNMUTED, volumeChangeHandler);\n\n    this.onSeekPreview.subscribe((sender, args) => {\n      if (args.scrubbing) {\n        player.setVolume(args.position);\n      }\n    });\n    this.onSeeked.subscribe((sender, percentage) => {\n      player.setVolume(percentage);\n    });\n\n    // Update the volume slider marker when the player resized, a source is loaded and player is ready,\n    // or the UI is configured. Check the seekbar for a detailed description.\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => {\n      this.refreshPlaybackPosition();\n    });\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      this.refreshPlaybackPosition();\n    });\n    uimanager.onConfigured.subscribe(() => {\n      this.refreshPlaybackPosition();\n    });\n\n    // Init volume bar\n    volumeChangeHandler();\n  }\n\n  private detectVolumeControlAvailability(player: bitmovin.player.Player): boolean {\n    // Store current player state so we can restore it later\n    let volume = player.getVolume();\n    let muted = player.isMuted();\n    let playing = player.isPlaying();\n\n    /*\n     * \"On iOS devices, the audio level is always under the users physical control. The volume property is not\n     * settable in JavaScript. Reading the volume property always returns 1.\"\n     * https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html\n     *\n     * Our player API returns a volume range of [0, 100] so we need to check for 100 instead of 1.\n     */\n\n    // Only if the volume is 100, there's the possibility we are on a volume-control-restricted iOS device\n    if (volume === 100) {\n      // We set the volume to zero (that's the only value that does not unmute a muted player!)\n      player.setVolume(0);\n      // Then we check if the value is still 100\n      if (player.getVolume() === 100) {\n        // If the volume stayed at 100, we're on a volume-control-restricted device\n        return false;\n      } else {\n        // We can control volume, so we must restore the previous player state\n        player.setVolume(volume);\n        if (muted) {\n          player.mute();\n        }\n        if (playing) {\n          // The volume restore above pauses autoplay on mobile devices (e.g. Android) so we need to resume playback\n          // (We cannot check isPaused() here because it is not set when playback is prohibited by the mobile platform)\n          player.play();\n        }\n        return true;\n      }\n    } else {\n      // Volume is not 100, so we're definitely not on a volume-control-restricted iOS device\n      return true;\n    }\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles audio muting.\n */\nexport class VolumeToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-volumetogglebutton',\n      text: 'Volume/Mute'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let muteStateHandler = () => {\n      if (player.isMuted()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    let volumeLevelHandler = () => {\n      // Toggle low class to display low volume icon below 50% volume\n      if (player.getVolume() < 50) {\n        this.getDomElement().addClass(this.prefixCss('low'));\n      } else {\n        this.getDomElement().removeClass(this.prefixCss('low'));\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_MUTED, muteStateHandler);\n    player.addEventHandler(player.EVENT.ON_UNMUTED, muteStateHandler);\n    player.addEventHandler(player.EVENT.ON_VOLUME_CHANGED, volumeLevelHandler);\n\n    this.onClick.subscribe(() => {\n      if (player.isMuted()) {\n        player.unmute();\n      } else {\n        player.mute();\n      }\n    });\n\n    // Startup init\n    muteStateHandler();\n    volumeLevelHandler();\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles the video view between normal/mono and VR/stereo.\n */\nexport class VRToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-vrtogglebutton',\n      text: 'VR'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let isVRConfigured = () => {\n      // VR availability cannot be checked through getVRStatus() because it is asynchronously populated and not\n      // available at UI initialization. As an alternative, we check the VR settings in the config.\n      // TODO use getVRStatus() through isVRStereoAvailable() once the player has been rewritten and the status is\n      // available in ON_READY\n      let config = player.getConfig();\n      return config.source && config.source.vr && config.source.vr.contentType !== 'none';\n    };\n\n    let isVRStereoAvailable = () => {\n      return player.getVRStatus().contentType !== 'none';\n    };\n\n    let vrStateHandler = () => {\n      if (isVRConfigured() && isVRStereoAvailable()) {\n        this.show(); // show button in case it is hidden\n\n        if (player.getVRStatus().isStereo) {\n          this.on();\n        } else {\n          this.off();\n        }\n      } else {\n        this.hide(); // hide button if no stereo mode available\n      }\n    };\n\n    let vrButtonVisibilityHandler = () => {\n      if (isVRConfigured()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_VR_MODE_CHANGED, vrStateHandler);\n    player.addEventHandler(player.EVENT.ON_VR_STEREO_CHANGED, vrStateHandler);\n    player.addEventHandler(player.EVENT.ON_VR_ERROR, vrStateHandler);\n    // Hide button when VR source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, vrButtonVisibilityHandler);\n    // Show button when a new source is loaded and it's VR\n    player.addEventHandler(player.EVENT.ON_READY, vrButtonVisibilityHandler);\n\n    this.onClick.subscribe(() => {\n      if (!isVRStereoAvailable()) {\n        if (console) {\n          console.log('No VR content');\n        }\n      } else {\n        if (player.getVRStatus().isStereo) {\n          player.setVRStereo(false);\n        } else {\n          player.setVRStereo(true);\n        }\n      }\n    });\n\n    // Set startup visibility\n    vrButtonVisibilityHandler();\n  }\n}","import {ClickOverlay, ClickOverlayConfig} from './clickoverlay';\n\n/**\n * Configuration interface for a {@link ClickOverlay}.\n */\nexport interface WatermarkConfig extends ClickOverlayConfig {\n  // nothing yet\n}\n\n/**\n * A watermark overlay with a clickable logo.\n */\nexport class Watermark extends ClickOverlay {\n\n  constructor(config: WatermarkConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-watermark',\n      url: 'http://bitmovin.com'\n    }, <WatermarkConfig>this.config);\n  }\n}","export interface Offset {\n  left: number;\n  top: number;\n}\n\n/**\n * Simple DOM manipulation and DOM element event handling modeled after jQuery (as replacement for jQuery).\n *\n * Like jQuery, DOM operates on single elements and lists of elements. For example: creating an element returns a DOM\n * instance with a single element, selecting elements returns a DOM instance with zero, one, or many elements. Similar\n * to jQuery, setters usually affect all elements, while getters operate on only the first element.\n * Also similar to jQuery, most methods (except getters) return the DOM instance facilitating easy chaining of method\n * calls.\n *\n * Built with the help of: http://youmightnotneedjquery.com/\n */\nexport class DOM {\n\n  private document: Document;\n\n  /**\n   * The list of elements that the instance wraps. Take care that not all methods can operate on the whole list,\n   * getters usually just work on the first element.\n   */\n  private elements: HTMLElement[];\n\n  /**\n   * Creates a DOM element.\n   * @param tagName the tag name of the DOM element\n   * @param attributes a list of attributes of the element\n   */\n  constructor(tagName: string, attributes: {[name: string]: string});\n  /**\n   * Selects all elements from the DOM that match the specified selector.\n   * @param selector the selector to match DOM elements with\n   */\n  constructor(selector: string);\n  /**\n   * Wraps a plain HTMLElement with a DOM instance.\n   * @param element the HTMLElement to wrap with DOM\n   */\n  constructor(element: HTMLElement);\n  /**\n   * Wraps a list of plain HTMLElements with a DOM instance.\n   * @param element the HTMLElements to wrap with DOM\n   */\n  constructor(elements: HTMLElement[]);\n  /**\n   * Wraps the document with a DOM instance. Useful to attach event listeners to the document.\n   * @param document the document to wrap\n   */\n  constructor(document: Document);\n  constructor(something: string | HTMLElement | HTMLElement[] | Document, attributes?: {[name: string]: string}) {\n    this.document = document; // Set the global document to the local document field\n\n    if (something instanceof Array) {\n      if (something.length > 0 && something[0] instanceof HTMLElement) {\n        let elements = something;\n        this.elements = elements;\n      }\n    }\n    else if (something instanceof HTMLElement) {\n      let element = something;\n      this.elements = [element];\n    }\n    else if (something instanceof Document) {\n      // When a document is passed in, we do not do anything with it, but by setting this.elements to null\n      // we give the event handling method a means to detect if the events should be registered on the document\n      // instead of elements.\n      this.elements = null;\n    }\n    else if (attributes) {\n      let tagName = something;\n      let element = document.createElement(tagName);\n\n      for (let attributeName in attributes) {\n        let attributeValue = attributes[attributeName];\n        element.setAttribute(attributeName, attributeValue);\n      }\n\n      this.elements = [element];\n    }\n    else {\n      let selector = something;\n      this.elements = this.findChildElements(selector);\n    }\n  }\n\n  /**\n   * Gets the number of elements that this DOM instance currently holds.\n   * @returns {number} the number of elements\n   */\n  get length(): number {\n    return this.elements ? this.elements.length : 0;\n  }\n\n  /**\n   * Gets the HTML elements that this DOM instance currently holds.\n   * @returns {HTMLElement[]} the raw HTML elements\n   */\n  getElements(): HTMLElement[] {\n    return this.elements;\n  }\n\n  /**\n   * A shortcut method for iterating all elements. Shorts this.elements.forEach(...) to this.forEach(...).\n   * @param handler the handler to execute an operation on an element\n   */\n  private forEach(handler: (element: HTMLElement) => void): void {\n    this.elements.forEach((element) => {\n      handler(element);\n    });\n  }\n\n  private findChildElementsOfElement(element: HTMLElement | Document, selector: string): HTMLElement[] {\n    let childElements = element.querySelectorAll(selector);\n\n    // Convert NodeList to Array\n    // https://toddmotto.com/a-comprehensive-dive-into-nodelists-arrays-converting-nodelists-and-understanding-the-dom/\n    return [].slice.call(childElements);\n  }\n\n  private findChildElements(selector: string): HTMLElement[] {\n    let allChildElements = <HTMLElement[]>[];\n\n    if (this.elements) {\n      this.forEach((element) => {\n        allChildElements = allChildElements.concat(this.findChildElementsOfElement(element, selector));\n      });\n    }\n    else {\n      return this.findChildElementsOfElement(document, selector);\n    }\n\n    return allChildElements;\n  }\n\n  /**\n   * Finds all child elements of all elements matching the supplied selector.\n   * @param selector the selector to match with child elements\n   * @returns {DOM} a new DOM instance representing all matched children\n   */\n  find(selector: string): DOM {\n    let allChildElements = this.findChildElements(selector);\n    return new DOM(allChildElements);\n  }\n\n  /**\n   * Returns a string of the inner HTML content of the first element.\n   */\n  html(): string;\n  /**\n   * Sets the inner HTML content of all elements.\n   * @param content a string of plain text or HTML markup\n   */\n  html(content: string): DOM;\n  html(content?: string): string | DOM {\n    if (arguments.length > 0) {\n      return this.setHtml(content);\n    }\n    else {\n      return this.getHtml();\n    }\n  }\n\n  private getHtml(): string | null {\n    return this.elements[0].innerHTML;\n  }\n\n  private setHtml(content: string): DOM {\n    if (content === undefined || content == null) {\n      // Set to empty string to avoid innerHTML getting set to 'undefined' (all browsers) or 'null' (IE9)\n      content = '';\n    }\n\n    this.forEach((element) => {\n      element.innerHTML = content;\n    });\n\n    return this;\n  }\n\n  /**\n   * Clears the inner HTML of all elements (deletes all children).\n   * @returns {DOM}\n   */\n  empty(): DOM {\n    this.forEach((element) => {\n      element.innerHTML = '';\n    });\n    return this;\n  }\n\n  /**\n   * Returns the current value of the first form element, e.g. the selected value of a select box or the text if an\n   * input field.\n   * @returns {string} the value of a form element\n   */\n  val(): string {\n    let element = this.elements[0];\n\n    if (element instanceof HTMLSelectElement || element instanceof HTMLInputElement) {\n      return element.value;\n    }\n    else {\n      // TODO add support for missing form elements\n      throw new Error(`val() not supported for ${typeof element}`);\n    }\n  }\n\n  /**\n   * Returns the value of an attribute on the first element.\n   * @param attribute\n   */\n  attr(attribute: string): string | null;\n  /**\n   * Sets an attribute on all elements.\n   * @param attribute the name of the attribute\n   * @param value the value of the attribute\n   */\n  attr(attribute: string, value: string): DOM;\n  attr(attribute: string, value?: string): string | null | DOM {\n    if (arguments.length > 1) {\n      return this.setAttr(attribute, value);\n    }\n    else {\n      return this.getAttr(attribute);\n    }\n  }\n\n  private getAttr(attribute: string): string | null {\n    return this.elements[0].getAttribute(attribute);\n  }\n\n  private setAttr(attribute: string, value: string): DOM {\n    this.forEach((element) => {\n      element.setAttribute(attribute, value);\n    });\n    return this;\n  }\n\n  /**\n   * Returns the value of a data element on the first element.\n   * @param dataAttribute the name of the data attribute without the 'data-' prefix\n   */\n  data(dataAttribute: string): string | null;\n  /**\n   * Sets a data attribute on all elements.\n   * @param dataAttribute the name of the data attribute without the 'data-' prefix\n   * @param value the value of the data attribute\n   */\n  data(dataAttribute: string, value: string): DOM;\n  data(dataAttribute: string, value?: string): string | null | DOM {\n    if (arguments.length > 1) {\n      return this.setData(dataAttribute, value);\n    }\n    else {\n      return this.getData(dataAttribute);\n    }\n  }\n\n  private getData(dataAttribute: string): string | null {\n    return this.elements[0].getAttribute('data-' + dataAttribute);\n  }\n\n  private setData(dataAttribute: string, value: string): DOM {\n    this.forEach((element) => {\n      element.setAttribute('data-' + dataAttribute, value);\n    });\n    return this;\n  }\n\n  /**\n   * Appends one or more DOM elements as children to all elements.\n   * @param childElements the chrild elements to append\n   * @returns {DOM}\n   */\n  append(...childElements: DOM[]): DOM {\n    this.forEach((element) => {\n      childElements.forEach((childElement) => {\n        childElement.elements.forEach((_, index) => {\n          element.appendChild(childElement.elements[index]);\n        });\n      });\n    });\n    return this;\n  }\n\n  /**\n   * Removes all elements from the DOM.\n   */\n  remove(): void {\n    this.forEach((element) => {\n      let parent = element.parentNode;\n      if (parent) {\n        parent.removeChild(element);\n      }\n    });\n  }\n\n  /**\n   * Returns the offset of the first element from the document's top left corner.\n   * @returns {Offset}\n   */\n  offset(): Offset {\n    let element = this.elements[0];\n    let elementRect = element.getBoundingClientRect();\n    let htmlRect = document.body.parentElement.getBoundingClientRect();\n\n    // Virtual viewport scroll handling (e.g. pinch zoomed viewports in mobile browsers or desktop Chrome/Edge)\n    // 'normal' zooms and virtual viewport zooms (aka layout viewport) result in different\n    // element.getBoundingClientRect() results:\n    //  - with normal scrolls, the clientRect decreases with an increase in scroll(Top|Left)/page(X|Y)Offset\n    //  - with pinch zoom scrolls, the clientRect stays the same while scroll/pageOffset changes\n    // This means, that the combination of clientRect + scroll/pageOffset does not work to calculate the offset\n    // from the document's upper left origin when pinch zoom is used.\n    // To work around this issue, we do not use scroll/pageOffset but get the clientRect of the html element and\n    // subtract it from the element's rect, which always results in the offset from the document origin.\n    // NOTE: the current way of offset calculation was implemented specifically to track event positions on the\n    // seek bar, and it might break compatibility with jQuery's offset() method. If this ever turns out to be a\n    // problem, this method should be reverted to the old version and the offset calculation moved to the seek bar.\n\n    return {\n      top: elementRect.top - htmlRect.top,\n      left: elementRect.left - htmlRect.left\n    };\n  }\n\n  /**\n   * Returns the width of the first element.\n   * @returns {number} the width of the first element\n   */\n  width(): number {\n    // TODO check if this is the same as jQuery's width() (probably not)\n    return this.elements[0].offsetWidth;\n  }\n\n  /**\n   * Returns the height of the first element.\n   * @returns {number} the height of the first element\n   */\n  height(): number {\n    // TODO check if this is the same as jQuery's height() (probably not)\n    return this.elements[0].offsetHeight;\n  }\n\n  /**\n   * Attaches an event handler to one or more events on all elements.\n   * @param eventName the event name (or multiple names separated by space) to listen to\n   * @param eventHandler the event handler to call when the event fires\n   * @returns {DOM}\n   */\n  on(eventName: string, eventHandler: EventListenerOrEventListenerObject): DOM {\n    let events = eventName.split(' ');\n\n    events.forEach((event) => {\n      if (this.elements == null) {\n        this.document.addEventListener(event, eventHandler);\n      }\n      else {\n        this.forEach((element) => {\n          element.addEventListener(event, eventHandler);\n        });\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Removes an event handler from one or more events on all elements.\n   * @param eventName the event name (or multiple names separated by space) to remove the handler from\n   * @param eventHandler the event handler to remove\n   * @returns {DOM}\n   */\n  off(eventName: string, eventHandler: EventListenerOrEventListenerObject): DOM {\n    let events = eventName.split(' ');\n\n    events.forEach((event) => {\n      if (this.elements == null) {\n        this.document.removeEventListener(event, eventHandler);\n      }\n      else {\n        this.forEach((element) => {\n          element.removeEventListener(event, eventHandler);\n        });\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds the specified class(es) to all elements.\n   * @param className the class(es) to add, multiple classes separated by space\n   * @returns {DOM}\n   */\n  addClass(className: string): DOM {\n    this.forEach((element) => {\n      if (element.classList) {\n        element.classList.add(className);\n      }\n      else {\n        element.className += ' ' + className;\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Removed the specified class(es) from all elements.\n   * @param className the class(es) to remove, multiple classes separated by space\n   * @returns {DOM}\n   */\n  removeClass(className: string): DOM {\n    this.forEach((element) => {\n      if (element.classList) {\n        element.classList.remove(className);\n      }\n      else {\n        element.className = element.className.replace(\n          new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Checks if any of the elements has the specified class.\n   * @param className the class name to check\n   * @returns {boolean} true if one of the elements has the class attached, else if no element has it attached\n   */\n  hasClass(className: string): boolean {\n    let hasClass = false;\n\n    this.forEach((element) => {\n      if (element.classList) {\n        if (element.classList.contains(className)) {\n          // Since we are inside a handler, we can't just 'return true'. Instead, we save it to a variable\n          // and return it at the end of the function body.\n          hasClass = true;\n        }\n      }\n      else {\n        if (new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className)) {\n          // See comment above\n          hasClass = true;\n        }\n      }\n    });\n\n    return hasClass;\n  }\n\n  /**\n   * Returns the value of a CSS property of the first element.\n   * @param propertyName the name of the CSS property to retrieve the value of\n   */\n  css(propertyName: string): string | null;\n  /**\n   * Sets the value of a CSS property on all elements.\n   * @param propertyName the name of the CSS property to set the value for\n   * @param value the value to set for the given CSS property\n   */\n  css(propertyName: string, value: string): DOM;\n  /**\n   * Sets a collection of CSS properties and their values on all elements.\n   * @param propertyValueCollection an object containing pairs of property names and their values\n   */\n  css(propertyValueCollection: {[propertyName: string]: string}): DOM;\n  css(propertyNameOrCollection: string | {[propertyName: string]: string}, value?: string): string | null | DOM {\n    if (typeof propertyNameOrCollection === 'string') {\n      let propertyName = propertyNameOrCollection;\n\n      if (arguments.length === 2) {\n        return this.setCss(propertyName, value);\n      }\n      else {\n        return this.getCss(propertyName);\n      }\n    }\n    else {\n      let propertyValueCollection = propertyNameOrCollection;\n      return this.setCssCollection(propertyValueCollection);\n    }\n  }\n\n  private getCss(propertyName: string): string | null {\n    return getComputedStyle(this.elements[0])[<any>propertyName];\n  }\n\n  private setCss(propertyName: string, value: string): DOM {\n    this.forEach((element) => {\n      // <any> cast to resolve TS7015: http://stackoverflow.com/a/36627114/370252\n      element.style[<any>propertyName] = value;\n    });\n    return this;\n  }\n\n  private setCssCollection(ruleValueCollection: {[ruleName: string]: string}): DOM {\n    this.forEach((element) => {\n      // http://stackoverflow.com/a/34490573/370252\n      Object.assign(element.style, ruleValueCollection);\n    });\n\n    return this;\n  }\n}\n","import {ArrayUtils} from './utils';\n/**\n * Function interface for event listeners on the {@link EventDispatcher}.\n */\nexport interface EventListener<Sender, Args> {\n  (sender: Sender, args: Args): void;\n}\n\n/**\n * Empty type for creating {@link EventDispatcher event dispatchers} that do not carry any arguments.\n */\nexport interface NoArgs {\n}\n\n/**\n * Event args for an event that can be canceled.\n */\nexport interface CancelEventArgs extends NoArgs {\n  /**\n   * Gets or sets a flag whether the event should be canceled.\n   */\n  cancel?: boolean;\n}\n\n/**\n * Public interface that represents an event. Can be used to subscribe to and unsubscribe from events.\n */\nexport interface Event<Sender, Args> {\n  /**\n   * Subscribes an event listener to this event dispatcher.\n   * @param listener the listener to add\n   */\n  subscribe(listener: EventListener<Sender, Args>): void;\n\n  /**\n   * Subscribes an event listener to this event dispatcher that is only called once.\n   * @param listener the listener to add\n   */\n  subscribeOnce(listener: EventListener<Sender, Args>): void;\n\n  /**\n   * Subscribes an event listener to this event dispatcher that will be called at a limited rate with a minimum\n   * interval of the specified milliseconds.\n   * @param listener the listener to add\n   * @param rateMs the rate in milliseconds to which calling of the listeners should be limited\n   */\n  subscribeRateLimited(listener: EventListener<Sender, Args>, rateMs: number): void;\n\n  /**\n   * Unsubscribes a subscribed event listener from this dispatcher.\n   * @param listener the listener to remove\n   * @returns {boolean} true if the listener was successfully unsubscribed, false if it isn't subscribed on this\n   *   dispatcher\n   */\n  unsubscribe(listener: EventListener<Sender, Args>): boolean;\n}\n\n/**\n * Event dispatcher to subscribe and trigger events. Each event should have its own dispatcher.\n */\nexport class EventDispatcher<Sender, Args> implements Event<Sender, Args> {\n\n  private listeners: EventListenerWrapper<Sender, Args>[] = [];\n\n  constructor() {\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribe(listener: EventListener<Sender, Args>) {\n    this.listeners.push(new EventListenerWrapper(listener));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribeOnce(listener: EventListener<Sender, Args>) {\n    this.listeners.push(new EventListenerWrapper(listener, true));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribeRateLimited(listener: EventListener<Sender, Args>, rateMs: number) {\n    this.listeners.push(new RateLimitedEventListenerWrapper(listener, rateMs));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  unsubscribe(listener: EventListener<Sender, Args>): boolean {\n    // Iterate through listeners, compare with parameter, and remove if found\n    for (let i = 0; i < this.listeners.length; i++) {\n      let subscribedListener = this.listeners[i];\n      if (subscribedListener.listener === listener) {\n        ArrayUtils.remove(this.listeners, subscribedListener);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Removes all listeners from this dispatcher.\n   */\n  unsubscribeAll(): void {\n    this.listeners = [];\n  }\n\n  /**\n   * Dispatches an event to all subscribed listeners.\n   * @param sender the source of the event\n   * @param args the arguments for the event\n   */\n  dispatch(sender: Sender, args: Args = null) {\n    let listenersToRemove = [];\n\n    // Call every listener\n    for (let listener of this.listeners) {\n      listener.fire(sender, args);\n\n      if (listener.isOnce()) {\n        listenersToRemove.push(listener);\n      }\n    }\n\n    // Remove one-time listener\n    for (let listenerToRemove of listenersToRemove) {\n      ArrayUtils.remove(this.listeners, listenerToRemove);\n    }\n  }\n\n  /**\n   * Returns the event that this dispatcher manages and on which listeners can subscribe and unsubscribe event handlers.\n   * @returns {Event}\n   */\n  getEvent(): Event<Sender, Args> {\n    // For now, just cast the event dispatcher to the event interface. At some point in the future when the\n    // codebase grows, it might make sense to split the dispatcher into separate dispatcher and event classes.\n    return <Event<Sender, Args>>this;\n  }\n}\n\n/**\n * A basic event listener wrapper to manage listeners within the {@link EventDispatcher}. This is a 'private' class\n * for internal dispatcher use and it is therefore not exported.\n */\nclass EventListenerWrapper<Sender, Args> {\n\n  private eventListener: EventListener<Sender, Args>;\n  private once: boolean;\n\n  constructor(listener: EventListener<Sender, Args>, once: boolean = false) {\n    this.eventListener = listener;\n    this.once = once;\n  }\n\n  /**\n   * Returns the wrapped event listener.\n   * @returns {EventListener<Sender, Args>}\n   */\n  get listener(): EventListener<Sender, Args> {\n    return this.eventListener;\n  }\n\n  /**\n   * Fires the wrapped event listener with the given arguments.\n   * @param sender\n   * @param args\n   */\n  fire(sender: Sender, args: Args) {\n    this.eventListener(sender, args);\n  }\n\n  /**\n   * Checks if this listener is scheduled to be called only once.\n   * @returns {boolean} once if true\n   */\n  isOnce(): boolean {\n    return this.once;\n  }\n}\n\n/**\n * Extends the basic {@link EventListenerWrapper} with rate-limiting functionality.\n */\nclass RateLimitedEventListenerWrapper<Sender, Args> extends EventListenerWrapper<Sender, Args> {\n\n  private rateMs: number;\n  private rateLimitingEventListener: EventListener<Sender, Args>;\n\n  private lastFireTime: number;\n\n  constructor(listener: EventListener<Sender, Args>, rateMs: number) {\n    super(listener); // sets the event listener sink\n\n    this.rateMs = rateMs;\n    this.lastFireTime = 0;\n\n    // Wrap the event listener with an event listener that does the rate-limiting\n    this.rateLimitingEventListener = (sender: Sender, args: Args) => {\n      if (Date.now() - this.lastFireTime > this.rateMs) {\n        // Only if enough time since the previous call has passed, call the\n        // actual event listener and record the current time\n        this.fireSuper(sender, args);\n        this.lastFireTime = Date.now();\n      }\n    };\n  }\n\n  private fireSuper(sender: Sender, args: Args) {\n    // Fire the actual external event listener\n    super.fire(sender, args);\n  }\n\n  fire(sender: Sender, args: Args) {\n    // Fire the internal rate-limiting listener instead of the external event listener\n    this.rateLimitingEventListener(sender, args);\n  }\n}","export namespace Guid {\n\n  let guid = 1;\n\n  export function next() {\n    return guid++;\n  }\n}\n","/// <reference path='player.d.ts' />\nimport {UIManager, UIInstanceManager} from './uimanager';\nimport {Button} from './components/button';\nimport {ControlBar} from './components/controlbar';\nimport {FullscreenToggleButton} from './components/fullscreentogglebutton';\nimport {HugePlaybackToggleButton} from './components/hugeplaybacktogglebutton';\nimport {PlaybackTimeLabel, PlaybackTimeLabelMode} from './components/playbacktimelabel';\nimport {PlaybackToggleButton} from './components/playbacktogglebutton';\nimport {SeekBar} from './components/seekbar';\nimport {SelectBox} from './components/selectbox';\nimport {SettingsPanel, SettingsPanelItem} from './components/settingspanel';\nimport {SettingsToggleButton} from './components/settingstogglebutton';\nimport {ToggleButton} from './components/togglebutton';\nimport {VideoQualitySelectBox} from './components/videoqualityselectbox';\nimport {VolumeToggleButton} from './components/volumetogglebutton';\nimport {VRToggleButton} from './components/vrtogglebutton';\nimport {Watermark} from './components/watermark';\nimport {UIContainer} from './components/uicontainer';\nimport {Container} from './components/container';\nimport {Label} from './components/label';\nimport {AudioQualitySelectBox} from './components/audioqualityselectbox';\nimport {AudioTrackSelectBox} from './components/audiotrackselectbox';\nimport {CastStatusOverlay} from './components/caststatusoverlay';\nimport {CastToggleButton} from './components/casttogglebutton';\nimport {Component} from './components/component';\nimport {ErrorMessageOverlay} from './components/errormessageoverlay';\nimport {RecommendationOverlay} from './components/recommendationoverlay';\nimport {SeekBarLabel} from './components/seekbarlabel';\nimport {SubtitleOverlay} from './components/subtitleoverlay';\nimport {SubtitleSelectBox} from './components/subtitleselectbox';\nimport {TitleBar} from './components/titlebar';\nimport {VolumeControlButton} from './components/volumecontrolbutton';\nimport {ClickOverlay} from './components/clickoverlay';\nimport {AdSkipButton} from './components/adskipbutton';\nimport {AdMessageLabel} from './components/admessagelabel';\nimport {AdClickOverlay} from './components/adclickoverlay';\nimport {PlaybackSpeedSelectBox} from './components/playbackspeedselectbox';\nimport {HugeReplayButton} from './components/hugereplaybutton';\nimport {BufferingOverlay} from './components/bufferingoverlay';\nimport {CastUIContainer} from './components/castuicontainer';\nimport {PlaybackToggleOverlay} from './components/playbacktoggleoverlay';\nimport {CloseButton} from './components/closebutton';\nimport {MetadataLabel, MetadataLabelContent} from './components/metadatalabel';\nimport {AirPlayToggleButton} from './components/airplaytogglebutton';\nimport {VolumeSlider} from './components/volumeslider';\nimport {PictureInPictureToggleButton} from './components/pictureinpicturetogglebutton';\nimport {Spacer} from './components/spacer';\nimport {ArrayUtils, StringUtils, PlayerUtils, UIUtils, BrowserUtils} from './utils';\n\n// Object.assign polyfill for ES5/IE9\n// https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nif (typeof Object.assign !== 'function') {\n  Object.assign = function(target: any) {\n    'use strict';\n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    target = Object(target);\n    for (let index = 1; index < arguments.length; index++) {\n      let source = arguments[index];\n      if (source != null) {\n        for (let key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n    }\n    return target;\n  };\n}\n\n// Expose classes to window\n(window as any).bitmovin.playerui = {\n  // Management\n  UIManager,\n  UIInstanceManager,\n  // Utils\n  ArrayUtils,\n  StringUtils,\n  PlayerUtils,\n  UIUtils,\n  BrowserUtils,\n  // Components\n  AdClickOverlay,\n  AdMessageLabel,\n  AdSkipButton,\n  AirPlayToggleButton,\n  AudioQualitySelectBox,\n  AudioTrackSelectBox,\n  BufferingOverlay,\n  Button,\n  CastStatusOverlay,\n  CastToggleButton,\n  CastUIContainer,\n  ClickOverlay,\n  CloseButton,\n  Component,\n  Container,\n  ControlBar,\n  ErrorMessageOverlay,\n  FullscreenToggleButton,\n  HugePlaybackToggleButton,\n  HugeReplayButton,\n  Label,\n  MetadataLabel,\n  MetadataLabelContent,\n  PictureInPictureToggleButton,\n  PlaybackSpeedSelectBox,\n  PlaybackTimeLabel,\n  PlaybackTimeLabelMode,\n  PlaybackToggleButton,\n  PlaybackToggleOverlay,\n  RecommendationOverlay,\n  SeekBar,\n  SeekBarLabel,\n  SelectBox,\n  SettingsPanel,\n  SettingsPanelItem,\n  SettingsToggleButton,\n  Spacer,\n  SubtitleOverlay,\n  SubtitleSelectBox,\n  TitleBar,\n  ToggleButton,\n  UIContainer,\n  VideoQualitySelectBox,\n  VolumeControlButton,\n  VolumeSlider,\n  VolumeToggleButton,\n  VRToggleButton,\n  Watermark,\n};","// TODO change to internal (not exported) class, how to use in other files?\n/**\n * Executes a callback after a specified amount of time,\n * optionally repeatedly until stopped. When delay is <= 0\n * the timeout is disabled\n */\nexport class Timeout {\n\n  private delay: number;\n  private callback: () => void;\n  private repeat: boolean;\n  private timeoutHandle: number;\n\n  /**\n   * Creates a new timeout callback handler.\n   * @param delay the delay in milliseconds after which the callback should be executed\n   * @param callback the callback to execute after the delay time\n   * @param repeat if true, call the callback repeatedly in delay intervals\n   */\n  constructor(delay: number, callback: () => void, repeat: boolean = false) {\n    this.delay = delay;\n    this.callback = callback;\n    this.repeat = repeat;\n    this.timeoutHandle = 0;\n  }\n\n  /**\n   * Starts the timeout and calls the callback when the timeout delay has passed.\n   * @returns {Timeout} the current timeout (so the start call can be chained to the constructor)\n   */\n  start(): this {\n    this.reset();\n    return this;\n  }\n\n  /**\n   * Clears the timeout. The callback will not be called if clear is called during the timeout.\n   */\n  clear(): void {\n    clearTimeout(this.timeoutHandle);\n  }\n\n  /**\n   * Resets the passed timeout delay to zero. Can be used to defer the calling of the callback.\n   */\n  reset(): void {\n    let lastScheduleTime = 0;\n    let delayAdjust = 0;\n\n    this.clear();\n\n    let internalCallback = () => {\n      this.callback();\n\n      if (this.repeat) {\n        let now = Date.now();\n\n        // The time of one iteration from scheduling to executing the callback (usually a bit longer than the delay\n        // time)\n        let delta = now - lastScheduleTime;\n\n        // Calculate the delay adjustment for the next schedule to keep a steady delay interval over time\n        delayAdjust = this.delay - delta + delayAdjust;\n\n        lastScheduleTime = now;\n\n        // Schedule next execution by the adjusted delay\n        this.timeoutHandle = setTimeout(internalCallback, this.delay + delayAdjust);\n      }\n    };\n\n    lastScheduleTime = Date.now();\n    if (this.delay > 0) {\n      this.timeoutHandle = setTimeout(internalCallback, this.delay);\n    }\n  }\n}","import {UIContainer} from './components/uicontainer';\nimport {DOM} from './dom';\nimport {Component, ComponentConfig} from './components/component';\nimport {Container} from './components/container';\nimport {PlaybackToggleButton} from './components/playbacktogglebutton';\nimport {FullscreenToggleButton} from './components/fullscreentogglebutton';\nimport {VRToggleButton} from './components/vrtogglebutton';\nimport {VolumeToggleButton} from './components/volumetogglebutton';\nimport {SeekBar} from './components/seekbar';\nimport {PlaybackTimeLabel, PlaybackTimeLabelMode} from './components/playbacktimelabel';\nimport {ControlBar} from './components/controlbar';\nimport {NoArgs, EventDispatcher, CancelEventArgs} from './eventdispatcher';\nimport {SettingsToggleButton} from './components/settingstogglebutton';\nimport {SettingsPanel, SettingsPanelItem} from './components/settingspanel';\nimport {VideoQualitySelectBox} from './components/videoqualityselectbox';\nimport {Watermark} from './components/watermark';\nimport {AudioQualitySelectBox} from './components/audioqualityselectbox';\nimport {AudioTrackSelectBox} from './components/audiotrackselectbox';\nimport {SeekBarLabel} from './components/seekbarlabel';\nimport {VolumeSlider} from './components/volumeslider';\nimport {SubtitleSelectBox} from './components/subtitleselectbox';\nimport {SubtitleOverlay} from './components/subtitleoverlay';\nimport {VolumeControlButton} from './components/volumecontrolbutton';\nimport {CastToggleButton} from './components/casttogglebutton';\nimport {CastStatusOverlay} from './components/caststatusoverlay';\nimport {ErrorMessageOverlay} from './components/errormessageoverlay';\nimport {TitleBar} from './components/titlebar';\nimport Player = bitmovin.player.Player;\nimport {RecommendationOverlay} from './components/recommendationoverlay';\nimport {AdMessageLabel} from './components/admessagelabel';\nimport {AdSkipButton} from './components/adskipbutton';\nimport {AdClickOverlay} from './components/adclickoverlay';\nimport EVENT = bitmovin.player.EVENT;\nimport PlayerEventCallback = bitmovin.player.PlayerEventCallback;\nimport AdStartedEvent = bitmovin.player.AdStartedEvent;\nimport {ArrayUtils, UIUtils, BrowserUtils} from './utils';\nimport {PlaybackSpeedSelectBox} from './components/playbackspeedselectbox';\nimport {BufferingOverlay} from './components/bufferingoverlay';\nimport {CastUIContainer} from './components/castuicontainer';\nimport {PlaybackToggleOverlay} from './components/playbacktoggleoverlay';\nimport {CloseButton} from './components/closebutton';\nimport {MetadataLabel, MetadataLabelContent} from './components/metadatalabel';\nimport {Label} from './components/label';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\nimport {AirPlayToggleButton} from './components/airplaytogglebutton';\nimport {PictureInPictureToggleButton} from './components/pictureinpicturetogglebutton';\nimport {Spacer} from './components/spacer';\n\nexport interface UIRecommendationConfig {\n  title: string;\n  url: string;\n  thumbnail?: string;\n  duration?: number;\n}\n\nexport interface TimelineMarker {\n  time: number;\n  title?: string;\n  markerType?: string;\n  comment?: string;\n  avatar?: string;\n  number?: string;\n}\n\nexport interface UIConfig {\n  metadata?: {\n    title?: string;\n    description?: string;\n    markers?: TimelineMarker[];\n  };\n  recommendations?: UIRecommendationConfig[];\n}\n\n/**\n * The context that will be passed to a {@link UIConditionResolver} to determine if it's conditions fulfil the context.\n */\nexport interface UIConditionContext {\n  isAd: boolean;\n  isAdWithUI: boolean;\n  isFullscreen: boolean;\n  isMobile: boolean;\n  documentWidth: number;\n  width: number;\n}\n\n/**\n * Resolves the conditions of its associated UI in a {@link UIVariant} upon a {@link UIConditionContext} and decides\n * if the UI should be displayed. If it returns true, the UI is a candidate for display; if it returns false, it will\n * not be displayed in the given context.\n */\nexport interface UIConditionResolver {\n  (context: UIConditionContext): boolean;\n}\n\n/**\n * Associates a UI instance with an optional {@link UIConditionResolver} that determines if the UI should be displayed.\n */\nexport interface UIVariant {\n  ui: UIContainer;\n  condition?: UIConditionResolver;\n}\n\nexport class UIManager {\n\n  private player: Player;\n  private playerElement: DOM;\n  private uiVariants: UIVariant[];\n  private uiInstanceManagers: InternalUIInstanceManager[];\n  private currentUi: InternalUIInstanceManager;\n  private config: UIConfig;\n  private managerPlayerWrapper: PlayerWrapper;\n\n  /**\n   * Creates a UI manager with a single UI variant that will be permanently shown.\n   * @param player the associated player of this UI\n   * @param ui the UI to add to the player\n   * @param config optional UI configuration\n   */\n  constructor(player: Player, ui: UIContainer, config?: UIConfig);\n  /**\n   * Creates a UI manager with a list of UI variants that will be dynamically selected and switched according to\n   * the context of the UI.\n   *\n   * Every time the UI context changes, the conditions of the UI variants will be sequentially resolved and the first\n   * UI, whose condition evaluates to true, will be selected and displayed. The last variant in the list might omit the\n   * condition resolver and will be selected as default/fallback UI when all other conditions fail. If there is no\n   * fallback UI and all conditions fail, no UI will be displayed.\n   *\n   * @param player the associated player of this UI\n   * @param uiVariants a list of UI variants that will be dynamically switched\n   * @param config optional UI configuration\n   */\n  constructor(player: Player, uiVariants: UIVariant[], config?: UIConfig);\n  constructor(player: Player, playerUiOrUiVariants: UIContainer | UIVariant[], config: UIConfig = {}) {\n    if (playerUiOrUiVariants instanceof UIContainer) {\n      // Single-UI constructor has been called, transform arguments to UIVariant[] signature\n      let playerUi = <UIContainer>playerUiOrUiVariants;\n      let adsUi = null;\n\n      let uiVariants = [];\n\n      // Add the ads UI if defined\n      if (adsUi) {\n        uiVariants.push({\n          ui: adsUi,\n          condition: (context: UIConditionContext) => {\n            return context.isAdWithUI;\n          },\n        });\n      }\n\n      // Add the default player UI\n      uiVariants.push({ui: playerUi});\n\n      this.uiVariants = uiVariants;\n    }\n    else {\n      // Default constructor (UIVariant[]) has been called\n      this.uiVariants = <UIVariant[]>playerUiOrUiVariants;\n    }\n\n    this.player = player;\n    this.config = config;\n    this.managerPlayerWrapper = new PlayerWrapper(player);\n    this.playerElement = new DOM(player.getFigure());\n\n    // Create UI instance managers for the UI variants\n    // The instance managers map to the corresponding UI variants by their array index\n    this.uiInstanceManagers = [];\n    let uiVariantsWithoutCondition = [];\n    for (let uiVariant of this.uiVariants) {\n      if (uiVariant.condition == null) {\n        // Collect variants without conditions for error checking\n        uiVariantsWithoutCondition.push(uiVariant);\n      }\n      // Create the instance manager for a UI variant\n      this.uiInstanceManagers.push(new InternalUIInstanceManager(player, uiVariant.ui, this.config));\n    }\n    // Make sure that there is only one UI variant without a condition\n    // It does not make sense to have multiple variants without condition, because only the first one in the list\n    // (the one with the lowest index) will ever be selected.\n    if (uiVariantsWithoutCondition.length > 1) {\n      throw Error('Too many UIs without a condition: You cannot have more than one default UI');\n    }\n    // Make sure that the default UI variant, if defined, is at the end of the list (last index)\n    // If it comes earlier, the variants with conditions that come afterwards will never be selected because the\n    // default variant without a condition always evaluates to 'true'\n    if (uiVariantsWithoutCondition.length > 0\n      && uiVariantsWithoutCondition[0] !== this.uiVariants[this.uiVariants.length - 1]) {\n      throw Error('Invalid UI variant order: the default UI (without condition) must be at the end of the list');\n    }\n\n    let adStartedEvent: AdStartedEvent = null; // keep the event stored here during ad playback\n    let isMobile = BrowserUtils.isMobile;\n\n    // Dynamically select a UI variant that matches the current UI condition.\n    let resolveUiVariant = (event: PlayerEvent) => {\n      // Make sure that the ON_AD_STARTED event data is persisted through ad playback in case other events happen\n      // in the meantime, e.g. player resize. We need to store this data because there is no other way to find out\n      // ad details (e.g. the ad client) while an ad is playing.\n      // Existing event data signals that an ad is currently active. We cannot use player.isAd() because it returns\n      // true on ad start and also on ad end events, which is problematic.\n      if (event != null) {\n        switch (event.type) {\n          // When the ad starts, we store the event data\n          case player.EVENT.ON_AD_STARTED:\n            adStartedEvent = <AdStartedEvent>event;\n            break;\n          // When the ad ends, we delete the event data\n          case player.EVENT.ON_AD_FINISHED:\n          case player.EVENT.ON_AD_SKIPPED:\n          case player.EVENT.ON_AD_ERROR:\n            adStartedEvent = null;\n        }\n      }\n\n      // Detect if an ad has started\n      let ad = adStartedEvent != null;\n      let adWithUI = ad && adStartedEvent.clientType === 'vast';\n\n      // Determine the current context for which the UI variant will be resolved\n      let context: UIConditionContext = {\n        isAd: ad,\n        isAdWithUI: adWithUI,\n        isFullscreen: this.player.isFullscreen(),\n        isMobile: isMobile,\n        width: this.playerElement.width(),\n        documentWidth: document.body.clientWidth,\n      };\n\n      let nextUi: InternalUIInstanceManager = null;\n      let uiVariantChanged = false;\n\n      // Select new UI variant\n      // If no variant condition is fulfilled, we switch to *no* UI\n      for (let uiVariant of this.uiVariants) {\n        if (uiVariant.condition == null || uiVariant.condition(context) === true) {\n          nextUi = this.uiInstanceManagers[this.uiVariants.indexOf(uiVariant)];\n          break;\n        }\n      }\n\n      // Determine if the UI variant is changing\n      if (nextUi !== this.currentUi) {\n        uiVariantChanged = true;\n        // console.log('switched from ', this.currentUi ? this.currentUi.getUI() : 'none',\n        //   ' to ', nextUi ? nextUi.getUI() : 'none');\n      }\n\n      // Only if the UI variant is changing, we need to do some stuff. Else we just leave everything as-is.\n      if (uiVariantChanged) {\n        // Hide the currently active UI variant\n        if (this.currentUi) {\n          this.currentUi.getUI().hide();\n        }\n\n        // Assign the new UI variant as current UI\n        this.currentUi = nextUi;\n\n        // When we switch to a different UI instance, there's some additional stuff to manage. If we do not switch\n        // to an instance, we're done here.\n        if (this.currentUi != null) {\n          // Add the UI to the DOM (and configure it) the first time it is selected\n          if (!this.currentUi.isConfigured()) {\n            this.addUi(this.currentUi);\n          }\n\n          // If this is an ad UI, we need to relay the saved ON_AD_STARTED event data so ad components can configure\n          // themselves for the current ad.\n          if (context.isAd) {\n            /* Relay the ON_AD_STARTED event to the ads UI\n             *\n             * Because the ads UI is initialized in the ON_AD_STARTED handler, i.e. when the ON_AD_STARTED event has\n             * already been fired, components in the ads UI that listen for the ON_AD_STARTED event never receive it.\n             * Since this can break functionality of components that rely on this event, we relay the event to the\n             * ads UI components with the following call.\n             */\n            this.currentUi.getWrappedPlayer().fireEventInUI(this.player.EVENT.ON_AD_STARTED, adStartedEvent);\n          }\n\n          this.currentUi.getUI().show();\n        }\n      }\n    };\n\n    // Listen to the following events to trigger UI variant resolution\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_STARTED, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_FINISHED, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_SKIPPED, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_ERROR, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_PLAYER_RESIZE, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_FULLSCREEN_ENTER, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_FULLSCREEN_EXIT, resolveUiVariant);\n\n    // Initialize the UI\n    resolveUiVariant(null);\n  }\n\n  getConfig(): UIConfig {\n    return this.config;\n  }\n\n  private addUi(ui: InternalUIInstanceManager): void {\n    let dom = ui.getUI().getDomElement();\n    ui.configureControls();\n    /* Append the UI DOM after configuration to avoid CSS transitions at initialization\n     * Example: Components are hidden during configuration and these hides may trigger CSS transitions that are\n     * undesirable at this time. */\n\n    /* Append ui to parent instead of player */\n    let parentElement = new DOM(this.playerElement.getElements()[0].parentElement);\n    parentElement.addClass('smashcut-custom-ui-bitmovin-player-holder');\n    parentElement.append(dom);\n\n    // Fire onConfigured after UI DOM elements are successfully added. When fired immediately, the DOM elements\n    // might not be fully configured and e.g. do not have a size.\n    // https://swizec.com/blog/how-to-properly-wait-for-dom-elements-to-show-up-in-modern-browsers/swizec/6663\n    if (window.requestAnimationFrame) {\n      requestAnimationFrame(() => {\n        ui.onConfigured.dispatch(ui.getUI());\n      });\n    } else {\n      // IE9 fallback\n      setTimeout(() => {\n        ui.onConfigured.dispatch(ui.getUI());\n      }, 0);\n    }\n  }\n\n  private releaseUi(ui: InternalUIInstanceManager): void {\n    ui.releaseControls();\n    ui.getUI().getDomElement().remove();\n    ui.clearEventHandlers();\n  }\n\n  release(): void {\n    for (let uiInstanceManager of this.uiInstanceManagers) {\n      this.releaseUi(uiInstanceManager);\n    }\n    this.managerPlayerWrapper.clearEventHandlers();\n  }\n}\n\nexport namespace UIManager.Factory {\n\n  export function buildDefaultUI(player: Player, config: UIConfig = {}): UIManager {\n    return UIManager.Factory.buildModernUI(player, config);\n  }\n\n  export function buildDefaultSmallScreenUI(player: Player, config: UIConfig = {}): UIManager {\n    return UIManager.Factory.buildModernSmallScreenUI(player, config);\n  }\n\n  export function buildDefaultCastReceiverUI(player: Player, config: UIConfig = {}): UIManager {\n    return UIManager.Factory.buildModernCastReceiverUI(player, config);\n  }\n\n  function smashcutUi() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBarTop = new Container({\n      cssClasses: ['controlbar-top'],\n      components: [\n        new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n        new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n      ]\n    });\n\n    let controlBarMiddle = new Container({\n      cssClasses: ['controlbar-middle'],\n      components: [\n        new SeekBar({label: new SeekBarLabel()}),\n      ]\n    });\n\n    let controlBarBottom = new Container({\n      cssClasses: ['controlbar-bottom'],\n      components: [\n        new Spacer(),\n        new VolumeSlider(),\n        new VolumeToggleButton(),\n        new SettingsToggleButton({settingsPanel: settingsPanel}),\n        new FullscreenToggleButton(),\n      ]\n    });\n\n\n    let controlBar = new ControlBar({\n      components: [\n        new PlaybackToggleButton(),\n        new Container({\n          cssClasses: ['controlbar-inner'],\n          components: [\n            settingsPanel,\n            controlBarTop,\n            controlBarMiddle,\n            controlBarBottom,\n          ]\n        })\n      ]\n    });\n\n    return new UIContainer({\n      hideDelay: 0,\n      cssClasses: ['ui-skin-modern ui-skin-smashcut'],\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        /** new PlaybackToggleOverlay(), **/\n        controlBar,\n        new TitleBar(),\n        new RecommendationOverlay(),\n        new ErrorMessageOverlay()\n      ]\n    });\n  }\n\n  function modernUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBar = new ControlBar({\n      components: [\n        settingsPanel,\n        new Container({\n          components: [\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n            new SeekBar({label: new SeekBarLabel()}),\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n          ],\n          cssClasses: ['controlbar-top']\n        }),\n        new Container({\n          components: [\n            new PlaybackToggleButton(),\n            new VolumeToggleButton(),\n            new VolumeSlider(),\n            new Spacer(),\n            new PictureInPictureToggleButton(),\n            new AirPlayToggleButton(),\n            new CastToggleButton(),\n            new VRToggleButton(),\n            new SettingsToggleButton({settingsPanel: settingsPanel}),\n            new FullscreenToggleButton(),\n          ],\n          cssClasses: ['controlbar-bottom']\n        }),\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new PlaybackToggleOverlay(),\n        new CastStatusOverlay(),\n        controlBar,\n        new TitleBar(),\n        new RecommendationOverlay(),\n        new Watermark(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-modern']\n    });\n  }\n\n  function modernAdsUI() {\n    return new UIContainer({\n      components: [\n        new BufferingOverlay(),\n        new AdClickOverlay(),\n        new PlaybackToggleOverlay(),\n        new Container({\n          components: [\n            new AdMessageLabel({text: 'Ad: {remainingTime} secs'}),\n            new AdSkipButton()\n          ],\n          cssClass: 'ui-ads-status'\n        }),\n        new ControlBar({\n          components: [\n            new Container({\n              components: [\n                new PlaybackToggleButton(),\n                new VolumeToggleButton(),\n                new VolumeSlider(),\n                new Spacer(),\n                new FullscreenToggleButton(),\n              ],\n              cssClasses: ['controlbar-bottom']\n            }),\n          ]\n        })\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-ads']\n    });\n  }\n\n  function modernSmallScreenUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true,\n      hideDelay: -1,\n    });\n    settingsPanel.addComponent(new CloseButton({target: settingsPanel}));\n\n    let controlBar = new ControlBar({\n      components: [\n        new Container({\n          components: [\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n            new SeekBar({label: new SeekBarLabel()}),\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n          ],\n          cssClasses: ['controlbar-top']\n        }),\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        controlBar,\n        new TitleBar({\n          components: [\n            new MetadataLabel({content: MetadataLabelContent.Title}),\n            new CastToggleButton(),\n            /*new VRToggleButton(),*/\n            new SettingsToggleButton({settingsPanel: settingsPanel}),\n            new FullscreenToggleButton(),\n          ]\n        }),\n        settingsPanel,\n        new RecommendationOverlay(),\n        new Watermark(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-smallscreen']\n    });\n  }\n\n  function modernSmallScreenAdsUI() {\n    return new UIContainer({\n      components: [\n        new BufferingOverlay(),\n        new AdClickOverlay(),\n        new PlaybackToggleOverlay(),\n        new TitleBar({\n          components: [\n            // dummy label with no content to move buttons to the right\n            new Label({cssClass: 'label-metadata-title'}),\n            new FullscreenToggleButton(),\n          ]\n        }),\n        new Container({\n          components: [\n            new AdMessageLabel({text: 'Ad: {remainingTime} secs'}),\n            new AdSkipButton()\n          ],\n          cssClass: 'ui-ads-status'\n        }),\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-ads', 'ui-skin-smallscreen']\n    });\n  }\n\n  function modernCastReceiverUI() {\n    let controlBar = new ControlBar({\n      components: [\n        new Container({\n          components: [\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n            new SeekBar({smoothPlaybackPositionUpdateIntervalMs: -1}),\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n          ],\n          cssClasses: ['controlbar-top']\n        }),\n      ]\n    });\n\n    return new CastUIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        controlBar,\n        new TitleBar({keepHiddenWithoutMetadata: true}),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-cast-receiver']\n    });\n  }\n\n  export function buildModernUI(player: Player, config: UIConfig = {}): UIManager {\n    // show smallScreen UI only on mobile/handheld devices\n    let smallScreenSwitchWidth = 600;\n\n    return new UIManager(player, [{\n      ui: modernSmallScreenAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isMobile && context.documentWidth < smallScreenSwitchWidth && context.isAdWithUI;\n      }\n    }, {\n      ui: modernAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isAdWithUI;\n      }\n    }, {\n      ui: modernSmallScreenUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isMobile && context.documentWidth < smallScreenSwitchWidth;\n      }\n    }, {\n      ui: smashcutUi()\n    }], config);\n  }\n\n  export function buildModernSmallScreenUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, [{\n      ui: modernSmallScreenAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isAdWithUI;\n      }\n    }, {\n      ui: modernSmallScreenUI()\n    }], config);\n  }\n\n  export function buildModernCastReceiverUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, modernCastReceiverUI(), config);\n  }\n\n  function legacyUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBar = new ControlBar({\n      components: [\n        settingsPanel,\n        new PlaybackToggleButton(),\n        new SeekBar({label: new SeekBarLabel()}),\n        new PlaybackTimeLabel(),\n        new VRToggleButton(),\n        new VolumeControlButton(),\n        new SettingsToggleButton({settingsPanel: settingsPanel}),\n        new CastToggleButton(),\n        new FullscreenToggleButton()\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        new RecommendationOverlay(),\n        controlBar,\n        new TitleBar(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-legacy']\n    });\n  }\n\n  function legacyAdsUI() {\n    return new UIContainer({\n      components: [\n        new AdClickOverlay(),\n        new ControlBar({\n          components: [\n            new PlaybackToggleButton(),\n            new AdMessageLabel(),\n            new VolumeControlButton(),\n            new FullscreenToggleButton()\n          ]\n        }),\n        new AdSkipButton()\n      ], cssClasses: ['ui-skin-legacy', 'ui-skin-ads']\n    });\n  }\n\n  function legacyCastReceiverUI() {\n    let controlBar = new ControlBar({\n      components: [\n        new SeekBar(),\n        new PlaybackTimeLabel(),\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        controlBar,\n        new TitleBar(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-legacy', 'ui-skin-cast-receiver']\n    });\n  }\n\n  function legacyTestUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBar = new ControlBar({\n      components: [settingsPanel,\n        new PlaybackToggleButton(),\n        new SeekBar({label: new SeekBarLabel()}),\n        new PlaybackTimeLabel(),\n        new VRToggleButton(),\n        new VolumeToggleButton(),\n        new VolumeSlider(),\n        new VolumeControlButton(),\n        new VolumeControlButton({vertical: false}),\n        new SettingsToggleButton({settingsPanel: settingsPanel}),\n        new CastToggleButton(),\n        new FullscreenToggleButton()\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        new RecommendationOverlay(),\n        controlBar,\n        new TitleBar(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-legacy']\n    });\n  }\n\n  export function buildLegacyUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, [{\n      ui: legacyAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isAdWithUI;\n      }\n    }, {\n      ui: legacyUI()\n    }], config);\n  }\n\n  export function buildLegacyCastReceiverUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, legacyCastReceiverUI(), config);\n  }\n\n  export function buildLegacyTestUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, legacyTestUI(), config);\n  }\n}\n\nexport interface SeekPreviewArgs extends NoArgs {\n  /**\n   * The timeline position in percent where the event originates from.\n   */\n  position: number;\n  /**\n   * The timeline marker associated with the current position, if existing.\n   */\n  marker?: TimelineMarker;\n}\n\n/**\n * Encapsulates functionality to manage a UI instance. Used by the {@link UIManager} to manage multiple UI instances.\n */\nexport class UIInstanceManager {\n  private playerWrapper: PlayerWrapper;\n  private ui: UIContainer;\n  private config: UIConfig;\n\n  private events = {\n    onConfigured: new EventDispatcher<UIContainer, NoArgs>(),\n    onSeek: new EventDispatcher<SeekBar, NoArgs>(),\n    onSeekPreview: new EventDispatcher<SeekBar, SeekPreviewArgs>(),\n    onSeeked: new EventDispatcher<SeekBar, NoArgs>(),\n    onComponentShow: new EventDispatcher<Component<ComponentConfig>, NoArgs>(),\n    onComponentHide: new EventDispatcher<Component<ComponentConfig>, NoArgs>(),\n    onControlsShow: new EventDispatcher<UIContainer, NoArgs>(),\n    onPreviewControlsHide: new EventDispatcher<UIContainer, CancelEventArgs>(),\n    onControlsHide: new EventDispatcher<UIContainer, NoArgs>(),\n  };\n\n  constructor(player: Player, ui: UIContainer, config: UIConfig = {}) {\n    this.playerWrapper = new PlayerWrapper(player);\n    this.ui = ui;\n    this.config = config;\n  }\n\n  getConfig(): UIConfig {\n    return this.config;\n  }\n\n  getUI(): UIContainer {\n    return this.ui;\n  }\n\n  getPlayer(): Player {\n    return this.playerWrapper.getPlayer();\n  }\n\n  /**\n   * Fires when the UI is fully configured and added to the DOM.\n   * @returns {EventDispatcher}\n   */\n  get onConfigured(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onConfigured;\n  }\n\n  /**\n   * Fires when a seek starts.\n   * @returns {EventDispatcher}\n   */\n  get onSeek(): EventDispatcher<SeekBar, NoArgs> {\n    return this.events.onSeek;\n  }\n\n  /**\n   * Fires when the seek timeline is scrubbed.\n   * @returns {EventDispatcher}\n   */\n  get onSeekPreview(): EventDispatcher<SeekBar, SeekPreviewArgs> {\n    return this.events.onSeekPreview;\n  }\n\n  /**\n   * Fires when a seek is finished.\n   * @returns {EventDispatcher}\n   */\n  get onSeeked(): EventDispatcher<SeekBar, NoArgs> {\n    return this.events.onSeeked;\n  }\n\n  /**\n   * Fires when a component is showing.\n   * @returns {EventDispatcher}\n   */\n  get onComponentShow(): EventDispatcher<Component<ComponentConfig>, NoArgs> {\n    return this.events.onComponentShow;\n  }\n\n  /**\n   * Fires when a component is hiding.\n   * @returns {EventDispatcher}\n   */\n  get onComponentHide(): EventDispatcher<Component<ComponentConfig>, NoArgs> {\n    return this.events.onComponentHide;\n  }\n\n  /**\n   * Fires when the UI controls are showing.\n   * @returns {EventDispatcher}\n   */\n  get onControlsShow(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onControlsShow;\n  }\n\n  /**\n   * Fires before the UI controls are hiding to check if they are allowed to hide.\n   * @returns {EventDispatcher}\n   */\n  get onPreviewControlsHide(): EventDispatcher<UIContainer, CancelEventArgs> {\n    return this.events.onPreviewControlsHide;\n  }\n\n  /**\n   * Fires when the UI controls are hiding.\n   * @returns {EventDispatcher}\n   */\n  get onControlsHide(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onControlsHide;\n  }\n\n  protected clearEventHandlers(): void {\n    this.playerWrapper.clearEventHandlers();\n\n    let events = <any>this.events; // avoid TS7017\n    for (let event in events) {\n      let dispatcher = <EventDispatcher<Object, Object>>events[event];\n      dispatcher.unsubscribeAll();\n    }\n  }\n}\n\n/**\n * Extends the {@link UIInstanceManager} for internal use in the {@link UIManager} and provides access to functionality\n * that components receiving a reference to the {@link UIInstanceManager} should not have access to.\n */\nclass InternalUIInstanceManager extends UIInstanceManager {\n\n  private configured: boolean;\n  private released: boolean;\n\n  getWrappedPlayer(): WrappedPlayer {\n    // TODO find a non-hacky way to provide the WrappedPlayer to the UIManager without exporting it\n    // getPlayer() actually returns the WrappedPlayer but its return type is set to Player so the WrappedPlayer does\n    // not need to be exported\n    return <WrappedPlayer>this.getPlayer();\n  }\n\n  configureControls(): void {\n    this.configureControlsTree(this.getUI());\n    this.configured = true;\n  }\n\n  isConfigured(): boolean {\n    return this.configured;\n  }\n\n  private configureControlsTree(component: Component<ComponentConfig>) {\n    let configuredComponents: Component<ComponentConfig>[] = [];\n\n    UIUtils.traverseTree(component, (component) => {\n      // First, check if we have already configured a component, and throw an error if we did. Multiple configuration\n      // of the same component leads to unexpected UI behavior. Also, a component that is in the UI tree multiple\n      // times hints at a wrong UI structure.\n      // We could just skip configuration in such a case and not throw an exception, but enforcing a clean UI tree\n      // seems like the better choice.\n      for (let configuredComponent of configuredComponents) {\n        if (configuredComponent === component) {\n          // Write the component to the console to simplify identification of the culprit\n          // (e.g. by inspecting the config)\n          if (console) {\n            console.error('Circular reference in UI tree', component);\n          }\n\n          // Additionally throw an error, because this case must not happen and leads to unexpected UI behavior.\n          throw Error('Circular reference in UI tree: ' + component.constructor.name);\n        }\n      }\n\n      component.initialize();\n      component.configure(this.getPlayer(), this);\n      configuredComponents.push(component);\n    });\n  }\n\n  releaseControls(): void {\n    // Do not call release methods if the components have never been configured; this can result in exceptions\n    if (this.configured) {\n      this.releaseControlsTree(this.getUI());\n      this.configured = false;\n    }\n    this.released = true;\n  }\n\n  isReleased(): boolean {\n    return this.released;\n  }\n\n  private releaseControlsTree(component: Component<ComponentConfig>) {\n    component.release();\n\n    if (component instanceof Container) {\n      for (let childComponent of component.getComponents()) {\n        this.releaseControlsTree(childComponent);\n      }\n    }\n  }\n\n  clearEventHandlers(): void {\n    super.clearEventHandlers();\n  }\n}\n\n/**\n * Extended interface of the {@link Player} for use in the UI.\n */\ninterface WrappedPlayer extends Player {\n  /**\n   * Fires an event on the player that targets all handlers in the UI but never enters the real player.\n   * @param event the event to fire\n   * @param data data to send with the event\n   */\n  fireEventInUI(event: EVENT, data: {}): void;\n}\n\n/**\n * Wraps the player to track event handlers and provide a simple method to remove all registered event\n * handlers from the player.\n */\nclass PlayerWrapper {\n\n  private player: Player;\n  private wrapper: WrappedPlayer;\n\n  private eventHandlers: { [eventType: string]: PlayerEventCallback[]; } = {};\n\n  constructor(player: Player) {\n    this.player = player;\n\n    // Collect all public API methods of the player\n    let methods = <any[]>[];\n    for (let member in player) {\n      if (typeof (<any>player)[member] === 'function') {\n        methods.push(member);\n      }\n    }\n\n    // Create wrapper object and add function wrappers for all API methods that do nothing but calling the base method\n    // on the player\n    let wrapper = <any>{};\n    for (let member of methods) {\n      wrapper[member] = function () {\n        // console.log('called ' + member); // track method calls on the player\n        return (<any>player)[member].apply(player, arguments);\n      };\n    }\n\n    // Collect all public properties of the player and add it to the wrapper\n    for (let member in player) {\n      if (typeof (<any>player)[member] !== 'function') {\n        wrapper[member] = (<any>player)[member];\n      }\n    }\n\n    // Explicitly add a wrapper method for 'addEventHandler' that adds added event handlers to the event list\n    wrapper.addEventHandler = (eventType: EVENT, callback: PlayerEventCallback) => {\n      player.addEventHandler(eventType, callback);\n\n      if (!this.eventHandlers[eventType]) {\n        this.eventHandlers[eventType] = [];\n      }\n\n      this.eventHandlers[eventType].push(callback);\n\n      return wrapper;\n    };\n\n    // Explicitly add a wrapper method for 'removeEventHandler' that removes removed event handlers from the event list\n    wrapper.removeEventHandler = (eventType: EVENT, callback: PlayerEventCallback) => {\n      player.removeEventHandler(eventType, callback);\n\n      if (this.eventHandlers[eventType]) {\n        ArrayUtils.remove(this.eventHandlers[eventType], callback);\n      }\n\n      return wrapper;\n    };\n\n    wrapper.fireEventInUI = (event: EVENT, data: {}) => {\n      if (this.eventHandlers[event]) { // check if there are handlers for this event registered\n        // Extend the data object with default values to convert it to a {@link PlayerEvent} object.\n        let playerEventData = <PlayerEvent>Object.assign({}, {\n          timestamp: Date.now(),\n          type: event,\n          // Add a marker property so the UI can detect UI-internal player events\n          uiSourced: true,\n        }, data);\n\n        // Execute the registered callbacks\n        for (let callback of this.eventHandlers[event]) {\n          callback(playerEventData);\n        }\n      }\n    };\n\n    this.wrapper = <WrappedPlayer>wrapper;\n  }\n\n  /**\n   * Returns a wrapped player object that can be used on place of the normal player object.\n   * @returns {WrappedPlayer} a wrapped player\n   */\n  getPlayer(): WrappedPlayer {\n    return this.wrapper;\n  }\n\n  /**\n   * Clears all registered event handlers from the player that were added through the wrapped player.\n   */\n  clearEventHandlers(): void {\n    for (let eventType in this.eventHandlers) {\n      for (let callback of this.eventHandlers[eventType]) {\n        this.player.removeEventHandler(eventType, callback);\n      }\n    }\n  }\n}\n","import {EventDispatcher, Event, NoArgs} from './eventdispatcher';\nimport {Component, ComponentConfig} from './components/component';\nimport {Container} from './components/container';\n\nexport namespace ArrayUtils {\n  /**\n   * Removes an item from an array.\n   * @param array the array that may contain the item to remove\n   * @param item the item to remove from the array\n   * @returns {any} the removed item or null if it wasn't part of the array\n   */\n  export function remove<T>(array: T[], item: T): T | null {\n    let index = array.indexOf(item);\n\n    if (index > -1) {\n      return array.splice(index, 1)[0];\n    } else {\n      return null;\n    }\n  }\n}\n\nexport namespace StringUtils {\n\n  export let FORMAT_HHMMSS: string = 'hh:mm:ss';\n  export let FORMAT_MMSS: string = 'mm:ss';\n\n  /**\n   * Formats a number of seconds into a time string with the pattern hh:mm:ss.\n   *\n   * @param totalSeconds the total number of seconds to format to string\n   * @param format the time format to output (default: hh:mm:ss)\n   * @returns {string} the formatted time string\n   */\n  export function secondsToTime(totalSeconds: number, format: string = FORMAT_HHMMSS): string {\n    let isNegative = totalSeconds < 0;\n\n    if (isNegative) {\n      // If the time is negative, we make it positive for the calculation below\n      // (else we'd get all negative numbers) and reattach the negative sign later.\n      totalSeconds = -totalSeconds;\n    }\n\n    // Split into separate time parts\n    let hours = Math.floor(totalSeconds / 3600);\n    let minutes = Math.floor(totalSeconds / 60) - hours * 60;\n    let seconds = Math.floor(totalSeconds) % 60;\n\n    return (isNegative ? '-' : '') + format\n        .replace('hh', leftPadWithZeros(hours, 2))\n        .replace('mm', leftPadWithZeros(minutes, 2))\n        .replace('ss', leftPadWithZeros(seconds, 2));\n  }\n\n  /**\n   * Converts a number to a string and left-pads it with zeros to the specified length.\n   * Example: leftPadWithZeros(123, 5) => '00123'\n   *\n   * @param num the number to convert to string and pad with zeros\n   * @param length the desired length of the padded string\n   * @returns {string} the padded number as string\n   */\n  function leftPadWithZeros(num: number | string, length: number): string {\n    let text = num + '';\n    let padding = '0000000000'.substr(0, length - text.length);\n    return padding + text;\n  }\n\n  /**\n   * Fills out placeholders in an ad message.\n   *\n   * Has the placeholders '{remainingTime[formatString]}', '{playedTime[formatString]}' and\n   * '{adDuration[formatString]}', which are replaced by the remaining time until the ad can be skipped, the current\n   * time or the ad duration. The format string is optional. If not specified, the placeholder is replaced by the time\n   * in seconds. If specified, it must be of the following format:\n   * - %d - Inserts the time as an integer.\n   * - %0Nd - Inserts the time as an integer with leading zeroes, if the length of the time string is smaller than N.\n   * - %f - Inserts the time as a float.\n   * - %0Nf - Inserts the time as a float with leading zeroes.\n   * - %.Mf - Inserts the time as a float with M decimal places. Can be combined with %0Nf, e.g. %04.2f (the time\n   * 10.123\n   * would be printed as 0010.12).\n   * - %hh:mm:ss\n   * - %mm:ss\n   *\n   * @param adMessage an ad message with optional placeholders to fill\n   * @param skipOffset if specified, {remainingTime} will be filled with the remaining time until the ad can be skipped\n   * @param player the player to get the time data from\n   * @returns {string} the ad message with filled placeholders\n   */\n  export function replaceAdMessagePlaceholders(adMessage: string, skipOffset: number, player: bitmovin.player.Player) {\n    let adMessagePlaceholderRegex = new RegExp(\n      '\\\\{(remainingTime|playedTime|adDuration)(}|%((0[1-9]\\\\d*(\\\\.\\\\d+(d|f)|d|f)|\\\\.\\\\d+f|d|f)|hh:mm:ss|mm:ss)})',\n      'g'\n    );\n\n    return adMessage.replace(adMessagePlaceholderRegex, (formatString) => {\n      let time = 0;\n      if (formatString.indexOf('remainingTime') > -1) {\n        if (skipOffset) {\n          time = Math.ceil(skipOffset - player.getCurrentTime());\n        } else {\n          time = player.getDuration() - player.getCurrentTime();\n        }\n      } else if (formatString.indexOf('playedTime') > -1) {\n        time = player.getCurrentTime();\n      } else if (formatString.indexOf('adDuration') > -1) {\n        time = player.getDuration();\n      }\n      return formatNumber(time, formatString);\n    });\n  }\n\n  function formatNumber(time: number, format: string) {\n    let formatStringValidationRegex = /%((0[1-9]\\d*(\\.\\d+(d|f)|d|f)|\\.\\d+f|d|f)|hh:mm:ss|mm:ss)/;\n    let leadingZeroesRegex = /(%0[1-9]\\d*)(?=(\\.\\d+f|f|d))/;\n    let decimalPlacesRegex = /\\.\\d*(?=f)/;\n\n    if (!formatStringValidationRegex.test(format)) {\n      // If the format is invalid, we set a default fallback format\n      format = '%d';\n    }\n\n    // Determine the number of leading zeros\n    let leadingZeroes = 0;\n    let leadingZeroesMatches = format.match(leadingZeroesRegex);\n    if (leadingZeroesMatches) {\n      leadingZeroes = parseInt(leadingZeroesMatches[0].substring(2));\n    }\n\n    // Determine the number of decimal places\n    let numDecimalPlaces = null;\n    let decimalPlacesMatches = format.match(decimalPlacesRegex);\n    if (decimalPlacesMatches && !isNaN(parseInt(decimalPlacesMatches[0].substring(1)))) {\n      numDecimalPlaces = parseInt(decimalPlacesMatches[0].substring(1));\n      if (numDecimalPlaces > 20) {\n        numDecimalPlaces = 20;\n      }\n    }\n\n    // Float format\n    if (format.indexOf('f') > -1) {\n      let timeString = '';\n\n      if (numDecimalPlaces !== null) {\n        // Apply fixed number of decimal places\n        timeString = time.toFixed(numDecimalPlaces);\n      } else {\n        timeString = '' + time;\n      }\n\n      // Apply leading zeros\n      if (timeString.indexOf('.') > -1) {\n        return leftPadWithZeros(timeString, timeString.length + (leadingZeroes - timeString.indexOf('.')));\n      } else {\n        return leftPadWithZeros(timeString, leadingZeroes);\n      }\n\n    }\n    // Time format\n    else if (format.indexOf(':') > -1) {\n      let totalSeconds = Math.ceil(time);\n\n      // hh:mm:ss format\n      if (format.indexOf('hh') > -1) {\n        return secondsToTime(totalSeconds);\n      }\n      // mm:ss format\n      else {\n        let minutes = Math.floor(totalSeconds / 60);\n        let seconds = totalSeconds % 60;\n\n        return leftPadWithZeros(minutes, 2) + ':' + leftPadWithZeros(seconds, 2);\n      }\n    }\n    // Integer format\n    else {\n      return leftPadWithZeros(Math.ceil(time), leadingZeroes);\n    }\n  }\n}\n\nexport namespace PlayerUtils {\n\n  import Player = bitmovin.player.Player;\n\n  export enum PlayerState {\n    IDLE,\n    PREPARED,\n    PLAYING,\n    PAUSED,\n    FINISHED,\n  }\n\n  export function isSourceLoaded(player: Player): boolean {\n    return player.getConfig().source !== undefined;\n  }\n\n  export function isTimeShiftAvailable(player: Player): boolean {\n    return player.isLive() && player.getMaxTimeShift() !== 0;\n  }\n\n  export function getState(player: Player): PlayerState {\n    if (player.hasEnded()) {\n      return PlayerState.FINISHED;\n    } else if (player.isPlaying()) {\n      return PlayerState.PLAYING;\n    } else if (player.isPaused()) {\n      return PlayerState.PAUSED;\n    } else if (isSourceLoaded(player)) {\n      return PlayerState.PREPARED;\n    } else {\n      return PlayerState.IDLE;\n    }\n  }\n\n  export interface TimeShiftAvailabilityChangedArgs extends NoArgs {\n    timeShiftAvailable: boolean;\n  }\n\n  export class TimeShiftAvailabilityDetector {\n\n    private timeShiftAvailabilityChangedEvent = new EventDispatcher<Player, TimeShiftAvailabilityChangedArgs>();\n\n    constructor(player: Player) {\n      let timeShiftAvailable: boolean = undefined;\n\n      let timeShiftDetector = () => {\n        if (player.isLive()) {\n          let timeShiftAvailableNow = PlayerUtils.isTimeShiftAvailable(player);\n\n          // When the availability changes, we fire the event\n          if (timeShiftAvailableNow !== timeShiftAvailable) {\n            this.timeShiftAvailabilityChangedEvent.dispatch(player, { timeShiftAvailable: timeShiftAvailableNow });\n            timeShiftAvailable = timeShiftAvailableNow;\n          }\n        }\n      };\n      // Try to detect timeshift availability in ON_READY, which works for DASH streams\n      player.addEventHandler(player.EVENT.ON_READY, timeShiftDetector);\n      // With HLS/NativePlayer streams, getMaxTimeShift can be 0 before the buffer fills, so we need to additionally\n      // check timeshift availability in ON_TIME_CHANGED\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, timeShiftDetector);\n    }\n\n    get onTimeShiftAvailabilityChanged(): Event<Player, TimeShiftAvailabilityChangedArgs> {\n      return this.timeShiftAvailabilityChangedEvent.getEvent();\n    }\n  }\n\n  export interface LiveStreamDetectorEventArgs extends NoArgs {\n    live: boolean;\n  }\n\n  /**\n   * Detects changes of the stream type, i.e. changes of the return value of the player#isLive method.\n   * Normally, a stream cannot change its type during playback, it's either VOD or live. Due to bugs on some\n   * platforms or browsers, it can still change. It is therefore unreliable to just check #isLive and this detector\n   * should be used as a workaround instead.\n   *\n   * Known cases:\n   *\n   * - HLS VOD on Android 4.3\n   * Video duration is initially 'Infinity' and only gets available after playback starts, so streams are wrongly\n   * reported as 'live' before playback (the live-check in the player checks for infinite duration).\n   */\n  export class LiveStreamDetector {\n\n    private liveChangedEvent = new EventDispatcher<Player, LiveStreamDetectorEventArgs>();\n\n    constructor(player: Player) {\n      let live: boolean = undefined;\n\n      let liveDetector = () => {\n        let liveNow = player.isLive();\n\n        // Compare current to previous live state flag and fire event when it changes. Since we initialize the flag\n        // with undefined, there is always at least an initial event fired that tells listeners the live state.\n        if (liveNow !== live) {\n          this.liveChangedEvent.dispatch(player, { live: liveNow });\n          live = liveNow;\n        }\n      };\n      // Initialize when player is ready\n      player.addEventHandler(player.EVENT.ON_READY, liveDetector);\n      // Re-evaluate when playback starts\n      player.addEventHandler(player.EVENT.ON_PLAY, liveDetector);\n\n      // HLS live detection workaround for Android:\n      // Also re-evaluate during playback, because that is when the live flag might change.\n      // (Doing it only in Android Chrome saves unnecessary overhead on other plattforms)\n      if (BrowserUtils.isAndroid && BrowserUtils.isChrome) {\n        player.addEventHandler(player.EVENT.ON_TIME_CHANGED, liveDetector);\n      }\n    }\n\n    get onLiveChanged(): Event<Player, LiveStreamDetectorEventArgs> {\n      return this.liveChangedEvent.getEvent();\n    }\n  }\n}\n\nexport namespace UIUtils {\n  export interface TreeTraversalCallback {\n    (component: Component<ComponentConfig>, parent?: Component<ComponentConfig>): void;\n  }\n\n  export function traverseTree(component: Component<ComponentConfig>, visit: TreeTraversalCallback): void {\n    let recursiveTreeWalker = (component: Component<ComponentConfig>, parent?: Component<ComponentConfig>) => {\n      visit(component, parent);\n\n      // If the current component is a container, visit it's children\n      if (component instanceof Container) {\n        for (let childComponent of component.getComponents()) {\n          recursiveTreeWalker(childComponent, component);\n        }\n      }\n    };\n\n    // Walk and configure the component tree\n    recursiveTreeWalker(component);\n  }\n}\n\nexport namespace BrowserUtils {\n\n  // isMobile only needs to be evaluated once (it cannot change during a browser session)\n  // Mobile detection according to Mozilla recommendation: \"In summary, we recommend looking for the string Mobi\n  // anywhere in the User Agent to detect a mobile device.\"\n  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent\n  export const isMobile = navigator && navigator.userAgent && /Mobi/.test(navigator.userAgent);\n\n  export const isChrome = navigator && navigator.userAgent && /Chrome/.test(navigator.userAgent);\n\n  export const isAndroid = navigator && navigator.userAgent && /Android/.test(navigator.userAgent);\n}"]}