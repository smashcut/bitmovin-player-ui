{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/ts/components/adclickoverlay.ts","src/ts/components/admessagelabel.ts","src/ts/components/adskipbutton.ts","src/ts/components/airplaytogglebutton.ts","src/ts/components/audioqualityselectbox.ts","src/ts/components/audiotrackselectbox.ts","src/ts/components/bufferingoverlay.ts","src/ts/components/button.ts","src/ts/components/caststatusoverlay.ts","src/ts/components/casttogglebutton.ts","src/ts/components/castuicontainer.ts","src/ts/components/clickoverlay.ts","src/ts/components/closebutton.ts","src/ts/components/component.ts","src/ts/components/container.ts","src/ts/components/controlbar.ts","src/ts/components/embedvideotogglebutton.ts","src/ts/components/errormessageoverlay.ts","src/ts/components/fullscreentogglebutton.ts","src/ts/components/hugeplaybacktogglebutton.ts","src/ts/components/hugereplaybutton.ts","src/ts/components/label.ts","src/ts/components/listselector.ts","src/ts/components/metadatalabel.ts","src/ts/components/pictureinpicturetogglebutton.ts","src/ts/components/playbackspeedselectbox.ts","src/ts/components/playbacktimelabel.ts","src/ts/components/playbacktogglebutton.ts","src/ts/components/playbacktoggleoverlay.ts","src/ts/components/recommendationoverlay.ts","src/ts/components/seekbar.ts","src/ts/components/seekbarlabel.ts","src/ts/components/selectbox.ts","src/ts/components/settingspanel.ts","src/ts/components/settingstogglebutton.ts","src/ts/components/spacer.ts","src/ts/components/subtitleoverlay.ts","src/ts/components/subtitleselectbox.ts","src/ts/components/titlebar.ts","src/ts/components/togglebutton.ts","src/ts/components/tvnoisecanvas.ts","src/ts/components/uicontainer.ts","src/ts/components/videoqualityselectbox.ts","src/ts/components/volumecontrolbutton.ts","src/ts/components/volumeslider.ts","src/ts/components/volumetogglebutton.ts","src/ts/components/vrtogglebutton.ts","src/ts/components/watermark.ts","src/ts/dom.ts","src/ts/eventdispatcher.ts","src/ts/guid.ts","src/ts/main.ts","src/ts/timeout.ts","src/ts/uimanager.ts","src/ts/utils.ts"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","clickoverlay_1","AdClickOverlay","_super","__extends","prototype","configure","player","uimanager","_this","this","clickThroughUrl","clickThroughEnabled","getConfig","advertising","hasOwnProperty","addEventHandler","EVENT","ON_AD_STARTED","event","setUrl","adFinishedHandler","ON_AD_FINISHED","ON_AD_SKIPPED","ON_AD_ERROR","onClick","subscribe","pause","fireEvent","ON_AD_CLICKED","ClickOverlay","label_1","utils_1","AdMessageLabel","config","mergeConfig","cssClass","text","updateMessageHandler","setText","StringUtils","replaceAdMessagePlaceholders","adStartHandler","adMessage","ON_TIME_CHANGED","ON_CAST_TIME_UPDATED","adEndHandler","removeEventHandler","Label","button_1","AdSkipButton","skipMessage","countdown","skip","adEvent","updateSkipMessageHandler","skipOffset","show","hide","getCurrentTime","skipAd","Button","togglebutton_1","AirPlayToggleButton","isAirplayAvailable","showAirplayTargetPicker","console","log","airPlayAvailableHandler","ON_AIRPLAY_AVAILABLE","ToggleButton","selectbox_1","AudioQualitySelectBox","updateAudioQualities","audioQualities","getAvailableAudioQualities","clearItems","addItem","_i","audioQualities_1","audioQuality","id","label","onItemSelected","sender","value","setAudioQuality","ON_AUDIO_CHANGED","ON_SOURCE_UNLOADED","ON_READY","ON_AUDIO_DOWNLOAD_QUALITY_CHANGE","data","getDownloadedAudioData","selectItem","isAuto","SelectBox","AudioTrackSelectBox","getAudioTrackLabel","updateAudioTracks","audioTracks","getAvailableAudio","audioTracks_1","audioTrack","setAudio","audioTrackHandler","currentAudioTrack","getAudio","container_1","component_1","timeout_1","BufferingOverlay","indicators","Component","tag","hidden","components","showDelayMs","overlayShowTimeout","Timeout","showOverlay","start","hideOverlay","clear","ON_STALL_STARTED","ON_STALL_ENDED","isStalled","Container","dom_1","eventdispatcher_1","buttonEvents","EventDispatcher","toDomElement","buttonElement","DOM","type","class","getCssClasses","append","prefixCss","html","on","onClickEvent","getDomElement","find","dispatch","Object","defineProperty","getEvent","CastStatusOverlay","statusLabel","ON_CAST_WAITING_FOR_DEVICE","castDeviceName","castPayload","deviceName","ON_CAST_STARTED","ON_CAST_STOPPED","CastToggleButton","isCastAvailable","isCasting","castStop","castVideo","castAvailableHander","ON_CAST_AVAILABLE","off","uicontainer_1","CastUIContainer","isUiShown","hideUi","onControlsHide","castUiHideTimeout","hideDelay","showUi","onControlsShow","showUiPermanently","showUiWithTimeout","showUiAfterSeek","isPlaying","ON_SOURCE_LOADED","ON_PLAY","ON_PAUSED","ON_SEEK","ON_SEEKED","release","UIContainer","initialize","url","element","window","open","getUrl","undefined","CloseButton","target","guid_1","componentEvents","onShow","onHide","onHoverChanged","Guid","next","cssPrefix","cssClasses","isHidden","onComponentShow","onComponentHide","onHoverChangedEvent","defaults","base","assign","flattenedArray","concat","map","css","join","trim","cssClassOrId","addClass","CLASS_HIDDEN","onHideEvent","removeClass","onShowEvent","isShown","toggleHidden","isHovered","hovered","addComponent","component","push","removeComponent","ArrayUtils","remove","getComponents","removeComponents","_a","updateComponents","innerContainerElement","empty","containerElement","innerContainer","spacer_1","ControlBar","hoverStackCount","UIUtils","traverseTree","Spacer","args","onPreviewControlsHide","cancel","EmbedVideoToggleButton","popup","visible","isVisible","hidePopup","showPopup","tvnoisecanvas_1","ErrorMessageOverlay","errorLabel","tvNoiseBackground","TvNoiseCanvas","ON_ERROR","message","messages","customMessage","stop","FullscreenToggleButton","fullscreenStateHandler","isFullscreen","ON_FULLSCREEN_ENTER","ON_FULLSCREEN_EXIT","exitFullscreen","enterFullscreen","playbacktogglebutton_1","HugePlaybackToggleButton","togglePlayback","play","toggleFullscreen","firstPlay","clickTime","doubleClickTime","now","Date","setTimeout","castInitializationHandler","ON_CAST_START","PlaybackToggleButton","HugeReplayButton","labelEvents","onTextChanged","labelElement","onTextChangedEvent","getText","clearText","isEmpty","ListSelector","listSelectorEvents","onItemAdded","onItemRemoved","items","getItemIndex","key","index","parseInt","hasItem","removeItem","onItemAddedEvent","onItemRemovedEvent","selectedItem","onItemSelectedEvent","getSelectedItem","items_1","item","itemCount","keys","MetadataLabelContent","MetadataLabel","content","toLowerCase","uiconfig","init","Title","metadata","title","source","Description","description","unload","PictureInPictureToggleButton","isPictureInPictureAvailable","isPictureInPicture","exitPictureInPicture","enterPictureInPicture","pipAvailableHander","ON_PICTURE_IN_PICTURE_ENTER","ON_PICTURE_IN_PICTURE_EXIT","PlaybackSpeedSelectBox","setPlaybackSpeed","parseFloat","PlaybackTimeLabelMode","PlaybackTimeLabel","timeLabelMode","CurrentAndTotalTime","hideInLivePlayback","live","liveCssClass","liveEdgeCssClass","minWidth","liveClickHandler","timeShift","updateLiveState","isLive","updateLiveTimeshiftState","unsubscribe","PlayerUtils","LiveStreamDetector","onLiveChanged","getTimeShift","playbackTimeHandler","getDuration","Infinity","setTime","width","min-width","ON_TIME_SHIFT","ON_TIME_SHIFTED","timeFormat","Math","abs","getMaxTimeShift","FORMAT_HHMMSS","FORMAT_MMSS","playbackSeconds","durationSeconds","currentTime","secondsToTime","totalTime","CurrentTime","TotalTime","handleClickEvent","isSeeking","playbackStateHandler","ON_PLAYBACK_FINISHED","ON_CAST_PLAYING","ON_CAST_PAUSED","ON_CAST_PLAYBACK_FINISHED","TimeShiftAvailabilityDetector","onTimeShiftAvailabilityChanged","timeShiftAvailable","CLASS_STOPTOGGLE","onSeek","onSeeked","hugeplaybacktogglebutton_1","PlaybackToggleOverlay","playbackToggleButton","hugereplaybutton_1","RecommendationOverlay","replayButton","clearRecommendations","RecommendationItem","setupRecommendations","hasRecommendationsInUiConfig","recommendations","hasRecommendationsInPlayerConfig","recommendations_1","itemConfig","isAd","itemElement","href","background-image","thumbnail","bgElement","titleElement","timeElement","duration","SeekBar","playbackPositionPercentage","touchSupported","seekBarEvents","onSeekPreview","vertical","smoothPlaybackPositionUpdateIntervalMs","timelineMarkers","hasLabel","getLabel","configureSeek","playbackNotInitialized","playbackPositionHandler","forceUpdate","setPlaybackPosition","setBufferPosition","videoBufferLength","getVideoBufferLength","audioBufferLength","getAudioBufferLength","bufferLength","min","Number","MAX_VALUE","bufferPercentage","SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED","isPaused","ON_SEGMENT_REQUEST_FINISHED","setSeeking","seek","percentage","subscribeRateLimited","scrubbing","position","hasTimeShift","switchVisibility","refreshPlaybackPosition","ON_PLAYER_RESIZE","onConfigured","setSeekPosition","configureSmoothPlaybackPositionUpdater","configureMarkers","currentTimeSeekBar","currentTimePlayer","smoothPlaybackPositionUpdater","updateIntervalMs","currentTimeDelta","startSmoothPlaybackPositionUpdater","stopSmoothPlaybackPositionUpdater","clearMarkers","updateMarkers","setupMarkers","hasMarkersInUiConfig","markers","hasMarkersInPlayerConfig","markers_1","marker","time","markerType","comment","avatar","number","seekBarContainer","seekBar","seekBarBufferLevel","seekBarBufferPosition","seekBarPlaybackPosition","seekBarPlaybackPositionMarker","seekBarSeekPosition","seekBarBackdrop","seekBarChapterMarkersContainer","seekBarMarkersContainer","seeking","mouseTouchMoveHandler","preventDefault","stopPropagation","targetPercentage","getOffset","onSeekPreviewEvent","mouseTouchUpHandler","document","snappedChapter","getMarkerAtPosition","onSeekedEvent","isTouchEvent","TouchEvent","onSeekEvent","className","markerDom","data-marker-time","String","data-marker-title","snappedMarker","getHorizontalOffset","eventPageX","elementOffsetPx","offset","left","widthPx","offsetPx","sanitizeOffset","getVerticalOffset","eventPageY","top","height","changedTouches","pageY","touches","pageX","MouseEvent","warn","percent","setPosition","px","style","transform","-ms-transform","scale","CLASS_SEEKING","hasClass","SeekBarLabel","timeLabel","titleLabel","commentLabel","numberLabel","avatarLabel","setTitleText","setSmashcutData","setThumbnail","setBackground","getThumb","seconds","thumbnailElement","display","w","h","background-position","x","y","onOff","metadataElement","background","listselector_1","selectElement","updateDomItems","val","selectedValue","optionElement","attr","videoqualityselectbox_1","audioqualityselectbox_1","SettingsPanel","settingsPanelEvents","onSettingsStateChanged","hideTimeout","reset","settingsStateChangedHandler","onSettingsStateChangedEvent","lastShownItem","getItems","SettingsPanelItem","CLASS_LAST","onActiveChanged","hasActiveSettings","isActive","selectBox","settingsPanelItemEvents","setting","handleConfigItemChanged","minItemsToDisplay","VideoQualitySelectBox","onActiveChangedEvent","SettingsToggleButton","settingsPanel","autoHideWhenNoActiveSettings","settingsPanelItemsChangedHandler","controlbar_1","SubtitleOverlay","subtitleManager","ActiveSubtitleManager","ON_CUE_ENTER","labelToAdd","cueEnter","ON_CUE_EXIT","labelToRemove","cueExit","hasCues","subtitleClearHandler","ON_SUBTITLE_CHANGED","CLASS_CONTROLBAR_VISIBLE","SubtitleLabel","activeSubtitleCueMap","calculateId","activeSubtitleCue","cueCount","SubtitleSelectBox","updateSubtitles","getAvailableSubtitles","subtitle","setSubtitle","ON_SUBTITLE_ADDED","targetSubtitle","ON_SUBTITLE_REMOVED","subtitleId","metadatalabel_1","TitleBar","keepHiddenWithoutMetadata","shouldBeShown","hasMetadataText","checkMetadataTextAndUpdateVisibility","toggleButtonEvents","onToggle","onToggleOn","onToggleOff","isOff","onState","CLASS_OFF","CLASS_ON","onToggleEvent","onToggleOnEvent","isOn","onToggleOffEvent","toggle","canvasWidth","canvasHeight","interferenceHeight","lastFrameUpdate","frameInterval","useAnimationFrame","requestAnimationFrame","canvas","canvasElement","getElements","canvasContext","getContext","noiseAnimationWindowPos","renderFrame","cancelAnimationFrame","frameUpdateHandlerId","clearTimeout","getTime","scheduleNextRender","currentPixelOffset","noiseImage","createImageData","random","putImageData","bind","configureUIShowHide","configurePlayerStates","container","isFirstTouch","uiHideTimeout","previewHideEventArgs","stateClassNames","state","PlayerState","isNaN","enumName","STATE_PREFIX","removeStates","IDLE","PREPARED","PLAYING","PAUSED","FINISHED","getState","FULLSCREEN","BUFFERING","REMOTE_CONTROL","CONTROLS_HIDDEN","CONTROLS_SHOWN","updateLayoutSizeClasses","round","substring","getFigure","createElement","flex","updateVideoQualities","videoQualities","getAvailableVideoQualities","videoQualities_1","videoQuality","setVideoQuality","ON_VIDEO_DOWNLOAD_QUALITY_CHANGE","getDownloadedVideoData","volumeslider_1","volumetogglebutton_1","VolumeControlButton","volumeToggleButton","VolumeToggleButton","volumeSlider","VolumeSlider","getVolumeToggleButton","getVolumeSlider","volumeSliderHideTimeout","volumeSliderHovered","seekbar_1","hideIfVolumeControlProhibited","detectVolumeControlAvailability","volumeChangeHandler","isMuted","getVolume","ON_VOLUME_CHANGED","ON_MUTED","ON_UNMUTED","setVolume","volume","muted","playing","mute","muteStateHandler","volumeLevelHandler","unmute","VRToggleButton","isVRConfigured","vr","contentType","isVRStereoAvailable","getVRStatus","vrStateHandler","isStereo","vrButtonVisibilityHandler","ON_VR_MODE_CHANGED","ON_VR_STEREO_CHANGED","ON_VR_ERROR","setVRStereo","Watermark","something","attributes","Array","HTMLElement","elements","Document","tagName","attributeName","attributeValue","setAttribute","selector","findChildElements","forEach","handler","findChildElementsOfElement","childElements","querySelectorAll","slice","allChildElements","arguments","setHtml","getHtml","innerHTML","HTMLSelectElement","HTMLInputElement","attribute","setAttr","getAttr","getAttribute","dataAttribute","setData","getData","childElement","_","appendChild","parent","parentNode","removeChild","elementRect","getBoundingClientRect","htmlRect","body","parentElement","offsetWidth","offsetHeight","eventName","eventHandler","split","addEventListener","removeEventListener","classList","add","replace","RegExp","contains","test","propertyNameOrCollection","propertyName","setCss","getCss","propertyValueCollection","setCssCollection","getComputedStyle","ruleValueCollection","listeners","listener","EventListenerWrapper","subscribeOnce","rateMs","RateLimitedEventListenerWrapper","subscribedListener","unsubscribeAll","listenersToRemove","fire","isOnce","_b","listenersToRemove_1","listenerToRemove","once","eventListener","lastFireTime","rateLimitingEventListener","fireSuper","guid","uimanager_1","fullscreentogglebutton_1","playbacktimelabel_1","settingspanel_1","settingstogglebutton_1","vrtogglebutton_1","watermark_1","audiotrackselectbox_1","caststatusoverlay_1","casttogglebutton_1","errormessageoverlay_1","recommendationoverlay_1","seekbarlabel_1","subtitleoverlay_1","subtitleselectbox_1","titlebar_1","volumecontrolbutton_1","adskipbutton_1","admessagelabel_1","adclickoverlay_1","playbackspeedselectbox_1","bufferingoverlay_1","castuicontainer_1","playbacktoggleoverlay_1","closebutton_1","airplaytogglebutton_1","pictureinpicturetogglebutton_1","TypeError","bitmovin","playerui","UIManager","UIInstanceManager","BrowserUtils","delay","callback","repeat","timeoutHandle","lastScheduleTime","delayAdjust","internalCallback","delta","embedvideotogglebutton_1","playerUiOrUiVariants","playerUi","uiVariants","ui","managerPlayerWrapper","PlayerWrapper","playerElement","uiInstanceManagers","uiVariantsWithoutCondition","uiVariant","condition","InternalUIInstanceManager","adStartedEvent","isMobile","resolveUiVariant","ad","adWithUI","clientType","context","isAdWithUI","documentWidth","clientWidth","nextUi","uiVariantChanged","indexOf","currentUi","getUI","isConfigured","addUi","getWrappedPlayer","fireEventInUI","getPlayer","dom","configureControls","releaseUi","releaseControls","clearEventHandlers","uiInstanceManager","Factory","buildDefaultUI","buildModernUI","buildDefaultSmallScreenUI","buildModernSmallScreenUI","buildDefaultCastReceiverUI","buildModernCastReceiverUI","smashcutUi","controlBarTop","controlBarMiddle","controlBarBottom","controlBar","modernAdsUI","modernSmallScreenUI","modernSmallScreenAdsUI","modernCastReceiverUI","legacyUI","legacyAdsUI","legacyCastReceiverUI","legacyTestUI","buildLegacyUI","buildLegacyCastReceiverUI","buildLegacyTestUI","events","playerWrapper","event_1","configureControlsTree","configured","configuredComponents","configuredComponents_1","error","constructor","name","releaseControlsTree","released","isReleased","childComponent","eventHandlers","methods","member","wrapper","methods_1","apply","eventType","playerEventData","timestamp","uiSourced","array","splice","totalSeconds","format","isNegative","hours","floor","minutes","leftPadWithZeros","num","substr","adMessagePlaceholderRegex","formatString","ceil","formatNumber","formatStringValidationRegex","leadingZeroes","leadingZeroesMatches","match","numDecimalPlaces","decimalPlacesMatches","timeString","toFixed","isSourceLoaded","isTimeShiftAvailable","hasEnded","timeShiftAvailabilityChangedEvent","timeShiftDetector","timeShiftAvailableNow","liveChangedEvent","liveDetector","liveNow","isAndroid","isChrome","visit","recursiveTreeWalker","navigator","userAgent"],"mappings":"CAAA,QAAAA,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAE,GAAA,kBAAAC,UAAAA,OAAA,KAAAF,GAAAC,EAAA,MAAAA,GAAAF,GAAA,EAAA,IAAAI,EAAA,MAAAA,GAAAJ,GAAA,EAAA,IAAAK,GAAA,GAAAC,OAAA,uBAAAN,EAAA,IAAA,MAAAK,GAAAE,KAAA,mBAAAF,EAAA,GAAAG,GAAAX,EAAAG,IAAAS,WAAAb,GAAAI,GAAA,GAAAU,KAAAF,EAAAC,QAAA,SAAAd,GAAA,GAAAE,GAAAD,EAAAI,GAAA,GAAAL,EAAA,OAAAI,GAAAF,GAAAF,IAAAa,EAAAA,EAAAC,QAAAd,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAS,QAAA,IAAA,GAAAL,GAAA,kBAAAD,UAAAA,QAAAH,EAAA,EAAAA,EAAAF,EAAAa,OAAAX,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,KAAAa,GAAA,SAAAT,EAAAU,EAAAJ,uYCAA,IAAAK,GAAAX,EAAA,kBAMAY,EAAA,SAAAC,GAAA,QAAAD,oDAuCA,MAvCoCE,GAAAF,EAAAC,GAElCD,EAAAG,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAIG,GAA0B,KAC1BC,GAAuBL,EAAOM,YAAYC,cACxCP,EAAOM,YAAYC,YAAYC,eAAe,wBAC/CR,EAAOM,YAAYC,YAAYF,mBAEpCL,GAAOS,gBAAgBT,EAAOU,MAAMC,cAAe,SAACC,GAClDR,EAAkBQ,EAAMR,gBAEpBC,EACFH,EAAKW,OAAOT,GAGZF,EAAKW,OAAO,OAKhB,IAAIC,GAAoB,WACtBZ,EAAKW,OAAO,MAEdb,GAAOS,gBAAgBT,EAAOU,MAAMK,eAAgBD,GACpDd,EAAOS,gBAAgBT,EAAOU,MAAMM,cAAeF,GACnDd,EAAOS,gBAAgBT,EAAOU,MAAMO,YAAaH,GAEjDX,KAAKe,QAAQC,UAAU,WAErBnB,EAAOoB,MAAM,oBAGbpB,EAAOqB,UAAUrB,EAAOU,MAAMY,eAC5BlB,gBAAiBA,OAIzBT,GAvCoCD,EAAA6B,aAAvBlC,GAAAM,eAAAA,ibCNb,IAAA6B,GAAAzC,EAAA,WAEA0C,EAAA1C,EAAA,YAKA2C,EAAA,SAAA9B,GAEE,QAAA8B,GAAYC,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,sBACVC,KAAM,gDACL5B,EAAKyB,UA8BZ,MAtCoC9B,GAAA6B,EAAA9B,GAWlC8B,EAAA5B,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAI6B,GAAO3B,KAAKG,YAAYwB,KAExBC,EAAuB,WACzB7B,EAAK8B,QAAQP,EAAAQ,YAAYC,6BAA6BJ,EAAM,KAAM9B,KAGhEmC,EAAiB,SAACvB,GACpBkB,EAAOlB,EAAMwB,WAAaN,EAC1BC,IAEA/B,EAAOS,gBAAgBT,EAAOU,MAAM2B,gBAAiBN,GACrD/B,EAAOS,gBAAgBT,EAAOU,MAAM4B,qBAAsBP,IAGxDQ,EAAe,WACjBvC,EAAOwC,mBAAmBxC,EAAOU,MAAM2B,gBAAiBN,GACxD/B,EAAOwC,mBAAmBxC,EAAOU,MAAM4B,qBAAsBP,GAG/D/B,GAAOS,gBAAgBT,EAAOU,MAAMC,cAAewB,GACnDnC,EAAOS,gBAAgBT,EAAOU,MAAMM,cAAeuB,GACnDvC,EAAOS,gBAAgBT,EAAOU,MAAMO,YAAasB,GACjDvC,EAAOS,gBAAgBT,EAAOU,MAAMK,eAAgBwB,IAExDb,GAtCoCF,EAAAiB,MAAvBpD,GAAAqC,eAAAA,wbCPb,IAAAgB,GAAA3D,EAAA,YAGA0C,EAAA1C,EAAA,YAYA4D,EAAA,SAAA/C,GAEE,QAAA+C,GAAYhB,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,oBACVe,aACEC,UAAW,6BACXC,KAAM,YAEP5C,EAAKyB,UAmDZ,MA9DkC9B,GAAA8C,EAAA/C,GAchC+C,EAAA7C,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAI0B,GAA6BxB,KAAKG,YAClCsC,EAAcjB,EAAOiB,YACrBG,EAA0C,KAE1CC,EAA2B,WAEzBD,EAAQE,WACV/C,EAAKgD,OAELhD,EAAKiD,OAIHnD,EAAOoD,iBAAmBL,EAAQE,WACpC/C,EAAK8B,QACHP,EAAAQ,YAAYC,6BAA6BP,EAAOiB,YAAYC,UAAWE,EAAQE,WAAYjD,IAE7FE,EAAK8B,QAAQL,EAAOiB,YAAYE,OAIhCX,EAAiB,SAACvB,GACpBmC,EAAUnC,EACVgC,EAAcG,EAAQH,aAAeA,EACrCI,IAEAhD,EAAOS,gBAAgBT,EAAOU,MAAM2B,gBAAiBW,GACrDhD,EAAOS,gBAAgBT,EAAOU,MAAM4B,qBAAsBU,IAGxDT,EAAe,WACjBvC,EAAOwC,mBAAmBxC,EAAOU,MAAM2B,gBAAiBW,GACxDhD,EAAOwC,mBAAmBxC,EAAOU,MAAM4B,qBAAsBU,GAG/DhD,GAAOS,gBAAgBT,EAAOU,MAAMC,cAAewB,GACnDnC,EAAOS,gBAAgBT,EAAOU,MAAMM,cAAeuB,GACnDvC,EAAOS,gBAAgBT,EAAOU,MAAMO,YAAasB,GACjDvC,EAAOS,gBAAgBT,EAAOU,MAAMK,eAAgBwB,GAEpDpC,KAAKe,QAAQC,UAAU,WAErBnB,EAAOqD,YAGbV,GA9DkCD,EAAAY,OAArBjE,GAAAsD,aAAAA,wbCfb,IAAAY,GAAAxE,EAAA,kBAMAyE,EAAA,SAAA5D,GAEE,QAAA4D,GAAY7B,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,yBACVC,KAAM,iBACL5B,EAAKyB,UA6BZ,MArCyC9B,GAAA2D,EAAA5D,GAWvC4D,EAAA1D,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,GAExBE,KAAKe,QAAQC,UAAU,WACjBnB,EAAOyD,qBACTzD,EAAO0D,0BAEHC,SACFA,QAAQC,IAAI,wBAKlB,IAAIC,GAA0B,WACxB7D,EAAOyD,qBACTvD,EAAKgD,OAELhD,EAAKiD,OAITnD,GAAOS,gBAAgBT,EAAOU,MAAMoD,qBAAsBD,GAG1DA,KAEJL,GArCyCD,EAAAQ,aAA5B1E,GAAAmE,oBAAAA,ibCNb,IAAAQ,GAAAjF,EAAA,eAOAkF,EAAA,SAAArE,GAEE,QAAAqE,GAAYtC,cAAA,KAAAA,IAAAA,MACV/B,EAAAN,KAAAa,KAAMwB,IAAOxB,KAuCjB,MA1C2CN,GAAAoE,EAAArE,GAMzCqE,EAAAnE,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAIiE,GAAuB,WACzB,GAAIC,GAAiBnE,EAAOoE,4BAE5BlE,GAAKmE,aAGLnE,EAAKoE,QAAQ,OAAQ,OAGrB,KAAyB,GAAAC,GAAA,EAAAC,EAAAL,EAAAI,EAAAC,EAAAjF,OAAAgF,IAAc,CAAlC,GAAIE,GAAYD,EAAAD,EACnBrE,GAAKoE,QAAQG,EAAaC,GAAID,EAAaE,QAI/CxE,MAAKyE,eAAezD,UAAU,SAAC0D,EAA+BC,GAC5D9E,EAAO+E,gBAAgBD,KAIzB9E,EAAOS,gBAAgBT,EAAOU,MAAMsE,iBAAkBd,GAEtDlE,EAAOS,gBAAgBT,EAAOU,MAAMuE,mBAAoBf,GAExDlE,EAAOS,gBAAgBT,EAAOU,MAAMwE,SAAUhB,GAE9ClE,EAAOS,gBAAgBT,EAAOU,MAAMyE,iCAAkC,WACpE,GAAIC,GAAOpF,EAAOqF,wBAClBnF,GAAKoF,WAAWF,EAAKG,OAAS,OAASH,EAAKV,MAI9CR,KAEJD,GA1C2CD,EAAAwB,UAA9BnG,GAAA4E,sBAAAA,8aCPb,IAAAD,GAAAjF,EAAA,eAOA0G,EAAA,SAAA7F,GAEE,QAAA6F,GAAY9D,cAAA,KAAAA,IAAAA,MACV/B,EAAAN,KAAAa,KAAMwB,IAAOxB,KA0DjB,MA7DyCN,GAAA4F,EAAA7F,GAMvC6F,EAAA3F,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAGxB,IAAIyF,GAAqB,SAAChB,GACxB,OAAQA,GACN,IAAK,YACH,MAAO,kBACT,KAAK,mBACH,MAAO,oBACT,KAAK,cACH,MAAO,oBACT,SACE,MAAOA,KAITiB,EAAoB,WACtB,GAAIC,GAAc5F,EAAO6F,mBAEzB3F,GAAKmE,YAGL,KAAuB,GAAAE,GAAA,EAAAuB,EAAAF,EAAArB,EAAAuB,EAAAvG,OAAAgF,IAAW,CAA7B,GAAIwB,GAAUD,EAAAvB,EACjBrE,GAAKoE,QAAQyB,EAAWrB,GAAIgB,EAAmBK,EAAWpB,SAI9DxE,MAAKyE,eAAezD,UAAU,SAAC0D,EAA6BC,GAC1D9E,EAAOgG,SAASlB,IAGlB,IAAImB,GAAoB,WACtB,GAAIC,GAAoBlG,EAAOmG,UAG3BD,IACFhG,EAAKoF,WAAWY,EAAkBxB,IAKtC1E,GAAOS,gBAAgBT,EAAOU,MAAMsE,iBAAkBiB,GAEtDjG,EAAOS,gBAAgBT,EAAOU,MAAMuE,mBAAoBU,GAExD3F,EAAOS,gBAAgBT,EAAOU,MAAMwE,SAAUS,GAG9CA,IAIAM,KAEJR,GA7DyCzB,EAAAwB,UAA5BnG,GAAAoG,oBAAAA,8aCPb,IAAAW,GAAArH,EAAA,eAEAsH,EAAAtH,EAAA,eACAuH,EAAAvH,EAAA,cAiBAwH,EAAA,SAAA3G,GAIE,QAAA2G,GAAY5E,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKsG,YACH,GAAIH,GAAAI,WAA6BC,IAAK,MAAO7E,SAAU,mCACvD,GAAIwE,GAAAI,WAA6BC,IAAK,MAAO7E,SAAU,mCACvD,GAAIwE,GAAAI,WAA6BC,IAAK,MAAO7E,SAAU,oCAGzD3B,EAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,uBACV8E,QAAQ,EACRC,WAAY1G,EAAKsG,WACjBK,YAAa,KACZ3G,EAAKyB,UA8BZ,MAhDsC9B,GAAA0G,EAAA3G,GAqBpC2G,EAAAzG,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAI0B,GAAiCxB,KAAKG,YAEtCwG,EAAqB,GAAIR,GAAAS,QAAQpF,EAAOkF,YAAa,WACvD3G,EAAKgD,SAGH8D,EAAc,WAChBF,EAAmBG,SAGjBC,EAAc,WAChBJ,EAAmBK,QACnBjH,EAAKiD,OAGPnD,GAAOS,gBAAgBT,EAAOU,MAAM0G,iBAAkBJ,GACtDhH,EAAOS,gBAAgBT,EAAOU,MAAM2G,eAAgBH,GACpDlH,EAAOS,gBAAgBT,EAAOU,MAAMuE,mBAAoBiC,GAGpDlH,EAAOsH,aACTnH,KAAK+C,QAGXqD,GAhDsCH,EAAAmB,UAAzBlI,GAAAkH,iBAAAA,+cCpBb,IAAAF,GAAAtH,EAAA,eACAyI,EAAAzI,EAAA,UACA0I,EAAA1I,EAAA,sBAeAuE,EAAA,SAAA1D,GAME,QAAA0D,GAAY3B,GAAZ,GAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WALPD,GAAAwH,cACNxG,QAAS,GAAIuG,GAAAE,iBAMbzH,EAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,aACT3B,EAAKyB,UAwCZ,MAnDyD9B,GAAAyD,EAAA1D,GAc7C0D,EAAAxD,UAAA8H,aAAV,WAAA,GAAA1H,GAAAC,KAEM0H,EAAgB,GAAIL,GAAAM,IAAI,UAC1BC,KAAQ,SACRrD,GAAMvE,KAAKwB,OAAO+C,GAClBsD,MAAS7H,KAAK8H,kBACbC,OAAO,GAAIV,GAAAM,IAAI,QAChBE,MAAS7H,KAAKgI,UAAU,WACvBC,KAAKjI,KAAKwB,OAAOG,MAOpB,OAJA+F,GAAcQ,GAAG,QAAS,WACxBnI,EAAKoI,iBAGAT,GAOTvE,EAAAxD,UAAAkC,QAAA,SAAQF,GACN3B,KAAKoI,gBAAgBC,KAAK,IAAMrI,KAAKgI,UAAU,UAAUC,KAAKtG,IAGtDwB,EAAAxD,UAAAwI,aAAV,WACEnI,KAAKuH,aAAaxG,QAAQuH,SAAStI,OAOrCuI,OAAAC,eAAIrF,EAAAxD,UAAA,eAAJ,WACE,MAAOK,MAAKuH,aAAaxG,QAAQ0H,4CAErCtF,GAnDyD+C,EAAAI,UAA5CpH,GAAAiE,OAAAA,kdCjBb,IAAA8C,GAAArH,EAAA,eACAyC,EAAAzC,EAAA,WAQA8J,EAAA,SAAAjJ,GAIE,QAAAiJ,GAAYlH,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAK4I,YAAc,GAAItH,GAAAiB,OAAqBZ,SAAU,yBAEtD3B,EAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,yBACV+E,YAAa1G,EAAK4I,aAClBnC,QAAQ,GACPzG,EAAKyB,UA0BZ,MAvCuC9B,GAAAgJ,EAAAjJ,GAgBrCiJ,EAAA/I,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,GAExBD,EAAOS,gBAAgBT,EAAOU,MAAMqI,2BAClC,SAACnI,GACCV,EAAKgD,MAEL,IAAI8F,GAAiBpI,EAAMqI,YAAYC,UACvChJ,GAAK4I,YAAY9G,QAAQ,yBAAyBgH,EAAc,kBAEpEhJ,EAAOS,gBAAgBT,EAAOU,MAAMyI,gBAAiB,SAACvI,GAIpDV,EAAKgD,MACL,IAAI8F,GAAiBpI,EAAMsI,UAC3BhJ,GAAK4I,YAAY9G,QAAQ,sBAAsBgH,EAAc,eAE/DhJ,EAAOS,gBAAgBT,EAAOU,MAAM0I,gBAAiB,SAACxI,GAEpDV,EAAKiD,UAGX0F,GAvCuCzC,EAAAmB,UAA1BlI,GAAAwJ,kBAAAA,4bCTb,IAAAtF,GAAAxE,EAAA,kBAMAsK,EAAA,SAAAzJ,GAEE,QAAAyJ,GAAY1H,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,sBACVC,KAAM,eACL5B,EAAKyB,UAgDZ,MAxDsC9B,GAAAwJ,EAAAzJ,GAWpCyJ,EAAAvJ,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,GAExBE,KAAKe,QAAQC,UAAU,WACjBnB,EAAOsJ,kBACLtJ,EAAOuJ,YACTvJ,EAAOwJ,WAEPxJ,EAAOyJ,YAGL9F,SACFA,QAAQC,IAAI,qBAKlB,IAAI8F,GAAsB,WACpB1J,EAAOsJ,kBACTpJ,EAAKgD,OAELhD,EAAKiD,OAITnD,GAAOS,gBAAgBT,EAAOU,MAAMiJ,kBAAmBD,GAGvD1J,EAAOS,gBAAgBT,EAAOU,MAAMqI,2BAA4B,WAC9D7I,EAAKmI,OAEPrI,EAAOS,gBAAgBT,EAAOU,MAAMyI,gBAAiB,WAEnDjJ,EAAKmI,OAEPrI,EAAOS,gBAAgBT,EAAOU,MAAM0I,gBAAiB,WACnDlJ,EAAK0J,QAIPF,IACI1J,EAAOuJ,aACTpJ,KAAKkI,MAGXgB,GAxDsC9F,EAAAQ,aAAzB1E,GAAAgK,iBAAAA,kbCNb,IAAAQ,GAAA9K,EAAA,iBAEAuH,EAAAvH,EAAA,cAMA+K,EAAA,SAAAlK,GAIE,QAAAkK,GAAYnI,SACV/B,GAAAN,KAAAa,KAAMwB,IAAOxB,KAgEjB,MArEqCN,GAAAiK,EAAAlK,GAQnCkK,EAAAhK,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAI0B,GAA4BxB,KAAKG,YAYjCyJ,GAAY,EAEZC,EAAS,WACX/J,EAAUgK,eAAexB,SAASvI,GAClC6J,GAAY,EAGd5J,MAAK+J,kBAAoB,GAAI5D,GAAAS,QAAQpF,EAAOwI,UAAWH,EAEvD,IAAII,GAAS,WACNL,IACH9J,EAAUoK,eAAe5B,SAASvI,GAClC6J,GAAY,IAIZO,EAAoB,WACtBF,IACAlK,EAAKgK,kBAAkB/C,SAGrBoD,EAAoB,WACtBH,IACAlK,EAAKgK,kBAAkBjD,SAGrBuD,EAAkB,WAChBxK,EAAOyK,YACTF,IAEAD,IAIJtK,GAAOS,gBAAgBT,EAAOU,MAAMwE,SAAUqF,GAC9CvK,EAAOS,gBAAgBT,EAAOU,MAAMgK,iBAAkBH,GACtDvK,EAAOS,gBAAgBT,EAAOU,MAAMiK,QAASJ,GAC7CvK,EAAOS,gBAAgBT,EAAOU,MAAMkK,UAAWN,GAC/CtK,EAAOS,gBAAgBT,EAAOU,MAAMmK,QAASP,GAC7CtK,EAAOS,gBAAgBT,EAAOU,MAAMoK,UAAWN,IAGjDV,EAAAhK,UAAAiL,QAAA,WACEnL,EAAAE,UAAMiL,QAAOzL,KAAAa,MACbA,KAAK+J,kBAAkB/C,SAE3B2C,GArEqCD,EAAAmB,YAAxB3L,GAAAyK,gBAAAA,icCRb,IAAApH,GAAA3D,EAAA,YAeAwC,EAAA,SAAA3B,GAEE,QAAA2B,GAAYI,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,mBACW3B,EAAKyB,UA6BhC,MApCkC9B,GAAA0B,EAAA3B,GAUhC2B,EAAAzB,UAAAmL,WAAA,WACErL,EAAAE,UAAMmL,WAAU3L,KAAAa,MAEhBA,KAAKU,OAA4BV,KAAKwB,OAAQuJ,IAC9C,IAAIC,GAAUhL,KAAKoI,eACnB4C,GAAQ9C,GAAG,QAAS,WACd8C,EAAQ/F,KAAK,QACfgG,OAAOC,KAAKF,EAAQ/F,KAAK,OAAQ,aASvC7D,EAAAzB,UAAAwL,OAAA,WACE,MAAOnL,MAAKoI,gBAAgBnD,KAAK,QAGnC7D,EAAAzB,UAAAe,OAAA,SAAOqK,OACOK,KAARL,GAA4B,MAAPA,IACvBA,EAAM,IAER/K,KAAKoI,gBAAgBnD,KAAK,MAAO8F,IAErC3J,GApCkCmB,EAAAY,OAArBjE,GAAAkC,aAAAA,2aCfb,IAAAmB,GAAA3D,EAAA,YAiBAyM,EAAA,SAAA5L,GAEE,QAAA4L,GAAY7J,GAAZ,GAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,iBACVC,KAAM,SACL5B,EAAKyB,UAYZ,MApBiC9B,GAAA2L,EAAA5L,GAW/B4L,EAAA1L,UAAAC,UAAA,SAAUC,EAAgCC,GACxCL,EAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAI0B,GAA4BxB,KAAKG,WAErCH,MAAKe,QAAQC,UAAU,WACrBQ,EAAO8J,OAAOtI,UAGpBqI,GApBiC9I,EAAAY,OAApBjE,GAAAmM,YAAAA,oGCjBb,IAAAE,GAAA3M,EAAA,WACAyI,EAAAzI,EAAA,UACA0I,EAAA1I,EAAA,sBAoDA0H,EAAA,WAiGE,QAAAA,GAAY9E,OAAA,KAAAA,IAAAA,MAXJxB,KAAAwL,iBACNC,OAAQ,GAAInE,GAAAE,gBACZkE,OAAQ,GAAIpE,GAAAE,gBACZmE,eAAgB,GAAIrE,GAAAE,iBAUpBxH,KAAKwB,OAAiBxB,KAAKyB,YAAYD,GACrC+E,IAAK,MACLhC,GAAI,YAAcgH,EAAAK,KAAKC,OACvBC,UAAW,QACXpK,SAAU,eACVqK,cACAvF,QAAQ,OAoPd,MAxOEF,GAAA3G,UAAAmL,WAAA,WACE9K,KAAKwG,OAASxG,KAAKwB,OAAOgF,OAGtBxG,KAAKgM,aACPhM,KAAKwG,QAAS,EACdxG,KAAKgD,SAeTsD,EAAA3G,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEA,MAAKyL,OAAOzK,UAAU,WACpBlB,EAAUmM,gBAAgB3D,SAASvI,KAErCC,KAAK0L,OAAO1K,UAAU,WACpBlB,EAAUoM,gBAAgB5D,SAASvI,KAIrCC,KAAKoI,gBAAgBF,GAAG,aAAc,WACpCnI,EAAKoM,qBAAoB,KAE3BnM,KAAKoI,gBAAgBF,GAAG,aAAc,WACpCnI,EAAKoM,qBAAoB,MAW7B7F,EAAA3G,UAAAiL,QAAA,aASUtE,EAAA3G,UAAA8H,aAAV,WAME,MALc,IAAIJ,GAAAM,IAAI3H,KAAKwB,OAAO+E,KAChChC,GAAMvE,KAAKwB,OAAO+C,GAClBsD,MAAS7H,KAAK8H,mBAalBxB,EAAA3G,UAAAyI,cAAA,WAKE,MAJKpI,MAAKgL,UACRhL,KAAKgL,QAAUhL,KAAKyH,gBAGfzH,KAAKgL,SAWJ1E,EAAA3G,UAAA8B,YAAV,SAA8BD,EAAgB4K,EAAkBC,GAK9D,MAHa9D,QAAO+D,UAAWD,EAAMD,EAAU5K,IAWvC8E,EAAA3G,UAAAmI,cAAV,WAAA,GAAA/H,GAAAC,KAEMuM,GAAkBvM,KAAKwB,OAAOE,UAAU8K,OAAOxM,KAAKwB,OAAOuK,WAQ/D,OANAQ,GAAiBA,EAAeE,IAAI,SAACC,GACnC,MAAO3M,GAAKiI,UAAU0E,KAGFH,EAAeI,KAAK,KAEnBC,QAGftG,EAAA3G,UAAAqI,UAAV,SAAoB6E,GAClB,MAAO7M,MAAKwB,OAAOsK,UAAY,IAAMe,GAOhCvG,EAAA3G,UAAAQ,UAAP,WACE,MAAOH,MAAKwB,QAOd8E,EAAA3G,UAAAqD,KAAA,WACOhD,KAAKwG,SACRxG,KAAKwG,QAAS,EACdxG,KAAKoI,gBAAgB0E,SAAS9M,KAAKgI,UAAU1B,EAAUyG,eACvD/M,KAAKgN,gBAOT1G,EAAA3G,UAAAoD,KAAA,WACM/C,KAAKwG,SACPxG,KAAKoI,gBAAgB6E,YAAYjN,KAAKgI,UAAU1B,EAAUyG,eAC1D/M,KAAKwG,QAAS,EACdxG,KAAKkN,gBAQT5G,EAAA3G,UAAAqM,SAAA,WACE,MAAOhM,MAAKwG,QAOdF,EAAA3G,UAAAwN,QAAA,WACE,OAAQnN,KAAKgM,YAMf1F,EAAA3G,UAAAyN,aAAA,WACMpN,KAAKgM,WACPhM,KAAK+C,OAEL/C,KAAKgD,QAQTsD,EAAA3G,UAAA0N,UAAA,WACE,MAAOrN,MAAKsN,SAOJhH,EAAA3G,UAAAuN,YAAV,WACElN,KAAKwL,gBAAgBC,OAAOnD,SAAStI,OAO7BsG,EAAA3G,UAAAqN,YAAV,WACEhN,KAAKwL,gBAAgBE,OAAOpD,SAAStI,OAO7BsG,EAAA3G,UAAAwM,oBAAV,SAA8BmB,GAC5BtN,KAAKsN,QAAUA,EACftN,KAAKwL,gBAAgBG,eAAerD,SAAStI,MAAQsN,QAASA,KAQhE/E,OAAAC,eAAIlC,EAAA3G,UAAA,cAAJ,WACE,MAAOK,MAAKwL,gBAAgBC,OAAOhD,4CAQrCF,OAAAC,eAAIlC,EAAA3G,UAAA,cAAJ,WACE,MAAOK,MAAKwL,gBAAgBE,OAAOjD,4CAOrCF,OAAAC,eAAIlC,EAAA3G,UAAA,sBAAJ,WACE,MAAOK,MAAKwL,gBAAgBG,eAAelD,4CAE/CnC,IAvV0BA,GAAAyG,aAAe,SAN5B7N,EAAAoH,UAAAA,+cCtDb,IAAAJ,GAAAtH,EAAA,eACAyI,EAAAzI,EAAA,UACA0C,EAAA1C,EAAA,YA+BAwI,EAAA,SAAA3H,GAOE,QAAA2H,GAAY5F,GAAZ,GAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,eACV+E,eACC1G,EAAKyB,UAmEZ,MAhF+D9B,GAAA0H,EAAA3H,GAoB7D2H,EAAAzH,UAAA4N,aAAA,SAAaC,GACXxN,KAAKwB,OAAOiF,WAAWgH,KAAKD,IAQ9BpG,EAAAzH,UAAA+N,gBAAA,SAAgBF,GACd,MAA+D,OAAxDlM,EAAAqM,WAAWC,OAAO5N,KAAKwB,OAAOiF,WAAY+G,IAOnDpG,EAAAzH,UAAAkO,cAAA,WACE,MAAO7N,MAAKwB,OAAOiF,YAMrBW,EAAAzH,UAAAmO,iBAAA,WACE,IAAsB,GAAA1J,GAAA,EAAA2J,EAAA/N,KAAK6N,gBAALzJ,EAAA2J,EAAA3O,OAAAgF,IAAoB,CAArC,GAAIoJ,GAASO,EAAA3J,EAChBpE,MAAK0N,gBAAgBF,KAOfpG,EAAAzH,UAAAqO,iBAAV,WACEhO,KAAKiO,sBAAsBC,OAE3B,KAAsB,GAAA9J,GAAA,EAAA2J,EAAA/N,KAAKwB,OAAOiF,WAAZrC,EAAA2J,EAAA3O,OAAAgF,IAAsB,CAAvC,GAAIoJ,GAASO,EAAA3J,EAChBpE,MAAKiO,sBAAsBlG,OAAOyF,EAAUpF,mBAItChB,EAAAzH,UAAA8H,aAAV,WAEE,GAAI0G,GAAmB,GAAI9G,GAAAM,IAAI3H,KAAKwB,OAAO+E,KACzChC,GAAMvE,KAAKwB,OAAO+C,GAClBsD,MAAS7H,KAAK8H,kBAIZsG,EAAiB,GAAI/G,GAAAM,IAAI3H,KAAKwB,OAAO+E,KACvCsB,MAAS7H,KAAKgI,UAAU,sBAQ1B,OANAhI,MAAKiO,sBAAwBG,EAE7BpO,KAAKgO,mBAELG,EAAiBpG,OAAOqG,GAEjBD,GAEX/G,GAhF+DlB,EAAAI,UAAlDpH,GAAAkI,UAAAA,ycCjCb,IAAAnB,GAAArH,EAAA,eAEA0C,EAAA1C,EAAA,YACAyP,EAAAzP,EAAA,YAaA0P,EAAA,SAAA7O,GAEE,QAAA6O,GAAY9M,GAAZ,GAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,gBACV8E,QAAQ,GACWzG,EAAKyB,UAqC9B,MA7CgC9B,GAAA4O,EAAA7O,GAW9B6O,EAAA3O,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAGxB,IAAIyO,GAAkB,CAGtBjN,GAAAkN,QAAQC,aAAazO,KAAM,SAACwN,GAEtBA,YAAqBvH,GAAAmB,WAAaoG,YAAqBa,GAAAK,QAK3DlB,EAAU7B,eAAe3K,UAAU,SAAC0D,EAAQiK,GACtCA,EAAKrB,QACPiB,IAEAA,QAKNzO,EAAUoK,eAAelJ,UAAU,WACjCjB,EAAKgD,SAEPjD,EAAU8O,sBAAsB5N,UAAU,SAAC0D,EAAQiK,GAEjDA,EAAKE,OAAUN,EAAkB,IAEnCzO,EAAUgK,eAAe9I,UAAU,WACjCjB,EAAKiD,UAGXsL,GA7CgCrI,EAAAmB,UAAnBlI,GAAAoP,WAAAA,2cChBb,IAAAlL,GAAAxE,EAAA,kBAMAkQ,EAAA,SAAArP,GAEE,QAAAqP,GAAYtN,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,4BACVC,KAAM,eACL5B,EAAKyB,UA6BZ,MArC4C9B,GAAAoP,EAAArP,GAW1CqP,EAAAnP,UAAAC,UAAA,SAAUC,EAAgCC,GACxCL,EAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAIiP,IACFC,SAAU,EACVC,UAAW,WACT,MAAOF,GAAMC,SAEfE,UAAW,WACTH,EAAMC,SAAU,EAChBxL,QAAQC,IAAI,2BAEd0L,UAAW,WACTJ,EAAMC,SAAU,EAChBxL,QAAQC,IAAI,2BAIhBzD,MAAKe,QAAQC,UAAU,WACjB+N,EAAME,YACRF,EAAMG,YAENH,EAAMI,eAIdL,GArC4C1L,EAAAQ,aAA/B1E,GAAA4P,uBAAAA,kbCNb,IAAA7I,GAAArH,EAAA,eACAyC,EAAAzC,EAAA,WAGAwQ,EAAAxQ,EAAA,mBAyEAyQ,EAAA,SAAA5P,GAKE,QAAA4P,GAAY7N,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKuP,WAAa,GAAIjO,GAAAiB,OAAqBZ,SAAU,0BACrD3B,EAAKwP,kBAAoB,GAAIH,GAAAI,cAE7BzP,EAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,0BACV+E,YAAa1G,EAAKwP,kBAAmBxP,EAAKuP,YAC1C9I,QAAQ,GACPzG,EAAKyB,UAyCZ,MAxDyC9B,GAAA2P,EAAA5P,GAkBvC4P,EAAA1P,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAI0B,GAAoCxB,KAAKG,WAE7CN,GAAOS,gBAAgBT,EAAOU,MAAMkP,SAAU,SAAChP,GAC7C,GAAIiP,GAAUjP,EAAMiP,OAGpB,IAAIlO,EAAOmO,SACT,GAA+B,kBAApBnO,GAAOmO,SAEhBD,EAAUlO,EAAOmO,SAASlP,OACrB,IAAIe,EAAOmO,SAASlP,EAAMzB,MAAO,CAEtC,GAAI4Q,GAAgBpO,EAAOmO,SAASlP,EAAMzB,KAGxC0Q,GAD2B,gBAAlBE,GACCA,EAGAA,EAAcnP,GAK9BV,EAAKuP,WAAWzN,QAAQ6N,GACxB3P,EAAKwP,kBAAkBzI,QACvB/G,EAAKgD,SAGPlD,EAAOS,gBAAgBT,EAAOU,MAAMgK,iBAAkB,SAAC9J,GACjDV,EAAKoN,YACPpN,EAAKwP,kBAAkBM,OACvB9P,EAAKiD,WAIbqM,GAxDyCpJ,EAAAmB,UAA5BlI,GAAAmQ,oBAAAA,idC7Eb,IAAAjM,GAAAxE,EAAA,kBAMAkR,EAAA,SAAArQ,GAEE,QAAAqQ,GAAYtO,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,4BACVC,KAAM,cACL5B,EAAKyB,UA4BZ,MApC4C9B,GAAAoQ,EAAArQ,GAW1CqQ,EAAAnQ,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAIiQ,GAAyB,WACvBlQ,EAAOmQ,eACTjQ,EAAKmI,KAELnI,EAAK0J,MAIT5J,GAAOS,gBAAgBT,EAAOU,MAAM0P,oBAAqBF,GACzDlQ,EAAOS,gBAAgBT,EAAOU,MAAM2P,mBAAoBH,GAExD/P,KAAKe,QAAQC,UAAU,WACjBnB,EAAOmQ,eACTnQ,EAAOsQ,iBAEPtQ,EAAOuQ,oBAKXL,KAEJD,GApC4C1M,EAAAQ,aAA/B1E,GAAA4Q,uBAAAA,kbCLb,IAAAO,GAAAzR,EAAA,0BACAyI,EAAAzI,EAAA,UAOA0R,EAAA,SAAA7Q,GAEE,QAAA6Q,GAAY9O,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,8BACVC,KAAM,cACL5B,EAAKyB,UAmHZ,MA3H8C9B,GAAA4Q,EAAA7Q,GAW5C6Q,EAAA3Q,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IAEEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,GAAW,EAEnC,IAAIyQ,GAAiB,WACf1Q,EAAOyK,YACTzK,EAAOoB,MAAM,cAEbpB,EAAO2Q,KAAK,eAIZC,EAAmB,WACjB5Q,EAAOmQ,eACTnQ,EAAOsQ,iBAEPtQ,EAAOuQ,mBAIPM,GAAY,EACZC,EAAY,EACZC,EAAkB,CAkBtB5Q,MAAKe,QAAQC,UAAU,WAKrB,GAAI0P,EAMF,WADAH,IAIF,IAAIM,GAAMC,KAAKD,KAEf,OAAIA,GAAMF,EAAY,KAEpBF,SACAG,EAAkBC,IAETA,EAAMF,EAAY,KAE3BF,IACAF,SACAK,EAAkBC,KAIpBF,EAAYE,MAEZE,YAAW,WACLD,KAAKD,MAAQD,EAAkB,KAEjCL,KAED,QAGL1Q,EAAOS,gBAAgBT,EAAOU,MAAMiK,QAAS,WAE3CkG,GAAY,GAId,IAAIM,GAA4B,SAACvQ,GAC3BA,EAAMmH,OAAS/H,EAAOU,MAAM0Q,cAE9BlR,EAAKiD,OAGLjD,EAAKgD,OAGTlD,GAAOS,gBAAgBT,EAAOU,MAAM0Q,cAAeD,GACnDnR,EAAOS,gBAAgBT,EAAOU,MAAMyI,gBAAiBgI,GACrDnR,EAAOS,gBAAgBT,EAAOU,MAAM0I,gBAAiB+H,IAG7CV,EAAA3Q,UAAA8H,aAAV,WACE,GAAIC,GAAgBjI,EAAAE,UAAM8H,aAAYtI,KAAAa,KAUtC,OAJA0H,GAAcK,OAAO,GAAIV,GAAAM,IAAI,OAC3BE,MAAS7H,KAAKgI,UAAU,YAGnBN,GAEX4I,GA3H8CD,EAAAa,qBAAjChS,GAAAoR,yBAAAA,scCTb,IAAA/N,GAAA3D,EAAA,YACAyI,EAAAzI,EAAA,UAOAuS,EAAA,SAAA1R,GAEE,QAAA0R,GAAY3P,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,sBACVC,KAAM,UACL5B,EAAKyB,UAwBZ,MAhCsC9B,GAAAyR,EAAA1R,GAWpC0R,EAAAxR,UAAAC,UAAA,SAAUC,EAAgCC,GACxCL,EAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,GAExBE,KAAKe,QAAQC,UAAU,WACrBnB,EAAO2Q,KAAK,iBAINW,EAAAxR,UAAA8H,aAAV,WACE,GAAIC,GAAgBjI,EAAAE,UAAM8H,aAAYtI,KAAAa,KAUtC,OAJA0H,GAAcK,OAAO,GAAIV,GAAAM,IAAI,OAC3BE,MAAS7H,KAAKgI,UAAU,YAGnBN,GAEXyJ,GAhCsC5O,EAAAY,OAAzBjE,GAAAiS,iBAAAA,ubCRb,IAAAjL,GAAAtH,EAAA,eACAyI,EAAAzI,EAAA,UACA0I,EAAA1I,EAAA,sBAoBA0D,EAAA,SAAA7C,GASE,QAAA6C,GAAYd,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WANPD,GAAAqR,aACNrQ,QAAS,GAAIuG,GAAAE,gBACb6J,cAAe,GAAI/J,GAAAE,iBAMnBzH,EAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,YACT3B,EAAKyB,QAERzB,EAAK4B,KAAO5B,EAAKyB,OAAOG,OAmF5B,MAnGuDjC,GAAA4C,EAAA7C,GAmB3C6C,EAAA3C,UAAA8H,aAAV,WAAA,GAAA1H,GAAAC,KACMsR,EAAe,GAAIjK,GAAAM,IAAI,QACzBpD,GAAMvE,KAAKwB,OAAO+C,GAClBsD,MAAS7H,KAAK8H,kBACbG,KAAKjI,KAAK2B,KAMb,OAJA2P,GAAapJ,GAAG,QAAS,WACvBnI,EAAKoI,iBAGAmJ,GAOThP,EAAA3C,UAAAkC,QAAA,SAAQF,GACN3B,KAAK2B,KAAOA,EACZ3B,KAAKoI,gBAAgBH,KAAKtG,GAC1B3B,KAAKuR,mBAAmB5P,IAO1BW,EAAA3C,UAAA6R,QAAA,WACE,MAAOxR,MAAK2B,MAMdW,EAAA3C,UAAA8R,UAAA,WACEzR,KAAKoI,gBAAgBH,KAAK,IAC1BjI,KAAKuR,mBAAmB,OAO1BjP,EAAA3C,UAAA+R,QAAA,WACE,OAAQ1R,KAAK2B,MAQLW,EAAA3C,UAAAwI,aAAV,WACEnI,KAAKoR,YAAYrQ,QAAQuH,SAAStI,OAQ1BsC,EAAA3C,UAAA4R,mBAAV,SAA6B5P,GAC3B3B,KAAKoR,YAAYC,cAAc/I,SAAStI,KAAM2B,IAOhD4G,OAAAC,eAAIlG,EAAA3C,UAAA,eAAJ,WACE,MAAOK,MAAKoR,YAAYrQ,QAAQ0H,4CAOlCF,OAAAC,eAAIlG,EAAA3C,UAAA,qBAAJ,WACE,MAAOK,MAAKoR,YAAYC,cAAc5I,4CAE1CnG,GAnGuD4D,EAAAI,UAA1CpH,GAAAoD,MAAAA,mdCtBb,IAAA4D,GAAAtH,EAAA,eACA0I,EAAA1I,EAAA,sBACA0C,EAAA1C,EAAA,YAiBA+S,EAAA,SAAAlS,GAWE,QAAAkS,GAAYnQ,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAPPD,GAAA6R,oBACNC,YAAa,GAAIvK,GAAAE,gBACjBsK,cAAe,GAAIxK,GAAAE,gBACnB/C,eAAgB,GAAI6C,GAAAE,iBAMpBzH,EAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BuQ,SACArQ,SAAU,mBACT3B,EAAKyB,QAERzB,EAAKgS,MAAQhS,EAAKyB,OAAOuQ,QAuI7B,MA1J8ErS,GAAAiS,EAAAlS,GAsBpEkS,EAAAhS,UAAAqS,aAAR,SAAqBC,GACnB,IAAK,GAAIC,KAASlS,MAAK+R,MACrB,GAAIE,IAAQjS,KAAK+R,MAAMG,GAAOD,IAC5B,MAAOE,UAASD,EAGpB,QAAQ,GAQVP,EAAAhS,UAAAyS,QAAA,SAAQH,GACN,MAAOjS,MAAKgS,aAAaC,IAAQ,GASnCN,EAAAhS,UAAAwE,QAAA,SAAQ8N,EAAazN,GACnBxE,KAAKqS,WAAWJ,GAChBjS,KAAK+R,MAAMtE,MAAOwE,IAAKA,EAAKzN,MAAOA,IACnCxE,KAAKsS,iBAAiBL,IAQxBN,EAAAhS,UAAA0S,WAAA,SAAWJ,GACT,GAAIC,GAAQlS,KAAKgS,aAAaC,EAC9B,OAAIC,IAAS,IACX5Q,EAAAqM,WAAWC,OAAO5N,KAAK+R,MAAO/R,KAAK+R,MAAMG,IACzClS,KAAKuS,mBAAmBN,IACjB,IAWXN,EAAAhS,UAAAwF,WAAA,SAAW8M,GACT,MAAIA,KAAQjS,KAAKwS,cAKLxS,KAAKgS,aAAaC,IAEjB,IACXjS,KAAKwS,aAAeP,EACpBjS,KAAKyS,oBAAoBR,IAClB,IAUXN,EAAAhS,UAAA+S,gBAAA,WACE,MAAO1S,MAAKwS,cAMdb,EAAAhS,UAAAuE,WAAA,WACE,GAAI6N,GAAQ/R,KAAK+R,KACjB/R,MAAK+R,QAGL,KAAiB,GAAA3N,GAAA,EAAAuO,EAAAZ,EAAA3N,EAAAuO,EAAAvT,OAAAgF,IAAK,CAAjB,GAAIwO,GAAID,EAAAvO,EACXpE,MAAKuS,mBAAmBK,EAAKX,OAQjCN,EAAAhS,UAAAkT,UAAA,WACE,MAAOtK,QAAOuK,KAAK9S,KAAK+R,OAAO3S,QAGvBuS,EAAAhS,UAAA2S,iBAAV,SAA2BL,GACzBjS,KAAK4R,mBAAmBC,YAAYvJ,SAAStI,KAAMiS,IAG3CN,EAAAhS,UAAA4S,mBAAV,SAA6BN,GAC3BjS,KAAK4R,mBAAmBE,cAAcxJ,SAAStI,KAAMiS,IAG7CN,EAAAhS,UAAA8S,oBAAV,SAA8BR,GAC5BjS,KAAK4R,mBAAmBnN,eAAe6D,SAAStI,KAAMiS,IAOxD1J,OAAAC,eAAImJ,EAAAhS,UAAA,mBAAJ,WACE,MAAOK,MAAK4R,mBAAmBC,YAAYpJ,4CAO7CF,OAAAC,eAAImJ,EAAAhS,UAAA,qBAAJ,WACE,MAAOK,MAAK4R,mBAAmBE,cAAcrJ,4CAO/CF,OAAAC,eAAImJ,EAAAhS,UAAA,sBAAJ,WACE,MAAOK,MAAK4R,mBAAmBnN,eAAegE,4CAElDkJ,GA1J8EzL,EAAAI,UAAxDpH,GAAAyS,aAAAA;wXCnBtB,IAMYoB,GANZ1R,EAAAzC,EAAA,YAMA,SAAYmU,GAIVA,EAAAA,EAAA,MAAA,GAAA,QAIAA,EAAAA,EAAA,YAAA,GAAA,eARUA,EAAA7T,EAAA6T,uBAAA7T,EAAA6T,yBAwBZ,IAAAC,GAAA,SAAAvT,GAEE,QAAAuT,GAAYxR,GAAZ,GAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BuK,YAAa,iBAAkB,kBAAoBgH,EAAqBvR,EAAOyR,SAASC,gBACvFnT,EAAKyB,UAuCZ,MA9CmC9B,GAAAsT,EAAAvT,GAUjCuT,EAAArT,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAI0B,GAA8BxB,KAAKG,YACnCgT,EAAWrT,EAAUK,YAErBiT,EAAO,WACT,OAAQ5R,EAAOyR,SACb,IAAKF,GAAqBM,MACpBF,GAAYA,EAASG,UAAYH,EAASG,SAASC,MACrDxT,EAAK8B,QAAQsR,EAASG,SAASC,OACtB1T,EAAOM,YAAYqT,QAAU3T,EAAOM,YAAYqT,OAAOD,OAChExT,EAAK8B,QAAQhC,EAAOM,YAAYqT,OAAOD,MAEzC,MACF,KAAKR,GAAqBU,YACpBN,GAAYA,EAASG,UAAYH,EAASG,SAASI,YACrD3T,EAAK8B,QAAQsR,EAASG,SAASI,aACtB7T,EAAOM,YAAYqT,QAAU3T,EAAOM,YAAYqT,OAAOE,aAChE3T,EAAK8B,QAAQhC,EAAOM,YAAYqT,OAAOE,eAM3CC,EAAS,WACX5T,EAAK8B,QAAQ,MAIfuR,KAEAvT,EAAOS,gBAAgBT,EAAOU,MAAMgK,iBAAkB6I,GAEtDvT,EAAOS,gBAAgBT,EAAOU,MAAMuE,mBAAoB6O,IAE5DX,GA9CmC3R,EAAAiB,MAAtBpD,GAAA8T,cAAAA,2aC9Bb,IAAA5P,GAAAxE,EAAA,kBAMAgV,EAAA,SAAAnU,GAEE,QAAAmU,GAAYpS,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,qBACVC,KAAM,sBACL5B,EAAKyB,UA4CZ,MApDkD9B,GAAAkU,EAAAnU,GAWhDmU,EAAAjU,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,GAExBE,KAAKe,QAAQC,UAAU,WACjBnB,EAAOgU,8BACLhU,EAAOiU,qBACTjU,EAAOkU,uBAEPlU,EAAOmU,wBAGLxQ,SACFA,QAAQC,IAAI,oBAKlB,IAAIwQ,GAAqB,WACnBpU,EAAOgU,8BACT9T,EAAKgD,OAELhD,EAAKiD,OAITnD,GAAOS,gBAAgBT,EAAOU,MAAMwE,SAAUkP,GAG9CpU,EAAOS,gBAAgBT,EAAOU,MAAM2T,4BAA6B,WAC/DnU,EAAKmI,OAEPrI,EAAOS,gBAAgBT,EAAOU,MAAM4T,2BAA4B,WAC9DpU,EAAK0J,QAIPwK,IACIpU,EAAOiU,sBACT9T,KAAKkI,MAGX0L,GApDkDxQ,EAAAQ,aAArC1E,GAAA0U,6BAAAA,kbCNb,IAAA/P,GAAAjF,EAAA,eAOAwV,EAAA,SAAA3U,GAEE,QAAA2U,GAAY5S,cAAA,KAAAA,IAAAA,MACV/B,EAAAN,KAAAa,KAAMwB,IAAOxB,KAmBjB,MAtB4CN,GAAA0U,EAAA3U,GAM1C2U,EAAAzU,UAAAC,UAAA,SAAUC,EAAgCC,GACxCL,EAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,GAExBE,KAAKmE,QAAQ,OAAQ,SACrBnE,KAAKmE,QAAQ,MAAO,QACpBnE,KAAKmE,QAAQ,IAAK,UAClBnE,KAAKmE,QAAQ,MAAO,QACpBnE,KAAKmE,QAAQ,IAAK,MAElBnE,KAAKmF,WAAW,KAGhBnF,KAAKyE,eAAezD,UAAU,SAAC0D,EAAgCC,GAC7D9E,EAAOwU,iBAAiBC,WAAW3P,OAGzCyP,GAtB4CvQ,EAAAwB,UAA/BnG,GAAAkV,uBAAAA,+aCPb,IAKYG,GALZlT,EAAAzC,EAAA,WAEA0C,EAAA1C,EAAA,aAGA,SAAY2V,GACVA,EAAAA,EAAA,YAAA,GAAA,cACAA,EAAAA,EAAA,UAAA,GAAA,YACAA,EAAAA,EAAA,oBAAA,GAAA,uBAHUA,EAAArV,EAAAqV,wBAAArV,EAAAqV,0BAeZ,IAAAC,GAAA,SAAA/U,GAIE,QAAA+U,GAAYhT,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,uBACV+S,cAAeF,EAAsBG,oBACrCC,oBAAoB,GACnB5U,EAAKyB,UAkHZ,MA7HuC9B,GAAA8U,EAAA/U,GAcrC+U,EAAA7U,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAI0B,GAAkCxB,KAAKG,YACvCyU,GAAO,EACPC,EAAe7U,KAAKgI,UAAU,6BAC9B8M,EAAmB9U,KAAKgI,UAAU,kCAClC+M,EAAW,EAEXC,EAAmB,WACrBnV,EAAOoV,UAAU,IAGfC,EAAkB,WAEpBN,EAAO/U,EAAOsV,SAGVP,GACF7U,EAAKqI,gBAAgB0E,SAAS+H,GAC9B9U,EAAK8B,QAAQ,QACTL,EAAOmT,oBACT5U,EAAKiD,OAEPjD,EAAKgB,QAAQC,UAAUgU,GACvBI,MAEArV,EAAKqI,gBAAgB6E,YAAY4H,GACjC9U,EAAKqI,gBAAgB6E,YAAY6H,GACjC/U,EAAKgD,OACLhD,EAAKgB,QAAQsU,YAAYL,IAI7B,IAAI1T,GAAAgU,YAAYC,mBAAmB1V,GAAQ2V,cAAcxU,UAAU,SAAC0D,EAAQiK,GAC1EiG,EAAOjG,EAAKiG,KACZM,KAGF,IAAIE,GAA2B,WACC,IAA1BvV,EAAO4V,eACT1V,EAAKqI,gBAAgB0E,SAASgI,GAE9B/U,EAAKqI,gBAAgB6E,YAAY6H,IAIjCY,EAAsB,WACnBd,GAAQ/U,EAAO8V,gBAAkBC,EAAAA,GACpC7V,EAAK8V,QAAQhW,EAAOoD,iBAAkBpD,EAAO8V,cAK/C,IAAIG,GAAQ/V,EAAKqI,gBAAgB0N,OAC7BA,GAAQf,IACVA,EAAWe,EACX/V,EAAKqI,gBAAgBsE,KACnBqJ,YAAahB,EAAW,QAK9BlV,GAAOS,gBAAgBT,EAAOU,MAAM2B,gBAAiBwT,GACrD7V,EAAOS,gBAAgBT,EAAOU,MAAMoK,UAAW+K,GAC/C7V,EAAOS,gBAAgBT,EAAOU,MAAM4B,qBAAsBuT,GAE1D7V,EAAOS,gBAAgBT,EAAOU,MAAMyV,cAAeZ,GACnDvV,EAAOS,gBAAgBT,EAAOU,MAAM0V,gBAAiBb,EAErD,IAAIhC,GAAO,WAGT2B,EAAW,EACXhV,EAAKqI,gBAAgBsE,KACnBqJ,YAAa,OAIfhW,EAAKmW,WAAaC,KAAKC,IAAIvW,EAAOsV,SAAWtV,EAAOwW,kBAAoBxW,EAAO8V,gBAAkB,KAC/FrU,EAAAQ,YAAYwU,cAAgBhV,EAAAQ,YAAYyU,YAG1Cb,IAEF7V,GAAOS,gBAAgBT,EAAOU,MAAMwE,SAAUqO,GAE9CA,KAQFoB,EAAA7U,UAAAkW,QAAA,SAAQW,EAAyBC,GAC/B,GAAIC,GAAcpV,EAAAQ,YAAY6U,cAAcH,EAAiBxW,KAAKkW,YAC9DU,EAAYtV,EAAAQ,YAAY6U,cAAcF,EAAiBzW,KAAKkW,WAEhE,QAAkClW,KAAKwB,OAAQiT,eAC7C,IAAKF,GAAsBsC,YACzB7W,KAAK6B,QAAQ,GAAG6U,EAChB,MACF,KAAKnC,GAAsBuC,UACzB9W,KAAK6B,QAAQ,GAAG+U,EAChB,MACF,KAAKrC,GAAsBG,oBACzB1U,KAAK6B,QAAW6U,EAAW,MAAME,KAIzCpC,GA7HuCnT,EAAAiB,MAA1BpD,GAAAsV,kBAAAA,ybCpBb,IAAApR,GAAAxE,EAAA,kBAGA0C,EAAA1C,EAAA,YAMAsS,EAAA,SAAAzR,GAIE,QAAAyR,GAAY1P,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,0BACVC,KAAM,cACL5B,EAAKyB,UAoEZ,MA9E0C9B,GAAAwR,EAAAzR,GAaxCyR,EAAAvR,UAAAC,UAAA,SAAUC,EAAgCC,EAA8BiX,GAAxE,GAAAhX,GAAAC,SAAwE,KAAA+W,IAAAA,GAAA,GACtEtX,EAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAIkX,IAAY,EAGZC,EAAuB,SAACxW,GAGtBuW,IAIAnX,EAAOyK,YACTvK,EAAKmI,KAELnI,EAAK0J,OAKT5J,GAAOS,gBAAgBT,EAAOU,MAAMiK,QAASyM,GAC7CpX,EAAOS,gBAAgBT,EAAOU,MAAMkK,UAAWwM,GAE/CpX,EAAOS,gBAAgBT,EAAOU,MAAM2W,qBAAsBD,GAC1DpX,EAAOS,gBAAgBT,EAAOU,MAAMyI,gBAAiBiO,GACrDpX,EAAOS,gBAAgBT,EAAOU,MAAM4W,gBAAiBF,GACrDpX,EAAOS,gBAAgBT,EAAOU,MAAM6W,eAAgBH,GACpDpX,EAAOS,gBAAgBT,EAAOU,MAAM8W,0BAA2BJ,GAG/D,GAAI3V,GAAAgU,YAAYgC,8BAA8BzX,GAAQ0X,+BAA+BvW,UACnF,SAAC0D,EAAQiK,GACFA,EAAK6I,mBAGRzX,EAAKqI,gBAAgB6E,YAAYlN,EAAKiI,UAAUkJ,EAAqBuG,mBAFrE1X,EAAKqI,gBAAgB0E,SAAS/M,EAAKiI,UAAUkJ,EAAqBuG,qBAOpEV,GAIF/W,KAAKe,QAAQC,UAAU,WACjBnB,EAAOyK,YACTzK,EAAOoB,MAAM,aAEbpB,EAAO2Q,KAAK,eAMlB1Q,EAAU4X,OAAO1W,UAAU,WACzBgW,GAAY,IAEdlX,EAAU6X,SAAS3W,UAAU,WAC3BgW,GAAY,IAIdC,KAEJ/F,GA9E0C9N,EAAAQ,aAEhBsN,GAAAuG,iBAAmB,aAFhCvY,EAAAgS,qBAAAA,gcCTb,IAAAjL,GAAArH,EAAA,eACAgZ,EAAAhZ,EAAA,8BAKAiZ,EAAA,SAAApY,GAIE,QAAAoY,GAAYrW,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAK+X,qBAAuB,GAAIF,GAAAtH,yBAEhCvQ,EAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,4BACV+E,YAAa1G,EAAK+X,uBACjB/X,EAAKyB,UAEZ,MAd2C9B,GAAAmY,EAAApY,GAc3CoY,GAd2C5R,EAAAmB,UAA9BlI,GAAA2Y,sBAAAA,+cCNb,IAAA5R,GAAArH,EAAA,eACAsH,EAAAtH,EAAA,eACAyI,EAAAzI,EAAA,UAEA0C,EAAA1C,EAAA,YACAmZ,EAAAnZ,EAAA,sBAKAoZ,EAAA,SAAAvY,GAIE,QAAAuY,GAAYxW,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKkY,aAAe,GAAIF,GAAA5G,iBAExBpR,EAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,4BACV8E,QAAQ,EACRC,YAAa1G,EAAKkY,eACjBlY,EAAKyB,UAqEZ,MAlF2C9B,GAAAsY,EAAAvY,GAgBzCuY,EAAArY,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAIoY,GAAuB,WACzB,IAAsB,GAAA9T,GAAA,EAAA2J,EAAAhO,EAAK8N,gBAALzJ,EAAA2J,EAAA3O,OAAAgF,IAAoB,CAArC,GAAIoJ,GAASO,EAAA3J,EACZoJ,aAAqB2K,IACvBpY,EAAK2N,gBAAgBF,GAGzBzN,EAAKiO,mBACLjO,EAAKqI,gBAAgB6E,YAAYlN,EAAKiI,UAAU,qBAG9CoQ,EAAuB,WACzBF,GAEA,IAAIG,GAA+BvY,EAAUK,YAAYmY,iBACpDxY,EAAUK,YAAYmY,gBAAgBlZ,OAAS,EAChDmZ,EAAmC1Y,EAAOM,YAAYqT,QAAU3T,EAAOM,YAAYqT,OAAO8E,iBACzFzY,EAAOM,YAAYqT,OAAO8E,gBAAgBlZ,OAAS,EAGpDkZ,EAAkBD,EAA+BvY,EAAUK,YAAYmY,gBACzEC,EAAmC1Y,EAAOM,YAAYqT,OAAO8E,gBAAkB,IAIjF,IAAIA,EAAiB,CAEnB,IAAiB,GADbpG,GAAQ,EACK9N,EAAA,EAAAoU,EAAAF,EAAAlU,EAAAoU,EAAApZ,OAAAgF,IAAe,CAA3B,GAAIwO,GAAI4F,EAAApU,EACXrE,GAAKwN,aAAa,GAAI4K,IACpBM,WAAY7F,EACZ7G,YAAa,uBAA0BmG,QAG3CnS,EAAKiO,mBAELjO,EAAKqI,gBAAgB0E,SAAS/M,EAAKiI,UAAU,qBAKjDnI,GAAOS,gBAAgBT,EAAOU,MAAMwE,SAAUqT,GAE9CvY,EAAOS,gBAAgBT,EAAOU,MAAMuE,mBAAoB,WACtDoT,IACAnY,EAAKiD,SAGPnD,EAAOS,gBAAgBT,EAAOU,MAAM2W,qBAAsB,WAGpDrX,EAAO6Y,QAIX3Y,EAAKgD,SAGPlD,EAAOS,gBAAgBT,EAAOU,MAAMiK,QAAS,WAC3CzK,EAAKiD,SAIPoV,KAEJJ,GAlF2C/R,EAAAmB,UAA9BlI,GAAA8Y,sBAAAA,CA8Fb,IAAAG,GAAA,SAAA1Y,GAEE,QAAA0Y,GAAY3W,GAAZ,GAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,yBACV+W,WAAY,MACX1Y,EAAKyB,UAiCZ,MAzCiC9B,GAAAyY,EAAA1Y,GAWrB0Y,EAAAxY,UAAA8H,aAAV,WACE,GAAIjG,GAAoCxB,KAAKwB,OAAQiX,WAEjDE,EAAc,GAAItR,GAAAM,IAAI,KACxBpD,GAAMvE,KAAKwB,OAAO+C,GAClBsD,MAAS7H,KAAK8H,gBACd8Q,KAAQpX,EAAOuJ,MACd2B,KAAMmM,mBAAoB,OAAOrX,EAAOsX,UAAS,MAEhDC,EAAY,GAAI1R,GAAAM,IAAI,OACtBE,MAAS7H,KAAKgI,UAAU,eAE1B2Q,GAAY5Q,OAAOgR,EAEnB,IAAIC,GAAe,GAAI3R,GAAAM,IAAI,QACzBE,MAAS7H,KAAKgI,UAAU,WACvBD,OAAO,GAAIV,GAAAM,IAAI,QAChBE,MAAS7H,KAAKgI,UAAU,gBACvBC,KAAKzG,EAAO+R,OACfoF,GAAY5Q,OAAOiR,EAEnB,IAAIC,GAAc,GAAI5R,GAAAM,IAAI,QACxBE,MAAS7H,KAAKgI,UAAU,cACvBD,OAAO,GAAIV,GAAAM,IAAI,QAChBE,MAAS7H,KAAKgI,UAAU,mBACvBC,KAAKzG,EAAO0X,SAAW5X,EAAAQ,YAAY6U,cAAcnV,EAAO0X,UAAY,IAGvE,OAFAP,GAAY5Q,OAAOkR,GAEZN,GAEXR,GAzCiCjS,EAAAI,2fCxGjC,IAAAJ,GAAAtH,EAAA,eACAyI,EAAAzI,EAAA,UACA0I,EAAA1I,EAAA,sBAGAuH,EAAAvH,EAAA,cACA0C,EAAA1C,EAAA,YA8CAua,EAAA,SAAA1Z,GAgDE,QAAA0Z,GAAY3X,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAvBPD,GAAAqZ,2BAA6B,EAK7BrZ,EAAAsZ,eAAkB,gBAAkBpO,QAEpClL,EAAAuZ,eAIN5B,OAAQ,GAAIpQ,GAAAE,gBAIZ+R,cAAe,GAAIjS,GAAAE,gBAInBmQ,SAAU,GAAIrQ,GAAAE,iBAMdzH,EAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,aACV8X,UAAU,EACVC,uCAAwC,IACvC1Z,EAAKyB,QAERzB,EAAKyE,MAAQzE,EAAKyB,OAAOgD,MACzBzE,EAAK2Z,qBA2uBT,MAryB6Bha,GAAAyZ,EAAA1Z,GA6D3B0Z,EAAAxZ,UAAAmL,WAAA,WACErL,EAAAE,UAAMmL,WAAU3L,KAAAa,MAEZA,KAAK2Z,YACP3Z,KAAK4Z,WAAW9O,cAIpBqO,EAAAxZ,UAAAC,UAAA,SAAUC,EAAgCC,EAA8B+Z,GAAxE,GAAA9Z,GAAAC,IAGE,QAHsE,KAAA6Z,IAAAA,GAAA,GACtEpa,EAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,GAEnB+Z,EAAL,CAQA,GAAIC,IAAyB,EACzBxP,GAAY,EACZ0M,GAAY,EAGZ+C,EAA0B,SAACtZ,EAA2BuZ,GAIxD,OAJ6B,KAAAvZ,IAAAA,EAAA,UAA2B,KAAAuZ,IAAAA,GAAA,GAExDF,GAAyB,GAErB9C,EAKJ,GAAInX,EAAOsV,SAAU,CACnB,GAAiC,IAA7BtV,EAAOwW,kBAETtW,EAAKka,oBAAoB,SAEtB,CACH,GAAIb,GAA6B,IAAO,IAAMvZ,EAAOwW,kBAAoBxW,EAAO4V,cAChF1V,GAAKka,oBAAoBb,GAI3BrZ,EAAKma,kBAAkB,SAEpB,CACH,GAAId,GAA6B,IAAMvZ,EAAO8V,cAAgB9V,EAAOoD,iBAEjEkX,EAAoBta,EAAOua,uBAC3BC,EAAoBxa,EAAOya,uBAI3BC,EAAepE,KAAKqE,IACD,MAArBL,EAA4BA,EAAoBM,OAAOC,UAClC,MAArBL,EAA4BA,EAAoBI,OAAOC,UAErDH,KAAiBE,OAAOC,YAC1BH,EAAe,EAGjB,IAAII,GAAmB,IAAM9a,EAAO8V,cAAgB4E,GAIhDxa,EAAKyB,OAAOiY,yCAA2CN,EAAQyB,0CAC9DZ,GAAena,EAAOgb,YAAehb,EAAOgb,aAAehb,EAAOyK,cACrEvK,EAAKka,oBAAoBb,GAG3BrZ,EAAKma,kBAAkBd,EAA6BuB,IAMxD9a,GAAOS,gBAAgBT,EAAOU,MAAMwE,SAAUgV,GAE9Cla,EAAOS,gBAAgBT,EAAOU,MAAM2B,gBAAiB6X,GAErDla,EAAOS,gBAAgBT,EAAOU,MAAM2G,eAAgB6S,GAEpDla,EAAOS,gBAAgBT,EAAOU,MAAMoK,UAAWoP,GAE/Cla,EAAOS,gBAAgBT,EAAOU,MAAM0V,gBAAiB8D,GAErDla,EAAOS,gBAAgBT,EAAOU,MAAMua,4BAA6Bf,GAEjEla,EAAOS,gBAAgBT,EAAOU,MAAM4B,qBAAsB4X,GAI1Dla,EAAOS,gBAAgBT,EAAOU,MAAMmK,QAAS,WAC3C3K,EAAKgb,YAAW,KAElBlb,EAAOS,gBAAgBT,EAAOU,MAAMoK,UAAW,WAC7C5K,EAAKgb,YAAW,KAElBlb,EAAOS,gBAAgBT,EAAOU,MAAMyV,cAAe,WACjDjW,EAAKgb,YAAW,KAElBlb,EAAOS,gBAAgBT,EAAOU,MAAM0V,gBAAiB,WACnDlW,EAAKgb,YAAW,IAGlB,IAAIC,GAAO,SAACC,GACNpb,EAAOsV,SACTtV,EAAOoV,UAAUpV,EAAOwW,kBAAqBxW,EAAOwW,mBAAqB4E,EAAa,MAEtFpb,EAAOmb,KAAKnb,EAAO8V,eAAiBsF,EAAa,MAGrDjb,MAAK0X,OAAO1W,UAAU,SAAC0D,GACrBsS,GAAY,EAGZlX,EAAU4X,OAAOpP,SAAS5D,IAG1B4F,EAAYzK,EAAOyK,cAIjBzK,EAAOoB,MAAM,aAGjBjB,KAAKuZ,cAAcvY,UAAU,SAAC0D,EAAiBiK,GAE7C7O,EAAUyZ,cAAcjR,SAAS5D,EAAQiK,KAE3C3O,KAAKuZ,cAAc2B,qBAAqB,SAACxW,EAAiBiK,GAEpDA,EAAKwM,WACPH,EAAKrM,EAAKyM,WAEX,KACHpb,KAAK2X,SAAS3W,UAAU,SAAC0D,EAAQuW,GAC/BjE,GAAY,EAGZgE,EAAKC,GAGD3Q,GACFzK,EAAO2Q,KAAK,WAId1Q,EAAU6X,SAASrP,SAAS5D,KAG1B1E,KAAK2Z,YAEP3Z,KAAK4Z,WAAWha,UAAUC,EAAQC,EAIpC,IAAIqV,IAAS,EACTkG,GAAe,EACfC,EAAmB,SAACnG,EAAiBkG,GACnClG,IAAWkG,EACbtb,EAAKiD,OAELjD,EAAKgD,OAEPgX,EAAwB,MAAM,GAC9Bha,EAAKwb,0BAEP,IAAIja,GAAAgU,YAAYC,mBAAmB1V,GAAQ2V,cAAcxU,UAAU,SAAC0D,EAAQiK,GAC1EwG,EAASxG,EAAKiG,KACd0G,EAAiBnG,EAAQkG,KAE3B,GAAI/Z,GAAAgU,YAAYgC,8BAA8BzX,GAAQ0X,+BAA+BvW,UACnF,SAAC0D,EAAQiK,GACP0M,EAAe1M,EAAK6I,mBACpB8D,EAAiBnG,EAAQkG,KAM7Bxb,EAAOS,gBAAgBT,EAAOU,MAAMib,iBAAkB,WACpDzb,EAAKwb,4BAIPzb,EAAU2b,aAAaza,UAAU,WAC/BjB,EAAKwb,4BAIP1b,EAAOS,gBAAgBT,EAAOU,MAAMwE,SAAU,WAC5ChF,EAAKwb,4BAIPxB,IACA/Z,KAAKka,kBAAkB,GACvBla,KAAK0b,gBAAgB,GACjB1b,KAAKwB,OAAOiY,yCAA2CN,EAAQyB,0CACjE5a,KAAK2b,uCAAuC9b,EAAQC,GAEtDE,KAAK4b,iBAAiB/b,EAAQC,KAGxBqZ,EAAAxZ,UAAAgc,uCAAR,SAA+C9b,EAAgCC,GAA/E,GAAAC,GAAAC,KASM6b,EAAqB,EACrBC,EAAoB,CAIxB9b,MAAK+b,8BAAgC,GAAI5V,GAAAS,QAHlB,GAG4C,WACjEiV,GAH+BG,IAI/BF,EAAoBjc,EAAOoD,gBAG3B,IAAIgZ,GAAmBJ,EAAqBC,CAGxC3F,MAAKC,IAAI6F,GAAoB,EAC/BJ,EAAqBC,EAIdG,IAfsBD,IAgB7BH,GAhB6BG,IAoBtBC,GApBsBD,MAqB7BH,GArB6BG,IAwB/B,IAAI5C,GAA6B,IAAMvZ,EAAO8V,cAAgBkG,CAC9D9b,GAAKka,oBAAoBb,KACxB,EAEH,IAAI8C,GAAqC,WAClCrc,EAAOsV,WACV0G,EAAqBhc,EAAOoD,iBAC5BlD,EAAKgc,8BAA8BjV,UAInCqV,EAAoC,WACtCpc,EAAKgc,8BAA8B/U,QAGrCnH,GAAOS,gBAAgBT,EAAOU,MAAMiK,QAAS0R,GAC7Crc,EAAOS,gBAAgBT,EAAOU,MAAM4W,gBAAiB+E,GACrDrc,EAAOS,gBAAgBT,EAAOU,MAAMkK,UAAW0R,GAC/Ctc,EAAOS,gBAAgBT,EAAOU,MAAM6W,eAAgB+E,GACpDtc,EAAOS,gBAAgBT,EAAOU,MAAMoK,UAAW,WAC7CkR,EAAqBhc,EAAOoD,mBAG1BpD,EAAOyK,aACT4R,KAII/C,EAAAxZ,UAAAic,iBAAR,SAAyB/b,EAAgCC,GAAzD,GAAAC,GAAAC,KACMoc,EAAe,WACjBrc,EAAK2Z,mBACL3Z,EAAKsc,iBAGHC,EAAe,WACjBF,GAEA,IAAIG,GAAuBzc,EAAUK,YAAYmT,UAAYxT,EAAUK,YAAYmT,SAASkJ,SACvF1c,EAAUK,YAAYmT,SAASkJ,QAAQpd,OAAS,EACjDqd,EAA2B5c,EAAOM,YAAYqT,QAAU3T,EAAOM,YAAYqT,OAAOgJ,SACjF3c,EAAOM,YAAYqT,OAAOgJ,QAAQpd,OAAS,EAG5Cod,EAAUD,EAAuBzc,EAAUK,YAAYmT,SAASkJ,QAClEC,EAA2B5c,EAAOM,YAAYqT,OAAOgJ,QAAU,IAIjE,IAAIA,GAAW3c,EAAO8V,gBAAkBC,EAAAA,EACtC,IAAc,GAAAxR,GAAA,EAAAsY,EAAAF,EAAApY,EAAAsY,EAAAtd,OAAAgF,IAAO,CAAhB,GAAI3F,GAACie,EAAAtY,GACJuY,GACFC,KAAM,IAAM/c,EAAO8V,cAAgBlX,EAAEme,KACrCrJ,MAAO9U,EAAE8U,MACTsJ,WAAY,IAAMpe,EAAEoe,YAAc,GAClCC,QAASre,EAAEqe,SAAW,GACtBC,OAAQte,EAAEse,OACVC,OAAQve,EAAEue,QAAU,GAEtBjd,GAAK2Z,gBAAgBjM,KAAKkP,GAK9B5c,EAAKsc,gBAIPxc,GAAOS,gBAAgBT,EAAOU,MAAMwE,SAAUuX,GAE9Czc,EAAOS,gBAAgBT,EAAOU,MAAMuE,mBAAoBsX,GAGxDE,KAGFnD,EAAAxZ,UAAAiL,QAAA,WACEnL,EAAAE,UAAMiL,QAAOzL,KAAAa,MAETA,KAAK+b,+BACP/b,KAAK+b,8BAA8B/U,SAI7BmS,EAAAxZ,UAAA8H,aAAV,WAAA,GAAA1H,GAAAC,IACMA,MAAKwB,OAAOgY,UACdxZ,KAAKwB,OAAOuK,WAAW0B,KAAK,WAG9B,IAAIwP,GAAmB,GAAI5V,GAAAM,IAAI,OAC7BpD,GAAMvE,KAAKwB,OAAO+C,GAClBsD,MAAS7H,KAAK8H,kBAGZoV,EAAU,GAAI7V,GAAAM,IAAI,OACpBE,MAAS7H,KAAKgI,UAAU,YAE1BhI,MAAKkd,QAAUA,CAGf,IAAIC,GAAqB,GAAI9V,GAAAM,IAAI,OAC/BE,MAAS7H,KAAKgI,UAAU,wBAE1BhI,MAAKod,sBAAwBD,CAG7B,IAAIE,GAA0B,GAAIhW,GAAAM,IAAI,OACpCE,MAAS7H,KAAKgI,UAAU,6BAE1BhI,MAAKqd,wBAA0BA,CAG/B,IAAIC,GAAgC,GAAIjW,GAAAM,IAAI,OAC1CE,MAAS7H,KAAKgI,UAAU,oCAE1BhI,MAAKsd,8BAAgCA,CAGrC,IAAIC,GAAsB,GAAIlW,GAAAM,IAAI,OAChCE,MAAS7H,KAAKgI,UAAU,yBAE1BhI,MAAKud,oBAAsBA,CAG3B,IAAIC,GAAkB,GAAInW,GAAAM,IAAI,OAC5BE,MAAS7H,KAAKgI,UAAU,qBAE1BhI,MAAKwd,gBAAkBA,CAEvB,IAAIC,GAAiC,GAAIpW,GAAAM,IAAI,OAC3CE,MAAS7H,KAAKgI,UAAU,oBAE1BhI,MAAK0d,wBAA0BD,EAE/BP,EAAQnV,OAAOyV,EAAiBL,EAAoBI,EAClDF,EAAyBI,EAAgCH,EAE3D,IAAIK,IAAU,EAGVC,EAAwB,SAACxf,GAC3BA,EAAEyf,iBAEFzf,EAAE0f,iBAEF,IAAIC,GAAmB,IAAMhe,EAAKie,UAAU5f,EAC5C2B,GAAK2b,gBAAgBqC,GACrBhe,EAAKka,oBAAoB8D,GACzBhe,EAAKke,mBAAmBF,GAAkB,IAExCG,EAAsB,SAAC9f,GACzBA,EAAEyf,iBAGF,GAAIxW,GAAAM,IAAIwW,UAAU1U,IAAI,sBAAuBmU,GAC7C,GAAIvW,GAAAM,IAAIwW,UAAU1U,IAAI,mBAAoByU,EAE1C,IAAIH,GAAmB,IAAMhe,EAAKie,UAAU5f,GACxCggB,EAAiBre,EAAKse,oBAAoBN,EAE9Che,GAAKgb,YAAW,GAChB4C,GAAU,EAGV5d,EAAKue,cAAcF,EAAiBA,EAAexB,KAAOmB,GAiE5D,OAzDAb,GAAQhV,GAAG,uBAAwB,SAAC9J,GAClC,GAAImgB,GAAexe,EAAKsZ,gBAAkBjb,YAAaogB,WAGvDpgB,GAAEyf,iBAEFzf,EAAE0f,kBAEF/d,EAAKgb,YAAW,GAChB4C,GAAU,EAGV5d,EAAK0e,cAGL,GAAIpX,GAAAM,IAAIwW,UAAUjW,GAAGqW,EAAe,YAAc,YAAaX,GAC/D,GAAIvW,GAAAM,IAAIwW,UAAUjW,GAAGqW,EAAe,WAAa,UAAWL,KAI9DhB,EAAQhV,GAAG,sBAAuB,SAAC9J,GACjCA,EAAEyf,iBAEEF,IAGFvf,EAAE0f,kBAEFF,EAAsBxf,GAGxB,IAAIgd,GAAW,IAAMrb,EAAKie,UAAU5f,EACpC2B,GAAK2b,gBAAgBN,GACrBrb,EAAKke,mBAAmB7C,GAAU,GAE9Brb,EAAK4Z,YAAc5Z,EAAK6Z,WAAW5N,YACrCjM,EAAK6Z,WAAW7W,SAKpBma,EAAQhV,GAAG,sBAAuB,SAAC9J,GACjCA,EAAEyf,iBAEF9d,EAAK2b,gBAAgB,GAEjB3b,EAAK4Z,YACP5Z,EAAK6Z,WAAW5W,SAIpBia,EAAiBlV,OAAOmV,GAEpBld,KAAKwE,OACPyY,EAAiBlV,OAAO/H,KAAKwE,MAAM4D,iBAG9B6U,GAGC9D,EAAAxZ,UAAA0c,cAAV,WACErc,KAAK0d,wBAAwBxP,OAE7B,KAAmB,GAAA9J,GAAA,EAAA2J,EAAA/N,KAAK0Z,gBAALtV,EAAA2J,EAAA3O,OAAAgF,IAAoB,CAAlC,GAAIuY,GAAM5O,EAAA3J,GACTsa,EAAkC,MAAtB/B,EAAOE,WAAqB7c,KAAKgI,UAAU,0BAA4BhI,KAAKgI,UAAU,kBAElG2W,EAAY,GAAItX,GAAAM,IAAI,OACtBE,MAAS6W,EACTE,mBAAoBC,OAAOlC,EAAOC,MAClCkC,oBAAqBD,OAAOlC,EAAOpJ,SAClC7G,KACDoJ,MAAS6G,EAAOC,KAAO,KAEzB5c,MAAK0d,wBAAwB3V,OAAO4W,KAI9BxF,EAAAxZ,UAAA0e,oBAAV,SAA8BpD,GAC5B,GAAI8D,GAAgC,IAEpC,IAAI/e,KAAK0Z,gBAAgBta,OAAS,EAChC,IAAmB,GAAAgF,GAAA,EAAA2J,EAAA/N,KAAK0Z,gBAALtV,EAAA2J,EAAA3O,OAAAgF,IAAoB,CAAlC,GAAIuY,GAAM5O,EAAA3J,EACb,IAAI6W,GAAc0B,EAAOC,KAHT,GAGiC3B,GAAc0B,EAAOC,KAHtD,EAG4E,CAC1FmC,EAAgBpC,CAChB,QAKN,MAAOoC,IAQD5F,EAAAxZ,UAAAqf,oBAAR,SAA4BC,GAC1B,GAAIC,GAAkBlf,KAAKkd,QAAQiC,SAASC,KACxCC,EAAUrf,KAAKkd,QAAQpH,QACvBwJ,EAAWL,EAAaC,EACxBC,EAAS,EAAIE,EAAUC,CAE3B,OAAOtf,MAAKuf,eAAeJ,IAQrBhG,EAAAxZ,UAAA6f,kBAAR,SAA0BC,GACxB,GAAIP,GAAkBlf,KAAKkd,QAAQiC,SAASO,IACxCL,EAAUrf,KAAKkd,QAAQyC,SACvBL,EAAWG,EAAaP,EACxBC,EAAS,EAAIE,EAAUC,CAE3B,OAAO,GAAItf,KAAKuf,eAAeJ,IAUzBhG,EAAAxZ,UAAAqe,UAAR,SAAkB5f,GAChB,MAAI4B,MAAKqZ,gBAAkBjb,YAAaogB,YAClCxe,KAAKwB,OAAOgY,SACPxZ,KAAKwf,kBAA6B,aAAXphB,EAAEwJ,KAAsBxJ,EAAEwhB,eAAe,GAAGC,MAAQzhB,EAAE0hB,QAAQ,GAAGD,OAExF7f,KAAKgf,oBAA+B,aAAX5gB,EAAEwJ,KAAsBxJ,EAAEwhB,eAAe,GAAGG,MAAQ3hB,EAAE0hB,QAAQ,GAAGC,OAG5F3hB,YAAa4hB,YAChBhgB,KAAKwB,OAAOgY,SACPxZ,KAAKwf,kBAAkBphB,EAAEyhB,OAEzB7f,KAAKgf,oBAAoB5gB,EAAE2hB,QAIhCvc,SACFA,QAAQyc,KAAK,iBAER,IAcH9G,EAAAxZ,UAAA4f,eAAR,SAAuBJ,GASrB,MANIA,GAAS,EACXA,EAAS,EACAA,EAAS,IAClBA,EAAS,GAGJA,GAOThG,EAAAxZ,UAAAsa,oBAAA,SAAoBiG,GAClBlgB,KAAKoZ,2BAA6B8G,EAGlClgB,KAAKmgB,YAAYngB,KAAKqd,wBAAyB6C,EAG/C,IAAIE,IAAMpgB,KAAKwB,OAAOgY,SAAWxZ,KAAKkd,QAAQyC,SAAW3f,KAAKkd,QAAQpH,SAAW,IAAMoK,CACnFlgB,MAAKwB,OAAOgY,WACd4G,EAAKpgB,KAAKkd,QAAQyC,SAAWS,EAE/B,IAAIC,GAAQrgB,KAAKwB,OAAOgY,UAEpB8G,UAAa,cAAgBF,EAAK,MAAOG,gBAAiB,cAAgBH,EAAK,QAC/EE,UAAa,cAAgBF,EAAK,MAAOG,gBAAiB,cAAgBH,EAAK,MACnFpgB,MAAKsd,8BAA8B5Q,IAAI2T,IAO/BlH,EAAAxZ,UAAA4b,wBAAV,WACEvb,KAAKia,oBAAoBja,KAAKoZ,6BAOhCD,EAAAxZ,UAAAua,kBAAA,SAAkBgG,GAChBlgB,KAAKmgB,YAAYngB,KAAKod,sBAAuB8C,IAO/C/G,EAAAxZ,UAAA+b,gBAAA,SAAgBwE,GACdlgB,KAAKmgB,YAAYngB,KAAKud,oBAAqB2C,IAQrC/G,EAAAxZ,UAAAwgB,YAAR,SAAoBnV,EAAckV,GAChC,GAAIM,GAAQN,EAAU,IAClBG,EAAQrgB,KAAKwB,OAAOgY,UAEpB8G,UAAa,UAAYE,EAAQ,IAAKD,gBAAiB,UAAYC,EAAQ,MAC3EF,UAAa,UAAYE,EAAQ,IAAKD,gBAAiB,UAAYC,EAAQ,IAC/ExV,GAAQ0B,IAAI2T,IASdlH,EAAAxZ,UAAAob,WAAA,SAAW4C,GACLA,EACF3d,KAAKoI,gBAAgB0E,SAAS9M,KAAKgI,UAAUmR,EAAQsH,gBAErDzgB,KAAKoI,gBAAgB6E,YAAYjN,KAAKgI,UAAUmR,EAAQsH,iBAQ5DtH,EAAAxZ,UAAAqX,UAAA,WACE,MAAOhX,MAAKoI,gBAAgBsY,SAAS1gB,KAAKgI,UAAUmR,EAAQsH,iBAO9DtH,EAAAxZ,UAAAga,SAAA,WACE,MAAqB,OAAd3Z,KAAKwE,OAOd2U,EAAAxZ,UAAAia,SAAA,WACE,MAAO5Z,MAAKwE,OAGJ2U,EAAAxZ,UAAA8e,YAAV,WACEze,KAAKsZ,cAAc5B,OAAOpP,SAAStI,OAG3BmZ,EAAAxZ,UAAAse,mBAAV,SAA6BhD,EAAoBE,GAC/C,GAAI4D,GAAgB/e,KAAKqe,oBAAoBpD,EAEzCjb,MAAKwE,OACPxE,KAAKwE,MAAM4D,gBAAgBsE,KACzB0S,MAASL,EAAgBA,EAAcnC,KAAO3B,GAAc,MAIhEjb,KAAKsZ,cAAcC,cAAcjR,SAAStI,MACxCmb,UAAWA,EACXC,SAAUH,EACV0B,OAAQoC,KAIF5F,EAAAxZ,UAAA2e,cAAV,SAAwBrD,GACtBjb,KAAKsZ,cAAc3B,SAASrP,SAAStI,KAAMib,IAO7C1S,OAAAC,eAAI2Q,EAAAxZ,UAAA,cAAJ,WACE,MAAOK,MAAKsZ,cAAc5B,OAAOjP,4CASnCF,OAAAC,eAAI2Q,EAAAxZ,UAAA,qBAAJ,WACE,MAAOK,MAAKsZ,cAAcC,cAAc9Q,4CAO1CF,OAAAC,eAAI2Q,EAAAxZ,UAAA,gBAAJ,WACE,MAAOK,MAAKsZ,cAAc3B,SAASlP,4CAI3B0Q,EAAAxZ,UAAAuN,YAAV,WACEzN,EAAAE,UAAMuN,YAAW/N,KAAAa,MAOjBA,KAAKub,2BAETpC,GAryB6BjT,EAAAI,UAEJ6S,GAAAyB,0CAA4C,EAK3CzB,EAAAsH,cAAgB,UAP7BvhB,EAAAia,QAAAA,ifCpDb,IAAAlT,GAAArH,EAAA,eACAyC,EAAAzC,EAAA,WACAsH,EAAAtH,EAAA,eAEA0C,EAAA1C,EAAA,YAYA+hB,EAAA,SAAAlhB,GAYE,QAAAkhB,GAAYnf,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAK6gB,UAAY,GAAIvf,GAAAiB,OAAOyJ,YAAa,wBACzChM,EAAK8gB,WAAa,GAAIxf,GAAAiB,OAAOyJ,YAAa,yBAC1ChM,EAAK+gB,aAAe,GAAIzf,GAAAiB,OAAOyJ,YAAa,2BAC5ChM,EAAKghB,YAAc,GAAI1f,GAAAiB,OAAOyJ,YAAa,0BAC3ChM,EAAKihB,YAAc,GAAI3f,GAAAiB,OAAOyJ,YAAa,0BAC3ChM,EAAK+Y,UAAY,GAAI5S,GAAAI,WAAWyF,YAAa,uBAC7ChM,EAAKuT,SAAW,GAAIrN,GAAAmB,WAClBX,YACE,GAAIR,GAAAmB,WACFX,YACE1G,EAAKihB,YACLjhB,EAAK8gB,WACL9gB,EAAKghB,aACPrf,SAAU,iCAEZ,GAAIuE,GAAAmB,WACFX,YACE1G,EAAK+gB,aACL/gB,EAAK6gB,WACPlf,SAAU,oCAGdA,SAAU,2BAGZ3B,EAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,mBACV+E,YAAa,GAAIR,GAAAmB,WACfX,YACE1G,EAAK+Y,UACL/Y,EAAKuT,UAEP5R,SAAU,yBAEZ8E,QAAQ,GACPzG,EAAKyB,UAoHZ,MAtKkC9B,GAAAihB,EAAAlhB,GAqDhCkhB,EAAAhhB,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,GAExBA,EAAUyZ,cAAcvY,UAAU,SAAC0D,EAAQiK,GACzC,GAAI9O,EAAOsV,SAAU,CACnB,GAAIyH,GAAO/c,EAAOwW,kBAAoBxW,EAAOwW,mBAAqB1H,EAAKyM,SAAW,IAClFrb,GAAK8V,QAAQ+G,OACR,CACL,GAAI3B,GAAa,CACjB,IAAItM,EAAKgO,OACP5c,EAAKkhB,aAAatS,EAAKgO,OAAOpJ,OAC9BxT,EAAKmhB,gBAAgBvS,EAAKgO,QAC1B5c,EAAK8V,QAAQlH,EAAKgO,OAAOC,MACzB7c,EAAKohB,aAAa,MAClBphB,EAAKqhB,eAAc,OACd,CACLnG,EAAatM,EAAKyM,SAClBrb,EAAKkhB,aAAa,MAClBlhB,EAAKmhB,gBAAgB,KACrB,IAAItE,GAAO/c,EAAO8V,eAAiBsF,EAAa,IAChDlb,GAAK8V,QAAQ+G,GACb7c,EAAKohB,aAAathB,EAAOwhB,SAASzE,IAClC7c,EAAKqhB,eAAc,MAKzB,IAAIhO,GAAO,WAETrT,EAAKmW,WAAaC,KAAKC,IAAIvW,EAAOsV,SAAWtV,EAAOwW,kBAAoBxW,EAAO8V,gBAAkB,KAC/FrU,EAAAQ,YAAYwU,cAAgBhV,EAAAQ,YAAYyU,YAG5C1W,GAAOS,gBAAgBT,EAAOU,MAAMwE,SAAUqO,GAC9CA,KAOFuN,EAAAhhB,UAAAkC,QAAA,SAAQF,GACN3B,KAAK4gB,UAAU/e,QAAQF,IAOzBgf,EAAAhhB,UAAAkW,QAAA,SAAQyL,GACNthB,KAAK6B,QAAQP,EAAAQ,YAAY6U,cAAc2K,EAASthB,KAAKkW,cAOvDyK,EAAAhhB,UAAAshB,aAAA,SAAatf,GACX3B,KAAK6gB,WAAWhf,QAAQF,IAG1Bgf,EAAAhhB,UAAAuhB,gBAAA,SAAgBvE,GACVA,GACF3c,KAAK8gB,aAAajf,QAAQ8a,EAAOG,SACjC9c,KAAK+gB,YAAYlf,QAAQ8a,EAAOK,QAChChd,KAAKghB,YAAYnf,QAAQ8a,EAAOI,UAEhC/c,KAAK8gB,aAAajf,QAAQ,MAC1B7B,KAAK+gB,YAAYlf,QAAQ,MACzB7B,KAAKghB,YAAYnf,QAAQ,QAQ7B8e,EAAAhhB,UAAAwhB,aAAA,SAAarI,OAAA,KAAAA,IAAAA,EAAA,KACX,IAAIyI,GAAmBvhB,KAAK8Y,UAAU1Q,eAErB,OAAb0Q,EACFyI,EAAiB7U,KACfmM,mBAAoB,KACpB2I,QAAW,OACX1L,MAAS,OACT6J,OAAU,SAIZ4B,EAAiB7U,KACf8U,QAAW,UACX3I,mBAAoB,OAAOC,EAAU/N,IAAG,IACxC+K,MAASgD,EAAU2I,EAAI,KACvB9B,OAAU7G,EAAU4I,EAAI,KACxBC,sBAAuB,IAAI7I,EAAU8I,EAAC,OAAO9I,EAAU+I,EAAC,QAK9DlB,EAAAhhB,UAAAyhB,cAAA,SAAcU,GACZ,GAAIC,GAAkB/hB,KAAKsT,SAASlL,eAEhC0Z,GACFC,EAAgBrV,KACdsV,WAAc,SAIhBD,EAAgBrV,KACdsV,WAAc,aAItBrB,GAtKkC1a,EAAAmB,UAArBlI,GAAAyhB,aAAAA,2dChBb,IAAAsB,GAAArjB,EAAA,kBACAyI,EAAAzI,EAAA,UAaAyG,EAAA,SAAA5F,GAIE,QAAA4F,GAAY7D,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,gBACT3B,EAAKyB,UAsDZ,MA/D+B9B,GAAA2F,EAAA5F,GAYnB4F,EAAA1F,UAAA8H,aAAV,WAAA,GAAA1H,GAAAC,KACMkiB,EAAgB,GAAI7a,GAAAM,IAAI,UAC1BpD,GAAMvE,KAAKwB,OAAO+C,GAClBsD,MAAS7H,KAAK8H,iBAWhB,OARA9H,MAAKkiB,cAAgBA,EACrBliB,KAAKmiB,iBAELD,EAAcha,GAAG,SAAU,WACzB,GAAIvD,GAAQud,EAAcE,KAC1BriB,GAAK0S,oBAAoB9N,GAAO,KAG3Bud,GAGC7c,EAAA1F,UAAAwiB,eAAV,SAAyBE,OAAA,KAAAA,IAAAA,EAAA,MAEvBriB,KAAKkiB,cAAchU,OAGnB,KAAiB,GAAA9J,GAAA,EAAA2J,EAAA/N,KAAK+R,MAAL3N,EAAA2J,EAAA3O,OAAAgF,IAAU,CAAtB,GAAIwO,GAAI7E,EAAA3J,GACPke,EAAgB,GAAIjb,GAAAM,IAAI,UAC1BhD,MAASiO,EAAKX,MACbhK,KAAK2K,EAAKpO,MAEToO,GAAKX,MAAQoQ,EAAgB,IAC/BC,EAAcC,KAAK,WAAY,YAGjCviB,KAAKkiB,cAAcna,OAAOua,KAIpBjd,EAAA1F,UAAA2S,iBAAV,SAA2B3N,GACzBlF,EAAAE,UAAM2S,iBAAgBnT,KAAAa,KAAC2E,GACvB3E,KAAKmiB,eAAeniB,KAAKwS,eAGjBnN,EAAA1F,UAAA4S,mBAAV,SAA6B5N,GAC3BlF,EAAAE,UAAM4S,mBAAkBpT,KAAAa,KAAC2E,GACzB3E,KAAKmiB,eAAeniB,KAAKwS,eAGjBnN,EAAA1F,UAAA8S,oBAAV,SAA8B9N,EAAewd,OAAA,KAAAA,IAAAA,GAAA,GAC3C1iB,EAAAE,UAAM8S,oBAAmBtT,KAAAa,KAAC2E,GACtBwd,GACFniB,KAAKmiB,eAAexd,IAG1BU,GA/D+B4c,EAAAtQ,aAAlBzS,GAAAmG,UAAAA,8bCdb,IAAAY,GAAArH,EAAA,eAEAyC,EAAAzC,EAAA,WAEA4jB,EAAA5jB,EAAA,2BACA6jB,EAAA7jB,EAAA,2BACAuH,EAAAvH,EAAA,cACA0I,EAAA1I,EAAA,sBAiBA8jB,EAAA,SAAAjjB,GAUE,QAAAijB,GAAYlhB,GAAZ,GAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAPPD,GAAA4iB,qBACNC,uBAAwB,GAAItb,GAAAE,iBAQ5BzH,EAAKyB,OAASzB,EAAK0B,YAAiCD,GAClDE,SAAU,oBACVsI,UAAW,KACVjK,EAAKyB,UAyFZ,MAzGmC9B,GAAAgjB,EAAAjjB,GAmBjCijB,EAAA/iB,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAI0B,GAA8BxB,KAAKG,WAEnCqB,GAAOwI,WAAa,IACtBhK,KAAK6iB,YAAc,GAAI1c,GAAAS,QAAQpF,EAAOwI,UAAW,WAC/CjK,EAAKiD,SAGPhD,KAAKyL,OAAOzK,UAAU,WAEpBjB,EAAK8iB,YAAY/b,UAEnB9G,KAAKoI,gBAAgBF,GAAG,YAAa,WAEnCnI,EAAK8iB,YAAYC,UAEnB9iB,KAAK0L,OAAO1K,UAAU,WAEpBjB,EAAK8iB,YAAY7b,UAsBrB,KAAsB,GAjBlB+b,GAA8B,WAChChjB,EAAKijB,6BAIL,KAAsB,GADlBC,GAAgB,KACE7e,EAAA,EAAA2J,EAAAhO,EAAKmjB,WAAL9e,EAAA2J,EAAA3O,OAAAgF,IAAe,CAAhC,GAAIoJ,GAASO,EAAA3J,EACZoJ,aAAqB2V,KACvB3V,EAAUpF,gBAAgB6E,YAAYlN,EAAKiI,UAAU0a,EAAcU,aAC/D5V,EAAUL,YACZ8V,EAAgBzV,IAIlByV,GACFA,EAAc7a,gBAAgB0E,SAAS/M,EAAKiI,UAAU0a,EAAcU,cAGlDhf,EAAA,EAAA2J,EAAA/N,KAAKkjB,WAAL9e,EAAA2J,EAAA3O,OAAAgF,IAAe,CAAhC,GAAIoJ,GAASO,EAAA3J,EACZoJ,aAAqB2V,IACvB3V,EAAU6V,gBAAgBriB,UAAU+hB,KAK1CL,EAAA/iB,UAAAiL,QAAA,WACEnL,EAAAE,UAAMiL,QAAOzL,KAAAa,MACTA,KAAK6iB,aACP7iB,KAAK6iB,YAAY7b,SASrB0b,EAAA/iB,UAAA2jB,kBAAA,WACE,IAAsB,GAAAlf,GAAA,EAAA2J,EAAA/N,KAAKkjB,WAAL9e,EAAA2J,EAAA3O,OAAAgF,IAAe,CACnC,GADgB2J,EAAA3J,GACFmf,WACZ,OAAO,EAIX,OAAO,GAGDb,EAAA/iB,UAAAujB,SAAR,WACE,MAA4BljB,MAAKwB,OAAOiF,YAGhCic,EAAA/iB,UAAAqjB,4BAAV,WACEhjB,KAAK2iB,oBAAoBC,uBAAuBta,SAAStI,OAO3DuI,OAAAC,eAAIka,EAAA/iB,UAAA,8BAAJ,WACE,MAAOK,MAAK2iB,oBAAoBC,uBAAuBna,4CAE3Dia,GAzGmCzc,EAAAmB,UAETsb,GAAAU,WAAa,OAF1BlkB,EAAAwjB,cAAAA,CA+Gb,IAAAS,GAAA,SAAA1jB,GASE,QAAA0jB,GAAY3e,EAAegf,EAAsBhiB,OAAA,KAAAA,IAAAA,KAAjD,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WALPD,GAAA0jB,yBACNJ,gBAAiB,GAAI/b,GAAAE,iBAMrBzH,EAAKyE,MAAQ,GAAInD,GAAAiB,OAAQX,KAAM6C,IAC/BzE,EAAK2jB,QAAUF,EAEfzjB,EAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,yBACV+E,YAAa1G,EAAKyE,MAAOzE,EAAK2jB,UAC7B3jB,EAAKyB,UAqDZ,MAvEuC9B,GAAAyjB,EAAA1jB,GAqBrC0jB,EAAAxjB,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,KACM2jB,EAA0B,WAG5B,GAAIC,GAAoB,GAGpB7jB,EAAK2jB,kBAAmBlB,GAAAqB,uBAAyB9jB,EAAK2jB,kBAAmBjB,GAAA3e,yBAC3E8f,EAAoB,GAIlB7jB,EAAK2jB,QAAQ7Q,YAAc+Q,EAC7B7jB,EAAKiD,OAELjD,EAAKgD,OAKPhD,EAAK+jB,uBAGP9jB,MAAK0jB,QAAQ7R,YAAY7Q,UAAU2iB,GACnC3jB,KAAK0jB,QAAQ5R,cAAc9Q,UAAU2iB,GAGrCA,KAOFR,EAAAxjB,UAAA4jB,SAAA,WACE,MAAOvjB,MAAKmN,WAGJgW,EAAAxjB,UAAAmkB,qBAAV,WACE9jB,KAAKyjB,wBAAwBJ,gBAAgB/a,SAAStI,OAQxDuI,OAAAC,eAAI2a,EAAAxjB,UAAA,uBAAJ,WACE,MAAOK,MAAKyjB,wBAAwBJ,gBAAgB5a,4CAExD0a,GAvEuCld,EAAAmB,UAA1BlI,GAAAikB,kBAAAA,6hBCvIb,IAAA/f,GAAAxE,EAAA,kBAuBAmlB,EAAA,SAAAtkB,GAEE,QAAAskB,GAAYviB,GAAZ,GAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,IAEb,KAAKwB,EAAOwiB,cACV,KAAM,IAAIjlB,OAAM,2CAGlBgB,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,0BACVC,KAAM,WACNqiB,cAAe,KACfC,8BAA8B,GACDlkB,EAAKyB,UAyCxC,MAvD0C9B,GAAAqkB,EAAAtkB,GAiBxCskB,EAAApkB,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAI0B,GAAqCxB,KAAKG,YAC1C6jB,EAAgBxiB,EAAOwiB,aAe3B,IAbAhkB,KAAKe,QAAQC,UAAU,WACrBgjB,EAAc5W,iBAEhB4W,EAAcvY,OAAOzK,UAAU,WAE7BjB,EAAKmI,OAEP8b,EAActY,OAAO1K,UAAU,WAE7BjB,EAAK0J,QAIHjI,EAAOyiB,6BAA8B,CAEvC,GAAIC,GAAmC,WACjCF,EAAcV,oBACZvjB,EAAKiM,YACPjM,EAAKgD,OAGHhD,EAAKoN,WACPpN,EAAKiD,OAKXghB,GAAcpB,uBAAuB5hB,UAAUkjB,GAE/CA,MAGNH,GAvD0C3gB,EAAAQ,aAA7B1E,GAAA6kB,qBAAAA;iDCvBb,IAAA7d,GAAAtH,EAAA,eAKA8P,EAAA,SAAAjP,GAEE,QAAAiP,GAAYlN,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,aACT3B,EAAKyB,UAeZ,MAtB4B9B,GAAAgP,EAAAjP,GAWhBiP,EAAA/O,UAAAuN,YAAV,aAIUwB,EAAA/O,UAAAqN,YAAV,aAIU0B,EAAA/O,UAAAwM,oBAAV,SAA8BmB,KAGhCoB,GAtB4BxI,EAAAI,UAAfpH,GAAAwP,OAAAA,+aCLb,IAAAzI,GAAArH,EAAA,eAGAyC,EAAAzC,EAAA,WAEAulB,EAAAvlB,EAAA,gBAKAwlB,EAAA,SAAA3kB,GAIE,QAAA2kB,GAAY5iB,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,uBACT3B,EAAKyB,UAsDZ,MA/DqC9B,GAAA0kB,EAAA3kB,GAYnC2kB,EAAAzkB,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAIukB,GAAkB,GAAIC,EAE1BzkB,GAAOS,gBAAgBT,EAAOU,MAAMgkB,aAAc,SAAC9jB,GACjD,GAAI+jB,GAAaH,EAAgBI,SAAShkB,EAE1CV,GAAKwN,aAAaiX,GAClBzkB,EAAKiO,mBAELjO,EAAKgD,SAEPlD,EAAOS,gBAAgBT,EAAOU,MAAMmkB,YAAa,SAACjkB,GAChD,GAAIkkB,GAAgBN,EAAgBO,QAAQnkB,EAE5CV,GAAK2N,gBAAgBiX,GACrB5kB,EAAKiO,mBAEAqW,EAAgBQ,SACnB9kB,EAAKiD,QAIT,IAAI8hB,GAAuB,WACzB/kB,EAAKiD,OACLqhB,EAAgBrd,QAChBjH,EAAK+N,mBACL/N,EAAKiO,mBAGPnO,GAAOS,gBAAgBT,EAAOU,MAAMsE,iBAAkBigB,GACtDjlB,EAAOS,gBAAgBT,EAAOU,MAAMwkB,oBAAqBD,GACzDjlB,EAAOS,gBAAgBT,EAAOU,MAAMmK,QAASoa,GAC7CjlB,EAAOS,gBAAgBT,EAAOU,MAAMyV,cAAe8O,GACnDjlB,EAAOS,gBAAgBT,EAAOU,MAAM2W,qBAAsB4N,GAE1DhlB,EAAUmM,gBAAgBjL,UAAU,SAACwM,GAC/BA,YAAqB2W,GAAA7V,YACvBvO,EAAKqI,gBAAgB0E,SAAS/M,EAAKiI,UAAUoc,EAAgBY,6BAGjEllB,EAAUoM,gBAAgBlL,UAAU,SAACwM,GAC/BA,YAAqB2W,GAAA7V,YACvBvO,EAAKqI,gBAAgB6E,YAAYlN,EAAKiI,UAAUoc,EAAgBY,6BAKpEF,KAEJV,GA/DqCne,EAAAmB,UAEXgd,GAAAY,yBAA2B,qBAFxC9lB,EAAAklB,gBAAAA,CA0Eb,IAAAa,GAAA,SAAAxlB,GAEE,QAAAwlB,GAAYzjB,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,qBACT3B,EAAKyB,UAEZ,MAT4B9B,GAAAulB,EAAAxlB,GAS5BwlB,GAT4B5jB,EAAAiB,OAW5BgiB,EAAA,WAIE,QAAAA,KACEtkB,KAAKklB,wBAqET,MAxDiBZ,GAAAa,YAAf,SAA2B1kB,GACzB,MAAOA,GAAMqG,MAAQrG,EAAMkB,MAQ7B2iB,EAAA3kB,UAAA8kB,SAAA,SAAShkB,GACP,GAAI8D,GAAK+f,EAAsBa,YAAY1kB,GAEvC+D,EAAQ,GAAIygB,IAEdtjB,KAAMlB,EAAMwH,MAAQxH,EAAMkB,MAK5B,OAFA3B,MAAKklB,qBAAqB3gB,IAAQ9D,MAAKA,EAAE+D,MAAKA,GAEvCA,GAQT8f,EAAA3kB,UAAAilB,QAAA,SAAQnkB,GACN,GAAI8D,GAAK+f,EAAsBa,YAAY1kB,GACvC2kB,EAAoBplB,KAAKklB,qBAAqB3gB,EAElD,cADOvE,MAAKklB,qBAAqB3gB,GAC1B6gB,EAAkB5gB,OAO3B+D,OAAAC,eAAI8b,EAAA3kB,UAAA,gBAAJ,WACE,MAAO4I,QAAOuK,KAAK9S,KAAKklB,sBAAsB9lB,wCAOhDmJ,OAAAC,eAAI8b,EAAA3kB,UAAA,eAAJ,WACE,MAAOK,MAAKqlB,SAAW,mCAMzBf,EAAA3kB,UAAAqH,MAAA,WACEhH,KAAKklB,yBAETZ,idCzKA,IAAAzgB,GAAAjF,EAAA,eAUA0mB,EAAA,SAAA7lB,GAEE,QAAA6lB,GAAY9jB,cAAA,KAAAA,IAAAA,MACV/B,EAAAN,KAAAa,KAAMwB,IAAOxB,KAsDjB,MAzDuCN,GAAA4lB,EAAA7lB,GAMrC6lB,EAAA3lB,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAI8Z,GAAW,SAACrV,GACd,OAAQA,GACN,IAAK,MACH,MAAO,KACT,KAAK,KACH,MAAO,SACT,KAAK,KACH,MAAO,UACT,KAAK,KACH,MAAO,SACT,KAAK,KACH,MAAO,UACT,SACE,MAAOA,KAITghB,EAAkB,WACpBxlB,EAAKmE,YAEL,KAAqB,GAAAE,GAAA,EAAA2J,EAAAlO,EAAO2lB,wBAAPphB,EAAA2J,EAAA3O,OAAAgF,IAA8B,CAA9C,GAAIqhB,GAAQ1X,EAAA3J,EACfrE,GAAKoE,QAAQshB,EAASlhB,GAAIqV,EAAS6L,EAASjhB,SAIhDxE,MAAKyE,eAAezD,UAAU,SAAC0D,EAA2BC,GACxD9E,EAAO6lB,YAAsB,SAAV/gB,EAAmB,KAAOA,KAI/C9E,EAAOS,gBAAgBT,EAAOU,MAAMolB,kBAAmB,SAACllB,GACtDV,EAAKoE,QAAQ1D,EAAMglB,SAASlhB,GAAI9D,EAAMglB,SAASjhB,SAEjD3E,EAAOS,gBAAgBT,EAAOU,MAAMwkB,oBAAqB,SAACtkB,GACxDV,EAAKoF,WAAW1E,EAAMmlB,eAAerhB,MAEvC1E,EAAOS,gBAAgBT,EAAOU,MAAMslB,oBAAqB,SAACplB,GACxDV,EAAKsS,WAAW5R,EAAMqlB,cAIxBjmB,EAAOS,gBAAgBT,EAAOU,MAAMuE,mBAAoBygB,GAExD1lB,EAAOS,gBAAgBT,EAAOU,MAAMwE,SAAUwgB,GAG9CA,KAEJD,GAzDuCzhB,EAAAwB,UAA1BnG,GAAAomB,kBAAAA,+aCVb,IAAArf,GAAArH,EAAA,eAEAmnB,EAAAnnB,EAAA,mBAiBAonB,EAAA,SAAAvmB,GAEE,QAAAumB,GAAYxkB,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,cACV8E,QAAQ,EACRC,YACE,GAAIsf,GAAA/S,eAAgBC,QAAS8S,EAAAhT,qBAAqBM,QAClD,GAAI0S,GAAA/S,eAAgBC,QAAS8S,EAAAhT,qBAAqBU,eAEpDwS,2BAA2B,GACVlmB,EAAKyB,UAuD5B,MApE8B9B,GAAAsmB,EAAAvmB,GAgB5BumB,EAAArmB,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EA+BxB,KAAsB,GA7BlB0B,GAAyBxB,KAAKG,YAC9B+lB,GAAiBlmB,KAAKgM,WACtBma,GAAkB,EAElBC,EAAuC,WACzCD,GAAkB,CAGlB,KAAsB,GAAA/hB,GAAA,EAAA2J,EAAAhO,EAAK8N,gBAALzJ,EAAA2J,EAAA3O,OAAAgF,IAAoB,CAArC,GAAIoJ,GAASO,EAAA3J,EAChB,IAAIoJ,YAAqBuY,GAAA/S,gBAClBxF,EAAUkE,UAAW,CACxByU,GAAkB,CAClB,QAKFpmB,EAAKoN,UAEH3L,EAAOykB,4BAA8BE,GACvCpmB,EAAKiD,OAEEkjB,GAETnmB,EAAKgD,QAKaqB,EAAA,EAAA2J,EAAA/N,KAAK6N,gBAALzJ,EAAA2J,EAAA3O,OAAAgF,IAAoB,CAArC,GAAIoJ,GAASO,EAAA3J,EACZoJ,aAAqBuY,GAAA/S,eACvBxF,EAAU6D,cAAcrQ,UAAUolB,GAItCtmB,EAAUoK,eAAelJ,UAAU,WACjCklB,GAAgB,EACV1kB,EAAOykB,4BAA8BE,GACzCpmB,EAAKgD,SAGTjD,EAAUgK,eAAe9I,UAAU,WACjCklB,GAAgB,EAChBnmB,EAAKiD,SAIPojB,KAEJJ,GApE8B/f,EAAAmB,UAAjBlI,GAAA8mB,SAAAA,ocCnBb,IAAAzjB,GAAA3D,EAAA,YACA0I,EAAA1I,EAAA,sBAeAgF,EAAA,SAAAnE,GAaE,QAAAmE,GAAYpC,GAAZ,GAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAPPD,GAAAsmB,oBACNC,SAAU,GAAIhf,GAAAE,gBACd+e,WAAY,GAAIjf,GAAAE,gBAChBgf,YAAa,GAAIlf,GAAAE,iBAMjBzH,EAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,mBACT3B,EAAKyB,UAqGZ,MAvHqE9B,GAAAkE,EAAAnE,GAwBnEmE,EAAAjE,UAAAuI,GAAA,WACMlI,KAAKymB,UACPzmB,KAAK0mB,SAAU,EACf1mB,KAAKoI,gBAAgB6E,YAAYjN,KAAKgI,UAAUpE,EAAa+iB,YAC7D3mB,KAAKoI,gBAAgB0E,SAAS9M,KAAKgI,UAAUpE,EAAagjB,WAE1D5mB,KAAK6mB,gBACL7mB,KAAK8mB,oBAOTljB,EAAAjE,UAAA8J,IAAA,WACMzJ,KAAK+mB,SACP/mB,KAAK0mB,SAAU,EACf1mB,KAAKoI,gBAAgB6E,YAAYjN,KAAKgI,UAAUpE,EAAagjB,WAC7D5mB,KAAKoI,gBAAgB0E,SAAS9M,KAAKgI,UAAUpE,EAAa+iB,YAE1D3mB,KAAK6mB,gBACL7mB,KAAKgnB,qBAOTpjB,EAAAjE,UAAAsnB,OAAA,WACMjnB,KAAK+mB,OACP/mB,KAAKyJ,MAELzJ,KAAKkI,MAQTtE,EAAAjE,UAAAonB,KAAA,WACE,MAAO/mB,MAAK0mB,SAOd9iB,EAAAjE,UAAA8mB,MAAA,WACE,OAAQzmB,KAAK+mB,QAGLnjB,EAAAjE,UAAAwI,aAAV,WACE1I,EAAAE,UAAMwI,aAAYhJ,KAAAa,MAIlBA,KAAK6mB,iBAGGjjB,EAAAjE,UAAAknB,cAAV,WACE7mB,KAAKqmB,mBAAmBC,SAAShe,SAAStI,OAGlC4D,EAAAjE,UAAAmnB,gBAAV,WACE9mB,KAAKqmB,mBAAmBE,WAAWje,SAAStI,OAGpC4D,EAAAjE,UAAAqnB,iBAAV,WACEhnB,KAAKqmB,mBAAmBG,YAAYle,SAAStI,OAO/CuI,OAAAC,eAAI5E,EAAAjE,UAAA,gBAAJ,WACE,MAAOK,MAAKqmB,mBAAmBC,SAAS7d,4CAO1CF,OAAAC,eAAI5E,EAAAjE,UAAA,kBAAJ,WACE,MAAOK,MAAKqmB,mBAAmBE,WAAW9d,4CAO5CF,OAAAC,eAAI5E,EAAAjE,UAAA,mBAAJ,WACE,MAAOK,MAAKqmB,mBAAmBG,YAAY/d,4CAE/C7E,GAvHqErB,EAAAY,OAE3CS,GAAAgjB,SAAW,KACXhjB,EAAA+iB,UAAY,MAHzBznB,EAAA0E,aAAAA,mcChBb,IAAAsC,GAAAtH,EAAA,eACAyI,EAAAzI,EAAA,UAKA4Q,EAAA,SAAA/P,GAeE,QAAA+P,GAAYhO,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAVPD,GAAAmnB,YAAc,IACdnnB,EAAAonB,aAAe,GACfpnB,EAAAqnB,mBAAqB,GACrBrnB,EAAAsnB,gBAA0B,EAC1BtnB,EAAAunB,cAAwB,GACxBvnB,EAAAwnB,oBAA+Btc,OAAOuc,sBAO5CznB,EAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,oBACT3B,EAAKyB,UA4EZ,MAhGmC9B,GAAA8P,EAAA/P,GAuBvB+P,EAAA7P,UAAA8H,aAAV,WACE,MAAOzH,MAAKynB,OAAS,GAAIpgB,GAAAM,IAAI,UAAYE,MAAS7H,KAAK8H,mBAGzD0H,EAAA7P,UAAAmH,MAAA,WACE9G,KAAK0nB,cAAmC1nB,KAAKynB,OAAOE,cAAc,GAClE3nB,KAAK4nB,cAAgB5nB,KAAK0nB,cAAcG,WAAW,MACnD7nB,KAAK8nB,yBAA2B9nB,KAAKmnB,aACrCnnB,KAAKqnB,gBAAkB,EAEvBrnB,KAAK0nB,cAAc5R,MAAQ9V,KAAKknB,YAChClnB,KAAK0nB,cAAc/H,OAAS3f,KAAKmnB,aAEjCnnB,KAAK+nB,eAGPvY,EAAA7P,UAAAkQ,KAAA,WACM7P,KAAKunB,kBACPS,qBAAqBhoB,KAAKioB,sBAE1BC,aAAaloB,KAAKioB,uBAIdzY,EAAA7P,UAAAooB,YAAR,WAGE,GAAI/nB,KAAKqnB,gBAAkBrnB,KAAKsnB,eAAgB,GAAIxW,OAAOqX,UAGzD,WADAnoB,MAAKooB,oBAYP,KAAK,GARDC,GACAnB,EAAclnB,KAAKknB,YACnBC,EAAennB,KAAKmnB,aAGpBmB,EAAatoB,KAAK4nB,cAAcW,gBAAgBrB,EAAaC,GAGxDtF,EAAI,EAAGA,EAAIsF,EAActF,IAChC,IAAK,GAAID,GAAI,EAAGA,EAAIsF,EAAatF,IAC/ByG,EAAsBnB,EAAcrF,EAAI,EAAS,EAAJD,EAC7C0G,EAAWrjB,KAAKojB,GAAsC,IAAhBlS,KAAKqS,UACvC3G,EAAI7hB,KAAK8nB,yBAA2BjG,EAAI7hB,KAAK8nB,wBAA0B9nB,KAAKonB,sBAC9EkB,EAAWrjB,KAAKojB,IAAuB,KAEzCC,EAAWrjB,KAAKojB,EAAqB,GAAKC,EAAWrjB,KAAKojB,GAC1DC,EAAWrjB,KAAKojB,EAAqB,GAAKC,EAAWrjB,KAAKojB,GAC1DC,EAAWrjB,KAAKojB,EAAqB,GAAK,EAK9CroB,MAAK4nB,cAAca,aAAaH,EAAY,EAAG,GAE/CtoB,KAAKqnB,iBAAkB,GAAIvW,OAAOqX,UAClCnoB,KAAK8nB,yBAA2B,EAC5B9nB,KAAK8nB,wBAA0BX,IACjCnnB,KAAK8nB,yBAA2BX,GAGlCnnB,KAAKooB,sBAGC5Y,EAAA7P,UAAAyoB,mBAAR,WACMpoB,KAAKunB,kBACPvnB,KAAKioB,qBAAuBhd,OAAOuc,sBAAsBxnB,KAAK+nB,YAAYW,KAAK1oB,OAE/EA,KAAKioB,qBAAuBlX,WAAW/Q,KAAK+nB,YAAYW,KAAK1oB,MAAOA,KAAKsnB,gBAG/E9X,GAhGmCtJ,EAAAI,UAAtBpH,GAAAsQ,cAAAA,2bCNb,IAAAvJ,GAAArH,EAAA,eAEAyI,EAAAzI,EAAA,UACAuH,EAAAvH,EAAA,cACA0C,EAAA1C,EAAA,YAmBAiM,EAAA,SAAApL,GAYE,QAAAoL,GAAYrJ,GAAZ,GAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,iBACVsI,UAAW,KACVjK,EAAKyB,UAuOZ,MAzPiC9B,GAAAmL,EAAApL,GAqB/BoL,EAAAlL,UAAAC,UAAA,SAAUC,EAAgCC,GACxCL,EAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,GAExBE,KAAK2oB,oBAAoB9oB,EAAQC,GACjCE,KAAK4oB,sBAAsB/oB,EAAQC,IAG7B+K,EAAAlL,UAAAgpB,oBAAR,SAA4B9oB,EAAgCC,GAA5D,GAAAC,GAAAC,KACM6oB,EAAY7oB,KAAKoI,gBACjB5G,EAA4BxB,KAAKG,YAEjCyJ,GAAY,EACZoN,GAAY,EACZ8R,GAAe,EAEf7e,EAAS,WACNL,IAEH9J,EAAUoK,eAAe5B,SAASvI,GAClC6J,GAAY,GAGToN,GAAcnX,EAAOuJ,aACxBrJ,EAAKgpB,cAAcjiB,SAInB+C,EAAS,WAEX,GAAID,IAAc/J,EAAOuJ,YAAa,CAEpC,GAAI4f,KACJlpB,GAAU8O,sBAAsBtG,SAASvI,EAAMipB,GAE1CA,EAAqBna,OAMxB5E,KAJAnK,EAAUgK,eAAexB,SAASvI,GAClC6J,GAAY,IASlB5J,MAAK+oB,cAAgB,GAAI5iB,GAAAS,QAAQpF,EAAOwI,UAAWH,GAGnDgf,EAAU3gB,GAAG,WAAY,SAAC9J,GACnBwL,IAKCkf,EACFA,GAAe,EAEf1qB,EAAEyf,iBAEJ5T,OAIJ4e,EAAU3gB,GAAG,aAAc,WACzB+B,MAGF4e,EAAU3gB,GAAG,YAAa,WACxB+B,MAGF4e,EAAU3gB,GAAG,aAAc,WAGpB8O,GACHjX,EAAKgpB,cAAcjiB,UAIvBhH,EAAU4X,OAAO1W,UAAU,WACzBjB,EAAKgpB,cAAc/hB,QACnBgQ,GAAY,IAEdlX,EAAU6X,SAAS3W,UAAU,WAC3BgW,GAAY,EACZjX,EAAKgpB,cAAcjiB,UAErBjH,EAAOS,gBAAgBT,EAAOU,MAAMyI,gBAAiB,WACnDiB,OAIIY,EAAAlL,UAAAipB,sBAAR,SAA8B/oB,EAAgCC,GAA9D,GAAAC,GAAAC,KACM6oB,EAAY7oB,KAAKoI,gBAGjB6gB,IACJ,KAAK,GAAIC,KAAS5nB,GAAAgU,YAAY6T,YAC5B,GAAIC,MAAM3O,OAAOyO,IAAS,CACxB,GAAIG,GAAW/nB,EAAAgU,YAAY6T,YAAiB7nB,EAAAgU,YAAY6T,YAAYD,GACpED,GAAgB3nB,EAAAgU,YAAY6T,YAAYD,IACtClpB,KAAKgI,UAAU6C,EAAYye,aAAeD,EAASnW,eAIzD,GAAIqW,GAAe,WACjBV,EAAU5b,YAAYgc,EAAgB3nB,EAAAgU,YAAY6T,YAAYK,OAC9DX,EAAU5b,YAAYgc,EAAgB3nB,EAAAgU,YAAY6T,YAAYM,WAC9DZ,EAAU5b,YAAYgc,EAAgB3nB,EAAAgU,YAAY6T,YAAYO,UAC9Db,EAAU5b,YAAYgc,EAAgB3nB,EAAAgU,YAAY6T,YAAYQ,SAC9Dd,EAAU5b,YAAYgc,EAAgB3nB,EAAAgU,YAAY6T,YAAYS,WAEhE/pB,GAAOS,gBAAgBT,EAAOU,MAAMwE,SAAU,WAC5CwkB,IACAV,EAAU/b,SAASmc,EAAgB3nB,EAAAgU,YAAY6T,YAAYM,aAE7D5pB,EAAOS,gBAAgBT,EAAOU,MAAMiK,QAAS,WAC3C+e,IACAV,EAAU/b,SAASmc,EAAgB3nB,EAAAgU,YAAY6T,YAAYO,YAE7D7pB,EAAOS,gBAAgBT,EAAOU,MAAMkK,UAAW,WAC7C8e,IACAV,EAAU/b,SAASmc,EAAgB3nB,EAAAgU,YAAY6T,YAAYQ,WAE7D9pB,EAAOS,gBAAgBT,EAAOU,MAAM2W,qBAAsB,WACxDqS,IACAV,EAAU/b,SAASmc,EAAgB3nB,EAAAgU,YAAY6T,YAAYS,aAE7D/pB,EAAOS,gBAAgBT,EAAOU,MAAMuE,mBAAoB,WACtDykB,IACAV,EAAU/b,SAASmc,EAAgB3nB,EAAAgU,YAAY6T,YAAYK,SAG7DX,EAAU/b,SAASmc,EAAgB3nB,EAAAgU,YAAYuU,SAAShqB,KAGxDA,EAAOS,gBAAgBT,EAAOU,MAAM0P,oBAAqB,WACvD4Y,EAAU/b,SAAS/M,EAAKiI,UAAU6C,EAAYif,eAEhDjqB,EAAOS,gBAAgBT,EAAOU,MAAM2P,mBAAoB,WACtD2Y,EAAU5b,YAAYlN,EAAKiI,UAAU6C,EAAYif,eAG/CjqB,EAAOmQ,gBACT6Y,EAAU/b,SAAS9M,KAAKgI,UAAU6C,EAAYif,aAIhDjqB,EAAOS,gBAAgBT,EAAOU,MAAM0G,iBAAkB,WACpD4hB,EAAU/b,SAAS/M,EAAKiI,UAAU6C,EAAYkf,cAEhDlqB,EAAOS,gBAAgBT,EAAOU,MAAM2G,eAAgB,WAClD2hB,EAAU5b,YAAYlN,EAAKiI,UAAU6C,EAAYkf,cAG/ClqB,EAAOsH,aACT0hB,EAAU/b,SAAS9M,KAAKgI,UAAU6C,EAAYkf,YAIhDlqB,EAAOS,gBAAgBT,EAAOU,MAAMyI,gBAAiB,WACnD6f,EAAU/b,SAAS/M,EAAKiI,UAAU6C,EAAYmf,mBAEhDnqB,EAAOS,gBAAgBT,EAAOU,MAAM0I,gBAAiB,WACnD4f,EAAU5b,YAAYlN,EAAKiI,UAAU6C,EAAYmf,mBAG/CnqB,EAAOuJ,aACTyf,EAAU/b,SAAS9M,KAAKgI,UAAU6C,EAAYmf,iBAIhDlqB,EAAUoK,eAAelJ,UAAU,WACjC6nB,EAAU5b,YAAYlN,EAAKiI,UAAU6C,EAAYof,kBACjDpB,EAAU/b,SAAS/M,EAAKiI,UAAU6C,EAAYqf,mBAEhDpqB,EAAUgK,eAAe9I,UAAU,WACjC6nB,EAAU5b,YAAYlN,EAAKiI,UAAU6C,EAAYqf,iBACjDrB,EAAU/b,SAAS/M,EAAKiI,UAAU6C,EAAYof,mBAIhD,IAAIE,GAA0B,SAACrU,EAAe6J,GAC5CkJ,EAAU5b,YAAYlN,EAAKiI,UAAU,yBACrC6gB,EAAU5b,YAAYlN,EAAKiI,UAAU,yBACrC6gB,EAAU5b,YAAYlN,EAAKiI,UAAU,yBACrC6gB,EAAU5b,YAAYlN,EAAKiI,UAAU,0BAEjC8N,GAAS,IACX+S,EAAU/b,SAAS/M,EAAKiI,UAAU,yBACzB8N,GAAS,IAClB+S,EAAU/b,SAAS/M,EAAKiI,UAAU,yBACzB8N,GAAS,IAClB+S,EAAU/b,SAAS/M,EAAKiI,UAAU,yBACzB8N,GAAS,MAClB+S,EAAU/b,SAAS/M,EAAKiI,UAAU,0BAGtCnI,GAAOS,gBAAgBT,EAAOU,MAAMib,iBAAkB,SAACpd,GAErD,GAAI0X,GAAQK,KAAKiU,MAAM3P,OAAOrc,EAAE0X,MAAMuU,UAAU,EAAGjsB,EAAE0X,MAAM1W,OAAS,IACvD+W,MAAKiU,MAAM3P,OAAOrc,EAAEuhB,OAAO0K,UAAU,EAAGjsB,EAAEuhB,OAAOvgB,OAAS,IAEvE+qB,GAAwBrU,KAI1BqU,EAAwB,GAAI9iB,GAAAM,IAAI9H,EAAOyqB,aAAaxU,QAAS,GAAIzO,GAAAM,IAAI9H,EAAOyqB,aAAa3K,WAG3F9U,EAAAlL,UAAAiL,QAAA,WACEnL,EAAAE,UAAMiL,QAAOzL,KAAAa,MACbA,KAAK+oB,cAAc/hB,SAGX6D,EAAAlL,UAAA8H,aAAV,WACE,GAAIohB,GAAYppB,EAAAE,UAAM8H,aAAYtI,KAAAa,KASlC,OANIme,eAA8D,KAA3CA,SAASoM,cAAc,KAAKlK,MAAMmK,KACvD3B,EAAU/b,SAAS9M,KAAKgI,UAAU,YAElC6gB,EAAU/b,SAAS9M,KAAKgI,UAAU,eAG7B6gB,GAEXhe,GAzPiC5E,EAAAmB,UAEPyD,GAAAye,aAAe,gBAEfze,EAAAif,WAAa,aACbjf,EAAAkf,UAAY,YACZlf,EAAAmf,eAAiB,iBACjBnf,EAAAqf,eAAiB,iBACjBrf,EAAAof,gBAAkB,kBAR/B/qB,EAAA2L,YAAAA,ydCvBb,IAAAhH,GAAAjF,EAAA,eAOAilB,EAAA,SAAApkB,GAEE,QAAAokB,GAAYriB,cAAA,KAAAA,IAAAA,MACV/B,EAAAN,KAAAa,KAAMwB,IAAOxB,KAqCjB,MAxC2CN,GAAAmkB,EAAApkB,GAMzCokB,EAAAlkB,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAI2qB,GAAuB,WACzB,GAAIC,GAAiB7qB,EAAO8qB,4BAE5B5qB,GAAKmE,aAGLnE,EAAKoE,QAAQ,OAAQ,OAGrB,KAAyB,GAAAC,GAAA,EAAAwmB,EAAAF,EAAAtmB,EAAAwmB,EAAAxrB,OAAAgF,IAAc,CAAlC,GAAIymB,GAAYD,EAAAxmB,EACnBrE,GAAKoE,QAAQ0mB,EAAatmB,GAAIsmB,EAAarmB,QAI/CxE,MAAKyE,eAAezD,UAAU,SAAC0D,EAA+BC,GAC5D9E,EAAOirB,gBAAgBnmB,KAIzB9E,EAAOS,gBAAgBT,EAAOU,MAAMuE,mBAAoB2lB,GAExD5qB,EAAOS,gBAAgBT,EAAOU,MAAMwE,SAAU0lB,GAE9C5qB,EAAOS,gBAAgBT,EAAOU,MAAMwqB,iCAAkC,WACpE,GAAI9lB,GAAOpF,EAAOmrB,wBAClBjrB,GAAKoF,WAAWF,EAAKG,OAAS,OAASH,EAAKV,MAI9CkmB,KAEJ5G,GAxC2ChgB,EAAAwB,UAA9BnG,GAAA2kB,sBAAAA,+aCPb,IAAA5d,GAAArH,EAAA,eACAqsB,EAAArsB,EAAA,kBACAssB,EAAAtsB,EAAA,wBAEAuH,EAAAvH,EAAA,cAyBAusB,EAAA,SAAA1rB,GAOE,QAAA0rB,GAAY3pB,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKqrB,mBAAqB,GAAIF,GAAAG,mBAC9BtrB,EAAKurB,aAAe,GAAIL,GAAAM,cACtB/R,SAA6B,MAAnBhY,EAAOgY,UAAmBhY,EAAOgY,SAC3ChT,QAAQ,IAGVzG,EAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,yBACV+E,YAAa1G,EAAKqrB,mBAAoBrrB,EAAKurB,cAC3CthB,UAAW,KACiBjK,EAAKyB,UA2EvC,MA/FyC9B,GAAAyrB,EAAA1rB,GAuBvC0rB,EAAAxrB,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAIsrB,GAAqBprB,KAAKwrB,wBAC1BF,EAAetrB,KAAKyrB,iBAExBzrB,MAAK0rB,wBAA0B,GAAIvlB,GAAAS,QAAoC5G,KAAKG,YAAa6J,UAAW,WAClGshB,EAAatoB,QAUf,IAAI2oB,IAAsB,CAC1BP,GAAmBhjB,gBAAgBF,GAAG,aAAc,WAE9CojB,EAAatf,YACfsf,EAAavoB,OAGfhD,EAAK2rB,wBAAwB1kB,UAE/BokB,EAAmBhjB,gBAAgBF,GAAG,aAAc,WAElDnI,EAAK2rB,wBAAwB5I,UAE/BwI,EAAaljB,gBAAgBF,GAAG,aAAc,WAE5CnI,EAAK2rB,wBAAwB1kB,QAC7B2kB,GAAsB,IAExBL,EAAaljB,gBAAgBF,GAAG,aAAc,WAExCojB,EAAatU,YACfjX,EAAK2rB,wBAAwB1kB,QAE7BjH,EAAK2rB,wBAAwB5I,QAE/B6I,GAAsB,IAExBL,EAAa3T,SAAS3W,UAAU,WAEzB2qB,GACH5rB,EAAK2rB,wBAAwB5I,WAKnCqI,EAAAxrB,UAAAiL,QAAA,WACEnL,EAAAE,UAAMiL,QAAOzL,KAAAa,MACbA,KAAK0rB,wBAAwB1kB,SAO/BmkB,EAAAxrB,UAAA6rB,sBAAA,WACE,MAAOxrB,MAAKorB,oBAOdD,EAAAxrB,UAAA8rB,gBAAA,WACE,MAAOzrB,MAAKsrB,cAEhBH,GA/FyCllB,EAAAmB,UAA5BlI,GAAAisB,oBAAAA,6eC7Bb,IAAAS,GAAAhtB,EAAA,aAkBA2sB,EAAA,SAAA9rB,GAEE,QAAA8rB,GAAY/pB,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,kBACVmqB,+BAA+B,GAC9B9rB,EAAKyB,UAiGZ,MAzGkC9B,GAAA6rB,EAAA9rB,GAWhC8rB,EAAA5rB,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IAKE,IAJAP,EAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,GAAW,GAEFE,KAAKG,YAE3B0rB,gCAAkC7rB,KAAK8rB,gCAAgCjsB,GAKhF,WAJAG,MAAKgD,MAOP,IAAI+oB,GAAsB,WACpBlsB,EAAOmsB,WACTjsB,EAAKka,oBAAoB,GACzBla,EAAKma,kBAAkB,KAEvBna,EAAKka,oBAAoBpa,EAAOosB,aAEhClsB,EAAKma,kBAAkBra,EAAOosB,cAIlCpsB,GAAOS,gBAAgBT,EAAOU,MAAMwE,SAAUgnB,GAC9ClsB,EAAOS,gBAAgBT,EAAOU,MAAM2rB,kBAAmBH,GACvDlsB,EAAOS,gBAAgBT,EAAOU,MAAM4rB,SAAUJ,GAC9ClsB,EAAOS,gBAAgBT,EAAOU,MAAM6rB,WAAYL,GAEhD/rB,KAAKuZ,cAAcvY,UAAU,SAAC0D,EAAQiK,GAChCA,EAAKwM,WACPtb,EAAOwsB,UAAU1d,EAAKyM,YAG1Bpb,KAAK2X,SAAS3W,UAAU,SAAC0D,EAAQuW,GAC/Bpb,EAAOwsB,UAAUpR,KAKnBpb,EAAOS,gBAAgBT,EAAOU,MAAMib,iBAAkB,WACpDzb,EAAKwb,4BAEP1b,EAAOS,gBAAgBT,EAAOU,MAAMwE,SAAU,WAC5ChF,EAAKwb,4BAEPzb,EAAU2b,aAAaza,UAAU,WAC/BjB,EAAKwb,4BAIPwQ,KAGMR,EAAA5rB,UAAAmsB,gCAAR,SAAwCjsB,GAEtC,GAAIysB,GAASzsB,EAAOosB,YAChBM,EAAQ1sB,EAAOmsB,UACfQ,EAAU3sB,EAAOyK,WAWrB,OAAe,OAAXgiB,IAEFzsB,EAAOwsB,UAAU,GAEU,MAAvBxsB,EAAOosB,cAKTpsB,EAAOwsB,UAAUC,GACbC,GACF1sB,EAAO4sB,OAELD,GAGF3sB,EAAO2Q,QAEF,KAOf+a,GAzGkCK,EAAAzS,QAArBja,GAAAqsB,aAAAA,6aClBb,IAAAnoB,GAAAxE,EAAA,kBAMAysB,EAAA,SAAA5rB,GAEE,QAAA4rB,GAAY7pB,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,wBACVC,KAAM,eACL5B,EAAKyB,UAuCZ,MA/CwC9B,GAAA2rB,EAAA5rB,GAWtC4rB,EAAA1rB,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAI4sB,GAAmB,WACjB7sB,EAAOmsB,UACTjsB,EAAKmI,KAELnI,EAAK0J,OAILkjB,EAAqB,WAEnB9sB,EAAOosB,YAAc,GACvBlsB,EAAKqI,gBAAgB0E,SAAS/M,EAAKiI,UAAU,QAE7CjI,EAAKqI,gBAAgB6E,YAAYlN,EAAKiI,UAAU,QAIpDnI,GAAOS,gBAAgBT,EAAOU,MAAM4rB,SAAUO,GAC9C7sB,EAAOS,gBAAgBT,EAAOU,MAAM6rB,WAAYM,GAChD7sB,EAAOS,gBAAgBT,EAAOU,MAAM2rB,kBAAmBS,GAEvD3sB,KAAKe,QAAQC,UAAU,WACjBnB,EAAOmsB,UACTnsB,EAAO+sB,SAEP/sB,EAAO4sB,SAKXC,IACAC,KAEJtB,GA/CwCjoB,EAAAQ,aAA3B1E,GAAAmsB,mBAAAA,kbCNb,IAAAjoB,GAAAxE,EAAA,kBAMAiuB,EAAA,SAAAptB,GAEE,QAAAotB,GAAYrrB,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,oBACVC,KAAM,MACL5B,EAAKyB,UAkEZ,MA1EoC9B,GAAAmtB,EAAAptB,GAWlCotB,EAAAltB,UAAAC,UAAA,SAAUC,EAAgCC,GAA1C,GAAAC,GAAAC,IACEP,GAAAE,UAAMC,UAAST,KAAAa,KAACH,EAAQC,EAExB,IAAIgtB,GAAiB,WAKnB,GAAItrB,GAAS3B,EAAOM,WACpB,OAAOqB,GAAOgS,QAAUhS,EAAOgS,OAAOuZ,IAAuC,SAAjCvrB,EAAOgS,OAAOuZ,GAAGC,aAG3DC,EAAsB,WACxB,MAA4C,SAArCptB,EAAOqtB,cAAcF,aAG1BG,EAAiB,WACfL,KAAoBG,KACtBltB,EAAKgD,OAEDlD,EAAOqtB,cAAcE,SACvBrtB,EAAKmI,KAELnI,EAAK0J,OAGP1J,EAAKiD,QAILqqB,EAA4B,WAC1BP,IACF/sB,EAAKgD,OAELhD,EAAKiD,OAITnD,GAAOS,gBAAgBT,EAAOU,MAAM+sB,mBAAoBH,GACxDttB,EAAOS,gBAAgBT,EAAOU,MAAMgtB,qBAAsBJ,GAC1DttB,EAAOS,gBAAgBT,EAAOU,MAAMitB,YAAaL,GAEjDttB,EAAOS,gBAAgBT,EAAOU,MAAMuE,mBAAoBuoB,GAExDxtB,EAAOS,gBAAgBT,EAAOU,MAAMwE,SAAUsoB,GAE9CrtB,KAAKe,QAAQC,UAAU,WAChBisB,IAKCptB,EAAOqtB,cAAcE,SACvBvtB,EAAO4tB,aAAY,GAEnB5tB,EAAO4tB,aAAY,GAPjBjqB,SACFA,QAAQC,IAAI,mBAYlB4pB,KAEJR,GA1EoCzpB,EAAAQ,aAAvB1E,GAAA2tB,eAAAA,kbCNb,IAAAttB,GAAAX,EAAA,kBAYA8uB,EAAA,SAAAjuB,GAEE,QAAAiuB,GAAYlsB,OAAA,KAAAA,IAAAA,KAAZ,IAAAzB,GACEN,EAAAN,KAAAa,KAAMwB,IAAOxB,WAEbD,GAAKyB,OAASzB,EAAK0B,YAAYD,GAC7BE,SAAU,eACVqJ,IAAK,uBACahL,EAAKyB,UAE7B,MAV+B9B,GAAAguB,EAAAjuB,GAU/BiuB,GAV+BnuB,EAAA6B,aAAlBlC,GAAAwuB,UAAAA,2GCIb,IAAA/lB,GAAA,WAoCE,QAAAA,GAAYgmB,EAA4DC,GAGtE,GAFA5tB,KAAKme,SAAWA,SAEZwP,YAAqBE,QACvB,GAAIF,EAAUvuB,OAAS,GAAKuuB,EAAU,YAAcG,aAAa,CAC/D,GAAIC,GAAWJ,CACf3tB,MAAK+tB,SAAWA,OAGf,IAAIJ,YAAqBG,aAAa,CACzC,GAAI9iB,GAAU2iB,CACd3tB,MAAK+tB,UAAY/iB,OAEd,IAAI2iB,YAAqBK,UAI5BhuB,KAAK+tB,SAAW,SAEb,IAAIH,EAAY,CACnB,GAAIK,GAAUN,EACV3iB,EAAUmT,SAASoM,cAAc0D,EAErC,KAAK,GAAIC,KAAiBN,GAAY,CACpC,GAAIO,GAAiBP,EAAWM,EAChCljB,GAAQojB,aAAaF,EAAeC,GAGtCnuB,KAAK+tB,UAAY/iB,OAEd,CACH,GAAIqjB,GAAWV,CACf3tB,MAAK+tB,SAAW/tB,KAAKsuB,kBAAkBD,IAya7C,MAjaE9lB,QAAAC,eAAIb,EAAAhI,UAAA,cAAJ,WACE,MAAOK,MAAK+tB,SAAW/tB,KAAK+tB,SAAS3uB,OAAS,mCAOhDuI,EAAAhI,UAAAgoB,YAAA,WACE,MAAO3nB,MAAK+tB,UAONpmB,EAAAhI,UAAA4uB,QAAR,SAAgBC,GACdxuB,KAAK+tB,SAASQ,QAAQ,SAACvjB,GACrBwjB,EAAQxjB,MAIJrD,EAAAhI,UAAA8uB,2BAAR,SAAmCzjB,EAAiCqjB,GAClE,GAAIK,GAAgB1jB,EAAQ2jB,iBAAiBN,EAI7C,UAAUO,MAAMzvB,KAAKuvB,IAGf/mB,EAAAhI,UAAA2uB,kBAAR,SAA0BD,GAA1B,GAAAtuB,GAAAC,KACM6uB,IAEJ,OAAI7uB,MAAK+tB,UACP/tB,KAAKuuB,QAAQ,SAACvjB,GACZ6jB,EAAmBA,EAAiBriB,OAAOzM,EAAK0uB,2BAA2BzjB,EAASqjB,MAOjFQ,GAHE7uB,KAAKyuB,2BAA2BtQ,SAAUkQ,IAWrD1mB,EAAAhI,UAAA0I,KAAA,SAAKgmB,GAEH,MAAO,IAAI1mB,GADY3H,KAAKsuB,kBAAkBD,KAahD1mB,EAAAhI,UAAAsI,KAAA,SAAKgL,GACH,MAAI6b,WAAU1vB,OAAS,EACdY,KAAK+uB,QAAQ9b,GAGbjT,KAAKgvB,WAIRrnB,EAAAhI,UAAAqvB,QAAR,WACE,MAAOhvB,MAAK+tB,SAAS,GAAGkB,WAGlBtnB,EAAAhI,UAAAovB,QAAR,SAAgB9b,GAUd,WATgB7H,KAAZ6H,GAAoC,MAAXA,IAE3BA,EAAU,IAGZjT,KAAKuuB,QAAQ,SAACvjB,GACZA,EAAQikB,UAAYhc,IAGfjT,MAOT2H,EAAAhI,UAAAuO,MAAA,WAIE,MAHAlO,MAAKuuB,QAAQ,SAACvjB,GACZA,EAAQikB,UAAY,KAEfjvB,MAQT2H,EAAAhI,UAAAyiB,IAAA,WACE,GAAIpX,GAAUhL,KAAK+tB,SAAS,EAE5B,IAAI/iB,YAAmBkkB,oBAAqBlkB,YAAmBmkB,kBAC7D,MAAOnkB,GAAQrG,KAIf,MAAM,IAAI5F,OAAM,iCAAkCiM,KAetDrD,EAAAhI,UAAA4iB,KAAA,SAAK6M,EAAmBzqB,GACtB,MAAImqB,WAAU1vB,OAAS,EACdY,KAAKqvB,QAAQD,EAAWzqB,GAGxB3E,KAAKsvB,QAAQF,IAIhBznB,EAAAhI,UAAA2vB,QAAR,SAAgBF,GACd,MAAOpvB,MAAK+tB,SAAS,GAAGwB,aAAaH,IAG/BznB,EAAAhI,UAAA0vB,QAAR,SAAgBD,EAAmBzqB,GAIjC,MAHA3E,MAAKuuB,QAAQ,SAACvjB,GACZA,EAAQojB,aAAagB,EAAWzqB,KAE3B3E,MAcT2H,EAAAhI,UAAAsF,KAAA,SAAKuqB,EAAuB7qB,GAC1B,MAAImqB,WAAU1vB,OAAS,EACdY,KAAKyvB,QAAQD,EAAe7qB,GAG5B3E,KAAK0vB,QAAQF,IAIhB7nB,EAAAhI,UAAA+vB,QAAR,SAAgBF,GACd,MAAOxvB,MAAK+tB,SAAS,GAAGwB,aAAa,QAAUC,IAGzC7nB,EAAAhI,UAAA8vB,QAAR,SAAgBD,EAAuB7qB,GAIrC,MAHA3E,MAAKuuB,QAAQ,SAACvjB,GACZA,EAAQojB,aAAa,QAAUoB,EAAe7qB,KAEzC3E,MAQT2H,EAAAhI,UAAAoI,OAAA,eAAO,GAAA2mB,MAAAtqB,EAAA,EAAAA,EAAA0qB,UAAA1vB,OAAAgF,IAAAsqB,EAAAtqB,GAAA0qB,UAAA1qB,EAQL,OAPApE,MAAKuuB,QAAQ,SAACvjB,GACZ0jB,EAAcH,QAAQ,SAACoB,GACrBA,EAAa5B,SAASQ,QAAQ,SAACqB,EAAG1d,GAChClH,EAAQ6kB,YAAYF,EAAa5B,SAAS7b,UAIzClS,MAMT2H,EAAAhI,UAAAiO,OAAA,WACE5N,KAAKuuB,QAAQ,SAACvjB,GACZ,GAAI8kB,GAAS9kB,EAAQ+kB,UACjBD,IACFA,EAAOE,YAAYhlB,MASzBrD,EAAAhI,UAAAwf,OAAA,WACE,GAAInU,GAAUhL,KAAK+tB,SAAS,GACxBkC,EAAcjlB,EAAQklB,wBACtBC,EAAWhS,SAASiS,KAAKC,cAAcH,uBAe3C,QACExQ,IAAKuQ,EAAYvQ,IAAMyQ,EAASzQ,IAChCN,KAAM6Q,EAAY7Q,KAAO+Q,EAAS/Q,OAQtCzX,EAAAhI,UAAAmW,MAAA,WAEE,MAAO9V,MAAK+tB,SAAS,GAAGuC,aAO1B3oB,EAAAhI,UAAAggB,OAAA,WAEE,MAAO3f,MAAK+tB,SAAS,GAAGwC,cAS1B5oB,EAAAhI,UAAAuI,GAAA,SAAGsoB,EAAmBC,GAAtB,GAAA1wB,GAAAC,IAcE,OAbawwB,GAAUE,MAAM,KAEtBnC,QAAQ,SAAC9tB,GACO,MAAjBV,EAAKguB,SACPhuB,EAAKoe,SAASwS,iBAAiBlwB,EAAOgwB,GAGtC1wB,EAAKwuB,QAAQ,SAACvjB,GACZA,EAAQ2lB,iBAAiBlwB,EAAOgwB,OAK/BzwB,MAST2H,EAAAhI,UAAA8J,IAAA,SAAI+mB,EAAmBC,GAAvB,GAAA1wB,GAAAC,IAcE,OAbawwB,GAAUE,MAAM,KAEtBnC,QAAQ,SAAC9tB,GACO,MAAjBV,EAAKguB,SACPhuB,EAAKoe,SAASyS,oBAAoBnwB,EAAOgwB,GAGzC1wB,EAAKwuB,QAAQ,SAACvjB,GACZA,EAAQ4lB,oBAAoBnwB,EAAOgwB,OAKlCzwB,MAQT2H,EAAAhI,UAAAmN,SAAA,SAAS4R,GAUP,MATA1e,MAAKuuB,QAAQ,SAACvjB,GACRA,EAAQ6lB,UACV7lB,EAAQ6lB,UAAUC,IAAIpS,GAGtB1T,EAAQ0T,WAAa,IAAMA,IAIxB1e,MAQT2H,EAAAhI,UAAAsN,YAAA,SAAYyR,GAWV,MAVA1e,MAAKuuB,QAAQ,SAACvjB,GACRA,EAAQ6lB,UACV7lB,EAAQ6lB,UAAUjjB,OAAO8Q,GAGzB1T,EAAQ0T,UAAY1T,EAAQ0T,UAAUqS,QACpC,GAAIC,QAAO,UAAYtS,EAAUgS,MAAM,KAAK/jB,KAAK,KAAO,UAAW,MAAO,OAIzE3M,MAQT2H,EAAAhI,UAAA+gB,SAAA,SAAShC,GACP,GAAIgC,IAAW,CAkBf,OAhBA1gB,MAAKuuB,QAAQ,SAACvjB,GACRA,EAAQ6lB,UACN7lB,EAAQ6lB,UAAUI,SAASvS,KAG7BgC,GAAW,GAIT,GAAIsQ,QAAO,QAAUtS,EAAY,QAAS,MAAMwS,KAAKlmB,EAAQ0T,aAE/DgC,GAAW,KAKVA,GAmBT/Y,EAAAhI,UAAA+M,IAAA,SAAIykB,EAAqExsB,GACvE,GAAwC,gBAA7BwsB,GAAuC,CAChD,GAAIC,GAAeD,CAEnB,OAAyB,KAArBrC,UAAU1vB,OACLY,KAAKqxB,OAAOD,EAAczsB,GAG1B3E,KAAKsxB,OAAOF,GAIrB,GAAIG,GAA0BJ,CAC9B,OAAOnxB,MAAKwxB,iBAAiBD,IAIzB5pB,EAAAhI,UAAA2xB,OAAR,SAAeF,GACb,MAAOK,kBAAiBzxB,KAAK+tB,SAAS,IAASqD,IAGzCzpB,EAAAhI,UAAA0xB,OAAR,SAAeD,EAAsBzsB,GAKnC,MAJA3E,MAAKuuB,QAAQ,SAACvjB,GAEZA,EAAQqV,MAAW+Q,GAAgBzsB,IAE9B3E,MAGD2H,EAAAhI,UAAA6xB,iBAAR,SAAyBE,GAMvB,MALA1xB,MAAKuuB,QAAQ,SAACvjB,GAEZzC,OAAO+D,OAAOtB,EAAQqV,MAAOqR,KAGxB1xB,MAEX2H,IA7eazI,GAAAyI,IAAAA,+ZChBb,IAAArG,GAAA1C,EAAA,WA4DA4I,EAAA,WAIE,QAAAA,KAFQxH,KAAA2xB,aAiFV,MAzEEnqB,GAAA7H,UAAAqB,UAAA,SAAU4wB,GACR5xB,KAAK2xB,UAAUlkB,KAAK,GAAIokB,GAAqBD,KAM/CpqB,EAAA7H,UAAAmyB,cAAA,SAAcF,GACZ5xB,KAAK2xB,UAAUlkB,KAAK,GAAIokB,GAAqBD,GAAU,KAMzDpqB,EAAA7H,UAAAub,qBAAA,SAAqB0W,EAAuCG,GAC1D/xB,KAAK2xB,UAAUlkB,KAAK,GAAIukB,GAAgCJ,EAAUG,KAMpEvqB,EAAA7H,UAAA0V,YAAA,SAAYuc,GAEV,IAAK,GAAI/yB,GAAI,EAAGA,EAAImB,KAAK2xB,UAAUvyB,OAAQP,IAAK,CAC9C,GAAIozB,GAAqBjyB,KAAK2xB,UAAU9yB,EACxC,IAAIozB,EAAmBL,WAAaA,EAElC,MADAtwB,GAAAqM,WAAWC,OAAO5N,KAAK2xB,UAAWM,IAC3B,EAIX,OAAO,GAMTzqB,EAAA7H,UAAAuyB,eAAA,WACElyB,KAAK2xB,cAQPnqB,EAAA7H,UAAA2I,SAAA,SAAS5D,EAAgBiK,OAAA,KAAAA,IAAAA,EAAA,KAIvB,KAAqB,GAHjBwjB,MAGiB/tB,EAAA,EAAA2J,EAAA/N,KAAK2xB,UAALvtB,EAAA2J,EAAA3O,OAAAgF,IAAc,CAA9B,GAAIwtB,GAAQ7jB,EAAA3J,EACfwtB,GAASQ,KAAK1tB,EAAQiK,GAElBijB,EAASS,UACXF,EAAkB1kB,KAAKmkB,GAK3B,IAA6B,GAAAU,GAAA,EAAAC,EAAAJ,EAAAG,EAAAC,EAAAnzB,OAAAkzB,IAAiB,CAAzC,GAAIE,GAAgBD,EAAAD,EACvBhxB,GAAAqM,WAAWC,OAAO5N,KAAK2xB,UAAWa,KAQtChrB,EAAA7H,UAAA8I,SAAA,WAGE,MAA4BzI,OAEhCwH,IAnFatI,GAAAsI,gBAAAA,CAyFb,IAAAqqB,GAAA,WAKE,QAAAA,GAAYD,EAAuCa,OAAA,KAAAA,IAAAA,GAAA,GACjDzyB,KAAK0yB,cAAgBd,EACrB5xB,KAAKyyB,KAAOA,EA2BhB,MApBElqB,QAAAC,eAAIqpB,EAAAlyB,UAAA,gBAAJ,WACE,MAAOK,MAAK0yB,+CAQdb,EAAAlyB,UAAAyyB,KAAA,SAAK1tB,EAAgBiK,GACnB3O,KAAK0yB,cAAchuB,EAAQiK,IAO7BkjB,EAAAlyB,UAAA0yB,OAAA,WACE,MAAOryB,MAAKyyB,MAEhBZ,KAKAG,EAAA,SAAAvyB,GAOE,QAAAuyB,GAAYJ,EAAuCG,GAAnD,GAAAhyB,GACEN,EAAAN,KAAAa,KAAM4xB,IAAS5xB,WAEfD,GAAKgyB,OAASA,EACdhyB,EAAK4yB,aAAe,EAGpB5yB,EAAK6yB,0BAA4B,SAACluB,EAAgBiK,GAC5CmC,KAAKD,MAAQ9Q,EAAK4yB,aAAe5yB,EAAKgyB,SAGxChyB,EAAK8yB,UAAUnuB,EAAQiK,GACvB5O,EAAK4yB,aAAe7hB,KAAKD,UAcjC,MAjC4DnR,GAAAsyB,EAAAvyB,GAwBlDuyB,EAAAryB,UAAAkzB,UAAR,SAAkBnuB,EAAgBiK,GAEhClP,EAAAE,UAAMyyB,KAAIjzB,KAAAa,KAAC0E,EAAQiK,IAGrBqjB,EAAAryB,UAAAyyB,KAAA,SAAK1tB,EAAgBiK,GAEnB3O,KAAK4yB,0BAA0BluB,EAAQiK,IAE3CqjB,GAjC4DH,uGC5L5D,SAAiBjmB,GAIf,QAAAC,KACE,MAAOinB,KAHT,GAAIA,GAAO,CAEKlnB,GAAAC,KAAIA,GAJL3M,EAAA0M,OAAA1M,EAAA0M,gGCCjB,IAAAmnB,GAAAn0B,EAAA,eACA2D,EAAA3D,EAAA,uBACAulB,EAAAvlB,EAAA,2BACAo0B,EAAAp0B,EAAA,uCACAgZ,EAAAhZ,EAAA,yCACAq0B,EAAAr0B,EAAA,kCACAyR,EAAAzR,EAAA,qCACAgtB,EAAAhtB,EAAA,wBACAiF,EAAAjF,EAAA,0BACAs0B,EAAAt0B,EAAA,8BACAu0B,EAAAv0B,EAAA,qCACAwE,EAAAxE,EAAA,6BACA4jB,EAAA5jB,EAAA,sCACAssB,EAAAtsB,EAAA,mCACAw0B,EAAAx0B,EAAA,+BACAy0B,EAAAz0B,EAAA,0BACA8K,EAAA9K,EAAA,4BACAqH,EAAArH,EAAA,0BACAyC,EAAAzC,EAAA,sBACA6jB,EAAA7jB,EAAA,sCACA00B,EAAA10B,EAAA,oCACA20B,EAAA30B,EAAA,kCACA40B,EAAA50B,EAAA,iCACAsH,EAAAtH,EAAA,0BACA60B,EAAA70B,EAAA,oCACA80B,EAAA90B,EAAA,sCACA+0B,EAAA/0B,EAAA,6BACAg1B,EAAAh1B,EAAA,gCACAi1B,EAAAj1B,EAAA,kCACAk1B,EAAAl1B,EAAA,yBACAm1B,EAAAn1B,EAAA,oCACAW,EAAAX,EAAA,6BACAo1B,EAAAp1B,EAAA,6BACAq1B,EAAAr1B,EAAA,+BACAs1B,EAAAt1B,EAAA,+BACAu1B,EAAAv1B,EAAA,uCACAmZ,EAAAnZ,EAAA,iCACAw1B,EAAAx1B,EAAA,iCACAy1B,EAAAz1B,EAAA,gCACA01B,EAAA11B,EAAA,sCACA21B,EAAA31B,EAAA,4BACAmnB,EAAAnnB,EAAA,8BACA41B,EAAA51B,EAAA,oCACAqsB,EAAArsB,EAAA,6BACA61B,EAAA71B,EAAA,6CACAyP,EAAAzP,EAAA,uBACA0C,EAAA1C,EAAA,UAI6B,mBAAlB2J,QAAO+D,SAChB/D,OAAO+D,OAAS,SAAShB,GAEvB,GAAc,MAAVA,EACF,KAAM,IAAIopB,WAAU,6CAGtBppB,GAAS/C,OAAO+C,EAChB,KAAK,GAAI4G,GAAQ,EAAGA,EAAQ4c,UAAU1vB,OAAQ8S,IAAS,CACrD,GAAIsB,GAASsb,UAAU5c,EACvB,IAAc,MAAVsB,EACF,IAAK,GAAIvB,KAAOuB,GACVjL,OAAO5I,UAAUU,eAAelB,KAAKqU,EAAQvB,KAC/C3G,EAAO2G,GAAOuB,EAAOvB,IAK7B,MAAO3G,KAKVL,OAAe0pB,SAASC,UAEvBC,UAAS9B,EAAA8B,UACTC,kBAAiB/B,EAAA+B,kBAEjBnnB,WAAUrM,EAAAqM,WACV7L,YAAWR,EAAAQ,YACXwT,YAAWhU,EAAAgU,YACX9G,QAAOlN,EAAAkN,QACPumB,aAAYzzB,EAAAyzB,aAEZv1B,eAAc00B,EAAA10B;gCACd+B,eAAc0yB,EAAA1yB,eACdiB,aAAYwxB,EAAAxxB,aACZa,oBAAmBmxB,EAAAnxB,oBACnBS,sBAAqB2e,EAAA3e,sBACrBwB,oBAAmBguB,EAAAhuB,oBACnBc,iBAAgBguB,EAAAhuB,iBAChBjD,OAAMZ,EAAAY,OACNuF,kBAAiB6qB,EAAA7qB,kBACjBQ,iBAAgBsqB,EAAAtqB,iBAChBS,gBAAe0qB,EAAA1qB,gBACfvI,aAAY7B,EAAA6B,aACZiK,YAAWkpB,EAAAlpB,YACX/E,UAASJ,EAAAI,UACTc,UAASnB,EAAAmB,UACTkH,WAAU6V,EAAA7V,WACVe,oBAAmBokB,EAAApkB,oBACnBS,uBAAsBkjB,EAAAljB,uBACtBQ,yBAAwBsH,EAAAtH,yBACxBa,iBAAgB4G,EAAA5G,iBAChB7O,MAAKjB,EAAAiB,MACL0Q,cAAa+S,EAAA/S,cACbD,qBAAoBgT,EAAAhT,qBACpBa,6BAA4B6gB,EAAA7gB,6BAC5BQ,uBAAsB+f,EAAA/f,uBACtBI,kBAAiBye,EAAAze,kBACjBD,sBAAqB0e,EAAA1e,sBACrBrD,qBAAoBb,EAAAa,qBACpB2G,sBAAqByc,EAAAzc,sBACrBG,sBAAqB0b,EAAA1b,sBACrBmB,QAAOyS,EAAAzS,QACPwH,aAAYgT,EAAAhT,aACZtb,UAASxB,EAAAwB,UACTqd,cAAawQ,EAAAxQ,cACbS,kBAAiB+P,EAAA/P,kBACjBY,qBAAoBoP,EAAApP,qBACpBrV,OAAML,EAAAK,OACN0V,gBAAewP,EAAAxP,gBACfkB,kBAAiBuO,EAAAvO,kBACjBU,SAAQ8N,EAAA9N,SACRpiB,aAAYR,EAAAQ,aACZiH,YAAWnB,EAAAmB,YACXgZ,sBAAqBrB,EAAAqB,sBACrBsH,oBAAmB4I,EAAA5I,oBACnBI,aAAYN,EAAAM,aACZF,mBAAkBH,EAAAG,mBAClBwB,eAAcuG,EAAAvG,eACda,UAAS2F,EAAA3F,2mDC9HX,IAAA9mB,GAAA,WAaE,QAAAA,GAAYouB,EAAeC,EAAsBC,OAAA,KAAAA,IAAAA,GAAA,GAC/Cl1B,KAAKg1B,MAAQA,EACbh1B,KAAKi1B,SAAWA,EAChBj1B,KAAKk1B,OAASA,EACdl1B,KAAKm1B,cAAgB,EAqDzB,MA9CEvuB,GAAAjH,UAAAmH,MAAA,WAEE,MADA9G,MAAK8iB,QACE9iB,MAMT4G,EAAAjH,UAAAqH,MAAA,WACEkhB,aAAaloB,KAAKm1B,gBAMpBvuB,EAAAjH,UAAAmjB,MAAA,WAAA,GAAA/iB,GAAAC,KACMo1B,EAAmB,EACnBC,EAAc,CAElBr1B,MAAKgH,OAEL,IAAIsuB,GAAmB,WAGrB,GAFAv1B,EAAKk1B,WAEDl1B,EAAKm1B,OAAQ,CACf,GAAIrkB,GAAMC,KAAKD,MAIX0kB,EAAQ1kB,EAAMukB,CAGlBC,GAAct1B,EAAKi1B,MAAQO,EAAQF,EAEnCD,EAAmBvkB,EAGnB9Q,EAAKo1B,cAAgBpkB,WAAWukB,EAAkBv1B,EAAKi1B,MAAQK,IAInED,GAAmBtkB,KAAKD,MACpB7Q,KAAKg1B,MAAQ,IACfh1B,KAAKm1B,cAAgBpkB,WAAWukB,EAAkBt1B,KAAKg1B,SAG7DpuB,IAtEa1H,GAAA0H,QAAAA,+ZCNb,IAAA8C,GAAA9K,EAAA,4BACAyI,EAAAzI,EAAA,SAEAqH,EAAArH,EAAA,0BACAyR,EAAAzR,EAAA,qCACAo0B,EAAAp0B,EAAA,uCACAw0B,EAAAx0B,EAAA,+BACAssB,EAAAtsB,EAAA,mCACAgtB,EAAAhtB,EAAA,wBACAq0B,EAAAr0B,EAAA,kCACAulB,EAAAvlB,EAAA,2BACA0I,EAAA1I,EAAA,qBACAu0B,EAAAv0B,EAAA,qCACAs0B,EAAAt0B,EAAA,8BACA4jB,EAAA5jB,EAAA,sCACAy0B,EAAAz0B,EAAA,0BACA6jB,EAAA7jB,EAAA,sCACA00B,EAAA10B,EAAA,oCACA+0B,EAAA/0B,EAAA,6BACAqsB,EAAArsB,EAAA,6BACAi1B,EAAAj1B,EAAA,kCACAg1B,EAAAh1B,EAAA,gCACAm1B,EAAAn1B,EAAA,oCACA40B,EAAA50B,EAAA,iCACA20B,EAAA30B,EAAA,kCACA60B,EAAA70B,EAAA,oCACAk1B,EAAAl1B,EAAA,yBAEA80B,EAAA90B,EAAA,sCACAq1B,EAAAr1B,EAAA,+BACAo1B,EAAAp1B,EAAA,6BACAs1B,EAAAt1B,EAAA,+BAIA0C,EAAA1C,EAAA,WACAu1B,EAAAv1B,EAAA,uCACAw1B,EAAAx1B,EAAA,iCACAy1B,EAAAz1B,EAAA,gCACA01B,EAAA11B,EAAA,sCACA21B,EAAA31B,EAAA,4BACAmnB,EAAAnnB,EAAA,8BACAyC,EAAAzC,EAAA,sBAIAyP,GAFAzP,EAAA,oCACAA,EAAA,6CACAA,EAAA,wBACA42B,EAAA52B,EAAA,uCAwDAi2B,EAAA,WA+BE,QAAAA,GAAYh1B,EAAgB41B,EAAiDj0B,OAAA,KAAAA,IAAAA,KAA7E,IAAAzB,GAAAC,IACE,IAAIy1B,YAAgC/rB,GAAAmB,YAAa,CAE/C,GAAI6qB,GAAwBD,EAGxBE,IAaJA,GAAWloB,MAAMmoB,GAAIF,IAErB11B,KAAK21B,WAAaA,MAIlB31B,MAAK21B,WAA0BF,CAGjCz1B,MAAKH,OAASA,EACdG,KAAKwB,OAASA,EACdxB,KAAK61B,qBAAuB,GAAIC,GAAcj2B,GAC9CG,KAAK+1B,cAAgB,GAAI1uB,GAAAM,IAAI9H,EAAOyqB,aAIpCtqB,KAAKg2B,qBAEL,KAAsB,GADlBC,MACkB7xB,EAAA,EAAA2J,EAAA/N,KAAK21B,WAALvxB,EAAA2J,EAAA3O,OAAAgF,IAAe,CAAhC,GAAI8xB,GAASnoB,EAAA3J,EACW,OAAvB8xB,EAAUC,WAEZF,EAA2BxoB,KAAKyoB,GAGlCl2B,KAAKg2B,mBAAmBvoB,KAAK,GAAI2oB,GAA0Bv2B,EAAQq2B,EAAUN,GAAI51B,KAAKwB,SAKxF,GAAIy0B,EAA2B72B,OAAS,EACtC,KAAML,OAAM,6EAKd,IAAIk3B,EAA2B72B,OAAS,GACnC62B,EAA2B,KAAOj2B,KAAK21B,WAAW31B,KAAK21B,WAAWv2B,OAAS,GAC9E,KAAML,OAAM,8FAGd,IAAIs3B,GAAiC,KACjCC,EAAWh1B,EAAAyzB,aAAauB,SAGxBC,EAAmB,SAAC91B,GAMtB,GAAa,MAATA,EACF,OAAQA,EAAMmH,MAEZ,IAAK/H,GAAOU,MAAMC,cAChB61B,EAAiC51B,CACjC,MAEF,KAAKZ,GAAOU,MAAMK,eAClB,IAAKf,GAAOU,MAAMM,cAClB,IAAKhB,GAAOU,MAAMO,YAChBu1B,EAAiB,KAuBvB,IAAsB,GAlBlBG,GAAuB,MAAlBH,EACLI,EAAWD,GAAoC,SAA9BH,EAAeK,WAGhCC,GACFje,KAAM8d,EACNI,WAAYH,EACZzmB,aAAcjQ,EAAKF,OAAOmQ,eAC1BsmB,SAAUA,EACVxgB,MAAO/V,EAAKg2B,cAAcjgB,QAC1B+gB,cAAe1Y,SAASiS,KAAK0G,aAG3BC,EAAoC,KACpCC,GAAmB,EAID5yB,EAAA,EAAA2J,EAAAhO,EAAK41B,WAALvxB,EAAA2J,EAAA3O,OAAAgF,IAAe,CAAhC,GAAI8xB,GAASnoB,EAAA3J,EAChB,IAA2B,MAAvB8xB,EAAUC,YAAsD,IAAjCD,EAAUC,UAAUQ,GAAmB,CACxEI,EAASh3B,EAAKi2B,mBAAmBj2B,EAAK41B,WAAWsB,QAAQf,GACzD,QAKAa,IAAWh3B,EAAKm3B,YAClBF,GAAmB,GAMjBA,IAEEj3B,EAAKm3B,WACPn3B,EAAKm3B,UAAUC,QAAQn0B,OAIzBjD,EAAKm3B,UAAYH,EAIK,MAAlBh3B,EAAKm3B,YAEFn3B,EAAKm3B,UAAUE,gBAClBr3B,EAAKs3B,MAAMt3B,EAAKm3B,WAKdP,EAAQje,MAQV3Y,EAAKm3B,UAAUI,mBAAmBC,cAAcx3B,EAAKF,OAAOU,MAAMC,cAAe61B,GAGnFt2B,EAAKm3B,UAAUC,QAAQp0B,SAM7B/C,MAAK61B,qBAAqB2B,YAAYl3B,gBAAgBN,KAAKH,OAAOU,MAAMC,cAAe+1B,GACvFv2B,KAAK61B,qBAAqB2B,YAAYl3B,gBAAgBN,KAAKH,OAAOU,MAAMK,eAAgB21B,GACxFv2B,KAAK61B,qBAAqB2B,YAAYl3B,gBAAgBN,KAAKH,OAAOU,MAAMM,cAAe01B,GACvFv2B,KAAK61B,qBAAqB2B,YAAYl3B,gBAAgBN,KAAKH,OAAOU,MAAMO,YAAay1B,GACrFv2B,KAAK61B,qBAAqB2B,YAAYl3B,gBAAgBN,KAAKH,OAAOU,MAAMib,iBAAkB+a,GAC1Fv2B,KAAK61B,qBAAqB2B,YAAYl3B,gBAAgBN,KAAKH,OAAOU,MAAM0P,oBAAqBsmB,GAC7Fv2B,KAAK61B,qBAAqB2B,YAAYl3B,gBAAgBN,KAAKH,OAAOU,MAAM2P,mBAAoBqmB,GAG5FA,EAAiB,MA8CrB,MA3CE1B,GAAAl1B,UAAAQ,UAAA,WACE,MAAOH,MAAKwB,QAGNqzB,EAAAl1B,UAAA03B,MAAR,SAAczB,GACZ,GAAI6B,GAAM7B,EAAGuB,QAAQ/uB,eACrBwtB,GAAG8B,mBAMH,IAAIrH,GAAgB,GAAIhpB,GAAAM,IAAI3H,KAAK+1B,cAAcpO,cAAc,GAAG0I,cAChEA,GAAcvjB,SAAS,6CACvBujB,EAActoB,OAAO0vB,GAKjBxsB,OAAOuc,sBACTA,sBAAsB,WACpBoO,EAAGna,aAAanT,SAASstB,EAAGuB,WAI9BpmB,WAAW,WACT6kB,EAAGna,aAAanT,SAASstB,EAAGuB,UAC3B,IAICtC,EAAAl1B,UAAAg4B,UAAR,SAAkB/B,GAChBA,EAAGgC,kBACHhC,EAAGuB,QAAQ/uB,gBAAgBwF,SAC3BgoB,EAAGiC,sBAGLhD,EAAAl1B,UAAAiL,QAAA,WACE,IAA8B,GAAAxG,GAAA,EAAA2J,EAAA/N,KAAKg2B,mBAAL5xB,EAAA2J,EAAA3O,OAAAgF,IAAuB,CAAhD,GAAI0zB,GAAiB/pB,EAAA3J,EACxBpE,MAAK23B,UAAUG,GAEjB93B,KAAK61B,qBAAqBgC,sBAE9BhD,IA/Oa31B,GAAA21B,UAAAA,EAiPb,SAAiBA,IAAU,SAAAkD,GAEzB,QAAAC,GAA+Bn4B,EAAgB2B,GAC7C,WAD6C,KAAAA,IAAAA,MACtCqzB,EAAUkD,QAAQE,cAAcp4B,EAAQ2B,GAGjD,QAAA02B,GAA0Cr4B,EAAgB2B,GACxD,WADwD,KAAAA,IAAAA,MACjDqzB,EAAUkD,QAAQI,yBAAyBt4B,EAAQ2B,GAG5D,QAAA42B,GAA2Cv4B,EAAgB2B,GACzD,WADyD,KAAAA,IAAAA,MAClDqzB,EAAUkD,QAAQM,0BAA0Bx4B,EAAQ2B,GAG7D,QAAA82B,KACE,GAAItU,GAAgB,GAAIkP,GAAAxQ,eACtBjc,YACE,GAAIysB,GAAA/P,kBAAkB,gBAAiB,GAAIX,GAAAqB,uBAC3C,GAAIqP,GAAA/P,kBAAkB,QAAS,GAAIgR,GAAA/f,wBACnC,GAAI8e,GAAA/P,kBAAkB,cAAe,GAAImQ,GAAAhuB,qBACzC,GAAI4tB,GAAA/P,kBAAkB,gBAAiB,GAAIV,GAAA3e,uBAC3C,GAAIovB,GAAA/P,kBAAkB,YAAa,GAAI0Q,GAAAvO,oBAEzC9e,QAAQ,IAGN+xB,EAAgB,GAAItyB,GAAAmB,WACtB2E,YAAa,kBACbtF,YACE,GAAIwsB,GAAAze,mBAAmBC,cAAewe,EAAA1e,sBAAsBsC,YAAalC,oBAAoB,IAC7F,GAAIse,GAAAze,mBAAmBC,cAAewe,EAAA1e,sBAAsBuC,UAAW/K,YAAa,mBAIpFysB,EAAmB,GAAIvyB,GAAAmB,WACzB2E,YAAa,qBACbtF,YACE,GAAImlB,GAAAzS,SAAS3U,MAAO,GAAImvB,GAAAhT,kBAIxB8X,EAAmB,GAAIxyB,GAAAmB,WACzB2E,YAAa,qBACbtF,YACE,GAAI4H,GAAAK,OACJ,GAAIuc,GAAAM,aACJ,GAAIL,GAAAG,mBACJ,GAAI8H,GAAApP,sBAAsBC,cAAeA,IACzC,GAAIwR,GAAA1mB,uBACJ,GAAIkkB,GAAAljB,0BAKJ4oB,EAAa,GAAIvU,GAAA7V,YACnB7H,YACE,GAAI4J,GAAAa,qBACJ,GAAIjL,GAAAmB,WACF2E,YAAa,oBACbtF,YACEud,EACAuU,EACAC,EACAC,OAMR,OAAO,IAAI/uB,GAAAmB,aACTb,UAAW,EACX+B,YAAa,mCACbtF,YACE,GAAImtB,GAAAxP,gBACJ,GAAIgQ,GAAAhuB,iBACJ,GAAIkuB,GAAAzc,sBACJ6gB,EACA,GAAI5E,GAAA9N,SACJ,GAAI0N,GAAA1b,sBACJ,GAAIyb,GAAApkB,uBA6DV,QAAAspB,KACE,MAAO,IAAIjvB,GAAAmB,aACTpE,YACE,GAAI2tB,GAAAhuB,iBACJ,GAAI8tB,GAAA10B,eACJ,GAAI80B,GAAAzc,sBACJ,GAAI5R,GAAAmB,WACFX,YACE,GAAIwtB,GAAA1yB,gBAAgBI,KAAM,6BAC1B,GAAIqyB,GAAAxxB,cAENd,SAAU,kBAEZ,GAAIyiB,GAAA7V,YACF7H,YACE,GAAIR,GAAAmB,WACFX,YACE,GAAI4J,GAAAa,qBACJ,GAAIga,GAAAG,mBACJ,GAAIJ,GAAAM,aACJ,GAAIld,GAAAK,OACJ,GAAIskB,GAAAljB,wBAEN/D,YAAa,2BAIlBA,YAAa,iBAAkB,iBAItC,QAAA6sB,KACE,GAAI5U,GAAgB,GAAIkP,GAAAxQ,eACtBjc,YACE,GAAIysB,GAAA/P,kBAAkB,gBAAiB,GAAIX,GAAAqB,uBAC3C,GAAIqP,GAAA/P,kBAAkB,QAAS,GAAIgR,GAAA/f,wBACnC,GAAI8e,GAAA/P,kBAAkB,cAAe,GAAImQ,GAAAhuB,qBACzC,GAAI4tB,GAAA/P,kBAAkB,gBAAiB,GAAIV,GAAA3e,uBAC3C,GAAIovB,GAAA/P,kBAAkB,YAAa,GAAI0Q,GAAAvO,oBAEzC9e,QAAQ,EACRwD,WAAY,GAEdga,GAAczW,aAAa,GAAIgnB,GAAAlpB,aAAaC,OAAQ0Y,IAEpD,IAAI0U,GAAa,GAAIvU,GAAA7V,YACnB7H,YACE,GAAIR,GAAAmB,WACFX,YACE,GAAIwsB,GAAAze,mBAAmBC,cAAewe,EAAA1e,sBAAsBsC,YAAalC,oBAAoB,IAC7F,GAAIiX,GAAAzS,SAAS3U,MAAO,GAAImvB,GAAAhT,eACxB,GAAIsS,GAAAze,mBAAmBC,cAAewe,EAAA1e,sBAAsBuC,UAAW/K,YAAa,iBAEtFA,YAAa,sBAKnB,OAAO,IAAIrC,GAAAmB,aACTpE,YACE,GAAImtB,GAAAxP,gBACJ,GAAIgQ,GAAAhuB,iBACJ,GAAImtB,GAAA7qB,kBACJ,GAAI4rB,GAAAzc,sBACJ6gB,EACA,GAAI5E,GAAA9N,UACFvf,YACE,GAAIsf,GAAA/S,eAAeC,QAAS8S,EAAAhT,qBAAqBM,QACjD,GAAImgB,GAAAtqB,iBAEJ,GAAIiqB,GAAApP,sBAAsBC,cAAeA,IACzC,GAAIgP,GAAAljB,0BAGRkU,EACA,GAAI0P,GAAA1b,sBACJ,GAAIqb,GAAA3F,UACJ,GAAI+F,GAAApkB,qBACHtD,YAAa,iBAAkB,yBAItC,QAAA8sB,KACE,MAAO,IAAInvB,GAAAmB,aACTpE,YACE,GAAI2tB,GAAAhuB,iBACJ,GAAI8tB,GAAA10B,eACJ,GAAI80B,GAAAzc,sBACJ,GAAIic,GAAA9N,UACFvf,YAEE,GAAIpF,GAAAiB,OAAOZ,SAAU,yBACrB,GAAIsxB,GAAAljB,0BAGR,GAAI7J,GAAAmB,WACFX,YACE,GAAIwtB,GAAA1yB,gBAAgBI,KAAM,6BAC1B,GAAIqyB,GAAAxxB,cAENd,SAAU,mBAEXqK,YAAa,iBAAkB,cAAe,yBAIrD,QAAA+sB,KACE,GAAIJ,GAAa,GAAIvU,GAAA7V,YACnB7H,YACE,GAAIR,GAAAmB,WACFX,YACE,GAAIwsB,GAAAze,mBAAmBC,cAAewe,EAAA1e,sBAAsBsC,YAAalC,oBAAoB,IAC7F,GAAIiX,GAAAzS,SAASM,wCAAyC,IACtD,GAAIwZ,GAAAze,mBAAmBC,cAAewe,EAAA1e,sBAAsBuC,UAAW/K,YAAa,iBAEtFA,YAAa,sBAKnB,OAAO,IAAIsoB,GAAA1qB,iBACTlD,YACE,GAAImtB,GAAAxP,gBACJ,GAAIgQ,GAAAhuB,iBACJ,GAAIkuB,GAAAzc,sBACJ,GAAIwb,GAAA3F,UACJgL,EACA,GAAI5E,GAAA9N,UAAUC,2BAA2B,IACzC,GAAIwN,GAAApkB,qBACHtD,YAAa,iBAAkB,2BAItC,QAAAksB,GAA8Bp4B,EAAgB2B,OAAA,KAAAA,IAAAA,KAI5C,OAAO,IAAIqzB,GAAUh1B,IACnB+1B,GAAIiD,IACJ1C,UAAW,SAACQ,GACV,MAAOA,GAAQL,UAAYK,EAAQE,cALV,KAKoDF,EAAQC,cAGvFhB,GAAI+C,IACJxC,UAAW,SAACQ,GACV,MAAOA,GAAQC,cAGjBhB,GAAIgD,IACJzC,UAAW,SAACQ,GACV,MAAOA,GAAQL,UAAYK,EAAQE,cAfV,OAkB3BjB,GAAI0C,MACF92B,GAGN,QAAA22B,GAAyCt4B,EAAgB2B,GACvD,WADuD,KAAAA,IAAAA,MAChD,GAAIqzB,GAAUh1B,IACnB+1B,GAAIiD,IACJ1C,UAAW,SAACQ,GACV,MAAOA,GAAQC,cAGjBhB,GAAIgD,MACFp3B,GAGN,QAAA62B,GAA0Cx4B,EAAgB2B,GACxD,WADwD,KAAAA,IAAAA,MACjD,GAAIqzB,GAAUh1B,EAAQi5B,IAAwBt3B,GAGvD,QAAAu3B,KACE,GAAI/U,GAAgB,GAAIkP,GAAAxQ,eACtBjc,YACE,GAAIysB,GAAA/P,kBAAkB,gBAAiB,GAAIX,GAAAqB,uBAC3C,GAAIqP,GAAA/P,kBAAkB,cAAe,GAAImQ,GAAAhuB,qBACzC,GAAI4tB,GAAA/P,kBAAkB,gBAAiB,GAAIV,GAAA3e,uBAC3C,GAAIovB,GAAA/P,kBAAkB,YAAa,GAAI0Q,GAAAvO,oBAEzC9e,QAAQ,IAGNkyB,EAAa,GAAIvU,GAAA7V,YACnB7H,YACEud,EACA,GAAI3T,GAAAa,qBACJ,GAAI0a,GAAAzS,SAAS3U,MAAO,GAAImvB,GAAAhT,eACxB,GAAIsS,GAAAze,kBACJ,GAAI4e,GAAAvG,eACJ,GAAIkH,GAAA5I,oBACJ,GAAIgI,GAAApP,sBAAsBC,cAAeA,IACzC,GAAIwP,GAAAtqB,iBACJ,GAAI8pB,GAAAljB,yBAIR,OAAO,IAAIpG,GAAAmB,aACTpE,YACE,GAAImtB,GAAAxP,gBACJ,GAAImP,GAAA7qB,kBACJ,GAAI4rB,GAAAzc,sBACJ,GAAIwb,GAAA3F,UACJ,GAAIgG,GAAA1b,sBACJ0gB,EACA,GAAI5E,GAAA9N,SACJ,GAAIyN,GAAApkB,qBACHtD,YAAa,oBAIpB,QAAAitB,KACE,MAAO,IAAItvB,GAAAmB,aACTpE,YACE,GAAIytB,GAAA10B,eACJ,GAAI2kB,GAAA7V,YACF7H,YACE,GAAI4J,GAAAa,qBACJ,GAAI+iB,GAAA1yB,eACJ,GAAIwyB,GAAA5I,oBACJ,GAAI6H,GAAAljB,0BAGR,GAAIkkB,GAAAxxB,cACHuJ,YAAa,iBAAkB,iBAItC,QAAAktB,KACE,GAAIP,GAAa,GAAIvU,GAAA7V,YACnB7H,YACE,GAAImlB,GAAAzS,QACJ,GAAI8Z,GAAAze,oBAIR,OAAO,IAAI9K,GAAAmB,aACTpE,YACE,GAAImtB,GAAAxP,gBACJ,GAAIkQ,GAAAzc,sBACJ,GAAIwb,GAAA3F,UACJgL,EACA,GAAI5E,GAAA9N,SACJ,GAAIyN,GAAApkB,qBACHtD,YAAa,iBAAkB,2BAItC,QAAAmtB,KACE,GAAIlV,GAAgB,GAAIkP,GAAAxQ,eACtBjc,YACE,GAAIysB,GAAA/P,kBAAkB,gBAAiB,GAAIX,GAAAqB,uBAC3C,GAAIqP,GAAA/P,kBAAkB,cAAe,GAAImQ,GAAAhuB,qBACzC,GAAI4tB,GAAA/P,kBAAkB,gBAAiB,GAAIV,GAAA3e,uBAC3C,GAAIovB,GAAA/P,kBAAkB,YAAa,GAAI0Q,GAAAvO,oBAEzC9e,QAAQ,IAGNkyB,EAAa,GAAIvU,GAAA7V,YACnB7H,YAAaud,EACX,GAAI3T,GAAAa,qBACJ,GAAI0a,GAAAzS,SAAS3U,MAAO,GAAImvB,GAAAhT,eACxB,GAAIsS,GAAAze,kBACJ,GAAI4e,GAAAvG,eACJ,GAAI3B,GAAAG,mBACJ,GAAIJ,GAAAM,aACJ,GAAIwI,GAAA5I,oBACJ,GAAI4I,GAAA5I,qBAAqB3R,UAAU,IACnC,GAAI2Z,GAAApP,sBAAsBC,cAAeA,IACzC,GAAIwP,GAAAtqB,iBACJ,GAAI8pB,GAAAljB,yBAIR,OAAO,IAAIpG,GAAAmB,aACTpE,YACE,GAAImtB,GAAAxP,gBACJ,GAAImP,GAAA7qB,kBACJ,GAAI4rB,GAAAzc,sBACJ,GAAIwb,GAAA3F,UACJ,GAAIgG,GAAA1b,sBACJ0gB,EACA,GAAI5E,GAAA9N,SACJ,GAAIyN,GAAApkB,qBACHtD,YAAa,oBAIpB,QAAAotB,IAA8Bt5B,EAAgB2B,GAC5C,WAD4C,KAAAA,IAAAA,MACrC,GAAIqzB,GAAUh1B,IACnB+1B,GAAIoD,IACJ7C,UAAW,SAACQ,GACV,MAAOA,GAAQC,cAGjBhB,GAAImD,MACFv3B,GAGN,QAAA43B,IAA0Cv5B,EAAgB2B,GACxD,WADwD,KAAAA,IAAAA,MACjD,GAAIqzB,GAAUh1B,EAAQo5B,IAAwBz3B,GAGvD,QAAA63B,IAAkCx5B,EAAgB2B,GAChD,WADgD,KAAAA,IAAAA,MACzC,GAAIqzB,GAAUh1B,EAAQq5B,IAAgB13B,GA3b/Bu2B,EAAAC,eAAcA,EAIdD,EAAAG,0BAAyBA,EAIzBH,EAAAK,2BAA0BA,EAuQ1BL,EAAAE,cAAaA,EAwBbF,EAAAI,yBAAwBA,EAWxBJ,EAAAM,0BAAyBA,EAyHzBN,EAAAoB,cAAaA,GAWbpB,EAAAqB,0BAAyBA,GAIzBrB,EAAAsB,kBAAiBA,IA5bRxE,EAAAkD,UAAAlD,EAAAkD,cAAVlD,EAAA31B,EAAA21B,YAAA31B,EAAA21B,eAjPJ31B,EAAA21B,UAAAA,CAgsBb,IAAAC,GAAA,WAiBE,QAAAA,GAAYj1B,EAAgB+1B,EAAiBp0B,OAAA,KAAAA,IAAAA,MAZrCxB,KAAAs5B,QACN7d,aAAc,GAAInU,GAAAE,gBAClBkQ,OAAQ,GAAIpQ,GAAAE,gBACZ+R,cAAe,GAAIjS,GAAAE,gBACnBmQ,SAAU,GAAIrQ,GAAAE,gBACdyE,gBAAiB,GAAI3E,GAAAE,gBACrB0E,gBAAiB,GAAI5E,GAAAE,gBACrB0C,eAAgB,GAAI5C,GAAAE,gBACpBoH,sBAAuB,GAAItH,GAAAE,gBAC3BsC,eAAgB,GAAIxC,GAAAE,iBAIpBxH,KAAKu5B,cAAgB,GAAIzD,GAAcj2B,GACvCG,KAAK41B,GAAKA,EACV51B,KAAKwB,OAASA,EAgGlB,MA7FEszB,GAAAn1B,UAAAQ,UAAA,WACE,MAAOH,MAAKwB,QAGdszB,EAAAn1B,UAAAw3B,MAAA,WACE,MAAOn3B,MAAK41B,IAGdd,EAAAn1B,UAAA63B,UAAA,WACE,MAAOx3B,MAAKu5B,cAAc/B,aAO5BjvB,OAAAC,eAAIssB,EAAAn1B,UAAA,oBAAJ,WACE,MAAOK,MAAKs5B,OAAO7d,8CAOrBlT,OAAAC,eAAIssB,EAAAn1B,UAAA,cAAJ,WACE,MAAOK,MAAKs5B,OAAO5hB,wCAOrBnP,OAAAC,eAAIssB,EAAAn1B,UAAA,qBAAJ,WACE,MAAOK,MAAKs5B,OAAO/f,+CAOrBhR,OAAAC,eAAIssB,EAAAn1B,UAAA,gBAAJ,WACE,MAAOK,MAAKs5B,OAAO3hB,0CAOrBpP,OAAAC,eAAIssB,EAAAn1B,UAAA,uBAAJ,WACE,MAAOK,MAAKs5B,OAAOrtB,iDAOrB1D,OAAAC,eAAIssB,EAAAn1B,UAAA,uBAAJ,WACE,MAAOK,MAAKs5B,OAAOptB,iDAOrB3D,OAAAC,eAAIssB,EAAAn1B,UAAA,sBAAJ,WACE,MAAOK,MAAKs5B,OAAOpvB,gDAOrB3B,OAAAC,eAAIssB,EAAAn1B,UAAA,6BAAJ,WACE,MAAOK,MAAKs5B,OAAO1qB,uDAOrBrG,OAAAC,eAAIssB,EAAAn1B,UAAA,sBAAJ,WACE,MAAOK,MAAKs5B,OAAOxvB,gDAGXgrB,EAAAn1B,UAAAk4B,mBAAV,WACE73B,KAAKu5B,cAAc1B,oBAEnB,IAAIyB,GAAct5B,KAAKs5B,MACvB,KAAK,GAAIE,KAASF,GAAQ,CAC0BA,EAAOE,GAC9CtH,mBAGjB4C,IApHa51B,GAAA41B,kBAAAA,CA0Hb,IAAAsB,GAAA,SAAA32B,GAAA,QAAA22B,oDA2EA,MA3EwC12B,GAAA02B,EAAA32B,GAKtC22B,EAAAz2B,UAAA23B,iBAAA,WAIE,MAAsBt3B,MAAKw3B,aAG7BpB,EAAAz2B,UAAA+3B,kBAAA,WACE13B,KAAKy5B,sBAAsBz5B,KAAKm3B,SAChCn3B,KAAK05B,YAAa,GAGpBtD,EAAAz2B,UAAAy3B,aAAA,WACE,MAAOp3B,MAAK05B,YAGNtD,EAAAz2B,UAAA85B,sBAAR,SAA8BjsB,GAA9B,GAAAzN,GAAAC,KACM25B,IAEJr4B,GAAAkN,QAAQC,aAAajB,EAAW,SAACA,GAM/B,IAAgC,GAAApJ,GAAA,EAAAw1B,EAAAD,EAAAv1B,EAAAw1B,EAAAx6B,OAAAgF,IAAoB,CAClD,GAD0Bw1B,EAAAx1B,KACEoJ,EAQ1B,KALIhK,UACFA,QAAQq2B,MAAM,gCAAiCrsB,GAI3CzO,MAAM,kCAAoCyO,EAAUssB,YAAYC,MAI1EvsB,EAAU1C,aACV0C,EAAU5N,UAAUG,EAAKy3B,YAAaz3B,GACtC45B,EAAqBlsB,KAAKD,MAI9B4oB,EAAAz2B,UAAAi4B,gBAAA,WAEM53B,KAAK05B,aACP15B,KAAKg6B,oBAAoBh6B,KAAKm3B,SAC9Bn3B,KAAK05B,YAAa,GAEpB15B,KAAKi6B,UAAW,GAGlB7D,EAAAz2B,UAAAu6B,WAAA,WACE,MAAOl6B,MAAKi6B,UAGN7D,EAAAz2B,UAAAq6B,oBAAR,SAA4BxsB,GAG1B,GAFAA,EAAU5C,UAEN4C,YAAqBvH,GAAAmB,UACvB,IAA2B,GAAAhD,GAAA,EAAA2J,EAAAP,EAAUK,gBAAVzJ,EAAA2J,EAAA3O,OAAAgF,IAAyB,CAA/C,GAAI+1B,GAAcpsB,EAAA3J,EACrBpE,MAAKg6B,oBAAoBG,KAK/B/D,EAAAz2B,UAAAk4B,mBAAA,WACEp4B,EAAAE,UAAMk4B,mBAAkB14B,KAAAa,OAE5Bo2B,GA3EwCtB,GA6FxCgB,EAAA,WAOE,QAAAA,GAAYj2B,GAAZ,GAAAE,GAAAC,IAFQA,MAAAo6B,iBAGNp6B,KAAKH,OAASA,CAGd,IAAIw6B,KACJ,KAAK,GAAIC,KAAUz6B,GACoB,kBAApBA,GAAQy6B,IACvBD,EAAQ5sB,KAAK6sB,EAOjB,KAAmB,GADfC,MACen2B,EAAA,EAAAo2B,EAAAH,EAAAj2B,EAAAo2B,EAAAp7B,OAAAgF,IAAO,CAArB,GAAIk2B,GAAME,EAAAp2B,aAANk2B,GACPC,EAAQD,GAAU,WAEhB,MAAaz6B,GAAQy6B,GAAQG,MAAM56B,EAAQivB,aAHtCwL,GAQT,IAAK,GAAIA,KAAUz6B,GACoB,kBAApBA,GAAQy6B,KACvBC,EAAQD,GAAgBz6B,EAAQy6B,GAKpCC,GAAQj6B,gBAAkB,SAACo6B,EAAkBzF,GAS3C,MARAp1B,GAAOS,gBAAgBo6B,EAAWzF,GAE7Bl1B,EAAKq6B,cAAcM,KACtB36B,EAAKq6B,cAAcM,OAGrB36B,EAAKq6B,cAAcM,GAAWjtB,KAAKwnB,GAE5BsF,GAITA,EAAQl4B,mBAAqB,SAACq4B,EAAkBzF,GAO9C,MANAp1B,GAAOwC,mBAAmBq4B,EAAWzF,GAEjCl1B,EAAKq6B,cAAcM,IACrBp5B,EAAAqM,WAAWC,OAAO7N,EAAKq6B,cAAcM,GAAYzF,GAG5CsF,GAGTA,EAAQhD,cAAgB,SAAC92B,EAAcwE,GACrC,GAAIlF,EAAKq6B,cAAc35B,GAUrB,IAAqB,GARjBk6B,GAA+BpyB,OAAO+D,WACxCsuB,UAAW9pB,KAAKD,MAChBjJ,KAAMnH,EAENo6B,WAAW,GACV51B,GAGkBb,EAAA,EAAA2J,EAAAhO,EAAKq6B,cAAc35B,GAAnB2D,EAAA2J,EAAA3O,OAAAgF,IAAyB,CAAzC,GAAI6wB,GAAQlnB,EAAA3J,EACf6wB,GAAS0F,KAKf36B,KAAKu6B,QAAyBA,EAqBlC,MAdEzE,GAAAn2B,UAAA63B,UAAA,WACE,MAAOx3B,MAAKu6B,SAMdzE,EAAAn2B,UAAAk4B,mBAAA,WACE,IAAK,GAAI6C,KAAa16B,MAAKo6B,cACzB,IAAqB,GAAAh2B,GAAA,EAAA2J,EAAA/N,KAAKo6B,cAAcM,GAAnBt2B,EAAA2J,EAAA3O,OAAAgF,IAA6B,CAA7C,GAAI6wB,GAAQlnB,EAAA3J,EACfpE,MAAKH,OAAOwC,mBAAmBq4B,EAAWzF,KAIlDa,m8CC/lCA,IAAAxuB,GAAA1I,EAAA,qBAEAqH,EAAArH,EAAA,2BAEA,SAAiB+O,GAOf,QAAAC,GAA0BktB,EAAYloB,GACpC,GAAIV,GAAQ4oB,EAAM7D,QAAQrkB,EAE1B,OAAIV,IAAS,EACJ4oB,EAAMC,OAAO7oB,EAAO,GAAG,GAEvB,KANKvE,EAAAC,OAAMA,GAPP1O,EAAAyO,aAAAzO,EAAAyO,iBAkBjB,SAAiB7L,GAYf,QAAA6U,GAA8BqkB,EAAsBC,OAAA,KAAAA,IAAAA,EAAiBn5B,EAAAwU,cACnE,IAAI4kB,GAAaF,EAAe,CAE5BE,KAGFF,GAAgBA,EAIlB,IAAIG,GAAQhlB,KAAKilB,MAAMJ,EAAe,MAClCK,EAAUllB,KAAKilB,MAAMJ,EAAe,IAAc,GAARG,EAC1C7Z,EAAUnL,KAAKilB,MAAMJ,GAAgB,EAEzC,QAAQE,EAAa,IAAM,IAAMD,EAC5BlK,QAAQ,KAAMuK,EAAiBH,EAAO,IACtCpK,QAAQ,KAAMuK,EAAiBD,EAAS,IACxCtK,QAAQ,KAAMuK,EAAiBha,EAAS,IAW/C,QAAAga,GAA0BC,EAAsBn8B,GAC9C,GAAIuC,GAAO45B,EAAM,EAEjB,OADc,aAAaC,OAAO,EAAGp8B,EAASuC,EAAKvC,QAClCuC,EAyBnB,QAAAI,GAA6CE,EAAmBa,EAAoBjD,GAClF,GAAI47B,GAA4B,GAAIzK,QAClC,6GACA,IAGF,OAAO/uB,GAAU8uB,QAAQ0K,EAA2B,SAACC,GACnD,GAAI9e,GAAO,CAYX,OAXI8e,GAAazE,QAAQ,kBAAoB,EAEzCra,EADE9Z,EACKqT,KAAKwlB,KAAK74B,EAAajD,EAAOoD,kBAE9BpD,EAAO8V,cAAgB9V,EAAOoD,iBAE9By4B,EAAazE,QAAQ,eAAiB,EAC/Cra,EAAO/c,EAAOoD,iBACLy4B,EAAazE,QAAQ,eAAiB,IAC/Cra,EAAO/c,EAAO8V,eAETimB,EAAahf,EAAM8e,KAI9B,QAAAE,GAAsBhf,EAAcqe,GAClC,GAAIY,GAA8B,0DAI7BA,GAA4B3K,KAAK+J,KAEpCA,EAAS,KAIX,IAAIa,GAAgB,EAChBC,EAAuBd,EAAOe,MAVT,+BAWrBD,KACFD,EAAgB3pB,SAAS4pB,EAAqB,GAAG1R,UAAU,IAI7D,IAAI4R,GAAmB,KACnBC,EAAuBjB,EAAOe,MAhBT,aAyBzB,IARIE,IAAyB9S,MAAMjX,SAAS+pB,EAAqB,GAAG7R,UAAU,OAC5E4R,EAAmB9pB,SAAS+pB,EAAqB,GAAG7R,UAAU,KACvC,KACrB4R,EAAmB,IAKnBhB,EAAOhE,QAAQ,MAAQ,EAAG,CAC5B,GAAIkF,GAAa,EAUjB,OANEA,GAFuB,OAArBF,EAEWrf,EAAKwf,QAAQH,GAEb,GAAKrf,EAIhBuf,EAAWlF,QAAQ,MAAQ,EACtBqE,EAAiBa,EAAYA,EAAW/8B,QAAU08B,EAAgBK,EAAWlF,QAAQ,OAErFqE,EAAiBa,EAAYL,GAKnC,GAAIb,EAAOhE,QAAQ,MAAQ,EAAG,CACjC,GAAI+D,GAAe7kB,KAAKwlB,KAAK/e,EAG7B,IAAIqe,EAAOhE,QAAQ,OAAS,EAC1B,MAAOtgB,GAAcqkB,EAIrB,IAAIK,GAAUllB,KAAKilB,MAAMJ,EAAe,IACpC1Z,EAAU0Z,EAAe,EAE7B,OAAOM,GAAiBD,EAAS,GAAK,IAAMC,EAAiBha,EAAS,GAKxE,MAAOga,GAAiBnlB,KAAKwlB,KAAK/e,GAAOkf,GAzJlCh6B,EAAAwU,cAAwB,WACxBxU,EAAAyU,YAAsB,QASjBzU,EAAA6U,cAAaA,EAwDb7U,EAAAC,6BAA4BA,GApE7B7C,EAAA4C,cAAA5C,EAAA4C,kBAgKjB,SAAiBwT,GAYf,QAAA+mB,GAA+Bx8B,GAC7B,WAAqCuL,KAA9BvL,EAAOM,YAAYqT,OAG5B,QAAA8oB,GAAqCz8B,GACnC,MAAOA,GAAOsV,UAAyC,IAA7BtV,EAAOwW,kBAGnC,QAAAwT,GAAyBhqB,GACvB,MAAIA,GAAO08B,WACFpT,EAAYS,SACV/pB,EAAOyK,YACT6e,EAAYO,QACV7pB,EAAOgb,WACTsO,EAAYQ,OACV0S,EAAex8B,GACjBspB,EAAYM,SAEZN,EAAYK,KA1BvB,GAAYL,IAAZ,SAAYA,GACVA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,SAAA,GAAA,WACAA,EAAAA,EAAA,QAAA,GAAA,UACAA,EAAAA,EAAA,OAAA,GAAA,SACAA,EAAAA,EAAA,SAAA,GAAA,YALUA,EAAA7T,EAAA6T,cAAA7T,EAAA6T,iBAQI7T,EAAA+mB,eAAcA,EAId/mB,EAAAgnB,qBAAoBA,EAIpBhnB,EAAAuU,SAAQA,CAkBxB,IAAAvS,GAAA,WAIE,QAAAA,GAAYzX,GAAZ,GAAAE,GAAAC,IAFQA,MAAAw8B,kCAAoC,GAAIl1B,GAAAE,eAG9C,IAAIgQ,OAA8BpM,GAE9BqxB,EAAoB,WACtB,GAAI58B,EAAOsV,SAAU,CACnB,GAAIunB,GAAwBpnB,EAAYgnB,qBAAqBz8B,EAGzD68B,KAA0BllB,IAC5BzX,EAAKy8B,kCAAkCl0B,SAASzI,GAAU2X,mBAAoBklB,IAC9EllB,EAAqBklB,IAK3B78B,GAAOS,gBAAgBT,EAAOU,MAAMwE,SAAU03B,GAG9C58B,EAAOS,gBAAgBT,EAAOU,MAAM2B,gBAAiBu6B,GAMzD,MAHEl0B,QAAAC,eAAI8O,EAAA3X,UAAA,sCAAJ,WACE,MAAOK,MAAKw8B,kCAAkC/zB,4CAElD6O,IA5BahC,GAAAgC,8BAA6BA,CA8C1C,IAAA/B,GAAA,WAIE,QAAAA,GAAY1V,GAAZ,GAAAE,GAAAC,IAFQA,MAAA28B,iBAAmB,GAAIr1B,GAAAE,eAG7B,IAAIoN,OAAgBxJ,GAEhBwxB,EAAe,WACjB,GAAIC,GAAUh9B,EAAOsV,QAIjB0nB,KAAYjoB,IACd7U,EAAK48B,iBAAiBr0B,SAASzI,GAAU+U,KAAMioB,IAC/CjoB,EAAOioB,GAIXh9B,GAAOS,gBAAgBT,EAAOU,MAAMwE,SAAU63B,GAE9C/8B,EAAOS,gBAAgBT,EAAOU,MAAMiK,QAASoyB,GAKzC7H,EAAa+H,WAAa/H,EAAagI,UACzCl9B,EAAOS,gBAAgBT,EAAOU,MAAM2B,gBAAiB06B,GAO3D,MAHEr0B,QAAAC,eAAI+M,EAAA5V,UAAA,qBAAJ,WACE,MAAOK,MAAK28B,iBAAiBl0B,4CAEjC8M,IAjCaD,GAAAC,mBAAkBA,GApFhBrW,EAAAoW,cAAApW,EAAAoW,kBAwHjB,SAAiB9G,GAKf,QAAAC,GAA6BjB,EAAuCwvB,GAClE,GAAIC,GAAsB,SAACzvB,EAAuCsiB,GAIhE,GAHAkN,EAAMxvB,EAAWsiB,GAGbtiB,YAAqBvH,GAAAmB,UACvB,IAA2B,GAAAhD,GAAA,EAAA2J,EAAAP,EAAUK,gBAAVzJ,EAAA2J,EAAA3O,OAAAgF,IAAyB,CAA/C,GAAI+1B,GAAcpsB,EAAA3J,EACrB64B,GAAoB9C,EAAgB3sB,IAM1CyvB,GAAoBzvB,GAbNgB,EAAAC,aAAYA,GALbvP,EAAAsP,UAAAtP,EAAAsP,YAsBjB,IAAiBumB,IAAjB,SAAiBA,GAMFA,EAAAuB,SAAW4G,WAAaA,UAAUC,WAAa,OAAOjM,KAAKgM,UAAUC,WAErEpI,EAAAgI,SAAWG,WAAaA,UAAUC,WAAa,SAASjM,KAAKgM,UAAUC,WAEvEpI,EAAA+H,UAAYI,WAAaA,UAAUC,WAAa,UAAUjM,KAAKgM,UAAUC,YAVvEpI,EAAA71B,EAAA61B,eAAA71B,EAAA61B","file":"bitmovinplayer-ui.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import {ClickOverlay} from './clickoverlay';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A simple click capture overlay for clickThroughUrls of ads.\n */\nexport class AdClickOverlay extends ClickOverlay {\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let clickThroughUrl = <string>null;\n    let clickThroughEnabled = !player.getConfig().advertising\n      || !player.getConfig().advertising.hasOwnProperty('clickThroughEnabled')\n      || player.getConfig().advertising.clickThroughEnabled;\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, (event: bitmovin.player.AdStartedEvent) => {\n      clickThroughUrl = event.clickThroughUrl;\n\n      if (clickThroughEnabled) {\n        this.setUrl(clickThroughUrl);\n      } else {\n        // If click-through is disabled, we set the url to null to avoid it open\n        this.setUrl(null);\n      }\n    });\n\n    // Clear click-through URL when ad has finished\n    let adFinishedHandler = () => {\n      this.setUrl(null);\n    };\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adFinishedHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adFinishedHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adFinishedHandler);\n\n    this.onClick.subscribe(() => {\n      // Pause the ad when overlay is clicked\n      player.pause('ui-content-click');\n\n      // Notify the player of the clicked ad\n      player.fireEvent(player.EVENT.ON_AD_CLICKED, {\n        clickThroughUrl: clickThroughUrl\n      });\n    });\n  }\n}","import {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {StringUtils} from '../utils';\n\n/**\n * A label that displays a message about a running ad, optionally with a countdown.\n */\nexport class AdMessageLabel extends Label<LabelConfig> {\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-label-ad-message',\n      text: 'This ad will end in {remainingTime} seconds.'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let text = this.getConfig().text;\n\n    let updateMessageHandler = () => {\n      this.setText(StringUtils.replaceAdMessagePlaceholders(text, null, player));\n    };\n\n    let adStartHandler = (event: bitmovin.player.AdStartedEvent) => {\n      text = event.adMessage || text;\n      updateMessageHandler();\n\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, updateMessageHandler);\n      player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateMessageHandler);\n    };\n\n    let adEndHandler = () => {\n      player.removeEventHandler(player.EVENT.ON_TIME_CHANGED, updateMessageHandler);\n      player.removeEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateMessageHandler);\n    };\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, adStartHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adEndHandler);\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {UIInstanceManager} from '../uimanager';\nimport SkipMessage = bitmovin.player.SkipMessage;\nimport {StringUtils} from '../utils';\n\n/**\n * Configuration interface for the {@link AdSkipButton}.\n */\nexport interface AdSkipButtonConfig extends ButtonConfig {\n  skipMessage?: SkipMessage;\n}\n\n/**\n * A button that is displayed during ads and can be used to skip the ad.\n */\nexport class AdSkipButton extends Button<AdSkipButtonConfig> {\n\n  constructor(config: AdSkipButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <AdSkipButtonConfig>{\n      cssClass: 'ui-button-ad-skip',\n      skipMessage: {\n        countdown: 'Skip ad in {remainingTime}',\n        skip: 'Skip ad'\n      }\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <AdSkipButtonConfig>this.getConfig(); // TODO get rid of generic cast\n    let skipMessage = config.skipMessage;\n    let adEvent = <bitmovin.player.AdStartedEvent>null;\n\n    let updateSkipMessageHandler = () => {\n      // Display this button only if ad is skippable\n      if (adEvent.skipOffset) {\n        this.show();\n      } else {\n        this.hide();\n      }\n\n      // Update the skip message on the button\n      if (player.getCurrentTime() < adEvent.skipOffset) {\n        this.setText(\n          StringUtils.replaceAdMessagePlaceholders(config.skipMessage.countdown, adEvent.skipOffset, player));\n      } else {\n        this.setText(config.skipMessage.skip);\n      }\n    };\n\n    let adStartHandler = (event: bitmovin.player.AdStartedEvent) => {\n      adEvent = event;\n      skipMessage = adEvent.skipMessage || skipMessage;\n      updateSkipMessageHandler();\n\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, updateSkipMessageHandler);\n      player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateSkipMessageHandler);\n    };\n\n    let adEndHandler = () => {\n      player.removeEventHandler(player.EVENT.ON_TIME_CHANGED, updateSkipMessageHandler);\n      player.removeEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateSkipMessageHandler);\n    };\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, adStartHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adEndHandler);\n\n    this.onClick.subscribe(() => {\n      // Try to skip the ad (this only works if it is skippable so we don't need to take extra care of that here)\n      player.skipAd();\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles Apple AirPlay.\n */\nexport class AirPlayToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-airplaytogglebutton',\n      text: 'Apple AirPlay'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      if (player.isAirplayAvailable()) {\n        player.showAirplayTargetPicker();\n      } else {\n        if (console) {\n          console.log('AirPlay unavailable');\n        }\n      }\n    });\n\n    let airPlayAvailableHandler = () => {\n      if (player.isAirplayAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_AIRPLAY_AVAILABLE, airPlayAvailableHandler);\n\n    // Startup init\n    airPlayAvailableHandler(); // Hide button if AirPlay is not available\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between 'auto' and the available audio qualities.\n */\nexport class AudioQualitySelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let updateAudioQualities = () => {\n      let audioQualities = player.getAvailableAudioQualities();\n\n      this.clearItems();\n\n      // Add entry for automatic quality switching (default setting)\n      this.addItem('Auto', 'Auto');\n\n      // Add audio qualities\n      for (let audioQuality of audioQualities) {\n        this.addItem(audioQuality.id, audioQuality.label);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: AudioQualitySelectBox, value: string) => {\n      player.setAudioQuality(value);\n    });\n\n    // Update qualities when audio track has changed\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, updateAudioQualities);\n    // Update qualities when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateAudioQualities);\n    // Update qualities when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateAudioQualities);\n    // Update quality selection when quality is changed (from outside)\n    player.addEventHandler(player.EVENT.ON_AUDIO_DOWNLOAD_QUALITY_CHANGE, () => {\n      let data = player.getDownloadedAudioData();\n      this.selectItem(data.isAuto ? 'Auto' : data.id);\n    });\n\n    // Populate qualities at startup\n    updateAudioQualities();\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between available audio tracks (e.g. different languages).\n */\nexport class AudioTrackSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    // TODO Move to config?\n    let getAudioTrackLabel = (id: string) => {\n      switch (id) {\n        case 'en_stereo':\n          return 'English - Stereo';\n        case 'no-voices_stereo':\n          return 'No Voices - Stereo';\n        case 'en_surround':\n          return 'English - Surround';\n        default:\n          return id\n      }\n    }\n\n    let updateAudioTracks = () => {\n      let audioTracks = player.getAvailableAudio();\n\n      this.clearItems();\n\n      // Add audio tracks\n      for (let audioTrack of audioTracks) {\n        this.addItem(audioTrack.id, getAudioTrackLabel(audioTrack.label));\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: AudioTrackSelectBox, value: string) => {\n      player.setAudio(value);\n    });\n\n    let audioTrackHandler = () => {\n      let currentAudioTrack = player.getAudio();\n\n      // HLS streams don't always provide this, so we have to check\n      if (currentAudioTrack) {\n        this.selectItem(currentAudioTrack.id);\n      }\n    };\n\n    // Update selection when selected track has changed\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, audioTrackHandler);\n    // Update tracks when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateAudioTracks);\n    // Update tracks when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateAudioTracks);\n\n    // Populate tracks at startup\n    updateAudioTracks();\n\n    // When `playback.audioLanguage` is set, the `ON_AUDIO_CHANGED` event for that change is triggered before the\n    // UI is created. Therefore we need to set the audio track on configure.\n    audioTrackHandler();\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {Component, ComponentConfig} from './component';\nimport {Timeout} from '../timeout';\n\n/**\n * Configuration interface for the {@link BufferingOverlay} component.\n */\nexport interface BufferingOverlayConfig extends ContainerConfig {\n  /**\n   * Delay in milliseconds after which the buffering overlay will be displayed. Useful to bypass short stalls without\n   * displaying the overlay. Set to 0 to display the overlay instantly.\n   * Default: 1000ms (1 second)\n   */\n  showDelayMs?: number;\n}\n\n/**\n * Overlays the player and displays a buffering indicator.\n */\nexport class BufferingOverlay extends Container<BufferingOverlayConfig> {\n\n  private indicators: Component<ComponentConfig>[];\n\n  constructor(config: BufferingOverlayConfig = {}) {\n    super(config);\n\n    this.indicators = [\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n    ];\n\n    this.config = this.mergeConfig(config, <BufferingOverlayConfig>{\n      cssClass: 'ui-buffering-overlay',\n      hidden: true,\n      components: this.indicators,\n      showDelayMs: 1000,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <BufferingOverlayConfig>this.getConfig();\n\n    let overlayShowTimeout = new Timeout(config.showDelayMs, () => {\n      this.show();\n    });\n\n    let showOverlay = () => {\n      overlayShowTimeout.start();\n    };\n\n    let hideOverlay = () => {\n      overlayShowTimeout.clear();\n      this.hide();\n    };\n\n    player.addEventHandler(player.EVENT.ON_STALL_STARTED, showOverlay);\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, hideOverlay);\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, hideOverlay);\n\n    // Show overlay if player is already stalled at init\n    if (player.isStalled()) {\n      this.show();\n    }\n  }\n}\n","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {EventDispatcher, NoArgs, Event} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link Button} component.\n */\nexport interface ButtonConfig extends ComponentConfig {\n  /**\n   * The text on the button.\n   */\n  text?: string;\n}\n\n/**\n * A simple clickable button.\n */\nexport class Button<Config extends ButtonConfig> extends Component<ButtonConfig> {\n\n  private buttonEvents = {\n    onClick: new EventDispatcher<Button<Config>, NoArgs>()\n  };\n\n  constructor(config: ButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-button'\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    // Create the button element with the text label\n    let buttonElement = new DOM('button', {\n      'type': 'button',\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    }).append(new DOM('span', {\n      'class': this.prefixCss('label')\n    }).html(this.config.text));\n\n    // Listen for the click event on the button element and trigger the corresponding event on the button component\n    buttonElement.on('click', () => {\n      this.onClickEvent();\n    });\n\n    return buttonElement;\n  }\n\n  /**\n   * Sets text on the label of the button.\n   * @param text the text to put into the label of the button\n   */\n  setText(text: string): void {\n    this.getDomElement().find('.' + this.prefixCss('label')).html(text);\n  }\n\n  protected onClickEvent() {\n    this.buttonEvents.onClick.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the button is clicked.\n   * @returns {Event<Button<Config>, NoArgs>}\n   */\n  get onClick(): Event<Button<Config>, NoArgs> {\n    return this.buttonEvents.onClick.getEvent();\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport CastWaitingForDeviceEvent = bitmovin.player.CastWaitingForDeviceEvent;\nimport CastStartedEvent = bitmovin.player.CastStartedEvent;\n\n/**\n * Overlays the player and displays the status of a Cast session.\n */\nexport class CastStatusOverlay extends Container<ContainerConfig> {\n\n  private statusLabel: Label<LabelConfig>;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.statusLabel = new Label<LabelConfig>({ cssClass: 'ui-cast-status-label' });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-cast-status-overlay',\n      components: [this.statusLabel],\n      hidden: true\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    player.addEventHandler(player.EVENT.ON_CAST_WAITING_FOR_DEVICE,\n      (event: CastWaitingForDeviceEvent) => {\n        this.show();\n        // Get device name and update status text while connecting\n        let castDeviceName = event.castPayload.deviceName;\n        this.statusLabel.setText(`Connecting to <strong>${castDeviceName}</strong>...`);\n      });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, (event: CastStartedEvent) => {\n      // Session is started or resumed\n      // For cases when a session is resumed, we do not receive the previous events and therefore show the status panel\n      // here too\n      this.show();\n      let castDeviceName = event.deviceName;\n      this.statusLabel.setText(`Playing on <strong>${castDeviceName}</strong>`);\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, (event) => {\n      // Cast session gone, hide the status panel\n      this.hide();\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles casting to a Cast receiver.\n */\nexport class CastToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-casttogglebutton',\n      text: 'Google Cast'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      if (player.isCastAvailable()) {\n        if (player.isCasting()) {\n          player.castStop();\n        } else {\n          player.castVideo();\n        }\n      } else {\n        if (console) {\n          console.log('Cast unavailable');\n        }\n      }\n    });\n\n    let castAvailableHander = () => {\n      if (player.isCastAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_CAST_AVAILABLE, castAvailableHander);\n\n    // Toggle button 'on' state\n    player.addEventHandler(player.EVENT.ON_CAST_WAITING_FOR_DEVICE, () => {\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      // When a session is resumed, there is no ON_CAST_START event, so we also need to toggle here for such cases\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, () => {\n      this.off();\n    });\n\n    // Startup init\n    castAvailableHander(); // Hide button if Cast not available\n    if (player.isCasting()) {\n      this.on();\n    }\n  }\n}","import {UIContainer, UIContainerConfig} from './uicontainer';\nimport {UIInstanceManager} from '../uimanager';\nimport {Timeout} from '../timeout';\n\n/**\n * The base container for Cast receivers that contains all of the UI and takes care that the UI is shown on\n * certain playback events.\n */\nexport class CastUIContainer extends UIContainer {\n\n  private castUiHideTimeout: Timeout;\n\n  constructor(config: UIContainerConfig) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <UIContainerConfig>this.getConfig();\n\n    /*\n     * Show UI on Cast devices at certain playback events\n     *\n     * Since a Cast receiver does not have a direct HCI, we show the UI on certain playback events to give the user\n     * a chance to see on the screen what's going on, e.g. on play/pause or a seek the UI is shown and the user can\n     * see the current time and position on the seek bar.\n     * The UI is shown permanently while playback is paused, otherwise hides automatically after the configured\n     * hide delay time.\n     */\n\n    let isUiShown = false;\n\n    let hideUi = () => {\n      uimanager.onControlsHide.dispatch(this);\n      isUiShown = false;\n    };\n\n    this.castUiHideTimeout = new Timeout(config.hideDelay, hideUi);\n\n    let showUi = () => {\n      if (!isUiShown) {\n        uimanager.onControlsShow.dispatch(this);\n        isUiShown = true;\n      }\n    };\n\n    let showUiPermanently = () => {\n      showUi();\n      this.castUiHideTimeout.clear();\n    };\n\n    let showUiWithTimeout = () => {\n      showUi();\n      this.castUiHideTimeout.start();\n    };\n\n    let showUiAfterSeek = () => {\n      if (player.isPlaying()) {\n        showUiWithTimeout();\n      } else {\n        showUiPermanently();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_PLAY, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_PAUSED, showUiPermanently);\n    player.addEventHandler(player.EVENT.ON_SEEK, showUiPermanently);\n    player.addEventHandler(player.EVENT.ON_SEEKED, showUiAfterSeek);\n  }\n\n  release(): void {\n    super.release();\n    this.castUiHideTimeout.clear();\n  }\n}","import {Button, ButtonConfig} from './button';\n\n/**\n * Configuration interface for a {@link ClickOverlay}.\n */\nexport interface ClickOverlayConfig extends ButtonConfig {\n  /**\n   * The url to open when the overlay is clicked. Set to null to disable the click handler.\n   */\n  url?: string;\n}\n\n/**\n * A click overlay that opens an url in a new tab if clicked.\n */\nexport class ClickOverlay extends Button<ClickOverlayConfig> {\n\n  constructor(config: ClickOverlayConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-clickoverlay'\n    }, <ClickOverlayConfig>this.config);\n  }\n\n  initialize(): void {\n    super.initialize();\n\n    this.setUrl((<ClickOverlayConfig>this.config).url);\n    let element = this.getDomElement();\n    element.on('click', () => {\n      if (element.data('url')) {\n        window.open(element.data('url'), '_blank');\n      }\n    });\n  }\n\n  /**\n   * Gets the URL that should be followed when the watermark is clicked.\n   * @returns {string} the watermark URL\n   */\n  getUrl(): string {\n    return this.getDomElement().data('url');\n  }\n\n  setUrl(url: string): void {\n    if (url === undefined || url == null) {\n      url = '';\n    }\n    this.getDomElement().data('url', url);\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {UIInstanceManager} from '../uimanager';\nimport {Component, ComponentConfig} from './component';\n\n/**\n * Configuration interface for the {@link CloseButton}.\n */\nexport interface CloseButtonConfig extends ButtonConfig {\n  /**\n   * The component that should be closed when the button is clicked.\n   */\n  target: Component<ComponentConfig>;\n}\n\n/**\n * A button that closes (hides) a configured component.\n */\nexport class CloseButton extends Button<CloseButtonConfig> {\n\n  constructor(config: CloseButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-closebutton',\n      text: 'Close'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <CloseButtonConfig>this.getConfig();\n\n    this.onClick.subscribe(() => {\n      config.target.hide();\n    });\n  }\n}","import {Guid} from '../guid';\nimport {DOM} from '../dom';\nimport {EventDispatcher, NoArgs, Event} from '../eventdispatcher';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Base configuration interface for a component.\n * Should be extended by components that want to add additional configuration options.\n */\nexport interface ComponentConfig {\n  /**\n   * The HTML tag name of the component.\n   * Default: 'div'\n   */\n  tag?: string;\n  /**\n   * The HTML ID of the component.\n   * Default: automatically generated with pattern 'ui-id-{guid}'.\n   */\n  id?: string;\n\n  /**\n   * A prefix to prepend all CSS classes with.\n   */\n  cssPrefix?: string;\n\n  /**\n   * The CSS classes of the component. This is usually the class from where the component takes its styling.\n   */\n  cssClass?: string; // 'class' is a reserved keyword, so we need to make the name more complicated\n\n  /**\n   * Additional CSS classes of the component.\n   */\n  cssClasses?: string[];\n\n  /**\n   * Specifies if the component should be hidden at startup.\n   * Default: false\n   */\n  hidden?: boolean;\n}\n\nexport interface ComponentHoverChangedEventArgs extends NoArgs {\n  /**\n   * True is the component is hovered, else false.\n   */\n  hovered: boolean;\n}\n\n/**\n * The base class of the UI framework.\n * Each component must extend this class and optionally the config interface.\n */\nexport class Component<Config extends ComponentConfig> {\n\n  /**\n   * The classname that is attached to the element when it is in the hidden state.\n   * @type {string}\n   */\n  private static readonly CLASS_HIDDEN = 'hidden';\n\n  /**\n   * Configuration object of this component.\n   */\n  protected config: Config;\n\n  /**\n   * The component's DOM element.\n   */\n  private element: DOM;\n\n  /**\n   * Flag that keeps track of the hidden state.\n   */\n  private hidden: boolean;\n\n  /**\n   * Flag that keeps track of the hover state.\n   */\n  private hovered: boolean;\n\n  /**\n   * The list of events that this component offers. These events should always be private and only directly\n   * accessed from within the implementing component.\n   *\n   * Because TypeScript does not support private properties with the same name on different class hierarchy levels\n   * (i.e. superclass and subclass cannot contain a private property with the same name), the default naming\n   * convention for the event list of a component that should be followed by subclasses is the concatenation of the\n   * camel-cased class name + 'Events' (e.g. SubClass extends Component => subClassEvents).\n   * See {@link #componentEvents} for an example.\n   *\n   * Event properties should be named in camel case with an 'on' prefix and in the present tense. Async events may\n   * have a start event (when the operation starts) in the present tense, and must have an end event (when the\n   * operation ends) in the past tense (or present tense in special cases (e.g. onStart/onStarted or onPlay/onPlaying).\n   * See {@link #componentEvents#onShow} for an example.\n   *\n   * Each event should be accompanied with a protected method named by the convention eventName + 'Event'\n   * (e.g. onStartEvent), that actually triggers the event by calling {@link EventDispatcher#dispatch dispatch} and\n   * passing a reference to the component as first parameter. Components should always trigger their events with these\n   * methods. Implementing this pattern gives subclasses means to directly listen to the events by overriding the\n   * method (and saving the overhead of passing a handler to the event dispatcher) and more importantly to trigger\n   * these events without having access to the private event list.\n   * See {@link #onShow} for an example.\n   *\n   * To provide external code the possibility to listen to this component's events (subscribe, unsubscribe, etc.),\n   * each event should also be accompanied by a public getter function with the same name as the event's property,\n   * that returns the {@link Event} obtained from the event dispatcher by calling {@link EventDispatcher#getEvent}.\n   * See {@link #onShow} for an example.\n   *\n   * Full example for an event representing an example action in a example component:\n   *\n   * <code>\n   * // Define an example component class with an example event\n   * class ExampleComponent extends Component<ComponentConfig> {\n     *\n     *     private exampleComponentEvents = {\n     *         onExampleAction: new EventDispatcher<ExampleComponent, NoArgs>()\n     *     }\n     *\n     *     // constructor and other stuff...\n     *\n     *     protected onExampleActionEvent() {\n     *        this.exampleComponentEvents.onExampleAction.dispatch(this);\n     *    }\n     *\n     *    get onExampleAction(): Event<ExampleComponent, NoArgs> {\n     *        return this.exampleComponentEvents.onExampleAction.getEvent();\n     *    }\n     * }\n   *\n   * // Create an instance of the component somewhere\n   * var exampleComponentInstance = new ExampleComponent();\n   *\n   * // Subscribe to the example event on the component\n   * exampleComponentInstance.onExampleAction.subscribe(function (sender: ExampleComponent) {\n     *     console.log('onExampleAction of ' + sender + ' has fired!');\n     * });\n   * </code>\n   */\n  private componentEvents = {\n    onShow: new EventDispatcher<Component<Config>, NoArgs>(),\n    onHide: new EventDispatcher<Component<Config>, NoArgs>(),\n    onHoverChanged: new EventDispatcher<Component<Config>, ComponentHoverChangedEventArgs>(),\n  };\n\n  /**\n   * Constructs a component with an optionally supplied config. All subclasses must call the constructor of their\n   * superclass and then merge their configuration into the component's configuration.\n   * @param config the configuration for the component\n   */\n  constructor(config: ComponentConfig = {}) {\n    // Create the configuration for this component\n    this.config = <Config>this.mergeConfig(config, {\n      tag: 'div',\n      id: 'bmpui-id-' + Guid.next(),\n      cssPrefix: 'bmpui',\n      cssClass: 'ui-component',\n      cssClasses: [],\n      hidden: false\n    }, {});\n  }\n\n  /**\n   * Initializes the component, e.g. by applying config settings.\n   * This method must not be called from outside the UI framework.\n   *\n   * This method is automatically called by the {@link UIInstanceManager}. If the component is an inner component of\n   * some component, and thus encapsulated abd managed internally and never directly exposed to the UIManager,\n   * this method must be called from the managing component's {@link #initialize} method.\n   */\n  initialize(): void {\n    this.hidden = this.config.hidden;\n\n    // Hide the component at initialization if it is configured to be hidden\n    if (this.isHidden()) {\n      this.hidden = false; // Set flag to false for the following hide() call to work (hide() checks the flag)\n      this.hide();\n    }\n  }\n\n  /**\n   * Configures the component for the supplied Player and UIInstanceManager. This is the place where all the magic\n   * happens, where components typically subscribe and react to events (on their DOM element, the Player, or the\n   * UIInstanceManager), and basically everything that makes them interactive.\n   * This method is called only once, when the UIManager initializes the UI.\n   *\n   * Subclasses usually overwrite this method to add their own functionality.\n   *\n   * @param player the player which this component controls\n   * @param uimanager the UIInstanceManager that manages this component\n   */\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    this.onShow.subscribe(() => {\n      uimanager.onComponentShow.dispatch(this);\n    });\n    this.onHide.subscribe(() => {\n      uimanager.onComponentHide.dispatch(this);\n    });\n\n    // Track the hovered state of the element\n    this.getDomElement().on('mouseenter', () => {\n      this.onHoverChangedEvent(true);\n    });\n    this.getDomElement().on('mouseleave', () => {\n      this.onHoverChangedEvent(false);\n    });\n  }\n\n  /**\n   * Releases all resources and dependencies that the component holds. Player, DOM, and UIManager events are\n   * automatically removed during release and do not explicitly need to be removed here.\n   * This method is called by the UIManager when it releases the UI.\n   *\n   * Subclasses that need to release resources should override this method and call super.release().\n   */\n  release(): void {\n    // Nothing to do here, override where necessary\n  }\n\n  /**\n   * Generate the DOM element for this component.\n   *\n   * Subclasses usually overwrite this method to extend or replace the DOM element with their own design.\n   */\n  protected toDomElement(): DOM {\n    let element = new DOM(this.config.tag, {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    return element;\n  }\n\n  /**\n   * Returns the DOM element of this component. Creates the DOM element if it does not yet exist.\n   *\n   * Should not be overwritten by subclasses.\n   *\n   * @returns {DOM}\n   */\n  getDomElement(): DOM {\n    if (!this.element) {\n      this.element = this.toDomElement();\n    }\n\n    return this.element;\n  }\n\n  /**\n   * Merges a configuration with a default configuration and a base configuration from the superclass.\n   *\n   * @param config the configuration settings for the components, as usually passed to the constructor\n   * @param defaults a default configuration for settings that are not passed with the configuration\n   * @param base configuration inherited from a superclass\n   * @returns {Config}\n   */\n  protected mergeConfig<Config>(config: Config, defaults: Config, base: Config): Config {\n    // Extend default config with supplied config\n    let merged = Object.assign({}, base, defaults, config);\n\n    // Return the extended config\n    return merged;\n  }\n\n  /**\n   * Helper method that returns a string of all CSS classes of the component.\n   *\n   * @returns {string}\n   */\n  protected getCssClasses(): string {\n    // Merge all CSS classes into single array\n    let flattenedArray = [this.config.cssClass].concat(this.config.cssClasses);\n    // Prefix classes\n    flattenedArray = flattenedArray.map((css) => {\n      return this.prefixCss(css);\n    });\n    // Join array values into a string\n    let flattenedString = flattenedArray.join(' ');\n    // Return trimmed string to prevent whitespace at the end from the join operation\n    return flattenedString.trim();\n  }\n\n  protected prefixCss(cssClassOrId: string): string {\n    return this.config.cssPrefix + '-' + cssClassOrId;\n  }\n\n  /**\n   * Returns the configuration object of the component.\n   * @returns {Config}\n   */\n  public getConfig(): Config {\n    return this.config;\n  }\n\n  /**\n   * Hides the component if shown.\n   * This method basically transfers the component into the hidden state. Actual hiding is done via CSS.\n   */\n  hide() {\n    if (!this.hidden) {\n      this.hidden = true;\n      this.getDomElement().addClass(this.prefixCss(Component.CLASS_HIDDEN));\n      this.onHideEvent();\n    }\n  }\n\n  /**\n   * Shows the component if hidden.\n   */\n  show() {\n    if (this.hidden) {\n      this.getDomElement().removeClass(this.prefixCss(Component.CLASS_HIDDEN));\n      this.hidden = false;\n      this.onShowEvent();\n    }\n  }\n\n  /**\n   * Determines if the component is hidden.\n   * @returns {boolean} true if the component is hidden, else false\n   */\n  isHidden(): boolean {\n    return this.hidden;\n  }\n\n  /**\n   * Determines if the component is shown.\n   * @returns {boolean} true if the component is visible, else false\n   */\n  isShown(): boolean {\n    return !this.isHidden();\n  }\n\n  /**\n   * Toggles the hidden state by hiding the component if it is shown, or showing it if hidden.\n   */\n  toggleHidden() {\n    if (this.isHidden()) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  }\n\n  /**\n   * Determines if the component is currently hovered.\n   * @returns {boolean} true if the component is hovered, else false\n   */\n  isHovered(): boolean {\n    return this.hovered;\n  }\n\n  /**\n   * Fires the onShow event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onShowEvent(): void {\n    this.componentEvents.onShow.dispatch(this);\n  }\n\n  /**\n   * Fires the onHide event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onHideEvent(): void {\n    this.componentEvents.onHide.dispatch(this);\n  }\n\n  /**\n   * Fires the onHoverChanged event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onHoverChangedEvent(hovered: boolean): void {\n    this.hovered = hovered;\n    this.componentEvents.onHoverChanged.dispatch(this, { hovered: hovered });\n  }\n\n  /**\n   * Gets the event that is fired when the component is showing.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   * @returns {Event<Component<Config>, NoArgs>}\n   */\n  get onShow(): Event<Component<Config>, NoArgs> {\n    return this.componentEvents.onShow.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the component is hiding.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   * @returns {Event<Component<Config>, NoArgs>}\n   */\n  get onHide(): Event<Component<Config>, NoArgs> {\n    return this.componentEvents.onHide.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the component's hover-state is changing.\n   * @returns {Event<Component<Config>, ComponentHoverChangedEventArgs>}\n   */\n  get onHoverChanged(): Event<Component<Config>, ComponentHoverChangedEventArgs> {\n    return this.componentEvents.onHoverChanged.getEvent();\n  }\n}","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {ArrayUtils} from '../utils';\n\n/**\n * Configuration interface for a {@link Container}.\n */\nexport interface ContainerConfig extends ComponentConfig {\n  /**\n   * Child components of the container.\n   */\n  components?: Component<ComponentConfig>[];\n}\n\n/**\n * A container component that can contain a collection of child components.\n * Components can be added at construction time through the {@link ContainerConfig#components} setting, or later\n * through the {@link Container#addComponent} method. The UIManager automatically takes care of all components, i.e. it\n * initializes and configures them automatically.\n *\n * In the DOM, the container consists of an outer <div> (that can be configured by the config) and an inner wrapper\n * <div> that contains the components. This double-<div>-structure is often required to achieve many advanced effects\n * in CSS and/or JS, e.g. animations and certain formatting with absolute positioning.\n *\n * DOM example:\n * <code>\n *     <div class='ui-container'>\n *         <div class='container-wrapper'>\n *             ... child components ...\n *         </div>\n *     </div>\n * </code>\n */\nexport class Container<Config extends ContainerConfig> extends Component<ContainerConfig> {\n\n  /**\n   * A reference to the inner element that contains the components of the container.\n   */\n  private innerContainerElement: DOM;\n\n  constructor(config: ContainerConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-container',\n      components: []\n    }, this.config);\n  }\n\n  /**\n   * Adds a child component to the container.\n   * @param component the component to add\n   */\n  addComponent(component: Component<ComponentConfig>) {\n    this.config.components.push(component);\n  }\n\n  /**\n   * Removes a child component from the container.\n   * @param component the component to remove\n   * @returns {boolean} true if the component has been removed, false if it is not contained in this container\n   */\n  removeComponent(component: Component<ComponentConfig>): boolean {\n    return ArrayUtils.remove(this.config.components, component) != null;\n  }\n\n  /**\n   * Gets an array of all child components in this container.\n   * @returns {Component<ComponentConfig>[]}\n   */\n  getComponents(): Component<ComponentConfig>[] {\n    return this.config.components;\n  }\n\n  /**\n   * Removes all child components from the container.\n   */\n  removeComponents(): void {\n    for (let component of this.getComponents()) {\n      this.removeComponent(component);\n    }\n  }\n\n  /**\n   * Updates the DOM of the container with the current components.\n   */\n  protected updateComponents(): void {\n    this.innerContainerElement.empty();\n\n    for (let component of this.config.components) {\n      this.innerContainerElement.append(component.getDomElement());\n    }\n  }\n\n  protected toDomElement(): DOM {\n    // Create the container element (the outer <div>)\n    let containerElement = new DOM(this.config.tag, {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    // Create the inner container element (the inner <div>) that will contain the components\n    let innerContainer = new DOM(this.config.tag, {\n      'class': this.prefixCss('container-wrapper')\n    });\n    this.innerContainerElement = innerContainer;\n\n    this.updateComponents();\n\n    containerElement.append(innerContainer);\n\n    return containerElement;\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {UIUtils} from '../utils';\nimport {Spacer} from './spacer';\n\n/**\n * Configuration interface for the {@link ControlBar}.\n */\nexport interface ControlBarConfig extends ContainerConfig {\n  // nothing yet\n}\n\n/**\n * A container for main player control components, e.g. play toggle button, seek bar, volume control, fullscreen toggle\n * button.\n */\nexport class ControlBar extends Container<ControlBarConfig> {\n\n  constructor(config: ControlBarConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-controlbar',\n      hidden: true,\n    }, <ControlBarConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    // Counts how many components are hovered and block hiding of the control bar\n    let hoverStackCount = 0;\n\n    // Track hover status of child components\n    UIUtils.traverseTree(this, (component) => {\n      // Do not track hover status of child containers or spacers, only of 'real' controls\n      if (component instanceof Container || component instanceof Spacer) {\n        return;\n      }\n\n      // Subscribe hover event and keep a count of the number of hovered children\n      component.onHoverChanged.subscribe((sender, args) => {\n        if (args.hovered) {\n          hoverStackCount++;\n        } else {\n          hoverStackCount--;\n        }\n      });\n    });\n\n    uimanager.onControlsShow.subscribe(() => {\n      this.show();\n    });\n    uimanager.onPreviewControlsHide.subscribe((sender, args) => {\n      // Cancel the hide event if hovered child components block hiding\n      args.cancel = (hoverStackCount > 0);\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      this.hide();\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles the embed video popup.\n */\nexport class EmbedVideoToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-embedvideotogglebutton',\n      text: 'Embed Video'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let popup = {\n      visible : false,\n      isVisible: () => {\n        return popup.visible;\n      },\n      hidePopup: () => {\n        popup.visible = false;\n        console.log('Hide Embed Video Popup')\n      },\n      showPopup: () => {\n        popup.visible = true;\n        console.log('Show Embed Video Popup')\n      }\n    }\n\n    this.onClick.subscribe(() => {\n      if (popup.isVisible()) {\n        popup.hidePopup();\n      } else {\n        popup.showPopup();\n      }\n    });\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport ErrorEvent = bitmovin.player.ErrorEvent;\nimport {TvNoiseCanvas} from './tvnoisecanvas';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\nexport interface ErrorMessageTranslator {\n  (error: ErrorEvent): string;\n}\n\nexport interface ErrorMessageMap {\n  [code: number]: string | ErrorMessageTranslator;\n}\n\n/**\n * Configuration interface for the {@link ErrorMessageOverlay}.\n */\nexport interface ErrorMessageOverlayConfig extends ContainerConfig {\n  /**\n   * Allows overwriting of the error messages displayed in the overlay for customization and localization.\n   * This is either a function that receives any {@link ErrorEvent} as parameter and translates error messages,\n   * or a map of error codes that overwrites specific error messages with a plain string or a function that\n   * receives the {@link ErrorEvent} as parameter and returns a customized string.\n   * The translation functions can be used to extract data (e.g. parameters) from the original error message.\n   *\n   * Example 1 (catch-all translation function):\n   * <code>\n   * errorMessageOverlayConfig = {\n   *   messages: function(error) {\n   *     switch (error.code) {\n   *       // Overwrite error 3000 'Unknown error'\n   *       case 3000:\n   *         return 'Houston, we have a problem'\n   *\n   *       // Transform error 3001 'Unsupported manifest format' to uppercase\n   *       case 3001:\n   *         return error.message.toUpperCase();\n   *\n   *       // Customize error 3006 'Could not load manifest, got HTTP status code XXX'\n   *       case 3006:\n   *         var statusCode = error.message.substring(46);\n   *         return 'Manifest loading failed with HTTP error ' + statusCode;\n   *     }\n   *     // Return unmodified error message for all other errors\n   *     return error.message;\n   *   }\n   * };\n   * </code>\n   *\n   * Example 2 (translating specific errors):\n   * <code>\n   * errorMessageOverlayConfig = {\n   *   messages: {\n   *     // Overwrite error 3000 'Unknown error'\n   *     3000: 'Houston, we have a problem',\n   *\n   *     // Transform error 3001 'Unsupported manifest format' to uppercase\n   *     3001: function(error) {\n   *       return error.message.toUpperCase();\n   *     },\n   *\n   *     // Customize error 3006 'Could not load manifest, got HTTP status code XXX'\n   *     3006: function(error) {\n   *       var statusCode = error.message.substring(46);\n   *       return 'Manifest loading failed with HTTP error ' + statusCode;\n   *     }\n   *   }\n   * };\n   * </code>\n   */\n  messages?: ErrorMessageMap | ErrorMessageTranslator;\n}\n\n/**\n * Overlays the player and displays error messages.\n */\nexport class ErrorMessageOverlay extends Container<ErrorMessageOverlayConfig> {\n\n  private errorLabel: Label<LabelConfig>;\n  private tvNoiseBackground: TvNoiseCanvas;\n\n  constructor(config: ErrorMessageOverlayConfig = {}) {\n    super(config);\n\n    this.errorLabel = new Label<LabelConfig>({ cssClass: 'ui-errormessage-label' });\n    this.tvNoiseBackground = new TvNoiseCanvas();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-errormessage-overlay',\n      components: [this.tvNoiseBackground, this.errorLabel],\n      hidden: true\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <ErrorMessageOverlayConfig>this.getConfig();\n\n    player.addEventHandler(player.EVENT.ON_ERROR, (event: ErrorEvent) => {\n      let message = event.message;\n\n      // Process message translations\n      if (config.messages) {\n        if (typeof config.messages === 'function') {\n          // Translation function for all errors\n          message = config.messages(event);\n        } else if (config.messages[event.code]) {\n          // It's not a translation function, so it must be a map of strings or translation functions\n          let customMessage = config.messages[event.code];\n\n          if (typeof customMessage === 'string') {\n            message = customMessage;\n          } else {\n            // The message is a translation function, so we call it\n            message = customMessage(event);\n          }\n        }\n      }\n\n      this.errorLabel.setText(message);\n      this.tvNoiseBackground.start();\n      this.show();\n    });\n\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, (event: PlayerEvent) => {\n      if (this.isShown()) {\n        this.tvNoiseBackground.stop();\n        this.hide();\n      }\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles the player between windowed and fullscreen view.\n */\nexport class FullscreenToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-fullscreentogglebutton',\n      text: 'Fullscreen'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let fullscreenStateHandler = () => {\n      if (player.isFullscreen()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_ENTER, fullscreenStateHandler);\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_EXIT, fullscreenStateHandler);\n\n    this.onClick.subscribe(() => {\n      if (player.isFullscreen()) {\n        player.exitFullscreen();\n      } else {\n        player.enterFullscreen();\n      }\n    });\n\n    // Startup init\n    fullscreenStateHandler();\n  }\n}","import {ToggleButtonConfig} from './togglebutton';\nimport {PlaybackToggleButton} from './playbacktogglebutton';\nimport {DOM} from '../dom';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\n/**\n * A button that overlays the video and toggles between playback and pause.\n */\nexport class HugePlaybackToggleButton extends PlaybackToggleButton {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-hugeplaybacktogglebutton',\n      text: 'Play/Pause'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    // Update button state through API events\n    super.configure(player, uimanager, false);\n\n    let togglePlayback = () => {\n      if (player.isPlaying()) {\n        player.pause('ui-overlay');\n      } else {\n        player.play('ui-overlay');\n      }\n    };\n\n    let toggleFullscreen = () => {\n      if (player.isFullscreen()) {\n        player.exitFullscreen();\n      } else {\n        player.enterFullscreen();\n      }\n    };\n\n    let firstPlay = true;\n    let clickTime = 0;\n    let doubleClickTime = 0;\n\n    /*\n     * YouTube-style toggle button handling\n     *\n     * The goal is to prevent a short pause or playback interval between a click, that toggles playback, and a\n     * double click, that toggles fullscreen. In this naive approach, the first click would e.g. start playback,\n     * the second click would be detected as double click and toggle to fullscreen, and as second normal click stop\n     * playback, which results is a short playback interval with max length of the double click detection\n     * period (usually 500ms).\n     *\n     * To solve this issue, we defer handling of the first click for 200ms, which is almost unnoticeable to the user,\n     * and just toggle playback if no second click (double click) has been registered during this period. If a double\n     * click is registered, we just toggle the fullscreen. In the first 200ms, undesired playback changes thus cannot\n     * happen. If a double click is registered within 500ms, we undo the playback change and switch fullscreen mode.\n     * In the end, this method basically introduces a 200ms observing interval in which playback changes are prevented\n     * if a double click happens.\n     */\n    this.onClick.subscribe(() => {\n      // Directly start playback on first click of the button.\n      // This is a required workaround for mobile browsers where video playback needs to be triggered directly\n      // by the user. A deferred playback start through the timeout below is not considered as user action and\n      // therefore ignored by mobile browsers.\n      if (firstPlay) {\n        // Try to start playback. Then we wait for ON_PLAY and only when it arrives, we disable the firstPlay flag.\n        // If we disable the flag here, onClick was triggered programmatically instead of by a user interaction, and\n        // playback is blocked (e.g. on mobile devices due to the programmatic play() call), we loose the chance to\n        // ever start playback through a user interaction again with this button.\n        togglePlayback();\n        return;\n      }\n\n      let now = Date.now();\n\n      if (now - clickTime < 200) {\n        // We have a double click inside the 200ms interval, just toggle fullscreen mode\n        toggleFullscreen();\n        doubleClickTime = now;\n        return;\n      } else if (now - clickTime < 500) {\n        // We have a double click inside the 500ms interval, undo playback toggle and toggle fullscreen mode\n        toggleFullscreen();\n        togglePlayback();\n        doubleClickTime = now;\n        return;\n      }\n\n      clickTime = now;\n\n      setTimeout(() => {\n        if (Date.now() - doubleClickTime > 200) {\n          // No double click detected, so we toggle playback and wait what happens next\n          togglePlayback();\n        }\n      }, 200);\n    });\n\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      // Playback has really started, we can disable the flag to switch to normal toggle button handling\n      firstPlay = false;\n    });\n\n    // Hide button while initializing a Cast session\n    let castInitializationHandler = (event: PlayerEvent) => {\n      if (event.type === player.EVENT.ON_CAST_START) {\n        // Hide button when session is being initialized\n        this.hide();\n      } else {\n        // Show button when session is established or initialization was aborted\n        this.show();\n      }\n    };\n    player.addEventHandler(player.EVENT.ON_CAST_START, castInitializationHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, castInitializationHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, castInitializationHandler);\n  }\n\n  protected toDomElement(): DOM {\n    let buttonElement = super.toDomElement();\n\n    // Add child that contains the play button image\n    // Setting the image directly on the button does not work together with scaling animations, because the button\n    // can cover the whole video player are and scaling would extend it beyond. By adding an inner element, confined\n    // to the size if the image, it can scale inside the player without overshooting.\n    buttonElement.append(new DOM('div', {\n      'class': this.prefixCss('image')\n    }));\n\n    return buttonElement;\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {DOM} from '../dom';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\n/**\n * A button to play/replay a video.\n */\nexport class HugeReplayButton extends Button<ButtonConfig> {\n\n  constructor(config: ButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-hugereplaybutton',\n      text: 'Replay'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      player.play('ui-overlay');\n    });\n  }\n\n  protected toDomElement(): DOM {\n    let buttonElement = super.toDomElement();\n\n    // Add child that contains the play button image\n    // Setting the image directly on the button does not work together with scaling animations, because the button\n    // can cover the whole video player are and scaling would extend it beyond. By adding an inner element, confined\n    // to the size if the image, it can scale inside the player without overshooting.\n    buttonElement.append(new DOM('div', {\n      'class': this.prefixCss('image')\n    }));\n\n    return buttonElement;\n  }\n}","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {EventDispatcher, Event, NoArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link Label} component.\n */\nexport interface LabelConfig extends ComponentConfig {\n  /**\n   * The text on the label.\n   */\n  text?: string;\n}\n\n/**\n * A simple text label.\n *\n * DOM example:\n * <code>\n *     <span class='ui-label'>...some text...</span>\n * </code>\n */\nexport class Label<Config extends LabelConfig> extends Component<LabelConfig> {\n\n  private text: string;\n\n  private labelEvents = {\n    onClick: new EventDispatcher<Label<Config>, NoArgs>(),\n    onTextChanged: new EventDispatcher<Label<Config>, string>(),\n  };\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-label'\n    }, this.config);\n\n    this.text = this.config.text;\n  }\n\n  protected toDomElement(): DOM {\n    let labelElement = new DOM('span', {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    }).html(this.text);\n\n    labelElement.on('click', () => {\n      this.onClickEvent();\n    });\n\n    return labelElement;\n  }\n\n  /**\n   * Set the text on this label.\n   * @param text\n   */\n  setText(text: string) {\n    this.text = text;\n    this.getDomElement().html(text);\n    this.onTextChangedEvent(text);\n  }\n\n  /**\n   * Gets the text on this label.\n   * @return {string} The text on the label\n   */\n  getText(): string {\n    return this.text;\n  }\n\n  /**\n   * Clears the text on this label.\n   */\n  clearText() {\n    this.getDomElement().html('');\n    this.onTextChangedEvent(null);\n  }\n\n  /**\n   * Tests if the label is empty and does not contain any text.\n   * @return {boolean} True if the label is empty, else false\n   */\n  isEmpty(): boolean {\n    return !this.text;\n  }\n\n  /**\n   * Fires the {@link #onClick} event.\n   * Can be used by subclasses to listen to this event without subscribing an event listener by overwriting the method\n   * and calling the super method.\n   */\n  protected onClickEvent() {\n    this.labelEvents.onClick.dispatch(this);\n  }\n\n  /**\n   * Fires the {@link #onClick} event.\n   * Can be used by subclasses to listen to this event without subscribing an event listener by overwriting the method\n   * and calling the super method.\n   */\n  protected onTextChangedEvent(text: string) {\n    this.labelEvents.onTextChanged.dispatch(this, text);\n  }\n\n  /**\n   * Gets the event that is fired when the label is clicked.\n   * @returns {Event<Label<LabelConfig>, NoArgs>}\n   */\n  get onClick(): Event<Label<LabelConfig>, NoArgs> {\n    return this.labelEvents.onClick.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the text on the label is changed.\n   * @returns {Event<Label<LabelConfig>, string>}\n   */\n  get onTextChanged(): Event<Label<LabelConfig>, string> {\n    return this.labelEvents.onTextChanged.getEvent();\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {EventDispatcher, Event} from '../eventdispatcher';\nimport {ArrayUtils} from '../utils';\n\n/**\n * A map of items (key/value -> label} for a {@link ListSelector} in a {@link ListSelectorConfig}.\n */\nexport interface ListItem {\n  key: string;\n  label: string;\n}\n\n/**\n * Configuration interface for a {@link ListSelector}.\n */\nexport interface ListSelectorConfig extends ComponentConfig {\n  items?: ListItem[];\n}\n\nexport abstract class ListSelector<Config extends ListSelectorConfig> extends Component<ListSelectorConfig> {\n\n  protected items: ListItem[];\n  protected selectedItem: string;\n\n  private listSelectorEvents = {\n    onItemAdded: new EventDispatcher<ListSelector<Config>, string>(),\n    onItemRemoved: new EventDispatcher<ListSelector<Config>, string>(),\n    onItemSelected: new EventDispatcher<ListSelector<Config>, string>()\n  };\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      items: [],\n      cssClass: 'ui-listselector'\n    }, this.config);\n\n    this.items = this.config.items;\n  }\n\n  private getItemIndex(key: string): number {\n    for (let index in this.items) {\n      if (key === this.items[index].key) {\n        return parseInt(index);\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Checks if the specified item is part of this selector.\n   * @param key the key of the item to check\n   * @returns {boolean} true if the item is part of this selector, else false\n   */\n  hasItem(key: string): boolean {\n    return this.getItemIndex(key) > -1;\n  }\n\n  /**\n   * Adds an item to this selector by appending it to the end of the list of items. If an item with the specified\n   * key already exists, it is replaced.\n   * @param key the key of the item to add\n   * @param label the (human-readable) label of the item to add\n   */\n  addItem(key: string, label: string) {\n    this.removeItem(key); // Try to remove key first to get overwrite behavior and avoid duplicate keys\n    this.items.push({ key: key, label: label });\n    this.onItemAddedEvent(key);\n  }\n\n  /**\n   * Removes an item from this selector.\n   * @param key the key of the item to remove\n   * @returns {boolean} true if removal was successful, false if the item is not part of this selector\n   */\n  removeItem(key: string): boolean {\n    let index = this.getItemIndex(key);\n    if (index > -1) {\n      ArrayUtils.remove(this.items, this.items[index]);\n      this.onItemRemovedEvent(key);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Selects an item from the items in this selector.\n   * @param key the key of the item to select\n   * @returns {boolean} true is the selection was successful, false if the selected item is not part of the selector\n   */\n  selectItem(key: string): boolean {\n    if (key === this.selectedItem) {\n      // itemConfig is already selected, suppress any further action\n      return true;\n    }\n\n    let index = this.getItemIndex(key);\n\n    if (index > -1) {\n      this.selectedItem = key;\n      this.onItemSelectedEvent(key);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns the key of the selected item.\n   * @returns {string} the key of the selected item or null if no item is selected\n   */\n  getSelectedItem(): string | null {\n    return this.selectedItem;\n  }\n\n  /**\n   * Removes all items from this selector.\n   */\n  clearItems() {\n    let items = this.items; // local copy for iteration after clear\n    this.items = []; // clear items\n\n    // fire events\n    for (let item of items) {\n      this.onItemRemovedEvent(item.key);\n    }\n  }\n\n  /**\n   * Returns the number of items in this selector.\n   * @returns {number}\n   */\n  itemCount(): number {\n    return Object.keys(this.items).length;\n  }\n\n  protected onItemAddedEvent(key: string) {\n    this.listSelectorEvents.onItemAdded.dispatch(this, key);\n  }\n\n  protected onItemRemovedEvent(key: string) {\n    this.listSelectorEvents.onItemRemoved.dispatch(this, key);\n  }\n\n  protected onItemSelectedEvent(key: string) {\n    this.listSelectorEvents.onItemSelected.dispatch(this, key);\n  }\n\n  /**\n   * Gets the event that is fired when an item is added to the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemAdded(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemAdded.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when an item is removed from the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemRemoved(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemRemoved.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when an item is selected from the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemSelected(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemSelected.getEvent();\n  }\n}","import {LabelConfig, Label} from './label';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Enumerates the types of content that the {@link MetadataLabel} can display.\n */\nexport enum MetadataLabelContent {\n  /**\n   * Title of the data source.\n   */\n  Title,\n  /**\n   * Description fo the data source.\n   */\n  Description,\n}\n\n/**\n * Configuration interface for {@link MetadataLabel}.\n */\nexport interface MetadataLabelConfig extends LabelConfig {\n  /**\n   * The type of content that should be displayed in the label.\n   */\n  content: MetadataLabelContent;\n}\n\n/**\n * A label that can be configured to display certain metadata.\n */\nexport class MetadataLabel extends Label<MetadataLabelConfig> {\n\n  constructor(config: MetadataLabelConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClasses: ['label-metadata', 'label-metadata-' + MetadataLabelContent[config.content].toLowerCase()]\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <MetadataLabelConfig>this.getConfig();\n    let uiconfig = uimanager.getConfig();\n\n    let init = () => {\n      switch (config.content) {\n        case MetadataLabelContent.Title:\n          if (uiconfig && uiconfig.metadata && uiconfig.metadata.title) {\n            this.setText(uiconfig.metadata.title);\n          } else if (player.getConfig().source && player.getConfig().source.title) {\n            this.setText(player.getConfig().source.title);\n          }\n          break;\n        case MetadataLabelContent.Description:\n          if (uiconfig && uiconfig.metadata && uiconfig.metadata.description) {\n            this.setText(uiconfig.metadata.description);\n          } else if (player.getConfig().source && player.getConfig().source.description) {\n            this.setText(player.getConfig().source.description);\n          }\n          break;\n      }\n    };\n\n    let unload = () => {\n      this.setText(null);\n    };\n\n    // Init label\n    init();\n    // Reinit label when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, init);\n    // Clear labels when source is unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, unload);\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles Apple macOS picture-in-picture mode.\n */\nexport class PictureInPictureToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-piptogglebutton',\n      text: 'Picture-in-Picture'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      if (player.isPictureInPictureAvailable()) {\n        if (player.isPictureInPicture()) {\n          player.exitPictureInPicture();\n        } else {\n          player.enterPictureInPicture();\n        }\n      } else {\n        if (console) {\n          console.log('PIP unavailable');\n        }\n      }\n    });\n\n    let pipAvailableHander = () => {\n      if (player.isPictureInPictureAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, pipAvailableHander);\n\n    // Toggle button 'on' state\n    player.addEventHandler(player.EVENT.ON_PICTURE_IN_PICTURE_ENTER, () => {\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_PICTURE_IN_PICTURE_EXIT, () => {\n      this.off();\n    });\n\n    // Startup init\n    pipAvailableHander(); // Hide button if PIP not available\n    if (player.isPictureInPicture()) {\n      this.on();\n    }\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection of different playback speeds.\n */\nexport class PlaybackSpeedSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem('0.25', '0.25x');\n    this.addItem('0.5', '0.5x');\n    this.addItem('1', 'Normal');\n    this.addItem('1.5', '1.5x');\n    this.addItem('2', '2x');\n\n    this.selectItem('1');\n\n\n    this.onItemSelected.subscribe((sender: PlaybackSpeedSelectBox, value: string) => {\n      player.setPlaybackSpeed(parseFloat(value));\n    });\n  }\n}","import {LabelConfig, Label} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {StringUtils, PlayerUtils} from '../utils';\nimport LiveStreamDetectorEventArgs = PlayerUtils.LiveStreamDetectorEventArgs;\n\nexport enum PlaybackTimeLabelMode {\n  CurrentTime,\n  TotalTime,\n  CurrentAndTotalTime,\n}\n\nexport interface PlaybackTimeLabelConfig extends LabelConfig {\n  timeLabelMode?: PlaybackTimeLabelMode;\n  hideInLivePlayback?: boolean;\n}\n\n/**\n * A label that display the current playback time and the total time through {@link PlaybackTimeLabel#setTime setTime}\n * or any string through {@link PlaybackTimeLabel#setText setText}.\n */\nexport class PlaybackTimeLabel extends Label<PlaybackTimeLabelConfig> {\n\n  private timeFormat: string;\n\n  constructor(config: PlaybackTimeLabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <PlaybackTimeLabelConfig>{\n      cssClass: 'ui-playbacktimelabel',\n      timeLabelMode: PlaybackTimeLabelMode.CurrentAndTotalTime,\n      hideInLivePlayback: false,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <PlaybackTimeLabelConfig>this.getConfig();\n    let live = false;\n    let liveCssClass = this.prefixCss('ui-playbacktimelabel-live');\n    let liveEdgeCssClass = this.prefixCss('ui-playbacktimelabel-live-edge');\n    let minWidth = 0;\n\n    let liveClickHandler = () => {\n      player.timeShift(0);\n    };\n\n    let updateLiveState = () => {\n      // Player is playing a live stream when the duration is infinite\n      live = player.isLive();\n\n      // Attach/detach live marker class\n      if (live) {\n        this.getDomElement().addClass(liveCssClass);\n        this.setText('Live');\n        if (config.hideInLivePlayback) {\n          this.hide();\n        }\n        this.onClick.subscribe(liveClickHandler);\n        updateLiveTimeshiftState();\n      } else {\n        this.getDomElement().removeClass(liveCssClass);\n        this.getDomElement().removeClass(liveEdgeCssClass);\n        this.show();\n        this.onClick.unsubscribe(liveClickHandler);\n      }\n    };\n\n    new PlayerUtils.LiveStreamDetector(player).onLiveChanged.subscribe((sender, args: LiveStreamDetectorEventArgs) => {\n      live = args.live;\n      updateLiveState();\n    });\n\n    let updateLiveTimeshiftState = () => {\n      if (player.getTimeShift() === 0) {\n        this.getDomElement().addClass(liveEdgeCssClass);\n      } else {\n        this.getDomElement().removeClass(liveEdgeCssClass);\n      }\n    };\n\n    let playbackTimeHandler = () => {\n      if (!live && player.getDuration() !== Infinity) {\n        this.setTime(player.getCurrentTime(), player.getDuration());\n      }\n\n      // To avoid 'jumping' in the UI by varying label sizes due to non-monospaced fonts,\n      // we gradually increase the min-width with the content to reach a stable size.\n      let width = this.getDomElement().width();\n      if (width > minWidth) {\n        minWidth = width;\n        this.getDomElement().css({\n          'min-width': minWidth + 'px'\n        });\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_TIME_CHANGED, playbackTimeHandler);\n    player.addEventHandler(player.EVENT.ON_SEEKED, playbackTimeHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, playbackTimeHandler);\n\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, updateLiveTimeshiftState);\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, updateLiveTimeshiftState);\n\n    let init = () => {\n      // Reset min-width when a new source is ready (especially for switching VOD/Live modes where the label content\n      // changes)\n      minWidth = 0;\n      this.getDomElement().css({\n        'min-width': null\n      });\n\n      // Set time format depending on source duration\n      this.timeFormat = Math.abs(player.isLive() ? player.getMaxTimeShift() : player.getDuration()) >= 3600 ?\n        StringUtils.FORMAT_HHMMSS : StringUtils.FORMAT_MMSS;\n\n      // Update time after the format has been set\n      playbackTimeHandler();\n    };\n    player.addEventHandler(player.EVENT.ON_READY, init);\n\n    init();\n  }\n\n  /**\n   * Sets the current playback time and total duration.\n   * @param playbackSeconds the current playback time in seconds\n   * @param durationSeconds the total duration in seconds\n   */\n  setTime(playbackSeconds: number, durationSeconds: number) {\n    let currentTime = StringUtils.secondsToTime(playbackSeconds, this.timeFormat);\n    let totalTime = StringUtils.secondsToTime(durationSeconds, this.timeFormat);\n\n    switch ((<PlaybackTimeLabelConfig>this.config).timeLabelMode) {\n      case PlaybackTimeLabelMode.CurrentTime:\n        this.setText(`${currentTime}`);\n        break;\n      case PlaybackTimeLabelMode.TotalTime:\n        this.setText(`${totalTime}`);\n        break;\n      case PlaybackTimeLabelMode.CurrentAndTotalTime:\n        this.setText(`${currentTime} / ${totalTime}`);\n        break;\n    }\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\nimport {PlayerUtils} from '../utils';\nimport TimeShiftAvailabilityChangedArgs = PlayerUtils.TimeShiftAvailabilityChangedArgs;\n\n/**\n * A button that toggles between playback and pause.\n */\nexport class PlaybackToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  private static readonly CLASS_STOPTOGGLE = 'stoptoggle';\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-playbacktogglebutton',\n      text: 'Play/Pause'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager, handleClickEvent: boolean = true): void {\n    super.configure(player, uimanager);\n\n    let isSeeking = false;\n\n    // Handler to update button state based on player state\n    let playbackStateHandler = (event: PlayerEvent) => {\n      // If the UI is currently seeking, playback is temporarily stopped but the buttons should\n      // not reflect that and stay as-is (e.g indicate playback while seeking).\n      if (isSeeking) {\n        return;\n      }\n\n      if (player.isPlaying()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    // Call handler upon these events\n    player.addEventHandler(player.EVENT.ON_PLAY, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_PAUSED, playbackStateHandler);\n    // when playback finishes, player turns to paused mode\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYING, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PAUSED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYBACK_FINISHED, playbackStateHandler);\n\n    // Detect absence of timeshifting on live streams and add tagging class to convert button icons to play/stop\n    new PlayerUtils.TimeShiftAvailabilityDetector(player).onTimeShiftAvailabilityChanged.subscribe(\n      (sender, args: TimeShiftAvailabilityChangedArgs) => {\n        if (!args.timeShiftAvailable) {\n          this.getDomElement().addClass(this.prefixCss(PlaybackToggleButton.CLASS_STOPTOGGLE));\n        } else {\n          this.getDomElement().removeClass(this.prefixCss(PlaybackToggleButton.CLASS_STOPTOGGLE));\n        }\n      }\n    );\n\n    if (handleClickEvent) {\n      // Control player by button events\n      // When a button event triggers a player API call, events are fired which in turn call the event handler\n      // above that updated the button state.\n      this.onClick.subscribe(() => {\n        if (player.isPlaying()) {\n          player.pause('ui-button');\n        } else {\n          player.play('ui-button');\n        }\n      });\n    }\n\n    // Track UI seeking status\n    uimanager.onSeek.subscribe(() => {\n      isSeeking = true;\n    });\n    uimanager.onSeeked.subscribe(() => {\n      isSeeking = false;\n    });\n\n    // Startup init\n    playbackStateHandler(null);\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {HugePlaybackToggleButton} from './hugeplaybacktogglebutton';\n\n/**\n * Overlays the player and displays error messages.\n */\nexport class PlaybackToggleOverlay extends Container<ContainerConfig> {\n\n  private playbackToggleButton: HugePlaybackToggleButton;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.playbackToggleButton = new HugePlaybackToggleButton();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-playbacktoggle-overlay',\n      components: [this.playbackToggleButton]\n    }, this.config);\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\nimport {UIInstanceManager, UIRecommendationConfig} from '../uimanager';\nimport {StringUtils} from '../utils';\nimport {HugeReplayButton} from './hugereplaybutton';\n\n/**\n * Overlays the player and displays recommended videos.\n */\nexport class RecommendationOverlay extends Container<ContainerConfig> {\n\n  private replayButton: HugeReplayButton;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.replayButton = new HugeReplayButton();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-recommendation-overlay',\n      hidden: true,\n      components: [this.replayButton]\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let clearRecommendations = () => {\n      for (let component of this.getComponents()) {\n        if (component instanceof RecommendationItem) {\n          this.removeComponent(component);\n        }\n      }\n      this.updateComponents();\n      this.getDomElement().removeClass(this.prefixCss('recommendations'));\n    };\n\n    let setupRecommendations = () => {\n      clearRecommendations();\n\n      let hasRecommendationsInUiConfig = uimanager.getConfig().recommendations\n        && uimanager.getConfig().recommendations.length > 0;\n      let hasRecommendationsInPlayerConfig = player.getConfig().source && player.getConfig().source.recommendations\n        && player.getConfig().source.recommendations.length > 0;\n\n      // Take markers from the UI config. If no markers defined, try to take them from the player's source config.\n      let recommendations = hasRecommendationsInUiConfig ? uimanager.getConfig().recommendations :\n        hasRecommendationsInPlayerConfig ? player.getConfig().source.recommendations : null;\n\n      // Generate timeline markers from the config if we have markers and if we have a duration\n      // The duration check is for buggy platforms where the duration is not available instantly (Chrome on Android 4.3)\n      if (recommendations) {\n        let index = 1;\n        for (let item of recommendations) {\n          this.addComponent(new RecommendationItem({\n            itemConfig: item,\n            cssClasses: ['recommendation-item-' + (index++)]\n          }));\n        }\n        this.updateComponents(); // create container DOM elements\n\n        this.getDomElement().addClass(this.prefixCss('recommendations'));\n      }\n    };\n\n    // Add recommendation when a source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, setupRecommendations);\n    // Remove recommendations and hide overlay when source is unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, () => {\n      clearRecommendations();\n      this.hide();\n    });\n    // Display recommendations when playback has finished\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, () => {\n      // Dismiss ON_PLAYBACK_FINISHED events at the end of ads\n      // TODO remove this workaround once issue #1278 is solved\n      if (player.isAd()) {\n        return;\n      }\n\n      this.show();\n    });\n    // Hide recommendations when playback starts, e.g. a restart\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      this.hide();\n    });\n\n    // Init on startup\n    setupRecommendations();\n  }\n}\n\n/**\n * Configuration interface for the {@link RecommendationItem}\n */\ninterface RecommendationItemConfig extends ComponentConfig {\n  itemConfig: UIRecommendationConfig;\n}\n\n/**\n * An item of the {@link RecommendationOverlay}. Used only internally in {@link RecommendationOverlay}.\n */\nclass RecommendationItem extends Component<RecommendationItemConfig> {\n\n  constructor(config: RecommendationItemConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-recommendation-item',\n      itemConfig: null // this must be passed in from outside\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    let config = (<RecommendationItemConfig>this.config).itemConfig; // TODO fix generics and get rid of cast\n\n    let itemElement = new DOM('a', {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n      'href': config.url\n    }).css({ 'background-image': `url(${config.thumbnail})` });\n\n    let bgElement = new DOM('div', {\n      'class': this.prefixCss('background')\n    });\n    itemElement.append(bgElement);\n\n    let titleElement = new DOM('span', {\n      'class': this.prefixCss('title')\n    }).append(new DOM('span', {\n      'class': this.prefixCss('innertitle')\n    }).html(config.title));\n    itemElement.append(titleElement);\n\n    let timeElement = new DOM('span', {\n      'class': this.prefixCss('duration')\n    }).append(new DOM('span', {\n      'class': this.prefixCss('innerduration')\n    }).html(config.duration ? StringUtils.secondsToTime(config.duration) : ''));\n    itemElement.append(timeElement);\n\n    return itemElement;\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\nimport {Event, EventDispatcher, NoArgs} from '../eventdispatcher';\nimport {SeekBarLabel} from './seekbarlabel';\nimport {UIInstanceManager, TimelineMarker, SeekPreviewArgs} from '../uimanager';\nimport {Timeout} from '../timeout';\nimport {PlayerUtils} from '../utils';\nimport TimeShiftAvailabilityChangedArgs = PlayerUtils.TimeShiftAvailabilityChangedArgs;\nimport LiveStreamDetectorEventArgs = PlayerUtils.LiveStreamDetectorEventArgs;\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\n/**\n * Configuration interface for the {@link SeekBar} component.\n */\nexport interface SeekBarConfig extends ComponentConfig {\n  /**\n   * The label above the seek position.\n   */\n  label?: SeekBarLabel;\n  /**\n   * Bar will be vertical instead of horizontal if set to true.\n   */\n  vertical?: boolean;\n  /**\n   * The interval in milliseconds in which the playback position on the seek bar will be updated. The shorter the\n   * interval, the smoother it looks and the more resource intense it is. The update interval will be kept as steady\n   * as possible to avoid jitter.\n   * Set to -1 to disable smooth updating and update it on player ON_TIME_CHANGED events instead.\n   * Default: 50 (50ms = 20fps).\n   */\n  smoothPlaybackPositionUpdateIntervalMs?: number;\n}\n\n/**\n * Event argument interface for a seek preview event.\n */\nexport interface SeekPreviewEventArgs extends SeekPreviewArgs {\n  /**\n   * Tells if the seek preview event comes from a scrubbing.\n   */\n  scrubbing: boolean;\n}\n\n/**\n * A seek bar to seek within the player's media. It displays the current playback position, amount of buffed data, seek\n * target, and keeps status about an ongoing seek.\n *\n * The seek bar displays different 'bars':\n *  - the playback position, i.e. the position in the media at which the player current playback pointer is positioned\n *  - the buffer position, which usually is the playback position plus the time span that is already buffered ahead\n *  - the seek position, used to preview to where in the timeline a seek will jump to\n */\nexport class SeekBar extends Component<SeekBarConfig> {\n\n  public static readonly SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED = -1;\n\n  /**\n   * The CSS class that is added to the DOM element while the seek bar is in 'seeking' state.\n   */\n  private static readonly CLASS_SEEKING = 'seeking';\n\n  private seekBar: DOM;\n  private seekBarPlaybackPosition: DOM;\n  private seekBarPlaybackPositionMarker: DOM;\n  private seekBarBufferPosition: DOM;\n  private seekBarSeekPosition: DOM;\n  private seekBarBackdrop: DOM;\n  private seekBarMarkersContainer: DOM;\n\n  private label: SeekBarLabel;\n\n  private timelineMarkers: TimelineMarker[];\n\n  /**\n   * Buffer of the the current playback position. The position must be buffered in case the element\n   * needs to be refreshed with {@link #refreshPlaybackPosition}.\n   * @type {number}\n   */\n  private playbackPositionPercentage = 0;\n\n  private smoothPlaybackPositionUpdater: Timeout;\n\n  // https://hacks.mozilla.org/2013/04/detecting-touch-its-the-why-not-the-how/\n  private touchSupported = ('ontouchstart' in window);\n\n  private seekBarEvents = {\n    /**\n     * Fired when a scrubbing seek operation is started.\n     */\n    onSeek: new EventDispatcher<SeekBar, NoArgs>(),\n    /**\n     * Fired during a scrubbing seek to indicate that the seek preview (i.e. the video frame) should be updated.\n     */\n    onSeekPreview: new EventDispatcher<SeekBar, SeekPreviewEventArgs>(),\n    /**\n     * Fired when a scrubbing seek has finished or when a direct seek is issued.\n     */\n    onSeeked: new EventDispatcher<SeekBar, number>()\n  };\n\n  constructor(config: SeekBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-seekbar',\n      vertical: false,\n      smoothPlaybackPositionUpdateIntervalMs: 50,\n    }, this.config);\n\n    this.label = this.config.label;\n    this.timelineMarkers = [];\n  }\n\n  initialize(): void {\n    super.initialize();\n\n    if (this.hasLabel()) {\n      this.getLabel().initialize();\n    }\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager, configureSeek: boolean = true): void {\n    super.configure(player, uimanager);\n\n    if (!configureSeek) {\n      // The configureSeek flag can be used by subclasses to disable configuration as seek bar. E.g. the volume\n      // slider is reusing this component but adds its own functionality, and does not need the seek functionality.\n      // This is actually a hack, the proper solution would be for both seek bar and volume sliders to extend\n      // a common base slider component and implement their functionality there.\n      return;\n    }\n\n    let playbackNotInitialized = true;\n    let isPlaying = false;\n    let isSeeking = false;\n\n    // Update playback and buffer positions\n    let playbackPositionHandler = (event: PlayerEvent = null, forceUpdate: boolean = false) => {\n      // Once this handler os called, playback has been started and we set the flag to false\n      playbackNotInitialized = false;\n\n      if (isSeeking) {\n        // We caught a seek preview seek, do not update the seekbar\n        return;\n      }\n\n      if (player.isLive()) {\n        if (player.getMaxTimeShift() === 0) {\n          // This case must be explicitly handled to avoid division by zero\n          this.setPlaybackPosition(100);\n        }\n        else {\n          let playbackPositionPercentage = 100 - (100 / player.getMaxTimeShift() * player.getTimeShift());\n          this.setPlaybackPosition(playbackPositionPercentage);\n        }\n\n        // Always show full buffer for live streams\n        this.setBufferPosition(100);\n      }\n      else {\n        let playbackPositionPercentage = 100 / player.getDuration() * player.getCurrentTime();\n\n        let videoBufferLength = player.getVideoBufferLength();\n        let audioBufferLength = player.getAudioBufferLength();\n        // Calculate the buffer length which is the smaller length of the audio and video buffers. If one of these\n        // buffers is not available, we set it's value to MAX_VALUE to make sure that the other real value is taken\n        // as the buffer length.\n        let bufferLength = Math.min(\n          videoBufferLength != null ? videoBufferLength : Number.MAX_VALUE,\n          audioBufferLength != null ? audioBufferLength : Number.MAX_VALUE);\n        // If both buffer lengths are missing, we set the buffer length to zero\n        if (bufferLength === Number.MAX_VALUE) {\n          bufferLength = 0;\n        }\n\n        let bufferPercentage = 100 / player.getDuration() * bufferLength;\n\n        // Update playback position only in paused state or in the initial startup state where player is neither\n        // paused nor playing. Playback updates are handled in the Timeout below.\n        if (this.config.smoothPlaybackPositionUpdateIntervalMs === SeekBar.SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED\n          || forceUpdate || player.isPaused() || (player.isPaused() === player.isPlaying())) {\n          this.setPlaybackPosition(playbackPositionPercentage);\n        }\n\n        this.setBufferPosition(playbackPositionPercentage + bufferPercentage);\n      }\n    };\n\n    // Update seekbar upon these events\n    // init playback position when the player is ready\n    player.addEventHandler(player.EVENT.ON_READY, playbackPositionHandler);\n    // update playback position when it changes\n    player.addEventHandler(player.EVENT.ON_TIME_CHANGED, playbackPositionHandler);\n    // update bufferlevel when buffering is complete\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, playbackPositionHandler);\n    // update playback position when a seek has finished\n    player.addEventHandler(player.EVENT.ON_SEEKED, playbackPositionHandler);\n    // update playback position when a timeshift has finished\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, playbackPositionHandler);\n    // update bufferlevel when a segment has been downloaded\n    player.addEventHandler(player.EVENT.ON_SEGMENT_REQUEST_FINISHED, playbackPositionHandler);\n    // update playback position of Cast playback\n    player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, playbackPositionHandler);\n\n\n    // Seek handling\n    player.addEventHandler(player.EVENT.ON_SEEK, () => {\n      this.setSeeking(true);\n    });\n    player.addEventHandler(player.EVENT.ON_SEEKED, () => {\n      this.setSeeking(false);\n    });\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, () => {\n      this.setSeeking(true);\n    });\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, () => {\n      this.setSeeking(false);\n    });\n\n    let seek = (percentage: number) => {\n      if (player.isLive()) {\n        player.timeShift(player.getMaxTimeShift() - (player.getMaxTimeShift() * (percentage / 100)));\n      } else {\n        player.seek(player.getDuration() * (percentage / 100));\n      }\n    };\n    this.onSeek.subscribe((sender) => {\n      isSeeking = true; // track seeking status so we can catch events from seek preview seeks\n\n      // Notify UI manager of started seek\n      uimanager.onSeek.dispatch(sender);\n\n      // Save current playback state\n      isPlaying = player.isPlaying();\n\n      // Pause playback while seeking\n      if (isPlaying) {\n        player.pause('ui-seek');\n      }\n    });\n    this.onSeekPreview.subscribe((sender: SeekBar, args: SeekPreviewEventArgs) => {\n      // Notify UI manager of seek preview\n      uimanager.onSeekPreview.dispatch(sender, args);\n    });\n    this.onSeekPreview.subscribeRateLimited((sender: SeekBar, args: SeekPreviewEventArgs) => {\n      // Rate-limited scrubbing seek\n      if (args.scrubbing) {\n        seek(args.position);\n      }\n    }, 200);\n    this.onSeeked.subscribe((sender, percentage) => {\n      isSeeking = false;\n\n      // Do the seek\n      seek(percentage);\n\n      // Continue playback after seek if player was playing when seek started\n      if (isPlaying) {\n        player.play('ui-seek');\n      }\n\n      // Notify UI manager of finished seek\n      uimanager.onSeeked.dispatch(sender);\n    });\n\n    if (this.hasLabel()) {\n      // Configure a seekbar label that is internal to the seekbar)\n      this.getLabel().configure(player, uimanager);\n    }\n\n    // Hide seekbar for live sources without timeshift\n    let isLive = false;\n    let hasTimeShift = false;\n    let switchVisibility = (isLive: boolean, hasTimeShift: boolean) => {\n      if (isLive && !hasTimeShift) {\n        this.hide();\n      } else {\n        this.show();\n      }\n      playbackPositionHandler(null, true);\n      this.refreshPlaybackPosition();\n    };\n    new PlayerUtils.LiveStreamDetector(player).onLiveChanged.subscribe((sender, args: LiveStreamDetectorEventArgs) => {\n      isLive = args.live;\n      switchVisibility(isLive, hasTimeShift);\n    });\n    new PlayerUtils.TimeShiftAvailabilityDetector(player).onTimeShiftAvailabilityChanged.subscribe(\n      (sender, args: TimeShiftAvailabilityChangedArgs) => {\n        hasTimeShift = args.timeShiftAvailable;\n        switchVisibility(isLive, hasTimeShift);\n      }\n    );\n\n    // Refresh the playback position when the player resized or the UI is configured. The playback position marker\n    // is positioned absolutely and must therefore be updated when the size of the seekbar changes.\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => {\n      this.refreshPlaybackPosition();\n    });\n    // Additionally, when this code is called, the seekbar is not part of the UI yet and therefore does not have a size,\n    // resulting in a wrong initial position of the marker. Refreshing it once the UI is configured solved this issue.\n    uimanager.onConfigured.subscribe(() => {\n      this.refreshPlaybackPosition();\n    });\n    // It can also happen that the value changes once the player is ready, or when a new source is loaded, so we need\n    // to update on ON_READY too\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      this.refreshPlaybackPosition();\n    });\n\n    // Initialize seekbar\n    playbackPositionHandler(); // Set the playback position\n    this.setBufferPosition(0);\n    this.setSeekPosition(0);\n    if (this.config.smoothPlaybackPositionUpdateIntervalMs !== SeekBar.SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED) {\n      this.configureSmoothPlaybackPositionUpdater(player, uimanager);\n    }\n    this.configureMarkers(player, uimanager);\n  }\n\n  private configureSmoothPlaybackPositionUpdater(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    /*\n     * Playback position update\n     *\n     * We do not update the position directly from the ON_TIME_CHANGED event, because it arrives very jittery and\n     * results in a jittery position indicator since the CSS transition time is statically set.\n     * To work around this issue, we maintain a local playback position that is updated in a stable regular interval\n     * and kept in sync with the player.\n     */\n    let currentTimeSeekBar = 0;\n    let currentTimePlayer = 0;\n    let updateIntervalMs = 50;\n    let currentTimeUpdateDeltaSecs = updateIntervalMs / 1000;\n\n    this.smoothPlaybackPositionUpdater = new Timeout(updateIntervalMs, () => {\n      currentTimeSeekBar += currentTimeUpdateDeltaSecs;\n      currentTimePlayer = player.getCurrentTime();\n\n      // Sync currentTime of seekbar to player\n      let currentTimeDelta = currentTimeSeekBar - currentTimePlayer;\n      // If the delta is larger that 2 secs, directly jump the seekbar to the\n      // player time instead of smoothly fast forwarding/rewinding.\n      if (Math.abs(currentTimeDelta) > 2) {\n        currentTimeSeekBar = currentTimePlayer;\n      }\n      // If currentTimeDelta is negative and below the adjustment threshold,\n      // the player is ahead of the seekbar and we 'fast forward' the seekbar\n      else if (currentTimeDelta <= -currentTimeUpdateDeltaSecs) {\n        currentTimeSeekBar += currentTimeUpdateDeltaSecs;\n      }\n      // If currentTimeDelta is positive and above the adjustment threshold,\n      // the player is behind the seekbar and we 'rewind' the seekbar\n      else if (currentTimeDelta >= currentTimeUpdateDeltaSecs) {\n        currentTimeSeekBar -= currentTimeUpdateDeltaSecs;\n      }\n\n      let playbackPositionPercentage = 100 / player.getDuration() * currentTimeSeekBar;\n      this.setPlaybackPosition(playbackPositionPercentage);\n    }, true);\n\n    let startSmoothPlaybackPositionUpdater = () => {\n      if (!player.isLive()) {\n        currentTimeSeekBar = player.getCurrentTime();\n        this.smoothPlaybackPositionUpdater.start();\n      }\n    };\n\n    let stopSmoothPlaybackPositionUpdater = () => {\n      this.smoothPlaybackPositionUpdater.clear();\n    };\n\n    player.addEventHandler(player.EVENT.ON_PLAY, startSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYING, startSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_PAUSED, stopSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_CAST_PAUSED, stopSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_SEEKED, () => {\n      currentTimeSeekBar = player.getCurrentTime();\n    });\n\n    if (player.isPlaying()) {\n      startSmoothPlaybackPositionUpdater();\n    }\n  }\n\n  private configureMarkers(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let clearMarkers = () => {\n      this.timelineMarkers = [];\n      this.updateMarkers();\n    };\n\n    let setupMarkers = () => {\n      clearMarkers();\n\n      let hasMarkersInUiConfig = uimanager.getConfig().metadata && uimanager.getConfig().metadata.markers\n        && uimanager.getConfig().metadata.markers.length > 0;\n      let hasMarkersInPlayerConfig = player.getConfig().source && player.getConfig().source.markers\n        && player.getConfig().source.markers.length > 0;\n\n      // Take markers from the UI config. If no markers defined, try to take them from the player's source config.\n      let markers = hasMarkersInUiConfig ? uimanager.getConfig().metadata.markers :\n        hasMarkersInPlayerConfig ? player.getConfig().source.markers : null;\n\n      // Generate timeline markers from the config if we have markers and if we have a duration\n      // The duration check is for buggy platforms where the duration is not available instantly (Chrome on Android 4.3)\n      if (markers && player.getDuration() !== Infinity) {\n        for (let o of markers) {\n          let marker = {\n            time: 100 / player.getDuration() * o.time, // convert time to percentage\n            title: o.title,\n            markerType: '' + (o.markerType || 1),\n            comment: o.comment || '',\n            avatar: o.avatar,\n            number: o.number || ''\n          }\n          this.timelineMarkers.push(marker)\n        }\n      }\n\n      // Populate the timeline with the markers\n      this.updateMarkers();\n    };\n\n    // Add markers when a source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, setupMarkers);\n    // Remove markers when unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, clearMarkers);\n\n    // Init markers at startup\n    setupMarkers();\n  }\n\n  release(): void {\n    super.release();\n\n    if (this.smoothPlaybackPositionUpdater) { // object must not necessarily exist, e.g. in volume slider subclass\n      this.smoothPlaybackPositionUpdater.clear();\n    }\n  }\n\n  protected toDomElement(): DOM {\n    if (this.config.vertical) {\n      this.config.cssClasses.push('vertical');\n    }\n\n    let seekBarContainer = new DOM('div', {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    let seekBar = new DOM('div', {\n      'class': this.prefixCss('seekbar')\n    });\n    this.seekBar = seekBar;\n\n    // Indicator that shows the buffer fill level\n    let seekBarBufferLevel = new DOM('div', {\n      'class': this.prefixCss('seekbar-bufferlevel')\n    });\n    this.seekBarBufferPosition = seekBarBufferLevel;\n\n    // Indicator that shows the current playback position\n    let seekBarPlaybackPosition = new DOM('div', {\n      'class': this.prefixCss('seekbar-playbackposition')\n    });\n    this.seekBarPlaybackPosition = seekBarPlaybackPosition;\n\n    // A marker of the current playback position, e.g. a dot or line\n    let seekBarPlaybackPositionMarker = new DOM('div', {\n      'class': this.prefixCss('seekbar-playbackposition-marker')\n    });\n    this.seekBarPlaybackPositionMarker = seekBarPlaybackPositionMarker;\n\n    // Indicator that show where a seek will go to\n    let seekBarSeekPosition = new DOM('div', {\n      'class': this.prefixCss('seekbar-seekposition')\n    });\n    this.seekBarSeekPosition = seekBarSeekPosition;\n\n    // Indicator that shows the full seekbar\n    let seekBarBackdrop = new DOM('div', {\n      'class': this.prefixCss('seekbar-backdrop')\n    });\n    this.seekBarBackdrop = seekBarBackdrop;\n\n    let seekBarChapterMarkersContainer = new DOM('div', {\n      'class': this.prefixCss('seekbar-markers')\n    });\n    this.seekBarMarkersContainer = seekBarChapterMarkersContainer;\n\n    seekBar.append(seekBarBackdrop, seekBarBufferLevel, seekBarSeekPosition,\n      seekBarPlaybackPosition, seekBarChapterMarkersContainer, seekBarPlaybackPositionMarker);\n\n    let seeking = false;\n\n    // Define handler functions so we can attach/remove them later\n    let mouseTouchMoveHandler = (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n      // Avoid propagation to VR handler\n      e.stopPropagation();\n\n      let targetPercentage = 100 * this.getOffset(e);\n      this.setSeekPosition(targetPercentage);\n      this.setPlaybackPosition(targetPercentage);\n      this.onSeekPreviewEvent(targetPercentage, true);\n    };\n    let mouseTouchUpHandler = (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      // Remove handlers, seek operation is finished\n      new DOM(document).off('touchmove mousemove', mouseTouchMoveHandler);\n      new DOM(document).off('touchend mouseup', mouseTouchUpHandler);\n\n      let targetPercentage = 100 * this.getOffset(e);\n      let snappedChapter = this.getMarkerAtPosition(targetPercentage);\n\n      this.setSeeking(false);\n      seeking = false;\n\n      // Fire seeked event\n      this.onSeekedEvent(snappedChapter ? snappedChapter.time : targetPercentage);\n    };\n\n    // A seek always start with a touchstart or mousedown directly on the seekbar.\n    // To track a mouse seek also outside the seekbar (for touch events this works automatically),\n    // so the user does not need to take care that the mouse always stays on the seekbar, we attach the mousemove\n    // and mouseup handlers to the whole document. A seek is triggered when the user lifts the mouse key.\n    // A seek mouse gesture is thus basically a click with a long time frame between down and up events.\n    seekBar.on('touchstart mousedown', (e: MouseEvent | TouchEvent) => {\n      let isTouchEvent = this.touchSupported && e instanceof TouchEvent;\n\n      // Prevent selection of DOM elements (also prevents mousedown if current event is touchstart)\n      e.preventDefault();\n      // Avoid propagation to VR handler\n      e.stopPropagation();\n\n      this.setSeeking(true); // Set seeking class on DOM element\n      seeking = true; // Set seek tracking flag\n\n      // Fire seeked event\n      this.onSeekEvent();\n\n      // Add handler to track the seek operation over the whole document\n      new DOM(document).on(isTouchEvent ? 'touchmove' : 'mousemove', mouseTouchMoveHandler);\n      new DOM(document).on(isTouchEvent ? 'touchend' : 'mouseup', mouseTouchUpHandler);\n    });\n\n    // Display seek target indicator when mouse hovers or finger slides over seekbar\n    seekBar.on('touchmove mousemove', (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      if (seeking) {\n        // During a seek (when mouse is down or touch move active), we need to stop propagation to avoid\n        // the VR viewport reacting to the moves.\n        e.stopPropagation();\n        // Because the stopped propagation inhibits the event on the document, we need to call it from here\n        mouseTouchMoveHandler(e);\n      }\n\n      let position = 100 * this.getOffset(e);\n      this.setSeekPosition(position);\n      this.onSeekPreviewEvent(position, false);\n\n      if (this.hasLabel() && this.getLabel().isHidden()) {\n        this.getLabel().show();\n      }\n    });\n\n    // Hide seek target indicator when mouse or finger leaves seekbar\n    seekBar.on('touchend mouseleave', (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      this.setSeekPosition(0);\n\n      if (this.hasLabel()) {\n        this.getLabel().hide();\n      }\n    });\n\n    seekBarContainer.append(seekBar);\n\n    if (this.label) {\n      seekBarContainer.append(this.label.getDomElement());\n    }\n\n    return seekBarContainer;\n  }\n\n  protected updateMarkers(): void {\n    this.seekBarMarkersContainer.empty();\n\n    for (let marker of this.timelineMarkers) {\n      let className = marker.markerType === '2' ? this.prefixCss('seekbar-marker-typetwo') : this.prefixCss('seekbar-marker')\n\n      let markerDom = new DOM('div', {\n        'class': className,\n        'data-marker-time': String(marker.time),\n        'data-marker-title': String(marker.title),\n      }).css({\n        'width': marker.time + '%',\n      })\n      this.seekBarMarkersContainer.append(markerDom)\n    }\n  }\n\n  protected getMarkerAtPosition(percentage: number): TimelineMarker | null {\n    let snappedMarker: TimelineMarker = null;\n    let snappingRange = 1;\n    if (this.timelineMarkers.length > 0) {\n      for (let marker of this.timelineMarkers) {\n        if (percentage >= marker.time - snappingRange && percentage <= marker.time + snappingRange) {\n          snappedMarker = marker;\n          break;\n        }\n      }\n    }\n\n    return snappedMarker;\n  }\n\n  /**\n   * Gets the horizontal offset of a mouse/touch event point from the left edge of the seek bar.\n   * @param eventPageX the pageX coordinate of an event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1], where 0 is the left edge and 1 is the right edge\n   */\n  private getHorizontalOffset(eventPageX: number): number {\n    let elementOffsetPx = this.seekBar.offset().left;\n    let widthPx = this.seekBar.width();\n    let offsetPx = eventPageX - elementOffsetPx;\n    let offset = 1 / widthPx * offsetPx;\n\n    return this.sanitizeOffset(offset);\n  }\n\n  /**\n   * Gets the vertical offset of a mouse/touch event point from the bottom edge of the seek bar.\n   * @param eventPageY the pageX coordinate of an event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1], where 0 is the bottom edge and 1 is the top edge\n   */\n  private getVerticalOffset(eventPageY: number): number {\n    let elementOffsetPx = this.seekBar.offset().top;\n    let widthPx = this.seekBar.height();\n    let offsetPx = eventPageY - elementOffsetPx;\n    let offset = 1 / widthPx * offsetPx;\n\n    return 1 - this.sanitizeOffset(offset);\n  }\n\n  /**\n   * Gets the mouse or touch event offset for the current configuration (horizontal or vertical).\n   * @param e the event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1]\n   * @see #getHorizontalOffset\n   * @see #getVerticalOffset\n   */\n  private getOffset(e: MouseEvent | TouchEvent): number {\n    if (this.touchSupported && e instanceof TouchEvent) {\n      if (this.config.vertical) {\n        return this.getVerticalOffset(e.type === 'touchend' ? e.changedTouches[0].pageY : e.touches[0].pageY);\n      } else {\n        return this.getHorizontalOffset(e.type === 'touchend' ? e.changedTouches[0].pageX : e.touches[0].pageX);\n      }\n    }\n    else if (e instanceof MouseEvent) {\n      if (this.config.vertical) {\n        return this.getVerticalOffset(e.pageY);\n      } else {\n        return this.getHorizontalOffset(e.pageX);\n      }\n    }\n    else {\n      if (console) {\n        console.warn('invalid event');\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Sanitizes the mouse offset to the range of [0, 1].\n   *\n   * When tracking the mouse outside the seek bar, the offset can be outside the desired range and this method\n   * limits it to the desired range. E.g. a mouse event left of the left edge of a seek bar yields an offset below\n   * zero, but to display the seek target on the seek bar, we need to limit it to zero.\n   *\n   * @param offset the offset to sanitize\n   * @returns {number} the sanitized offset.\n   */\n  private sanitizeOffset(offset: number) {\n    // Since we track mouse moves over the whole document, the target can be outside the seek range,\n    // and we need to limit it to the [0, 1] range.\n    if (offset < 0) {\n      offset = 0;\n    } else if (offset > 1) {\n      offset = 1;\n    }\n\n    return offset;\n  }\n\n  /**\n   * Sets the position of the playback position indicator.\n   * @param percent a number between 0 and 100 as returned by the player\n   */\n  setPlaybackPosition(percent: number) {\n    this.playbackPositionPercentage = percent;\n\n    // Set position of the bar\n    this.setPosition(this.seekBarPlaybackPosition, percent);\n\n    // Set position of the marker\n    let px = (this.config.vertical ? this.seekBar.height() : this.seekBar.width()) / 100 * percent;\n    if (this.config.vertical) {\n      px = this.seekBar.height() - px;\n    }\n    let style = this.config.vertical ?\n      // -ms-transform required for IE9\n      { 'transform': 'translateY(' + px + 'px)', '-ms-transform': 'translateY(' + px + 'px)' } :\n      { 'transform': 'translateX(' + px + 'px)', '-ms-transform': 'translateX(' + px + 'px)' };\n    this.seekBarPlaybackPositionMarker.css(style);\n  }\n\n  /**\n   * Refreshes the playback position. Can be used by subclasses to refresh the position when\n   * the size of the component changes.\n   */\n  protected refreshPlaybackPosition() {\n    this.setPlaybackPosition(this.playbackPositionPercentage);\n  }\n\n  /**\n   * Sets the position until which media is buffered.\n   * @param percent a number between 0 and 100\n   */\n  setBufferPosition(percent: number) {\n    this.setPosition(this.seekBarBufferPosition, percent);\n  }\n\n  /**\n   * Sets the position where a seek, if executed, would jump to.\n   * @param percent a number between 0 and 100\n   */\n  setSeekPosition(percent: number) {\n    this.setPosition(this.seekBarSeekPosition, percent);\n  }\n\n  /**\n   * Set the actual position (width or height) of a DOM element that represent a bar in the seek bar.\n   * @param element the element to set the position for\n   * @param percent a number between 0 and 100\n   */\n  private setPosition(element: DOM, percent: number) {\n    let scale = percent / 100;\n    let style = this.config.vertical ?\n      // -ms-transform required for IE9\n      { 'transform': 'scaleY(' + scale + ')', '-ms-transform': 'scaleY(' + scale + ')' } :\n      { 'transform': 'scaleX(' + scale + ')', '-ms-transform': 'scaleX(' + scale + ')' };\n    element.css(style);\n  }\n\n  /**\n   * Puts the seek bar into or out of seeking state by adding/removing a class to the DOM element. This can be used\n   * to adjust the styling while seeking.\n   *\n   * @param seeking should be true when entering seek state, false when exiting the seek state\n   */\n  setSeeking(seeking: boolean) {\n    if (seeking) {\n      this.getDomElement().addClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n    } else {\n      this.getDomElement().removeClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n    }\n  }\n\n  /**\n   * Checks if the seek bar is currently in the seek state.\n   * @returns {boolean} true if in seek state, else false\n   */\n  isSeeking(): boolean {\n    return this.getDomElement().hasClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n  }\n\n  /**\n   * Checks if the seek bar has a {@link SeekBarLabel}.\n   * @returns {boolean} true if the seek bar has a label, else false\n   */\n  hasLabel(): boolean {\n    return this.label != null;\n  }\n\n  /**\n   * Gets the label of this seek bar.\n   * @returns {SeekBarLabel} the label if this seek bar has a label, else null\n   */\n  getLabel(): SeekBarLabel | null {\n    return this.label;\n  }\n\n  protected onSeekEvent() {\n    this.seekBarEvents.onSeek.dispatch(this);\n  }\n\n  protected onSeekPreviewEvent(percentage: number, scrubbing: boolean) {\n    let snappedMarker = this.getMarkerAtPosition(percentage);\n\n    if (this.label) {\n      this.label.getDomElement().css({\n        'left': (snappedMarker ? snappedMarker.time : percentage) + '%'\n      });\n    }\n\n    this.seekBarEvents.onSeekPreview.dispatch(this, {\n      scrubbing: scrubbing,\n      position: percentage,\n      marker: snappedMarker,\n    });\n  }\n\n  protected onSeekedEvent(percentage: number) {\n    this.seekBarEvents.onSeeked.dispatch(this, percentage);\n  }\n\n  /**\n   * Gets the event that is fired when a scrubbing seek operation is started.\n   * @returns {Event<SeekBar, NoArgs>}\n   */\n  get onSeek(): Event<SeekBar, NoArgs> {\n    return this.seekBarEvents.onSeek.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired during a scrubbing seek (to indicate that the seek preview, i.e. the video frame,\n   * should be updated), or during a normal seek preview when the seek bar is hovered (and the seek target,\n   * i.e. the seek bar label, should be updated).\n   * @returns {Event<SeekBar, SeekPreviewEventArgs>}\n   */\n  get onSeekPreview(): Event<SeekBar, SeekPreviewEventArgs> {\n    return this.seekBarEvents.onSeekPreview.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when a scrubbing seek has finished or when a direct seek is issued.\n   * @returns {Event<SeekBar, number>}\n   */\n  get onSeeked(): Event<SeekBar, number> {\n    return this.seekBarEvents.onSeeked.getEvent();\n  }\n\n\n  protected onShowEvent(): void {\n    super.onShowEvent();\n\n    // Refresh the position of the playback position when the seek bar becomes visible. To correctly set the position,\n    // the DOM element must be fully initialized an have its size calculated, because the position is set as an absolute\n    // value calculated from the size. This required size is not known when it is hidden.\n    // For such cases, we refresh the position here in onShow because here it is guaranteed that the component knows\n    // its size and can set the position correctly.\n    this.refreshPlaybackPosition();\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {Label, LabelConfig} from './label';\nimport {Component, ComponentConfig} from './component';\nimport {UIInstanceManager, SeekPreviewArgs} from '../uimanager';\nimport {StringUtils} from '../utils';\n\n/**\n * Configuration interface for a {@link SeekBarLabel}.\n */\nexport interface SeekBarLabelConfig extends ContainerConfig {\n  // nothing yet\n}\n\n/**\n * A label for a {@link SeekBar} that can display the seek target time, a thumbnail, and title (e.g. chapter title).\n */\nexport class SeekBarLabel extends Container<SeekBarLabelConfig> {\n\n  private timeLabel: Label<LabelConfig>;\n  private titleLabel: Label<LabelConfig>;\n  private numberLabel: Label<LabelConfig>;\n  private commentLabel: Label<LabelConfig>;\n  private avatarLabel: Label<LabelConfig>;\n  private thumbnail: Component<ComponentConfig>;\n  private metadata: Component<ComponentConfig>;\n\n  private timeFormat: string;\n\n  constructor(config: SeekBarLabelConfig = {}) {\n    super(config);\n\n    this.timeLabel = new Label({cssClasses: ['seekbar-label-time']});\n    this.titleLabel = new Label({cssClasses: ['seekbar-label-title']});\n    this.commentLabel = new Label({cssClasses: ['seekbar-label-comment']});\n    this.numberLabel = new Label({cssClasses: ['seekbar-label-number']});\n    this.avatarLabel = new Label({cssClasses: ['seekbar-label-avatar']});\n    this.thumbnail = new Component({cssClasses: ['seekbar-thumbnail']});\n    this.metadata = new Container({\n      components: [\n        new Container({\n          components: [\n            this.avatarLabel,\n            this.titleLabel,\n            this.numberLabel],\n          cssClass: 'seekbar-label-metadata-title',\n        }),\n        new Container({\n          components: [\n            this.commentLabel,\n            this.timeLabel],\n          cssClass: 'seekbar-label-metadata-content',\n        }),\n      ],\n      cssClass: 'seekbar-label-metadata'\n    });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-seekbar-label',\n      components: [new Container({\n        components: [\n          this.thumbnail,\n          this.metadata\n        ],\n        cssClass: 'seekbar-label-inner',\n      })],\n      hidden: true\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    uimanager.onSeekPreview.subscribe((sender, args: SeekPreviewArgs) => {\n      if (player.isLive()) {\n        let time = player.getMaxTimeShift() - player.getMaxTimeShift() * (args.position / 100);\n        this.setTime(time);\n      } else {\n        let percentage = 0;\n        if (args.marker) {\n          this.setTitleText(args.marker.title);\n          this.setSmashcutData(args.marker);\n          this.setTime(args.marker.time);\n          this.setThumbnail(null);\n          this.setBackground(true);\n        } else {\n          percentage = args.position;\n          this.setTitleText(null);\n          this.setSmashcutData(null);\n          let time = player.getDuration() * (percentage / 100);\n          this.setTime(time);\n          this.setThumbnail(player.getThumb(time));\n          this.setBackground(false);\n        }\n      }\n    });\n\n    let init = () => {\n      // Set time format depending on source duration\n      this.timeFormat = Math.abs(player.isLive() ? player.getMaxTimeShift() : player.getDuration()) >= 3600 ?\n        StringUtils.FORMAT_HHMMSS : StringUtils.FORMAT_MMSS;\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, init);\n    init();\n  }\n\n  /**\n   * Sets arbitrary text on the label.\n   * @param text the text to show on the label\n   */\n  setText(text: string) {\n    this.timeLabel.setText(text);\n  }\n\n  /**\n   * Sets a time to be displayed on the label.\n   * @param seconds the time in seconds to display on the label\n   */\n  setTime(seconds: number) {\n    this.setText(StringUtils.secondsToTime(seconds, this.timeFormat));\n  }\n\n  /**\n   * Sets the text on the title label.\n   * @param text the text to show on the label\n   */\n  setTitleText(text: string) {\n    this.titleLabel.setText(text);\n  }\n\n  setSmashcutData(marker: any) {\n    if (marker) {\n      this.commentLabel.setText(marker.comment);\n      this.numberLabel.setText(marker.number);\n      this.avatarLabel.setText(marker.avatar);\n    } else {\n      this.commentLabel.setText(null);\n      this.numberLabel.setText(null);\n      this.avatarLabel.setText(null);\n    }\n  }\n\n  /**\n   * Sets or removes a thumbnail on the label.\n   * @param thumbnail the thumbnail to display on the label or null to remove a displayed thumbnail\n   */\n  setThumbnail(thumbnail: bitmovin.player.Thumbnail = null) {\n    let thumbnailElement = this.thumbnail.getDomElement();\n\n    if (thumbnail == null) {\n      thumbnailElement.css({\n        'background-image': null,\n        'display': 'null',\n        'width': 'null',\n        'height': 'null'\n      });\n    }\n    else {\n      thumbnailElement.css({\n        'display': 'inherit',\n        'background-image': `url(${thumbnail.url})`,\n        'width': thumbnail.w + 'px',\n        'height': thumbnail.h + 'px',\n        'background-position': `-${thumbnail.x}px -${thumbnail.y}px`\n      });\n    }\n  }\n\n  setBackground(onOff: boolean) {\n    let metadataElement = this.metadata.getDomElement();\n\n    if (onOff) {\n      metadataElement.css({\n        'background': '#000'\n      });\n    }\n    else {\n      metadataElement.css({\n        'background': 'initial'\n      });\n    }\n  }\n}","import {ListSelector, ListSelectorConfig} from './listselector';\nimport {DOM} from '../dom';\n\n/**\n * A simple select box providing the possibility to select a single item out of a list of available items.\n *\n * DOM example:\n * <code>\n *     <select class='ui-selectbox'>\n *         <option value='key'>label</option>\n *         ...\n *     </select>\n * </code>\n */\nexport class SelectBox extends ListSelector<ListSelectorConfig> {\n\n  private selectElement: DOM;\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-selectbox'\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    let selectElement = new DOM('select', {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    this.selectElement = selectElement;\n    this.updateDomItems();\n\n    selectElement.on('change', () => {\n      let value = selectElement.val();\n      this.onItemSelectedEvent(value, false);\n    });\n\n    return selectElement;\n  }\n\n  protected updateDomItems(selectedValue: string = null) {\n    // Delete all children\n    this.selectElement.empty();\n\n    // Add updated children\n    for (let item of this.items) {\n      let optionElement = new DOM('option', {\n        'value': item.key\n      }).html(item.label);\n\n      if (item.key === selectedValue + '') { // convert selectedValue to string to catch 'null'/null case\n        optionElement.attr('selected', 'selected');\n      }\n\n      this.selectElement.append(optionElement);\n    }\n  }\n\n  protected onItemAddedEvent(value: string) {\n    super.onItemAddedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemRemovedEvent(value: string) {\n    super.onItemRemovedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemSelectedEvent(value: string, updateDomItems: boolean = true) {\n    super.onItemSelectedEvent(value);\n    if (updateDomItems) {\n      this.updateDomItems(value);\n    }\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {SelectBox} from './selectbox';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {VideoQualitySelectBox} from './videoqualityselectbox';\nimport {AudioQualitySelectBox} from './audioqualityselectbox';\nimport {Timeout} from '../timeout';\nimport {Event, EventDispatcher, NoArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link SettingsPanel}.\n */\nexport interface SettingsPanelConfig extends ContainerConfig {\n  /**\n   * The delay in milliseconds after which the settings panel will be hidden when there is no user interaction.\n   * Set to -1 to disable automatic hiding.\n   * Default: 3 seconds (3000)\n   */\n  hideDelay?: number;\n}\n\n/**\n * A panel containing a list of {@link SettingsPanelItem items} that represent labelled settings.\n */\nexport class SettingsPanel extends Container<SettingsPanelConfig> {\n\n  private static readonly CLASS_LAST = 'last';\n\n  private settingsPanelEvents = {\n    onSettingsStateChanged: new EventDispatcher<SettingsPanel, NoArgs>()\n  };\n\n  private hideTimeout: Timeout;\n\n  constructor(config: SettingsPanelConfig) {\n    super(config);\n\n    this.config = this.mergeConfig<SettingsPanelConfig>(config, {\n      cssClass: 'ui-settings-panel',\n      hideDelay: 3000\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <SettingsPanelConfig>this.getConfig(); // TODO fix generics type inference\n\n    if (config.hideDelay > -1) {\n      this.hideTimeout = new Timeout(config.hideDelay, () => {\n        this.hide();\n      });\n\n      this.onShow.subscribe(() => {\n        // Activate timeout when shown\n        this.hideTimeout.start();\n      });\n      this.getDomElement().on('mousemove', () => {\n        // Reset timeout on interaction\n        this.hideTimeout.reset();\n      });\n      this.onHide.subscribe(() => {\n        // Clear timeout when hidden from outside\n        this.hideTimeout.clear();\n      });\n    }\n\n    // Fire event when the state of a settings-item has changed\n    let settingsStateChangedHandler = () => {\n      this.onSettingsStateChangedEvent();\n\n      // Attach marker class to last visible item\n      let lastShownItem = null;\n      for (let component of this.getItems()) {\n        if (component instanceof SettingsPanelItem) {\n          component.getDomElement().removeClass(this.prefixCss(SettingsPanel.CLASS_LAST));\n          if (component.isShown()) {\n            lastShownItem = component;\n          }\n        }\n      }\n      if (lastShownItem) {\n        lastShownItem.getDomElement().addClass(this.prefixCss(SettingsPanel.CLASS_LAST));\n      }\n    };\n    for (let component of this.getItems()) {\n      if (component instanceof SettingsPanelItem) {\n        component.onActiveChanged.subscribe(settingsStateChangedHandler);\n      }\n    }\n  }\n\n  release(): void {\n    super.release();\n    if (this.hideTimeout) {\n      this.hideTimeout.clear();\n    }\n  }\n\n  /**\n   * Checks if there are active settings within this settings panel. An active setting is a setting that is visible\n   * and enabled, which the user can interact with.\n   * @returns {boolean} true if there are active settings, false if the panel is functionally empty to a user\n   */\n  hasActiveSettings(): boolean {\n    for (let component of this.getItems()) {\n      if (component.isActive()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private getItems(): SettingsPanelItem[] {\n    return <SettingsPanelItem[]>this.config.components;\n  }\n\n  protected onSettingsStateChangedEvent() {\n    this.settingsPanelEvents.onSettingsStateChanged.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when one or more {@link SettingsPanelItem items} have changed state.\n   * @returns {Event<SettingsPanel, NoArgs>}\n   */\n  get onSettingsStateChanged(): Event<SettingsPanel, NoArgs> {\n    return this.settingsPanelEvents.onSettingsStateChanged.getEvent();\n  }\n}\n\n/**\n * An item for a {@link SettingsPanel}, containing a {@link Label} and a component that configures a setting.\n * Supported setting components: {@link SelectBox}\n */\nexport class SettingsPanelItem extends Container<ContainerConfig> {\n\n  private label: Label<LabelConfig>;\n  private setting: SelectBox;\n\n  private settingsPanelItemEvents = {\n    onActiveChanged: new EventDispatcher<SettingsPanelItem, NoArgs>()\n  };\n\n  constructor(label: string, selectBox: SelectBox, config: ContainerConfig = {}) {\n    super(config);\n\n    this.label = new Label({ text: label });\n    this.setting = selectBox;\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-settings-panel-item',\n      components: [this.label, this.setting]\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let handleConfigItemChanged = () => {\n      // The minimum number of items that must be available for the setting to be displayed\n      // By default, at least two items must be available, else a selection is not possible\n      let minItemsToDisplay = 2;\n      // Audio/video quality select boxes contain an additional 'auto' mode, which in combination with a single\n      // available quality also does not make sense\n      if (this.setting instanceof VideoQualitySelectBox || this.setting instanceof AudioQualitySelectBox) {\n        minItemsToDisplay = 3;\n      }\n\n      // Hide the setting if no meaningful choice is available\n      if (this.setting.itemCount() < minItemsToDisplay) {\n        this.hide();\n      } else {\n        this.show();\n      }\n\n      // Visibility might have changed and therefore the active state might have changed so we fire the event\n      // TODO fire only when state has really changed (e.g. check if visibility has really changed)\n      this.onActiveChangedEvent();\n    };\n\n    this.setting.onItemAdded.subscribe(handleConfigItemChanged);\n    this.setting.onItemRemoved.subscribe(handleConfigItemChanged);\n\n    // Initialize hidden state\n    handleConfigItemChanged();\n  }\n\n  /**\n   * Checks if this settings panel item is active, i.e. visible and enabled and a user can interact with it.\n   * @returns {boolean} true if the panel is active, else false\n   */\n  isActive(): boolean {\n    return this.isShown();\n  }\n\n  protected onActiveChangedEvent() {\n    this.settingsPanelItemEvents.onActiveChanged.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the 'active' state of this item changes.\n   * @see #isActive\n   * @returns {Event<SettingsPanelItem, NoArgs>}\n   */\n  get onActiveChanged(): Event<SettingsPanelItem, NoArgs> {\n    return this.settingsPanelItemEvents.onActiveChanged.getEvent();\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {SettingsPanel} from './settingspanel';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Configuration interface for the {@link SettingsToggleButton}.\n */\nexport interface SettingsToggleButtonConfig extends ToggleButtonConfig {\n  /**\n   * The settings panel whose visibility the button should toggle.\n   */\n  settingsPanel: SettingsPanel;\n\n  /**\n   * Decides if the button should be automatically hidden when the settings panel does not contain any active settings.\n   * Default: true\n   */\n  autoHideWhenNoActiveSettings?: boolean;\n}\n\n/**\n * A button that toggles visibility of a settings panel.\n */\nexport class SettingsToggleButton extends ToggleButton<SettingsToggleButtonConfig> {\n\n  constructor(config: SettingsToggleButtonConfig) {\n    super(config);\n\n    if (!config.settingsPanel) {\n      throw new Error('Required SettingsPanel is missing');\n    }\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-settingstogglebutton',\n      text: 'Settings',\n      settingsPanel: null,\n      autoHideWhenNoActiveSettings: true\n    }, <SettingsToggleButtonConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <SettingsToggleButtonConfig>this.getConfig(); // TODO fix generics type inference\n    let settingsPanel = config.settingsPanel;\n\n    this.onClick.subscribe(() => {\n      settingsPanel.toggleHidden();\n    });\n    settingsPanel.onShow.subscribe(() => {\n      // Set toggle status to on when the settings panel shows\n      this.on();\n    });\n    settingsPanel.onHide.subscribe(() => {\n      // Set toggle status to off when the settings panel hides\n      this.off();\n    });\n\n    // Handle automatic hiding of the button if there are no settings for the user to interact with\n    if (config.autoHideWhenNoActiveSettings) {\n      // Setup handler to show/hide button when the settings change\n      let settingsPanelItemsChangedHandler = () => {\n        if (settingsPanel.hasActiveSettings()) {\n          if (this.isHidden()) {\n            this.show();\n          }\n        } else {\n          if (this.isShown()) {\n            this.hide();\n          }\n        }\n      };\n      // Wire the handler to the event\n      settingsPanel.onSettingsStateChanged.subscribe(settingsPanelItemsChangedHandler);\n      // Call handler for first init at startup\n      settingsPanelItemsChangedHandler();\n    }\n  }\n}","import {Component, ComponentConfig} from './component';\n\n/**\n * A dummy component that just reserves some space and does nothing else.\n */\nexport class Spacer extends Component<ComponentConfig> {\n\n  constructor(config: ComponentConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-spacer',\n    }, this.config);\n  }\n\n\n  protected onShowEvent(): void {\n    // disable event firing by overwriting and not calling super\n  }\n\n  protected onHideEvent(): void {\n    // disable event firing by overwriting and not calling super\n  }\n\n  protected onHoverChangedEvent(hovered: boolean): void {\n    // disable event firing by overwriting and not calling super\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport SubtitleCueEvent = bitmovin.player.SubtitleCueEvent;\nimport {Label, LabelConfig} from './label';\nimport {ComponentConfig, Component} from './component';\nimport {ControlBar} from './controlbar';\n\n/**\n * Overlays the player to display subtitles.\n */\nexport class SubtitleOverlay extends Container<ContainerConfig> {\n\n  private static readonly CLASS_CONTROLBAR_VISIBLE = 'controlbar-visible';\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitle-overlay',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let subtitleManager = new ActiveSubtitleManager();\n\n    player.addEventHandler(player.EVENT.ON_CUE_ENTER, (event: SubtitleCueEvent) => {\n      let labelToAdd = subtitleManager.cueEnter(event);\n\n      this.addComponent(labelToAdd);\n      this.updateComponents();\n\n      this.show();\n    });\n    player.addEventHandler(player.EVENT.ON_CUE_EXIT, (event: SubtitleCueEvent) => {\n      let labelToRemove = subtitleManager.cueExit(event);\n\n      this.removeComponent(labelToRemove);\n      this.updateComponents();\n\n      if (!subtitleManager.hasCues) {\n        this.hide();\n      }\n    });\n\n    let subtitleClearHandler = () => {\n      this.hide();\n      subtitleManager.clear();\n      this.removeComponents();\n      this.updateComponents();\n    };\n\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_CHANGED, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_SEEK, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, subtitleClearHandler);\n\n    uimanager.onComponentShow.subscribe((component: Component<ComponentConfig>) => {\n      if (component instanceof ControlBar) {\n        this.getDomElement().addClass(this.prefixCss(SubtitleOverlay.CLASS_CONTROLBAR_VISIBLE));\n      }\n    });\n    uimanager.onComponentHide.subscribe((component: Component<ComponentConfig>) => {\n      if (component instanceof ControlBar) {\n        this.getDomElement().removeClass(this.prefixCss(SubtitleOverlay.CLASS_CONTROLBAR_VISIBLE));\n      }\n    });\n\n    // Init\n    subtitleClearHandler();\n  }\n}\n\ninterface ActiveSubtitleCue {\n  event: SubtitleCueEvent;\n  label: SubtitleLabel;\n}\n\ninterface ActiveSubtitleCueMap {\n  [id: string]: ActiveSubtitleCue;\n}\n\nclass SubtitleLabel extends Label<LabelConfig> {\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitle-label'\n    }, this.config);\n  }\n}\n\nclass ActiveSubtitleManager {\n\n  private activeSubtitleCueMap: ActiveSubtitleCueMap;\n\n  constructor() {\n    this.activeSubtitleCueMap = {};\n  }\n\n  /**\n   * Calculates a unique ID for a subtitle cue, which is needed to associate an ON_CUE_ENTER with its ON_CUE_EXIT\n   * event so we can remove the correct subtitle in ON_CUE_EXIT when multiple subtitles are active at the same time.\n   * The start time plus the text should make a unique identifier, and in the only case where a collision\n   * can happen, two similar texts will displayed at a similar time so it does not matter which one we delete.\n   * The start time should always be known, because it is required to schedule the ON_CUE_ENTER event. The end time\n   * must not necessarily be known and therefore cannot be used for the ID.\n   * @param event\n   * @return {string}\n   */\n  private static calculateId(event: SubtitleCueEvent): string {\n    return event.start + event.text;\n  }\n\n  /**\n   * Adds a subtitle cue to the manager and returns the label that should be added to the subtitle overlay.\n   * @param event\n   * @return {SubtitleLabel}\n   */\n  cueEnter(event: SubtitleCueEvent): SubtitleLabel {\n    let id = ActiveSubtitleManager.calculateId(event);\n\n    let label = new SubtitleLabel({\n      // Prefer the HTML subtitle text if set, else use the plain text\n      text: event.html || event.text\n    });\n\n    this.activeSubtitleCueMap[id] = { event, label };\n\n    return label;\n  }\n\n  /**\n   * Removes the subtitle cue from the manager and returns the label that should be removed from the subtitle overlay.\n   * @param event\n   * @return {SubtitleLabel}\n   */\n  cueExit(event: SubtitleCueEvent): SubtitleLabel {\n    let id = ActiveSubtitleManager.calculateId(event);\n    let activeSubtitleCue = this.activeSubtitleCueMap[id];\n    delete this.activeSubtitleCueMap[id];\n    return activeSubtitleCue.label;\n  }\n\n  /**\n   * Returns the number of active subtitle cues.\n   * @return {number}\n   */\n  get cueCount(): number {\n    return Object.keys(this.activeSubtitleCueMap).length;\n  }\n\n  /**\n   * Returns true if there are active subtitle cues, else false.\n   * @return {boolean}\n   */\n  get hasCues(): boolean {\n    return this.cueCount > 0;\n  }\n\n  /**\n   * Removes all subtitle cues from the manager.\n   */\n  clear(): void {\n    this.activeSubtitleCueMap = {};\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\nimport SubtitleAddedEvent = bitmovin.player.SubtitleAddedEvent;\nimport SubtitleChangedEvent = bitmovin.player.SubtitleChangedEvent;\nimport SubtitleRemovedEvent = bitmovin.player.SubtitleRemovedEvent;\n\n/**\n * A select box providing a selection between available subtitle and caption tracks.\n */\nexport class SubtitleSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let getLabel = (id: string) => {\n      switch (id) {\n        case 'off' :\n          return 'Off'\n        case 'en' :\n          return 'English'\n        case 'fr' :\n          return 'Francais'\n        case 'de' :\n          return 'Deutsch'\n        case 'es' :\n          return 'Espaniol'\n        default:\n          return id\n      }\n    }\n\n    let updateSubtitles = () => {\n      this.clearItems();\n\n      for (let subtitle of player.getAvailableSubtitles()) {\n        this.addItem(subtitle.id, getLabel(subtitle.label));\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: SubtitleSelectBox, value: string) => {\n      player.setSubtitle(value === 'null' ? null : value);\n    });\n\n    // React to API events\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_ADDED, (event: SubtitleAddedEvent) => {\n      this.addItem(event.subtitle.id, event.subtitle.label);\n    });\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_CHANGED, (event: SubtitleChangedEvent) => {\n      this.selectItem(event.targetSubtitle.id);\n    });\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_REMOVED, (event: SubtitleRemovedEvent) => {\n      this.removeItem(event.subtitleId);\n    });\n\n    // Update subtitles when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateSubtitles);\n    // Update subtitles when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateSubtitles);\n\n    // Populate subtitles at startup\n    updateSubtitles();\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {MetadataLabel, MetadataLabelContent} from './metadatalabel';\n\n/**\n * Configuration interface for a {@link TitleBar}.\n */\nexport interface TitleBarConfig extends ContainerConfig {\n  /**\n   * Specifies if the title bar should stay hidden when no metadata label contains any text. Does not make a lot\n   * of sense if the title bar contains other components than just MetadataLabels (like in the default configuration).\n   * Default: false\n   */\n  keepHiddenWithoutMetadata?: boolean;\n}\n\n/**\n * Displays a title bar containing a label with the title of the video.\n */\nexport class TitleBar extends Container<TitleBarConfig> {\n\n  constructor(config: TitleBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-titlebar',\n      hidden: true,\n      components: [\n        new MetadataLabel({ content: MetadataLabelContent.Title }),\n        new MetadataLabel({ content: MetadataLabelContent.Description })\n      ],\n      keepHiddenWithoutMetadata: false,\n    }, <TitleBarConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <TitleBarConfig>this.getConfig();\n    let shouldBeShown = !this.isHidden();\n    let hasMetadataText = true; // Flag to track if any metadata label contains text\n\n    let checkMetadataTextAndUpdateVisibility = () => {\n      hasMetadataText = false;\n\n      // Iterate through metadata labels and check if at least one of them contains text\n      for (let component of this.getComponents()) {\n        if (component instanceof MetadataLabel) {\n          if (!component.isEmpty()) {\n            hasMetadataText = true;\n            break;\n          }\n        }\n      }\n\n      if (this.isShown()) {\n        // Hide a visible titlebar if it does not contain any text and the hidden flag is set\n        if (config.keepHiddenWithoutMetadata && !hasMetadataText) {\n          this.hide();\n        }\n      } else if (shouldBeShown) {\n        // Show a hidden titlebar if it should actually be shown\n        this.show();\n      }\n    };\n\n    // Listen to text change events to update the hasMetadataText flag when the metadata dynamically changes\n    for (let component of this.getComponents()) {\n      if (component instanceof MetadataLabel) {\n        component.onTextChanged.subscribe(checkMetadataTextAndUpdateVisibility);\n      }\n    }\n\n    uimanager.onControlsShow.subscribe(() => {\n      shouldBeShown = true;\n      if (!(config.keepHiddenWithoutMetadata && !hasMetadataText)) {\n        this.show();\n      }\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      shouldBeShown = false;\n      this.hide();\n    });\n\n    // init\n    checkMetadataTextAndUpdateVisibility();\n  }\n}","import {Button, ButtonConfig} from './button';\nimport {NoArgs, EventDispatcher, Event} from '../eventdispatcher';\n\n/**\n * Configuration interface for a toggle button component.\n */\nexport interface ToggleButtonConfig extends ButtonConfig {\n  /**\n   * The text on the button.\n   */\n  text?: string;\n}\n\n/**\n * A button that can be toggled between 'on' and 'off' states.\n */\nexport class ToggleButton<Config extends ToggleButtonConfig> extends Button<ToggleButtonConfig> {\n\n  private static readonly CLASS_ON = 'on';\n  private static readonly CLASS_OFF = 'off';\n\n  private onState: boolean;\n\n  private toggleButtonEvents = {\n    onToggle: new EventDispatcher<ToggleButton<Config>, NoArgs>(),\n    onToggleOn: new EventDispatcher<ToggleButton<Config>, NoArgs>(),\n    onToggleOff: new EventDispatcher<ToggleButton<Config>, NoArgs>()\n  };\n\n  constructor(config: ToggleButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-togglebutton'\n    }, this.config);\n  }\n\n  /**\n   * Toggles the button to the 'on' state.\n   */\n  on() {\n    if (this.isOff()) {\n      this.onState = true;\n      this.getDomElement().removeClass(this.prefixCss(ToggleButton.CLASS_OFF));\n      this.getDomElement().addClass(this.prefixCss(ToggleButton.CLASS_ON));\n\n      this.onToggleEvent();\n      this.onToggleOnEvent();\n    }\n  }\n\n  /**\n   * Toggles the button to the 'off' state.\n   */\n  off() {\n    if (this.isOn()) {\n      this.onState = false;\n      this.getDomElement().removeClass(this.prefixCss(ToggleButton.CLASS_ON));\n      this.getDomElement().addClass(this.prefixCss(ToggleButton.CLASS_OFF));\n\n      this.onToggleEvent();\n      this.onToggleOffEvent();\n    }\n  }\n\n  /**\n   * Toggle the button 'on' if it is 'off', or 'off' if it is 'on'.\n   */\n  toggle() {\n    if (this.isOn()) {\n      this.off();\n    } else {\n      this.on();\n    }\n  }\n\n  /**\n   * Checks if the toggle button is in the 'on' state.\n   * @returns {boolean} true if button is 'on', false if 'off'\n   */\n  isOn(): boolean {\n    return this.onState;\n  }\n\n  /**\n   * Checks if the toggle button is in the 'off' state.\n   * @returns {boolean} true if button is 'off', false if 'on'\n   */\n  isOff(): boolean {\n    return !this.isOn();\n  }\n\n  protected onClickEvent() {\n    super.onClickEvent();\n\n    // Fire the toggle event together with the click event\n    // (they are technically the same, only the semantics are different)\n    this.onToggleEvent();\n  }\n\n  protected onToggleEvent() {\n    this.toggleButtonEvents.onToggle.dispatch(this);\n  }\n\n  protected onToggleOnEvent() {\n    this.toggleButtonEvents.onToggleOn.dispatch(this);\n  }\n\n  protected onToggleOffEvent() {\n    this.toggleButtonEvents.onToggleOff.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggle(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggle.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled 'on'.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggleOn(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggleOn.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled 'off'.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggleOff(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggleOff.getEvent();\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\n\n/**\n * Animated analog TV static noise.\n */\nexport class TvNoiseCanvas extends Component<ComponentConfig> {\n\n  private canvas: DOM;\n\n  private canvasElement: HTMLCanvasElement;\n  private canvasContext: CanvasRenderingContext2D;\n  private canvasWidth = 160;\n  private canvasHeight = 90;\n  private interferenceHeight = 50;\n  private lastFrameUpdate: number = 0;\n  private frameInterval: number = 60;\n  private useAnimationFrame: boolean = !!window.requestAnimationFrame;\n  private noiseAnimationWindowPos: number;\n  private frameUpdateHandlerId: number;\n\n  constructor(config: ComponentConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-tvnoisecanvas'\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    return this.canvas = new DOM('canvas', { 'class': this.getCssClasses() });\n  }\n\n  start(): void {\n    this.canvasElement = <HTMLCanvasElement>this.canvas.getElements()[0];\n    this.canvasContext = this.canvasElement.getContext('2d');\n    this.noiseAnimationWindowPos = -this.canvasHeight;\n    this.lastFrameUpdate = 0;\n\n    this.canvasElement.width = this.canvasWidth;\n    this.canvasElement.height = this.canvasHeight;\n\n    this.renderFrame();\n  }\n\n  stop(): void {\n    if (this.useAnimationFrame) {\n      cancelAnimationFrame(this.frameUpdateHandlerId);\n    } else {\n      clearTimeout(this.frameUpdateHandlerId);\n    }\n  }\n\n  private renderFrame(): void {\n    // This code has been copied from the player controls.js and simplified\n\n    if (this.lastFrameUpdate + this.frameInterval > new Date().getTime()) {\n      // It's too early to render the next frame\n      this.scheduleNextRender();\n      return;\n    }\n\n    let currentPixelOffset;\n    let canvasWidth = this.canvasWidth;\n    let canvasHeight = this.canvasHeight;\n\n    // Create texture\n    let noiseImage = this.canvasContext.createImageData(canvasWidth, canvasHeight);\n\n    // Fill texture with noise\n    for (let y = 0; y < canvasHeight; y++) {\n      for (let x = 0; x < canvasWidth; x++) {\n        currentPixelOffset = (canvasWidth * y * 4) + x * 4;\n        noiseImage.data[currentPixelOffset] = Math.random() * 255;\n        if (y < this.noiseAnimationWindowPos || y > this.noiseAnimationWindowPos + this.interferenceHeight) {\n          noiseImage.data[currentPixelOffset] *= 0.85;\n        }\n        noiseImage.data[currentPixelOffset + 1] = noiseImage.data[currentPixelOffset];\n        noiseImage.data[currentPixelOffset + 2] = noiseImage.data[currentPixelOffset];\n        noiseImage.data[currentPixelOffset + 3] = 50;\n      }\n    }\n\n    // Put texture onto canvas\n    this.canvasContext.putImageData(noiseImage, 0, 0);\n\n    this.lastFrameUpdate = new Date().getTime();\n    this.noiseAnimationWindowPos += 7;\n    if (this.noiseAnimationWindowPos > canvasHeight) {\n      this.noiseAnimationWindowPos = -canvasHeight;\n    }\n\n    this.scheduleNextRender();\n  }\n\n  private scheduleNextRender(): void {\n    if (this.useAnimationFrame) {\n      this.frameUpdateHandlerId = window.requestAnimationFrame(this.renderFrame.bind(this));\n    } else {\n      this.frameUpdateHandlerId = setTimeout(this.renderFrame.bind(this), this.frameInterval);\n    }\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {DOM} from '../dom';\nimport {Timeout} from '../timeout';\nimport {PlayerUtils} from '../utils';\nimport PlayerResizeEvent = bitmovin.player.PlayerResizeEvent;\nimport {CancelEventArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link UIContainer}.\n */\nexport interface UIContainerConfig extends ContainerConfig {\n  /**\n   * The delay in milliseconds after which the control bar will be hidden when there is no user interaction.\n   * Default: 5 seconds (5000)\n   */\n  hideDelay?: number;\n}\n\n/**\n * The base container that contains all of the UI. The UIContainer is passed to the {@link UIManager} to build and\n * setup the UI.\n */\nexport class UIContainer extends Container<UIContainerConfig> {\n\n  private static readonly STATE_PREFIX = 'player-state-';\n\n  private static readonly FULLSCREEN = 'fullscreen';\n  private static readonly BUFFERING = 'buffering';\n  private static readonly REMOTE_CONTROL = 'remote-control';\n  private static readonly CONTROLS_SHOWN = 'controls-shown';\n  private static readonly CONTROLS_HIDDEN = 'controls-hidden';\n\n  private uiHideTimeout: Timeout;\n\n  constructor(config: UIContainerConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <UIContainerConfig>{\n      cssClass: 'ui-uicontainer',\n      hideDelay: 5000,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.configureUIShowHide(player, uimanager);\n    this.configurePlayerStates(player, uimanager);\n  }\n\n  private configureUIShowHide(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let container = this.getDomElement();\n    let config = <UIContainerConfig>this.getConfig();\n\n    let isUiShown = false;\n    let isSeeking = false;\n    let isFirstTouch = true;\n\n    let showUi = () => {\n      if (!isUiShown) {\n        // Let subscribers know that they should reveal themselves\n        uimanager.onControlsShow.dispatch(this);\n        isUiShown = true;\n      }\n      // Don't trigger timeout while seeking (it will be triggered once the seek is finished) or casting\n      if (!isSeeking && !player.isCasting()) {\n        this.uiHideTimeout.start();\n      }\n    };\n\n    let hideUi = () => {\n      // Hide the UI only if it is shown, and if not casting\n      if (isUiShown && !player.isCasting()) {\n        // Issue a preview event to check if we are good to hide the controls\n        let previewHideEventArgs = <CancelEventArgs>{};\n        uimanager.onPreviewControlsHide.dispatch(this, previewHideEventArgs);\n\n        if (!previewHideEventArgs.cancel) {\n          // If the preview wasn't canceled, let subscribers know that they should now hide themselves\n          uimanager.onControlsHide.dispatch(this);\n          isUiShown = false;\n        } else {\n          // If the hide preview was canceled, continue to show UI\n          showUi();\n        }\n      }\n    };\n\n    // Timeout to defer UI hiding by the configured delay time\n    this.uiHideTimeout = new Timeout(config.hideDelay, hideUi);\n\n    // On touch displays, the first touch reveals the UI\n    container.on('touchend', (e) => {\n      if (!isUiShown) {\n        // Only if the UI is hidden, we prevent other actions (except for the first touch) and reveal the UI instead.\n        // The first touch is not prevented to let other listeners receive the event and trigger an initial action, e.g.\n        // the huge playback button can directly start playback instead of requiring a double tap which 1. reveals\n        // the UI and 2. starts playback.\n        if (isFirstTouch) {\n          isFirstTouch = false;\n        } else {\n          e.preventDefault();\n        }\n        showUi();\n      }\n    });\n    // When the mouse enters, we show the UI\n    container.on('mouseenter', () => {\n      showUi();\n    });\n    // When the mouse moves within, we show the UI\n    container.on('mousemove', () => {\n      showUi();\n    });\n    // When the mouse leaves, we can prepare to hide the UI, except a seek is going on\n    container.on('mouseleave', () => {\n      // When a seek is going on, the seek scrub pointer may exit the UI area while still seeking, and we do not hide\n      // the UI in such cases\n      if (!isSeeking) {\n        this.uiHideTimeout.start();\n      }\n    });\n\n    uimanager.onSeek.subscribe(() => {\n      this.uiHideTimeout.clear(); // Don't hide UI while a seek is in progress\n      isSeeking = true;\n    });\n    uimanager.onSeeked.subscribe(() => {\n      isSeeking = false;\n      this.uiHideTimeout.start(); // Re-enable UI hide timeout after a seek\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      showUi(); // Show UI when a Cast session has started (UI will then stay permanently on during the session)\n    });\n  }\n\n  private configurePlayerStates(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let container = this.getDomElement();\n\n    // Convert player states into CSS class names\n    let stateClassNames = <any>[];\n    for (let state in PlayerUtils.PlayerState) {\n      if (isNaN(Number(state))) {\n        let enumName = PlayerUtils.PlayerState[<any>PlayerUtils.PlayerState[state]];\n        stateClassNames[PlayerUtils.PlayerState[state]] =\n          this.prefixCss(UIContainer.STATE_PREFIX + enumName.toLowerCase());\n      }\n    }\n\n    let removeStates = () => {\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.IDLE]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PREPARED]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PLAYING]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PAUSED]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.FINISHED]);\n    };\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PREPARED]);\n    });\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PLAYING]);\n    });\n    player.addEventHandler(player.EVENT.ON_PAUSED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PAUSED]);\n    });\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.FINISHED]);\n    });\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.IDLE]);\n    });\n    // Init in current player state\n    container.addClass(stateClassNames[PlayerUtils.getState(player)]);\n\n    // Fullscreen marker class\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_ENTER, () => {\n      container.addClass(this.prefixCss(UIContainer.FULLSCREEN));\n    });\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_EXIT, () => {\n      container.removeClass(this.prefixCss(UIContainer.FULLSCREEN));\n    });\n    // Init fullscreen state\n    if (player.isFullscreen()) {\n      container.addClass(this.prefixCss(UIContainer.FULLSCREEN));\n    }\n\n    // Buffering marker class\n    player.addEventHandler(player.EVENT.ON_STALL_STARTED, () => {\n      container.addClass(this.prefixCss(UIContainer.BUFFERING));\n    });\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, () => {\n      container.removeClass(this.prefixCss(UIContainer.BUFFERING));\n    });\n    // Init buffering state\n    if (player.isStalled()) {\n      container.addClass(this.prefixCss(UIContainer.BUFFERING));\n    }\n\n    // RemoteControl marker class\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      container.addClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, () => {\n      container.removeClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    });\n    // Init RemoteControl state\n    if (player.isCasting()) {\n      container.addClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    }\n\n    // Controls visibility marker class\n    uimanager.onControlsShow.subscribe(() => {\n      container.removeClass(this.prefixCss(UIContainer.CONTROLS_HIDDEN));\n      container.addClass(this.prefixCss(UIContainer.CONTROLS_SHOWN));\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      container.removeClass(this.prefixCss(UIContainer.CONTROLS_SHOWN));\n      container.addClass(this.prefixCss(UIContainer.CONTROLS_HIDDEN));\n    });\n\n    // Layout size classes\n    let updateLayoutSizeClasses = (width: number, height: number) => {\n      container.removeClass(this.prefixCss('layout-max-width-400'));\n      container.removeClass(this.prefixCss('layout-max-width-600'));\n      container.removeClass(this.prefixCss('layout-max-width-800'));\n      container.removeClass(this.prefixCss('layout-max-width-1200'));\n\n      if (width <= 400) {\n        container.addClass(this.prefixCss('layout-max-width-400'));\n      } else if (width <= 600) {\n        container.addClass(this.prefixCss('layout-max-width-600'));\n      } else if (width <= 800) {\n        container.addClass(this.prefixCss('layout-max-width-800'));\n      } else if (width <= 1200) {\n        container.addClass(this.prefixCss('layout-max-width-1200'));\n      }\n    };\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, (e: PlayerResizeEvent) => {\n      // Convert strings (with \"px\" suffix) to ints\n      let width = Math.round(Number(e.width.substring(0, e.width.length - 2)));\n      let height = Math.round(Number(e.height.substring(0, e.height.length - 2)));\n\n      updateLayoutSizeClasses(width, height);\n    });\n\n    // Init layout state\n    updateLayoutSizeClasses(new DOM(player.getFigure()).width(), new DOM(player.getFigure()).height());\n  }\n\n  release(): void {\n    super.release();\n    this.uiHideTimeout.clear();\n  }\n\n  protected toDomElement(): DOM {\n    let container = super.toDomElement();\n\n    // Detect flexbox support (not supported in IE9)\n    if (document && typeof document.createElement('p').style.flex !== 'undefined') {\n      container.addClass(this.prefixCss('flexbox'));\n    } else {\n      container.addClass(this.prefixCss('no-flexbox'));\n    }\n\n    return container;\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between 'auto' and the available video qualities.\n */\nexport class VideoQualitySelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let updateVideoQualities = () => {\n      let videoQualities = player.getAvailableVideoQualities();\n\n      this.clearItems();\n\n      // Add entry for automatic quality switching (default setting)\n      this.addItem('Auto', 'Auto');\n\n      // Add video qualities\n      for (let videoQuality of videoQualities) {\n        this.addItem(videoQuality.id, videoQuality.label);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: VideoQualitySelectBox, value: string) => {\n      player.setVideoQuality(value);\n    });\n\n    // Update qualities when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateVideoQualities);\n    // Update qualities when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateVideoQualities);\n    // Update quality selection when quality is changed (from outside)\n    player.addEventHandler(player.EVENT.ON_VIDEO_DOWNLOAD_QUALITY_CHANGE, () => {\n      let data = player.getDownloadedVideoData();\n      this.selectItem(data.isAuto ? 'Auto' : data.id);\n    });\n\n    // Populate qualities at startup\n    updateVideoQualities();\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {VolumeSlider} from './volumeslider';\nimport {VolumeToggleButton} from './volumetogglebutton';\nimport {UIInstanceManager} from '../uimanager';\nimport {Timeout} from '../timeout';\n\n/**\n * Configuration interface for a {@link VolumeControlButton}.\n */\nexport interface VolumeControlButtonConfig extends ContainerConfig {\n  /**\n   * The delay after which the volume slider will be hidden when there is no user interaction.\n   * Care must be taken that the delay is long enough so users can reach the slider from the toggle button, e.g. by\n   * mouse movement. If the delay is too short, the sliders disappears before the mouse pointer has reached it and\n   * the user is not able to use it.\n   * Default: 500ms\n   */\n  hideDelay?: number;\n  /**\n   * Specifies if the volume slider should be vertically or horizontally aligned.\n   * Default: true\n   */\n  vertical?: boolean;\n}\n\n/**\n * A composite volume control that consists of and internally manages a volume control button that can be used\n * for muting, and a (depending on the CSS style, e.g. slide-out) volume control bar.\n */\nexport class VolumeControlButton extends Container<VolumeControlButtonConfig> {\n\n  private volumeToggleButton: VolumeToggleButton;\n  private volumeSlider: VolumeSlider;\n\n  private volumeSliderHideTimeout: Timeout;\n\n  constructor(config: VolumeControlButtonConfig = {}) {\n    super(config);\n\n    this.volumeToggleButton = new VolumeToggleButton();\n    this.volumeSlider = new VolumeSlider({\n      vertical: config.vertical != null ? config.vertical : true,\n      hidden: true\n    });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-volumecontrolbutton',\n      components: [this.volumeToggleButton, this.volumeSlider],\n      hideDelay: 500\n    }, <VolumeControlButtonConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let volumeToggleButton = this.getVolumeToggleButton();\n    let volumeSlider = this.getVolumeSlider();\n\n    this.volumeSliderHideTimeout = new Timeout((<VolumeControlButtonConfig>this.getConfig()).hideDelay, () => {\n      volumeSlider.hide();\n    });\n\n    /*\n     * Volume Slider visibility handling\n     *\n     * The volume slider shall be visible while the user hovers the mute toggle button, while the user hovers the\n     * volume slider, and while the user slides the volume slider. If none of these situations are true, the slider\n     * shall disappear.\n     */\n    let volumeSliderHovered = false;\n    volumeToggleButton.getDomElement().on('mouseenter', () => {\n      // Show volume slider when mouse enters the button area\n      if (volumeSlider.isHidden()) {\n        volumeSlider.show();\n      }\n      // Avoid hiding of the slider when button is hovered\n      this.volumeSliderHideTimeout.clear();\n    });\n    volumeToggleButton.getDomElement().on('mouseleave', () => {\n      // Hide slider delayed when button is left\n      this.volumeSliderHideTimeout.reset();\n    });\n    volumeSlider.getDomElement().on('mouseenter', () => {\n      // When the slider is entered, cancel the hide timeout activated by leaving the button\n      this.volumeSliderHideTimeout.clear();\n      volumeSliderHovered = true;\n    });\n    volumeSlider.getDomElement().on('mouseleave', () => {\n      // When mouse leaves the slider, only hide it if there is no slide operation in progress\n      if (volumeSlider.isSeeking()) {\n        this.volumeSliderHideTimeout.clear();\n      } else {\n        this.volumeSliderHideTimeout.reset();\n      }\n      volumeSliderHovered = false;\n    });\n    volumeSlider.onSeeked.subscribe(() => {\n      // When a slide operation is done and the slider not hovered (mouse outside slider), hide slider delayed\n      if (!volumeSliderHovered) {\n        this.volumeSliderHideTimeout.reset();\n      }\n    });\n  }\n\n  release(): void {\n    super.release();\n    this.volumeSliderHideTimeout.clear();\n  }\n\n  /**\n   * Provides access to the internally managed volume toggle button.\n   * @returns {VolumeToggleButton}\n   */\n  getVolumeToggleButton(): VolumeToggleButton {\n    return this.volumeToggleButton;\n  }\n\n  /**\n   * Provides access to the internally managed volume silder.\n   * @returns {VolumeSlider}\n   */\n  getVolumeSlider(): VolumeSlider {\n    return this.volumeSlider;\n  }\n}","import {SeekBar, SeekBarConfig} from './seekbar';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Configuration interface for the {@link VolumeSlider} component.\n */\nexport interface VolumeSliderConfig extends SeekBarConfig {\n  /**\n   * Specifies if the volume slider should be automatically hidden when volume control is prohibited by the\n   * browser or platform. This currently only applies to iOS.\n   * Default: true\n   */\n  hideIfVolumeControlProhibited: boolean;\n}\n\n/**\n * A simple volume slider component to adjust the player's volume setting.\n */\nexport class VolumeSlider extends SeekBar {\n\n  constructor(config: SeekBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <VolumeSliderConfig>{\n      cssClass: 'ui-volumeslider',\n      hideIfVolumeControlProhibited: true,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager, false);\n\n    let config = <VolumeSliderConfig>this.getConfig();\n\n    if (config.hideIfVolumeControlProhibited && !this.detectVolumeControlAvailability(player)) {\n      this.hide();\n\n      // We can just return from here, because the user will never interact with the control and any configured\n      // functionality would only eat resources for no reason.\n      return;\n    }\n\n    let volumeChangeHandler = () => {\n      if (player.isMuted()) {\n        this.setPlaybackPosition(0);\n        this.setBufferPosition(0);\n      } else {\n        this.setPlaybackPosition(player.getVolume());\n\n        this.setBufferPosition(player.getVolume());\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_VOLUME_CHANGED, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_MUTED, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_UNMUTED, volumeChangeHandler);\n\n    this.onSeekPreview.subscribe((sender, args) => {\n      if (args.scrubbing) {\n        player.setVolume(args.position);\n      }\n    });\n    this.onSeeked.subscribe((sender, percentage) => {\n      player.setVolume(percentage);\n    });\n\n    // Update the volume slider marker when the player resized, a source is loaded and player is ready,\n    // or the UI is configured. Check the seekbar for a detailed description.\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => {\n      this.refreshPlaybackPosition();\n    });\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      this.refreshPlaybackPosition();\n    });\n    uimanager.onConfigured.subscribe(() => {\n      this.refreshPlaybackPosition();\n    });\n\n    // Init volume bar\n    volumeChangeHandler();\n  }\n\n  private detectVolumeControlAvailability(player: bitmovin.player.Player): boolean {\n    // Store current player state so we can restore it later\n    let volume = player.getVolume();\n    let muted = player.isMuted();\n    let playing = player.isPlaying();\n\n    /*\n     * \"On iOS devices, the audio level is always under the users physical control. The volume property is not\n     * settable in JavaScript. Reading the volume property always returns 1.\"\n     * https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html\n     *\n     * Our player API returns a volume range of [0, 100] so we need to check for 100 instead of 1.\n     */\n\n    // Only if the volume is 100, there's the possibility we are on a volume-control-restricted iOS device\n    if (volume === 100) {\n      // We set the volume to zero (that's the only value that does not unmute a muted player!)\n      player.setVolume(0);\n      // Then we check if the value is still 100\n      if (player.getVolume() === 100) {\n        // If the volume stayed at 100, we're on a volume-control-restricted device\n        return false;\n      } else {\n        // We can control volume, so we must restore the previous player state\n        player.setVolume(volume);\n        if (muted) {\n          player.mute();\n        }\n        if (playing) {\n          // The volume restore above pauses autoplay on mobile devices (e.g. Android) so we need to resume playback\n          // (We cannot check isPaused() here because it is not set when playback is prohibited by the mobile platform)\n          player.play();\n        }\n        return true;\n      }\n    } else {\n      // Volume is not 100, so we're definitely not on a volume-control-restricted iOS device\n      return true;\n    }\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles audio muting.\n */\nexport class VolumeToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-volumetogglebutton',\n      text: 'Volume/Mute'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let muteStateHandler = () => {\n      if (player.isMuted()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    let volumeLevelHandler = () => {\n      // Toggle low class to display low volume icon below 50% volume\n      if (player.getVolume() < 50) {\n        this.getDomElement().addClass(this.prefixCss('low'));\n      } else {\n        this.getDomElement().removeClass(this.prefixCss('low'));\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_MUTED, muteStateHandler);\n    player.addEventHandler(player.EVENT.ON_UNMUTED, muteStateHandler);\n    player.addEventHandler(player.EVENT.ON_VOLUME_CHANGED, volumeLevelHandler);\n\n    this.onClick.subscribe(() => {\n      if (player.isMuted()) {\n        player.unmute();\n      } else {\n        player.mute();\n      }\n    });\n\n    // Startup init\n    muteStateHandler();\n    volumeLevelHandler();\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles the video view between normal/mono and VR/stereo.\n */\nexport class VRToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-vrtogglebutton',\n      text: 'VR'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let isVRConfigured = () => {\n      // VR availability cannot be checked through getVRStatus() because it is asynchronously populated and not\n      // available at UI initialization. As an alternative, we check the VR settings in the config.\n      // TODO use getVRStatus() through isVRStereoAvailable() once the player has been rewritten and the status is\n      // available in ON_READY\n      let config = player.getConfig();\n      return config.source && config.source.vr && config.source.vr.contentType !== 'none';\n    };\n\n    let isVRStereoAvailable = () => {\n      return player.getVRStatus().contentType !== 'none';\n    };\n\n    let vrStateHandler = () => {\n      if (isVRConfigured() && isVRStereoAvailable()) {\n        this.show(); // show button in case it is hidden\n\n        if (player.getVRStatus().isStereo) {\n          this.on();\n        } else {\n          this.off();\n        }\n      } else {\n        this.hide(); // hide button if no stereo mode available\n      }\n    };\n\n    let vrButtonVisibilityHandler = () => {\n      if (isVRConfigured()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_VR_MODE_CHANGED, vrStateHandler);\n    player.addEventHandler(player.EVENT.ON_VR_STEREO_CHANGED, vrStateHandler);\n    player.addEventHandler(player.EVENT.ON_VR_ERROR, vrStateHandler);\n    // Hide button when VR source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, vrButtonVisibilityHandler);\n    // Show button when a new source is loaded and it's VR\n    player.addEventHandler(player.EVENT.ON_READY, vrButtonVisibilityHandler);\n\n    this.onClick.subscribe(() => {\n      if (!isVRStereoAvailable()) {\n        if (console) {\n          console.log('No VR content');\n        }\n      } else {\n        if (player.getVRStatus().isStereo) {\n          player.setVRStereo(false);\n        } else {\n          player.setVRStereo(true);\n        }\n      }\n    });\n\n    // Set startup visibility\n    vrButtonVisibilityHandler();\n  }\n}","import {ClickOverlay, ClickOverlayConfig} from './clickoverlay';\n\n/**\n * Configuration interface for a {@link ClickOverlay}.\n */\nexport interface WatermarkConfig extends ClickOverlayConfig {\n  // nothing yet\n}\n\n/**\n * A watermark overlay with a clickable logo.\n */\nexport class Watermark extends ClickOverlay {\n\n  constructor(config: WatermarkConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-watermark',\n      url: 'http://bitmovin.com'\n    }, <WatermarkConfig>this.config);\n  }\n}","export interface Offset {\n  left: number;\n  top: number;\n}\n\n/**\n * Simple DOM manipulation and DOM element event handling modeled after jQuery (as replacement for jQuery).\n *\n * Like jQuery, DOM operates on single elements and lists of elements. For example: creating an element returns a DOM\n * instance with a single element, selecting elements returns a DOM instance with zero, one, or many elements. Similar\n * to jQuery, setters usually affect all elements, while getters operate on only the first element.\n * Also similar to jQuery, most methods (except getters) return the DOM instance facilitating easy chaining of method\n * calls.\n *\n * Built with the help of: http://youmightnotneedjquery.com/\n */\nexport class DOM {\n\n  private document: Document;\n\n  /**\n   * The list of elements that the instance wraps. Take care that not all methods can operate on the whole list,\n   * getters usually just work on the first element.\n   */\n  private elements: HTMLElement[];\n\n  /**\n   * Creates a DOM element.\n   * @param tagName the tag name of the DOM element\n   * @param attributes a list of attributes of the element\n   */\n  constructor(tagName: string, attributes: {[name: string]: string});\n  /**\n   * Selects all elements from the DOM that match the specified selector.\n   * @param selector the selector to match DOM elements with\n   */\n  constructor(selector: string);\n  /**\n   * Wraps a plain HTMLElement with a DOM instance.\n   * @param element the HTMLElement to wrap with DOM\n   */\n  constructor(element: HTMLElement);\n  /**\n   * Wraps a list of plain HTMLElements with a DOM instance.\n   * @param element the HTMLElements to wrap with DOM\n   */\n  constructor(elements: HTMLElement[]);\n  /**\n   * Wraps the document with a DOM instance. Useful to attach event listeners to the document.\n   * @param document the document to wrap\n   */\n  constructor(document: Document);\n  constructor(something: string | HTMLElement | HTMLElement[] | Document, attributes?: {[name: string]: string}) {\n    this.document = document; // Set the global document to the local document field\n\n    if (something instanceof Array) {\n      if (something.length > 0 && something[0] instanceof HTMLElement) {\n        let elements = something;\n        this.elements = elements;\n      }\n    }\n    else if (something instanceof HTMLElement) {\n      let element = something;\n      this.elements = [element];\n    }\n    else if (something instanceof Document) {\n      // When a document is passed in, we do not do anything with it, but by setting this.elements to null\n      // we give the event handling method a means to detect if the events should be registered on the document\n      // instead of elements.\n      this.elements = null;\n    }\n    else if (attributes) {\n      let tagName = something;\n      let element = document.createElement(tagName);\n\n      for (let attributeName in attributes) {\n        let attributeValue = attributes[attributeName];\n        element.setAttribute(attributeName, attributeValue);\n      }\n\n      this.elements = [element];\n    }\n    else {\n      let selector = something;\n      this.elements = this.findChildElements(selector);\n    }\n  }\n\n  /**\n   * Gets the number of elements that this DOM instance currently holds.\n   * @returns {number} the number of elements\n   */\n  get length(): number {\n    return this.elements ? this.elements.length : 0;\n  }\n\n  /**\n   * Gets the HTML elements that this DOM instance currently holds.\n   * @returns {HTMLElement[]} the raw HTML elements\n   */\n  getElements(): HTMLElement[] {\n    return this.elements;\n  }\n\n  /**\n   * A shortcut method for iterating all elements. Shorts this.elements.forEach(...) to this.forEach(...).\n   * @param handler the handler to execute an operation on an element\n   */\n  private forEach(handler: (element: HTMLElement) => void): void {\n    this.elements.forEach((element) => {\n      handler(element);\n    });\n  }\n\n  private findChildElementsOfElement(element: HTMLElement | Document, selector: string): HTMLElement[] {\n    let childElements = element.querySelectorAll(selector);\n\n    // Convert NodeList to Array\n    // https://toddmotto.com/a-comprehensive-dive-into-nodelists-arrays-converting-nodelists-and-understanding-the-dom/\n    return [].slice.call(childElements);\n  }\n\n  private findChildElements(selector: string): HTMLElement[] {\n    let allChildElements = <HTMLElement[]>[];\n\n    if (this.elements) {\n      this.forEach((element) => {\n        allChildElements = allChildElements.concat(this.findChildElementsOfElement(element, selector));\n      });\n    }\n    else {\n      return this.findChildElementsOfElement(document, selector);\n    }\n\n    return allChildElements;\n  }\n\n  /**\n   * Finds all child elements of all elements matching the supplied selector.\n   * @param selector the selector to match with child elements\n   * @returns {DOM} a new DOM instance representing all matched children\n   */\n  find(selector: string): DOM {\n    let allChildElements = this.findChildElements(selector);\n    return new DOM(allChildElements);\n  }\n\n  /**\n   * Returns a string of the inner HTML content of the first element.\n   */\n  html(): string;\n  /**\n   * Sets the inner HTML content of all elements.\n   * @param content a string of plain text or HTML markup\n   */\n  html(content: string): DOM;\n  html(content?: string): string | DOM {\n    if (arguments.length > 0) {\n      return this.setHtml(content);\n    }\n    else {\n      return this.getHtml();\n    }\n  }\n\n  private getHtml(): string | null {\n    return this.elements[0].innerHTML;\n  }\n\n  private setHtml(content: string): DOM {\n    if (content === undefined || content == null) {\n      // Set to empty string to avoid innerHTML getting set to 'undefined' (all browsers) or 'null' (IE9)\n      content = '';\n    }\n\n    this.forEach((element) => {\n      element.innerHTML = content;\n    });\n\n    return this;\n  }\n\n  /**\n   * Clears the inner HTML of all elements (deletes all children).\n   * @returns {DOM}\n   */\n  empty(): DOM {\n    this.forEach((element) => {\n      element.innerHTML = '';\n    });\n    return this;\n  }\n\n  /**\n   * Returns the current value of the first form element, e.g. the selected value of a select box or the text if an\n   * input field.\n   * @returns {string} the value of a form element\n   */\n  val(): string {\n    let element = this.elements[0];\n\n    if (element instanceof HTMLSelectElement || element instanceof HTMLInputElement) {\n      return element.value;\n    }\n    else {\n      // TODO add support for missing form elements\n      throw new Error(`val() not supported for ${typeof element}`);\n    }\n  }\n\n  /**\n   * Returns the value of an attribute on the first element.\n   * @param attribute\n   */\n  attr(attribute: string): string | null;\n  /**\n   * Sets an attribute on all elements.\n   * @param attribute the name of the attribute\n   * @param value the value of the attribute\n   */\n  attr(attribute: string, value: string): DOM;\n  attr(attribute: string, value?: string): string | null | DOM {\n    if (arguments.length > 1) {\n      return this.setAttr(attribute, value);\n    }\n    else {\n      return this.getAttr(attribute);\n    }\n  }\n\n  private getAttr(attribute: string): string | null {\n    return this.elements[0].getAttribute(attribute);\n  }\n\n  private setAttr(attribute: string, value: string): DOM {\n    this.forEach((element) => {\n      element.setAttribute(attribute, value);\n    });\n    return this;\n  }\n\n  /**\n   * Returns the value of a data element on the first element.\n   * @param dataAttribute the name of the data attribute without the 'data-' prefix\n   */\n  data(dataAttribute: string): string | null;\n  /**\n   * Sets a data attribute on all elements.\n   * @param dataAttribute the name of the data attribute without the 'data-' prefix\n   * @param value the value of the data attribute\n   */\n  data(dataAttribute: string, value: string): DOM;\n  data(dataAttribute: string, value?: string): string | null | DOM {\n    if (arguments.length > 1) {\n      return this.setData(dataAttribute, value);\n    }\n    else {\n      return this.getData(dataAttribute);\n    }\n  }\n\n  private getData(dataAttribute: string): string | null {\n    return this.elements[0].getAttribute('data-' + dataAttribute);\n  }\n\n  private setData(dataAttribute: string, value: string): DOM {\n    this.forEach((element) => {\n      element.setAttribute('data-' + dataAttribute, value);\n    });\n    return this;\n  }\n\n  /**\n   * Appends one or more DOM elements as children to all elements.\n   * @param childElements the chrild elements to append\n   * @returns {DOM}\n   */\n  append(...childElements: DOM[]): DOM {\n    this.forEach((element) => {\n      childElements.forEach((childElement) => {\n        childElement.elements.forEach((_, index) => {\n          element.appendChild(childElement.elements[index]);\n        });\n      });\n    });\n    return this;\n  }\n\n  /**\n   * Removes all elements from the DOM.\n   */\n  remove(): void {\n    this.forEach((element) => {\n      let parent = element.parentNode;\n      if (parent) {\n        parent.removeChild(element);\n      }\n    });\n  }\n\n  /**\n   * Returns the offset of the first element from the document's top left corner.\n   * @returns {Offset}\n   */\n  offset(): Offset {\n    let element = this.elements[0];\n    let elementRect = element.getBoundingClientRect();\n    let htmlRect = document.body.parentElement.getBoundingClientRect();\n\n    // Virtual viewport scroll handling (e.g. pinch zoomed viewports in mobile browsers or desktop Chrome/Edge)\n    // 'normal' zooms and virtual viewport zooms (aka layout viewport) result in different\n    // element.getBoundingClientRect() results:\n    //  - with normal scrolls, the clientRect decreases with an increase in scroll(Top|Left)/page(X|Y)Offset\n    //  - with pinch zoom scrolls, the clientRect stays the same while scroll/pageOffset changes\n    // This means, that the combination of clientRect + scroll/pageOffset does not work to calculate the offset\n    // from the document's upper left origin when pinch zoom is used.\n    // To work around this issue, we do not use scroll/pageOffset but get the clientRect of the html element and\n    // subtract it from the element's rect, which always results in the offset from the document origin.\n    // NOTE: the current way of offset calculation was implemented specifically to track event positions on the\n    // seek bar, and it might break compatibility with jQuery's offset() method. If this ever turns out to be a\n    // problem, this method should be reverted to the old version and the offset calculation moved to the seek bar.\n\n    return {\n      top: elementRect.top - htmlRect.top,\n      left: elementRect.left - htmlRect.left\n    };\n  }\n\n  /**\n   * Returns the width of the first element.\n   * @returns {number} the width of the first element\n   */\n  width(): number {\n    // TODO check if this is the same as jQuery's width() (probably not)\n    return this.elements[0].offsetWidth;\n  }\n\n  /**\n   * Returns the height of the first element.\n   * @returns {number} the height of the first element\n   */\n  height(): number {\n    // TODO check if this is the same as jQuery's height() (probably not)\n    return this.elements[0].offsetHeight;\n  }\n\n  /**\n   * Attaches an event handler to one or more events on all elements.\n   * @param eventName the event name (or multiple names separated by space) to listen to\n   * @param eventHandler the event handler to call when the event fires\n   * @returns {DOM}\n   */\n  on(eventName: string, eventHandler: EventListenerOrEventListenerObject): DOM {\n    let events = eventName.split(' ');\n\n    events.forEach((event) => {\n      if (this.elements == null) {\n        this.document.addEventListener(event, eventHandler);\n      }\n      else {\n        this.forEach((element) => {\n          element.addEventListener(event, eventHandler);\n        });\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Removes an event handler from one or more events on all elements.\n   * @param eventName the event name (or multiple names separated by space) to remove the handler from\n   * @param eventHandler the event handler to remove\n   * @returns {DOM}\n   */\n  off(eventName: string, eventHandler: EventListenerOrEventListenerObject): DOM {\n    let events = eventName.split(' ');\n\n    events.forEach((event) => {\n      if (this.elements == null) {\n        this.document.removeEventListener(event, eventHandler);\n      }\n      else {\n        this.forEach((element) => {\n          element.removeEventListener(event, eventHandler);\n        });\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds the specified class(es) to all elements.\n   * @param className the class(es) to add, multiple classes separated by space\n   * @returns {DOM}\n   */\n  addClass(className: string): DOM {\n    this.forEach((element) => {\n      if (element.classList) {\n        element.classList.add(className);\n      }\n      else {\n        element.className += ' ' + className;\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Removed the specified class(es) from all elements.\n   * @param className the class(es) to remove, multiple classes separated by space\n   * @returns {DOM}\n   */\n  removeClass(className: string): DOM {\n    this.forEach((element) => {\n      if (element.classList) {\n        element.classList.remove(className);\n      }\n      else {\n        element.className = element.className.replace(\n          new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Checks if any of the elements has the specified class.\n   * @param className the class name to check\n   * @returns {boolean} true if one of the elements has the class attached, else if no element has it attached\n   */\n  hasClass(className: string): boolean {\n    let hasClass = false;\n\n    this.forEach((element) => {\n      if (element.classList) {\n        if (element.classList.contains(className)) {\n          // Since we are inside a handler, we can't just 'return true'. Instead, we save it to a variable\n          // and return it at the end of the function body.\n          hasClass = true;\n        }\n      }\n      else {\n        if (new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className)) {\n          // See comment above\n          hasClass = true;\n        }\n      }\n    });\n\n    return hasClass;\n  }\n\n  /**\n   * Returns the value of a CSS property of the first element.\n   * @param propertyName the name of the CSS property to retrieve the value of\n   */\n  css(propertyName: string): string | null;\n  /**\n   * Sets the value of a CSS property on all elements.\n   * @param propertyName the name of the CSS property to set the value for\n   * @param value the value to set for the given CSS property\n   */\n  css(propertyName: string, value: string): DOM;\n  /**\n   * Sets a collection of CSS properties and their values on all elements.\n   * @param propertyValueCollection an object containing pairs of property names and their values\n   */\n  css(propertyValueCollection: {[propertyName: string]: string}): DOM;\n  css(propertyNameOrCollection: string | {[propertyName: string]: string}, value?: string): string | null | DOM {\n    if (typeof propertyNameOrCollection === 'string') {\n      let propertyName = propertyNameOrCollection;\n\n      if (arguments.length === 2) {\n        return this.setCss(propertyName, value);\n      }\n      else {\n        return this.getCss(propertyName);\n      }\n    }\n    else {\n      let propertyValueCollection = propertyNameOrCollection;\n      return this.setCssCollection(propertyValueCollection);\n    }\n  }\n\n  private getCss(propertyName: string): string | null {\n    return getComputedStyle(this.elements[0])[<any>propertyName];\n  }\n\n  private setCss(propertyName: string, value: string): DOM {\n    this.forEach((element) => {\n      // <any> cast to resolve TS7015: http://stackoverflow.com/a/36627114/370252\n      element.style[<any>propertyName] = value;\n    });\n    return this;\n  }\n\n  private setCssCollection(ruleValueCollection: {[ruleName: string]: string}): DOM {\n    this.forEach((element) => {\n      // http://stackoverflow.com/a/34490573/370252\n      Object.assign(element.style, ruleValueCollection);\n    });\n\n    return this;\n  }\n}\n","import {ArrayUtils} from './utils';\n/**\n * Function interface for event listeners on the {@link EventDispatcher}.\n */\nexport interface EventListener<Sender, Args> {\n  (sender: Sender, args: Args): void;\n}\n\n/**\n * Empty type for creating {@link EventDispatcher event dispatchers} that do not carry any arguments.\n */\nexport interface NoArgs {\n}\n\n/**\n * Event args for an event that can be canceled.\n */\nexport interface CancelEventArgs extends NoArgs {\n  /**\n   * Gets or sets a flag whether the event should be canceled.\n   */\n  cancel?: boolean;\n}\n\n/**\n * Public interface that represents an event. Can be used to subscribe to and unsubscribe from events.\n */\nexport interface Event<Sender, Args> {\n  /**\n   * Subscribes an event listener to this event dispatcher.\n   * @param listener the listener to add\n   */\n  subscribe(listener: EventListener<Sender, Args>): void;\n\n  /**\n   * Subscribes an event listener to this event dispatcher that is only called once.\n   * @param listener the listener to add\n   */\n  subscribeOnce(listener: EventListener<Sender, Args>): void;\n\n  /**\n   * Subscribes an event listener to this event dispatcher that will be called at a limited rate with a minimum\n   * interval of the specified milliseconds.\n   * @param listener the listener to add\n   * @param rateMs the rate in milliseconds to which calling of the listeners should be limited\n   */\n  subscribeRateLimited(listener: EventListener<Sender, Args>, rateMs: number): void;\n\n  /**\n   * Unsubscribes a subscribed event listener from this dispatcher.\n   * @param listener the listener to remove\n   * @returns {boolean} true if the listener was successfully unsubscribed, false if it isn't subscribed on this\n   *   dispatcher\n   */\n  unsubscribe(listener: EventListener<Sender, Args>): boolean;\n}\n\n/**\n * Event dispatcher to subscribe and trigger events. Each event should have its own dispatcher.\n */\nexport class EventDispatcher<Sender, Args> implements Event<Sender, Args> {\n\n  private listeners: EventListenerWrapper<Sender, Args>[] = [];\n\n  constructor() {\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribe(listener: EventListener<Sender, Args>) {\n    this.listeners.push(new EventListenerWrapper(listener));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribeOnce(listener: EventListener<Sender, Args>) {\n    this.listeners.push(new EventListenerWrapper(listener, true));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribeRateLimited(listener: EventListener<Sender, Args>, rateMs: number) {\n    this.listeners.push(new RateLimitedEventListenerWrapper(listener, rateMs));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  unsubscribe(listener: EventListener<Sender, Args>): boolean {\n    // Iterate through listeners, compare with parameter, and remove if found\n    for (let i = 0; i < this.listeners.length; i++) {\n      let subscribedListener = this.listeners[i];\n      if (subscribedListener.listener === listener) {\n        ArrayUtils.remove(this.listeners, subscribedListener);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Removes all listeners from this dispatcher.\n   */\n  unsubscribeAll(): void {\n    this.listeners = [];\n  }\n\n  /**\n   * Dispatches an event to all subscribed listeners.\n   * @param sender the source of the event\n   * @param args the arguments for the event\n   */\n  dispatch(sender: Sender, args: Args = null) {\n    let listenersToRemove = [];\n\n    // Call every listener\n    for (let listener of this.listeners) {\n      listener.fire(sender, args);\n\n      if (listener.isOnce()) {\n        listenersToRemove.push(listener);\n      }\n    }\n\n    // Remove one-time listener\n    for (let listenerToRemove of listenersToRemove) {\n      ArrayUtils.remove(this.listeners, listenerToRemove);\n    }\n  }\n\n  /**\n   * Returns the event that this dispatcher manages and on which listeners can subscribe and unsubscribe event handlers.\n   * @returns {Event}\n   */\n  getEvent(): Event<Sender, Args> {\n    // For now, just cast the event dispatcher to the event interface. At some point in the future when the\n    // codebase grows, it might make sense to split the dispatcher into separate dispatcher and event classes.\n    return <Event<Sender, Args>>this;\n  }\n}\n\n/**\n * A basic event listener wrapper to manage listeners within the {@link EventDispatcher}. This is a 'private' class\n * for internal dispatcher use and it is therefore not exported.\n */\nclass EventListenerWrapper<Sender, Args> {\n\n  private eventListener: EventListener<Sender, Args>;\n  private once: boolean;\n\n  constructor(listener: EventListener<Sender, Args>, once: boolean = false) {\n    this.eventListener = listener;\n    this.once = once;\n  }\n\n  /**\n   * Returns the wrapped event listener.\n   * @returns {EventListener<Sender, Args>}\n   */\n  get listener(): EventListener<Sender, Args> {\n    return this.eventListener;\n  }\n\n  /**\n   * Fires the wrapped event listener with the given arguments.\n   * @param sender\n   * @param args\n   */\n  fire(sender: Sender, args: Args) {\n    this.eventListener(sender, args);\n  }\n\n  /**\n   * Checks if this listener is scheduled to be called only once.\n   * @returns {boolean} once if true\n   */\n  isOnce(): boolean {\n    return this.once;\n  }\n}\n\n/**\n * Extends the basic {@link EventListenerWrapper} with rate-limiting functionality.\n */\nclass RateLimitedEventListenerWrapper<Sender, Args> extends EventListenerWrapper<Sender, Args> {\n\n  private rateMs: number;\n  private rateLimitingEventListener: EventListener<Sender, Args>;\n\n  private lastFireTime: number;\n\n  constructor(listener: EventListener<Sender, Args>, rateMs: number) {\n    super(listener); // sets the event listener sink\n\n    this.rateMs = rateMs;\n    this.lastFireTime = 0;\n\n    // Wrap the event listener with an event listener that does the rate-limiting\n    this.rateLimitingEventListener = (sender: Sender, args: Args) => {\n      if (Date.now() - this.lastFireTime > this.rateMs) {\n        // Only if enough time since the previous call has passed, call the\n        // actual event listener and record the current time\n        this.fireSuper(sender, args);\n        this.lastFireTime = Date.now();\n      }\n    };\n  }\n\n  private fireSuper(sender: Sender, args: Args) {\n    // Fire the actual external event listener\n    super.fire(sender, args);\n  }\n\n  fire(sender: Sender, args: Args) {\n    // Fire the internal rate-limiting listener instead of the external event listener\n    this.rateLimitingEventListener(sender, args);\n  }\n}","export namespace Guid {\n\n  let guid = 1;\n\n  export function next() {\n    return guid++;\n  }\n}\n","/// <reference path='player.d.ts' />\nimport {UIManager, UIInstanceManager} from './uimanager';\nimport {Button} from './components/button';\nimport {ControlBar} from './components/controlbar';\nimport {FullscreenToggleButton} from './components/fullscreentogglebutton';\nimport {HugePlaybackToggleButton} from './components/hugeplaybacktogglebutton';\nimport {PlaybackTimeLabel, PlaybackTimeLabelMode} from './components/playbacktimelabel';\nimport {PlaybackToggleButton} from './components/playbacktogglebutton';\nimport {SeekBar} from './components/seekbar';\nimport {SelectBox} from './components/selectbox';\nimport {SettingsPanel, SettingsPanelItem} from './components/settingspanel';\nimport {SettingsToggleButton} from './components/settingstogglebutton';\nimport {ToggleButton} from './components/togglebutton';\nimport {VideoQualitySelectBox} from './components/videoqualityselectbox';\nimport {VolumeToggleButton} from './components/volumetogglebutton';\nimport {VRToggleButton} from './components/vrtogglebutton';\nimport {Watermark} from './components/watermark';\nimport {UIContainer} from './components/uicontainer';\nimport {Container} from './components/container';\nimport {Label} from './components/label';\nimport {AudioQualitySelectBox} from './components/audioqualityselectbox';\nimport {AudioTrackSelectBox} from './components/audiotrackselectbox';\nimport {CastStatusOverlay} from './components/caststatusoverlay';\nimport {CastToggleButton} from './components/casttogglebutton';\nimport {Component} from './components/component';\nimport {ErrorMessageOverlay} from './components/errormessageoverlay';\nimport {RecommendationOverlay} from './components/recommendationoverlay';\nimport {SeekBarLabel} from './components/seekbarlabel';\nimport {SubtitleOverlay} from './components/subtitleoverlay';\nimport {SubtitleSelectBox} from './components/subtitleselectbox';\nimport {TitleBar} from './components/titlebar';\nimport {VolumeControlButton} from './components/volumecontrolbutton';\nimport {ClickOverlay} from './components/clickoverlay';\nimport {AdSkipButton} from './components/adskipbutton';\nimport {AdMessageLabel} from './components/admessagelabel';\nimport {AdClickOverlay} from './components/adclickoverlay';\nimport {PlaybackSpeedSelectBox} from './components/playbackspeedselectbox';\nimport {HugeReplayButton} from './components/hugereplaybutton';\nimport {BufferingOverlay} from './components/bufferingoverlay';\nimport {CastUIContainer} from './components/castuicontainer';\nimport {PlaybackToggleOverlay} from './components/playbacktoggleoverlay';\nimport {CloseButton} from './components/closebutton';\nimport {MetadataLabel, MetadataLabelContent} from './components/metadatalabel';\nimport {AirPlayToggleButton} from './components/airplaytogglebutton';\nimport {VolumeSlider} from './components/volumeslider';\nimport {PictureInPictureToggleButton} from './components/pictureinpicturetogglebutton';\nimport {Spacer} from './components/spacer';\nimport {ArrayUtils, StringUtils, PlayerUtils, UIUtils, BrowserUtils} from './utils';\n\n// Object.assign polyfill for ES5/IE9\n// https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nif (typeof Object.assign !== 'function') {\n  Object.assign = function(target: any) {\n    'use strict';\n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    target = Object(target);\n    for (let index = 1; index < arguments.length; index++) {\n      let source = arguments[index];\n      if (source != null) {\n        for (let key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n    }\n    return target;\n  };\n}\n\n// Expose classes to window\n(window as any).bitmovin.playerui = {\n  // Management\n  UIManager,\n  UIInstanceManager,\n  // Utils\n  ArrayUtils,\n  StringUtils,\n  PlayerUtils,\n  UIUtils,\n  BrowserUtils,\n  // Components\n  AdClickOverlay,\n  AdMessageLabel,\n  AdSkipButton,\n  AirPlayToggleButton,\n  AudioQualitySelectBox,\n  AudioTrackSelectBox,\n  BufferingOverlay,\n  Button,\n  CastStatusOverlay,\n  CastToggleButton,\n  CastUIContainer,\n  ClickOverlay,\n  CloseButton,\n  Component,\n  Container,\n  ControlBar,\n  ErrorMessageOverlay,\n  FullscreenToggleButton,\n  HugePlaybackToggleButton,\n  HugeReplayButton,\n  Label,\n  MetadataLabel,\n  MetadataLabelContent,\n  PictureInPictureToggleButton,\n  PlaybackSpeedSelectBox,\n  PlaybackTimeLabel,\n  PlaybackTimeLabelMode,\n  PlaybackToggleButton,\n  PlaybackToggleOverlay,\n  RecommendationOverlay,\n  SeekBar,\n  SeekBarLabel,\n  SelectBox,\n  SettingsPanel,\n  SettingsPanelItem,\n  SettingsToggleButton,\n  Spacer,\n  SubtitleOverlay,\n  SubtitleSelectBox,\n  TitleBar,\n  ToggleButton,\n  UIContainer,\n  VideoQualitySelectBox,\n  VolumeControlButton,\n  VolumeSlider,\n  VolumeToggleButton,\n  VRToggleButton,\n  Watermark,\n};","// TODO change to internal (not exported) class, how to use in other files?\n/**\n * Executes a callback after a specified amount of time,\n * optionally repeatedly until stopped. When delay is <= 0\n * the timeout is disabled\n */\nexport class Timeout {\n\n  private delay: number;\n  private callback: () => void;\n  private repeat: boolean;\n  private timeoutHandle: number;\n\n  /**\n   * Creates a new timeout callback handler.\n   * @param delay the delay in milliseconds after which the callback should be executed\n   * @param callback the callback to execute after the delay time\n   * @param repeat if true, call the callback repeatedly in delay intervals\n   */\n  constructor(delay: number, callback: () => void, repeat: boolean = false) {\n    this.delay = delay;\n    this.callback = callback;\n    this.repeat = repeat;\n    this.timeoutHandle = 0;\n  }\n\n  /**\n   * Starts the timeout and calls the callback when the timeout delay has passed.\n   * @returns {Timeout} the current timeout (so the start call can be chained to the constructor)\n   */\n  start(): this {\n    this.reset();\n    return this;\n  }\n\n  /**\n   * Clears the timeout. The callback will not be called if clear is called during the timeout.\n   */\n  clear(): void {\n    clearTimeout(this.timeoutHandle);\n  }\n\n  /**\n   * Resets the passed timeout delay to zero. Can be used to defer the calling of the callback.\n   */\n  reset(): void {\n    let lastScheduleTime = 0;\n    let delayAdjust = 0;\n\n    this.clear();\n\n    let internalCallback = () => {\n      this.callback();\n\n      if (this.repeat) {\n        let now = Date.now();\n\n        // The time of one iteration from scheduling to executing the callback (usually a bit longer than the delay\n        // time)\n        let delta = now - lastScheduleTime;\n\n        // Calculate the delay adjustment for the next schedule to keep a steady delay interval over time\n        delayAdjust = this.delay - delta + delayAdjust;\n\n        lastScheduleTime = now;\n\n        // Schedule next execution by the adjusted delay\n        this.timeoutHandle = setTimeout(internalCallback, this.delay + delayAdjust);\n      }\n    };\n\n    lastScheduleTime = Date.now();\n    if (this.delay > 0) {\n      this.timeoutHandle = setTimeout(internalCallback, this.delay);\n    }\n  }\n}","import {UIContainer} from './components/uicontainer';\nimport {DOM} from './dom';\nimport {Component, ComponentConfig} from './components/component';\nimport {Container} from './components/container';\nimport {PlaybackToggleButton} from './components/playbacktogglebutton';\nimport {FullscreenToggleButton} from './components/fullscreentogglebutton';\nimport {VRToggleButton} from './components/vrtogglebutton';\nimport {VolumeToggleButton} from './components/volumetogglebutton';\nimport {SeekBar} from './components/seekbar';\nimport {PlaybackTimeLabel, PlaybackTimeLabelMode} from './components/playbacktimelabel';\nimport {ControlBar} from './components/controlbar';\nimport {NoArgs, EventDispatcher, CancelEventArgs} from './eventdispatcher';\nimport {SettingsToggleButton} from './components/settingstogglebutton';\nimport {SettingsPanel, SettingsPanelItem} from './components/settingspanel';\nimport {VideoQualitySelectBox} from './components/videoqualityselectbox';\nimport {Watermark} from './components/watermark';\nimport {AudioQualitySelectBox} from './components/audioqualityselectbox';\nimport {AudioTrackSelectBox} from './components/audiotrackselectbox';\nimport {SeekBarLabel} from './components/seekbarlabel';\nimport {VolumeSlider} from './components/volumeslider';\nimport {SubtitleSelectBox} from './components/subtitleselectbox';\nimport {SubtitleOverlay} from './components/subtitleoverlay';\nimport {VolumeControlButton} from './components/volumecontrolbutton';\nimport {CastToggleButton} from './components/casttogglebutton';\nimport {CastStatusOverlay} from './components/caststatusoverlay';\nimport {ErrorMessageOverlay} from './components/errormessageoverlay';\nimport {TitleBar} from './components/titlebar';\nimport Player = bitmovin.player.Player;\nimport {RecommendationOverlay} from './components/recommendationoverlay';\nimport {AdMessageLabel} from './components/admessagelabel';\nimport {AdSkipButton} from './components/adskipbutton';\nimport {AdClickOverlay} from './components/adclickoverlay';\nimport EVENT = bitmovin.player.EVENT;\nimport PlayerEventCallback = bitmovin.player.PlayerEventCallback;\nimport AdStartedEvent = bitmovin.player.AdStartedEvent;\nimport {ArrayUtils, UIUtils, BrowserUtils} from './utils';\nimport {PlaybackSpeedSelectBox} from './components/playbackspeedselectbox';\nimport {BufferingOverlay} from './components/bufferingoverlay';\nimport {CastUIContainer} from './components/castuicontainer';\nimport {PlaybackToggleOverlay} from './components/playbacktoggleoverlay';\nimport {CloseButton} from './components/closebutton';\nimport {MetadataLabel, MetadataLabelContent} from './components/metadatalabel';\nimport {Label} from './components/label';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\nimport {AirPlayToggleButton} from './components/airplaytogglebutton';\nimport {PictureInPictureToggleButton} from './components/pictureinpicturetogglebutton';\nimport {Spacer} from './components/spacer';\nimport {EmbedVideoToggleButton} from './components/embedvideotogglebutton'\n\nexport interface UIRecommendationConfig {\n  title: string;\n  url: string;\n  thumbnail?: string;\n  duration?: number;\n}\n\nexport interface TimelineMarker {\n  time: number;\n  title?: string;\n  markerType?: string;\n  comment?: string;\n  avatar?: string;\n  number?: string;\n}\n\nexport interface UIConfig {\n  metadata?: {\n    title?: string;\n    description?: string;\n    markers?: TimelineMarker[];\n  };\n  recommendations?: UIRecommendationConfig[];\n}\n\n/**\n * The context that will be passed to a {@link UIConditionResolver} to determine if it's conditions fulfil the context.\n */\nexport interface UIConditionContext {\n  isAd: boolean;\n  isAdWithUI: boolean;\n  isFullscreen: boolean;\n  isMobile: boolean;\n  documentWidth: number;\n  width: number;\n}\n\n/**\n * Resolves the conditions of its associated UI in a {@link UIVariant} upon a {@link UIConditionContext} and decides\n * if the UI should be displayed. If it returns true, the UI is a candidate for display; if it returns false, it will\n * not be displayed in the given context.\n */\nexport interface UIConditionResolver {\n  (context: UIConditionContext): boolean;\n}\n\n/**\n * Associates a UI instance with an optional {@link UIConditionResolver} that determines if the UI should be displayed.\n */\nexport interface UIVariant {\n  ui: UIContainer;\n  condition?: UIConditionResolver;\n}\n\nexport class UIManager {\n\n  private player: Player;\n  private playerElement: DOM;\n  private uiVariants: UIVariant[];\n  private uiInstanceManagers: InternalUIInstanceManager[];\n  private currentUi: InternalUIInstanceManager;\n  private config: UIConfig;\n  private managerPlayerWrapper: PlayerWrapper;\n\n  /**\n   * Creates a UI manager with a single UI variant that will be permanently shown.\n   * @param player the associated player of this UI\n   * @param ui the UI to add to the player\n   * @param config optional UI configuration\n   */\n  constructor(player: Player, ui: UIContainer, config?: UIConfig);\n  /**\n   * Creates a UI manager with a list of UI variants that will be dynamically selected and switched according to\n   * the context of the UI.\n   *\n   * Every time the UI context changes, the conditions of the UI variants will be sequentially resolved and the first\n   * UI, whose condition evaluates to true, will be selected and displayed. The last variant in the list might omit the\n   * condition resolver and will be selected as default/fallback UI when all other conditions fail. If there is no\n   * fallback UI and all conditions fail, no UI will be displayed.\n   *\n   * @param player the associated player of this UI\n   * @param uiVariants a list of UI variants that will be dynamically switched\n   * @param config optional UI configuration\n   */\n  constructor(player: Player, uiVariants: UIVariant[], config?: UIConfig);\n  constructor(player: Player, playerUiOrUiVariants: UIContainer | UIVariant[], config: UIConfig = {}) {\n    if (playerUiOrUiVariants instanceof UIContainer) {\n      // Single-UI constructor has been called, transform arguments to UIVariant[] signature\n      let playerUi = <UIContainer>playerUiOrUiVariants;\n      let adsUi = null;\n\n      let uiVariants = [];\n\n      // Add the ads UI if defined\n      if (adsUi) {\n        uiVariants.push({\n          ui: adsUi,\n          condition: (context: UIConditionContext) => {\n            return context.isAdWithUI;\n          },\n        });\n      }\n\n      // Add the default player UI\n      uiVariants.push({ui: playerUi});\n\n      this.uiVariants = uiVariants;\n    }\n    else {\n      // Default constructor (UIVariant[]) has been called\n      this.uiVariants = <UIVariant[]>playerUiOrUiVariants;\n    }\n\n    this.player = player;\n    this.config = config;\n    this.managerPlayerWrapper = new PlayerWrapper(player);\n    this.playerElement = new DOM(player.getFigure());\n\n    // Create UI instance managers for the UI variants\n    // The instance managers map to the corresponding UI variants by their array index\n    this.uiInstanceManagers = [];\n    let uiVariantsWithoutCondition = [];\n    for (let uiVariant of this.uiVariants) {\n      if (uiVariant.condition == null) {\n        // Collect variants without conditions for error checking\n        uiVariantsWithoutCondition.push(uiVariant);\n      }\n      // Create the instance manager for a UI variant\n      this.uiInstanceManagers.push(new InternalUIInstanceManager(player, uiVariant.ui, this.config));\n    }\n    // Make sure that there is only one UI variant without a condition\n    // It does not make sense to have multiple variants without condition, because only the first one in the list\n    // (the one with the lowest index) will ever be selected.\n    if (uiVariantsWithoutCondition.length > 1) {\n      throw Error('Too many UIs without a condition: You cannot have more than one default UI');\n    }\n    // Make sure that the default UI variant, if defined, is at the end of the list (last index)\n    // If it comes earlier, the variants with conditions that come afterwards will never be selected because the\n    // default variant without a condition always evaluates to 'true'\n    if (uiVariantsWithoutCondition.length > 0\n      && uiVariantsWithoutCondition[0] !== this.uiVariants[this.uiVariants.length - 1]) {\n      throw Error('Invalid UI variant order: the default UI (without condition) must be at the end of the list');\n    }\n\n    let adStartedEvent: AdStartedEvent = null; // keep the event stored here during ad playback\n    let isMobile = BrowserUtils.isMobile;\n\n    // Dynamically select a UI variant that matches the current UI condition.\n    let resolveUiVariant = (event: PlayerEvent) => {\n      // Make sure that the ON_AD_STARTED event data is persisted through ad playback in case other events happen\n      // in the meantime, e.g. player resize. We need to store this data because there is no other way to find out\n      // ad details (e.g. the ad client) while an ad is playing.\n      // Existing event data signals that an ad is currently active. We cannot use player.isAd() because it returns\n      // true on ad start and also on ad end events, which is problematic.\n      if (event != null) {\n        switch (event.type) {\n          // When the ad starts, we store the event data\n          case player.EVENT.ON_AD_STARTED:\n            adStartedEvent = <AdStartedEvent>event;\n            break;\n          // When the ad ends, we delete the event data\n          case player.EVENT.ON_AD_FINISHED:\n          case player.EVENT.ON_AD_SKIPPED:\n          case player.EVENT.ON_AD_ERROR:\n            adStartedEvent = null;\n        }\n      }\n\n      // Detect if an ad has started\n      let ad = adStartedEvent != null;\n      let adWithUI = ad && adStartedEvent.clientType === 'vast';\n\n      // Determine the current context for which the UI variant will be resolved\n      let context: UIConditionContext = {\n        isAd: ad,\n        isAdWithUI: adWithUI,\n        isFullscreen: this.player.isFullscreen(),\n        isMobile: isMobile,\n        width: this.playerElement.width(),\n        documentWidth: document.body.clientWidth,\n      };\n\n      let nextUi: InternalUIInstanceManager = null;\n      let uiVariantChanged = false;\n\n      // Select new UI variant\n      // If no variant condition is fulfilled, we switch to *no* UI\n      for (let uiVariant of this.uiVariants) {\n        if (uiVariant.condition == null || uiVariant.condition(context) === true) {\n          nextUi = this.uiInstanceManagers[this.uiVariants.indexOf(uiVariant)];\n          break;\n        }\n      }\n\n      // Determine if the UI variant is changing\n      if (nextUi !== this.currentUi) {\n        uiVariantChanged = true;\n        // console.log('switched from ', this.currentUi ? this.currentUi.getUI() : 'none',\n        //   ' to ', nextUi ? nextUi.getUI() : 'none');\n      }\n\n      // Only if the UI variant is changing, we need to do some stuff. Else we just leave everything as-is.\n      if (uiVariantChanged) {\n        // Hide the currently active UI variant\n        if (this.currentUi) {\n          this.currentUi.getUI().hide();\n        }\n\n        // Assign the new UI variant as current UI\n        this.currentUi = nextUi;\n\n        // When we switch to a different UI instance, there's some additional stuff to manage. If we do not switch\n        // to an instance, we're done here.\n        if (this.currentUi != null) {\n          // Add the UI to the DOM (and configure it) the first time it is selected\n          if (!this.currentUi.isConfigured()) {\n            this.addUi(this.currentUi);\n          }\n\n          // If this is an ad UI, we need to relay the saved ON_AD_STARTED event data so ad components can configure\n          // themselves for the current ad.\n          if (context.isAd) {\n            /* Relay the ON_AD_STARTED event to the ads UI\n             *\n             * Because the ads UI is initialized in the ON_AD_STARTED handler, i.e. when the ON_AD_STARTED event has\n             * already been fired, components in the ads UI that listen for the ON_AD_STARTED event never receive it.\n             * Since this can break functionality of components that rely on this event, we relay the event to the\n             * ads UI components with the following call.\n             */\n            this.currentUi.getWrappedPlayer().fireEventInUI(this.player.EVENT.ON_AD_STARTED, adStartedEvent);\n          }\n\n          this.currentUi.getUI().show();\n        }\n      }\n    };\n\n    // Listen to the following events to trigger UI variant resolution\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_STARTED, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_FINISHED, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_SKIPPED, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_ERROR, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_PLAYER_RESIZE, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_FULLSCREEN_ENTER, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_FULLSCREEN_EXIT, resolveUiVariant);\n\n    // Initialize the UI\n    resolveUiVariant(null);\n  }\n\n  getConfig(): UIConfig {\n    return this.config;\n  }\n\n  private addUi(ui: InternalUIInstanceManager): void {\n    let dom = ui.getUI().getDomElement();\n    ui.configureControls();\n    /* Append the UI DOM after configuration to avoid CSS transitions at initialization\n     * Example: Components are hidden during configuration and these hides may trigger CSS transitions that are\n     * undesirable at this time. */\n\n    /* Append ui to parent instead of player */\n    let parentElement = new DOM(this.playerElement.getElements()[0].parentElement);\n    parentElement.addClass('smashcut-custom-ui-bitmovin-player-holder');\n    parentElement.append(dom);\n\n    // Fire onConfigured after UI DOM elements are successfully added. When fired immediately, the DOM elements\n    // might not be fully configured and e.g. do not have a size.\n    // https://swizec.com/blog/how-to-properly-wait-for-dom-elements-to-show-up-in-modern-browsers/swizec/6663\n    if (window.requestAnimationFrame) {\n      requestAnimationFrame(() => {\n        ui.onConfigured.dispatch(ui.getUI());\n      });\n    } else {\n      // IE9 fallback\n      setTimeout(() => {\n        ui.onConfigured.dispatch(ui.getUI());\n      }, 0);\n    }\n  }\n\n  private releaseUi(ui: InternalUIInstanceManager): void {\n    ui.releaseControls();\n    ui.getUI().getDomElement().remove();\n    ui.clearEventHandlers();\n  }\n\n  release(): void {\n    for (let uiInstanceManager of this.uiInstanceManagers) {\n      this.releaseUi(uiInstanceManager);\n    }\n    this.managerPlayerWrapper.clearEventHandlers();\n  }\n}\n\nexport namespace UIManager.Factory {\n\n  export function buildDefaultUI(player: Player, config: UIConfig = {}): UIManager {\n    return UIManager.Factory.buildModernUI(player, config);\n  }\n\n  export function buildDefaultSmallScreenUI(player: Player, config: UIConfig = {}): UIManager {\n    return UIManager.Factory.buildModernSmallScreenUI(player, config);\n  }\n\n  export function buildDefaultCastReceiverUI(player: Player, config: UIConfig = {}): UIManager {\n    return UIManager.Factory.buildModernCastReceiverUI(player, config);\n  }\n\n  function smashcutUi() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBarTop = new Container({\n      cssClasses: ['controlbar-top'],\n      components: [\n        new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n        new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n      ]\n    });\n\n    let controlBarMiddle = new Container({\n      cssClasses: ['controlbar-middle'],\n      components: [\n        new SeekBar({label: new SeekBarLabel()}),\n      ]\n    });\n\n    let controlBarBottom = new Container({\n      cssClasses: ['controlbar-bottom'],\n      components: [\n        new Spacer(),\n        new VolumeSlider(),\n        new VolumeToggleButton(),\n        new SettingsToggleButton({settingsPanel: settingsPanel}),\n        new EmbedVideoToggleButton(),\n        new FullscreenToggleButton(),\n      ]\n    });\n\n\n    let controlBar = new ControlBar({\n      components: [\n        new PlaybackToggleButton(),\n        new Container({\n          cssClasses: ['controlbar-inner'],\n          components: [\n            settingsPanel,\n            controlBarTop,\n            controlBarMiddle,\n            controlBarBottom,\n          ]\n        })\n      ]\n    });\n\n    return new UIContainer({\n      hideDelay: 0,\n      cssClasses: ['ui-skin-modern ui-skin-smashcut'],\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new PlaybackToggleOverlay(),\n        controlBar,\n        new TitleBar(),\n        new RecommendationOverlay(),\n        new ErrorMessageOverlay()\n      ]\n    });\n  }\n\n  function modernUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBar = new ControlBar({\n      components: [\n        settingsPanel,\n        new Container({\n          components: [\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n            new SeekBar({label: new SeekBarLabel()}),\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n          ],\n          cssClasses: ['controlbar-top']\n        }),\n        new Container({\n          components: [\n            new PlaybackToggleButton(),\n            new VolumeToggleButton(),\n            new VolumeSlider(),\n            new Spacer(),\n            new PictureInPictureToggleButton(),\n            new AirPlayToggleButton(),\n            new CastToggleButton(),\n            new VRToggleButton(),\n            new SettingsToggleButton({settingsPanel: settingsPanel}),\n            new FullscreenToggleButton(),\n          ],\n          cssClasses: ['controlbar-bottom']\n        }),\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new PlaybackToggleOverlay(),\n        new CastStatusOverlay(),\n        controlBar,\n        new TitleBar(),\n        new RecommendationOverlay(),\n        new Watermark(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-modern']\n    });\n  }\n\n  function modernAdsUI() {\n    return new UIContainer({\n      components: [\n        new BufferingOverlay(),\n        new AdClickOverlay(),\n        new PlaybackToggleOverlay(),\n        new Container({\n          components: [\n            new AdMessageLabel({text: 'Ad: {remainingTime} secs'}),\n            new AdSkipButton()\n          ],\n          cssClass: 'ui-ads-status'\n        }),\n        new ControlBar({\n          components: [\n            new Container({\n              components: [\n                new PlaybackToggleButton(),\n                new VolumeToggleButton(),\n                new VolumeSlider(),\n                new Spacer(),\n                new FullscreenToggleButton(),\n              ],\n              cssClasses: ['controlbar-bottom']\n            }),\n          ]\n        })\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-ads']\n    });\n  }\n\n  function modernSmallScreenUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true,\n      hideDelay: -1,\n    });\n    settingsPanel.addComponent(new CloseButton({target: settingsPanel}));\n\n    let controlBar = new ControlBar({\n      components: [\n        new Container({\n          components: [\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n            new SeekBar({label: new SeekBarLabel()}),\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n          ],\n          cssClasses: ['controlbar-top']\n        }),\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        controlBar,\n        new TitleBar({\n          components: [\n            new MetadataLabel({content: MetadataLabelContent.Title}),\n            new CastToggleButton(),\n            /*new VRToggleButton(),*/\n            new SettingsToggleButton({settingsPanel: settingsPanel}),\n            new FullscreenToggleButton(),\n          ]\n        }),\n        settingsPanel,\n        new RecommendationOverlay(),\n        new Watermark(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-smallscreen']\n    });\n  }\n\n  function modernSmallScreenAdsUI() {\n    return new UIContainer({\n      components: [\n        new BufferingOverlay(),\n        new AdClickOverlay(),\n        new PlaybackToggleOverlay(),\n        new TitleBar({\n          components: [\n            // dummy label with no content to move buttons to the right\n            new Label({cssClass: 'label-metadata-title'}),\n            new FullscreenToggleButton(),\n          ]\n        }),\n        new Container({\n          components: [\n            new AdMessageLabel({text: 'Ad: {remainingTime} secs'}),\n            new AdSkipButton()\n          ],\n          cssClass: 'ui-ads-status'\n        }),\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-ads', 'ui-skin-smallscreen']\n    });\n  }\n\n  function modernCastReceiverUI() {\n    let controlBar = new ControlBar({\n      components: [\n        new Container({\n          components: [\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n            new SeekBar({smoothPlaybackPositionUpdateIntervalMs: -1}),\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n          ],\n          cssClasses: ['controlbar-top']\n        }),\n      ]\n    });\n\n    return new CastUIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        controlBar,\n        new TitleBar({keepHiddenWithoutMetadata: true}),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-cast-receiver']\n    });\n  }\n\n  export function buildModernUI(player: Player, config: UIConfig = {}): UIManager {\n    // show smallScreen UI only on mobile/handheld devices\n    let smallScreenSwitchWidth = 600;\n\n    return new UIManager(player, [{\n      ui: modernSmallScreenAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isMobile && context.documentWidth < smallScreenSwitchWidth && context.isAdWithUI;\n      }\n    }, {\n      ui: modernAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isAdWithUI;\n      }\n    }, {\n      ui: modernSmallScreenUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isMobile && context.documentWidth < smallScreenSwitchWidth;\n      }\n    }, {\n      ui: smashcutUi()\n    }], config);\n  }\n\n  export function buildModernSmallScreenUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, [{\n      ui: modernSmallScreenAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isAdWithUI;\n      }\n    }, {\n      ui: modernSmallScreenUI()\n    }], config);\n  }\n\n  export function buildModernCastReceiverUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, modernCastReceiverUI(), config);\n  }\n\n  function legacyUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBar = new ControlBar({\n      components: [\n        settingsPanel,\n        new PlaybackToggleButton(),\n        new SeekBar({label: new SeekBarLabel()}),\n        new PlaybackTimeLabel(),\n        new VRToggleButton(),\n        new VolumeControlButton(),\n        new SettingsToggleButton({settingsPanel: settingsPanel}),\n        new CastToggleButton(),\n        new FullscreenToggleButton()\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        new RecommendationOverlay(),\n        controlBar,\n        new TitleBar(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-legacy']\n    });\n  }\n\n  function legacyAdsUI() {\n    return new UIContainer({\n      components: [\n        new AdClickOverlay(),\n        new ControlBar({\n          components: [\n            new PlaybackToggleButton(),\n            new AdMessageLabel(),\n            new VolumeControlButton(),\n            new FullscreenToggleButton()\n          ]\n        }),\n        new AdSkipButton()\n      ], cssClasses: ['ui-skin-legacy', 'ui-skin-ads']\n    });\n  }\n\n  function legacyCastReceiverUI() {\n    let controlBar = new ControlBar({\n      components: [\n        new SeekBar(),\n        new PlaybackTimeLabel(),\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        controlBar,\n        new TitleBar(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-legacy', 'ui-skin-cast-receiver']\n    });\n  }\n\n  function legacyTestUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBar = new ControlBar({\n      components: [settingsPanel,\n        new PlaybackToggleButton(),\n        new SeekBar({label: new SeekBarLabel()}),\n        new PlaybackTimeLabel(),\n        new VRToggleButton(),\n        new VolumeToggleButton(),\n        new VolumeSlider(),\n        new VolumeControlButton(),\n        new VolumeControlButton({vertical: false}),\n        new SettingsToggleButton({settingsPanel: settingsPanel}),\n        new CastToggleButton(),\n        new FullscreenToggleButton()\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        new RecommendationOverlay(),\n        controlBar,\n        new TitleBar(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-legacy']\n    });\n  }\n\n  export function buildLegacyUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, [{\n      ui: legacyAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isAdWithUI;\n      }\n    }, {\n      ui: legacyUI()\n    }], config);\n  }\n\n  export function buildLegacyCastReceiverUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, legacyCastReceiverUI(), config);\n  }\n\n  export function buildLegacyTestUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, legacyTestUI(), config);\n  }\n}\n\nexport interface SeekPreviewArgs extends NoArgs {\n  /**\n   * The timeline position in percent where the event originates from.\n   */\n  position: number;\n  /**\n   * The timeline marker associated with the current position, if existing.\n   */\n  marker?: TimelineMarker;\n}\n\n/**\n * Encapsulates functionality to manage a UI instance. Used by the {@link UIManager} to manage multiple UI instances.\n */\nexport class UIInstanceManager {\n  private playerWrapper: PlayerWrapper;\n  private ui: UIContainer;\n  private config: UIConfig;\n\n  private events = {\n    onConfigured: new EventDispatcher<UIContainer, NoArgs>(),\n    onSeek: new EventDispatcher<SeekBar, NoArgs>(),\n    onSeekPreview: new EventDispatcher<SeekBar, SeekPreviewArgs>(),\n    onSeeked: new EventDispatcher<SeekBar, NoArgs>(),\n    onComponentShow: new EventDispatcher<Component<ComponentConfig>, NoArgs>(),\n    onComponentHide: new EventDispatcher<Component<ComponentConfig>, NoArgs>(),\n    onControlsShow: new EventDispatcher<UIContainer, NoArgs>(),\n    onPreviewControlsHide: new EventDispatcher<UIContainer, CancelEventArgs>(),\n    onControlsHide: new EventDispatcher<UIContainer, NoArgs>(),\n  };\n\n  constructor(player: Player, ui: UIContainer, config: UIConfig = {}) {\n    this.playerWrapper = new PlayerWrapper(player);\n    this.ui = ui;\n    this.config = config;\n  }\n\n  getConfig(): UIConfig {\n    return this.config;\n  }\n\n  getUI(): UIContainer {\n    return this.ui;\n  }\n\n  getPlayer(): Player {\n    return this.playerWrapper.getPlayer();\n  }\n\n  /**\n   * Fires when the UI is fully configured and added to the DOM.\n   * @returns {EventDispatcher}\n   */\n  get onConfigured(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onConfigured;\n  }\n\n  /**\n   * Fires when a seek starts.\n   * @returns {EventDispatcher}\n   */\n  get onSeek(): EventDispatcher<SeekBar, NoArgs> {\n    return this.events.onSeek;\n  }\n\n  /**\n   * Fires when the seek timeline is scrubbed.\n   * @returns {EventDispatcher}\n   */\n  get onSeekPreview(): EventDispatcher<SeekBar, SeekPreviewArgs> {\n    return this.events.onSeekPreview;\n  }\n\n  /**\n   * Fires when a seek is finished.\n   * @returns {EventDispatcher}\n   */\n  get onSeeked(): EventDispatcher<SeekBar, NoArgs> {\n    return this.events.onSeeked;\n  }\n\n  /**\n   * Fires when a component is showing.\n   * @returns {EventDispatcher}\n   */\n  get onComponentShow(): EventDispatcher<Component<ComponentConfig>, NoArgs> {\n    return this.events.onComponentShow;\n  }\n\n  /**\n   * Fires when a component is hiding.\n   * @returns {EventDispatcher}\n   */\n  get onComponentHide(): EventDispatcher<Component<ComponentConfig>, NoArgs> {\n    return this.events.onComponentHide;\n  }\n\n  /**\n   * Fires when the UI controls are showing.\n   * @returns {EventDispatcher}\n   */\n  get onControlsShow(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onControlsShow;\n  }\n\n  /**\n   * Fires before the UI controls are hiding to check if they are allowed to hide.\n   * @returns {EventDispatcher}\n   */\n  get onPreviewControlsHide(): EventDispatcher<UIContainer, CancelEventArgs> {\n    return this.events.onPreviewControlsHide;\n  }\n\n  /**\n   * Fires when the UI controls are hiding.\n   * @returns {EventDispatcher}\n   */\n  get onControlsHide(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onControlsHide;\n  }\n\n  protected clearEventHandlers(): void {\n    this.playerWrapper.clearEventHandlers();\n\n    let events = <any>this.events; // avoid TS7017\n    for (let event in events) {\n      let dispatcher = <EventDispatcher<Object, Object>>events[event];\n      dispatcher.unsubscribeAll();\n    }\n  }\n}\n\n/**\n * Extends the {@link UIInstanceManager} for internal use in the {@link UIManager} and provides access to functionality\n * that components receiving a reference to the {@link UIInstanceManager} should not have access to.\n */\nclass InternalUIInstanceManager extends UIInstanceManager {\n\n  private configured: boolean;\n  private released: boolean;\n\n  getWrappedPlayer(): WrappedPlayer {\n    // TODO find a non-hacky way to provide the WrappedPlayer to the UIManager without exporting it\n    // getPlayer() actually returns the WrappedPlayer but its return type is set to Player so the WrappedPlayer does\n    // not need to be exported\n    return <WrappedPlayer>this.getPlayer();\n  }\n\n  configureControls(): void {\n    this.configureControlsTree(this.getUI());\n    this.configured = true;\n  }\n\n  isConfigured(): boolean {\n    return this.configured;\n  }\n\n  private configureControlsTree(component: Component<ComponentConfig>) {\n    let configuredComponents: Component<ComponentConfig>[] = [];\n\n    UIUtils.traverseTree(component, (component) => {\n      // First, check if we have already configured a component, and throw an error if we did. Multiple configuration\n      // of the same component leads to unexpected UI behavior. Also, a component that is in the UI tree multiple\n      // times hints at a wrong UI structure.\n      // We could just skip configuration in such a case and not throw an exception, but enforcing a clean UI tree\n      // seems like the better choice.\n      for (let configuredComponent of configuredComponents) {\n        if (configuredComponent === component) {\n          // Write the component to the console to simplify identification of the culprit\n          // (e.g. by inspecting the config)\n          if (console) {\n            console.error('Circular reference in UI tree', component);\n          }\n\n          // Additionally throw an error, because this case must not happen and leads to unexpected UI behavior.\n          throw Error('Circular reference in UI tree: ' + component.constructor.name);\n        }\n      }\n\n      component.initialize();\n      component.configure(this.getPlayer(), this);\n      configuredComponents.push(component);\n    });\n  }\n\n  releaseControls(): void {\n    // Do not call release methods if the components have never been configured; this can result in exceptions\n    if (this.configured) {\n      this.releaseControlsTree(this.getUI());\n      this.configured = false;\n    }\n    this.released = true;\n  }\n\n  isReleased(): boolean {\n    return this.released;\n  }\n\n  private releaseControlsTree(component: Component<ComponentConfig>) {\n    component.release();\n\n    if (component instanceof Container) {\n      for (let childComponent of component.getComponents()) {\n        this.releaseControlsTree(childComponent);\n      }\n    }\n  }\n\n  clearEventHandlers(): void {\n    super.clearEventHandlers();\n  }\n}\n\n/**\n * Extended interface of the {@link Player} for use in the UI.\n */\ninterface WrappedPlayer extends Player {\n  /**\n   * Fires an event on the player that targets all handlers in the UI but never enters the real player.\n   * @param event the event to fire\n   * @param data data to send with the event\n   */\n  fireEventInUI(event: EVENT, data: {}): void;\n}\n\n/**\n * Wraps the player to track event handlers and provide a simple method to remove all registered event\n * handlers from the player.\n */\nclass PlayerWrapper {\n\n  private player: Player;\n  private wrapper: WrappedPlayer;\n\n  private eventHandlers: { [eventType: string]: PlayerEventCallback[]; } = {};\n\n  constructor(player: Player) {\n    this.player = player;\n\n    // Collect all public API methods of the player\n    let methods = <any[]>[];\n    for (let member in player) {\n      if (typeof (<any>player)[member] === 'function') {\n        methods.push(member);\n      }\n    }\n\n    // Create wrapper object and add function wrappers for all API methods that do nothing but calling the base method\n    // on the player\n    let wrapper = <any>{};\n    for (let member of methods) {\n      wrapper[member] = function () {\n        // console.log('called ' + member); // track method calls on the player\n        return (<any>player)[member].apply(player, arguments);\n      };\n    }\n\n    // Collect all public properties of the player and add it to the wrapper\n    for (let member in player) {\n      if (typeof (<any>player)[member] !== 'function') {\n        wrapper[member] = (<any>player)[member];\n      }\n    }\n\n    // Explicitly add a wrapper method for 'addEventHandler' that adds added event handlers to the event list\n    wrapper.addEventHandler = (eventType: EVENT, callback: PlayerEventCallback) => {\n      player.addEventHandler(eventType, callback);\n\n      if (!this.eventHandlers[eventType]) {\n        this.eventHandlers[eventType] = [];\n      }\n\n      this.eventHandlers[eventType].push(callback);\n\n      return wrapper;\n    };\n\n    // Explicitly add a wrapper method for 'removeEventHandler' that removes removed event handlers from the event list\n    wrapper.removeEventHandler = (eventType: EVENT, callback: PlayerEventCallback) => {\n      player.removeEventHandler(eventType, callback);\n\n      if (this.eventHandlers[eventType]) {\n        ArrayUtils.remove(this.eventHandlers[eventType], callback);\n      }\n\n      return wrapper;\n    };\n\n    wrapper.fireEventInUI = (event: EVENT, data: {}) => {\n      if (this.eventHandlers[event]) { // check if there are handlers for this event registered\n        // Extend the data object with default values to convert it to a {@link PlayerEvent} object.\n        let playerEventData = <PlayerEvent>Object.assign({}, {\n          timestamp: Date.now(),\n          type: event,\n          // Add a marker property so the UI can detect UI-internal player events\n          uiSourced: true,\n        }, data);\n\n        // Execute the registered callbacks\n        for (let callback of this.eventHandlers[event]) {\n          callback(playerEventData);\n        }\n      }\n    };\n\n    this.wrapper = <WrappedPlayer>wrapper;\n  }\n\n  /**\n   * Returns a wrapped player object that can be used on place of the normal player object.\n   * @returns {WrappedPlayer} a wrapped player\n   */\n  getPlayer(): WrappedPlayer {\n    return this.wrapper;\n  }\n\n  /**\n   * Clears all registered event handlers from the player that were added through the wrapped player.\n   */\n  clearEventHandlers(): void {\n    for (let eventType in this.eventHandlers) {\n      for (let callback of this.eventHandlers[eventType]) {\n        this.player.removeEventHandler(eventType, callback);\n      }\n    }\n  }\n}\n","import {EventDispatcher, Event, NoArgs} from './eventdispatcher';\nimport {Component, ComponentConfig} from './components/component';\nimport {Container} from './components/container';\n\nexport namespace ArrayUtils {\n  /**\n   * Removes an item from an array.\n   * @param array the array that may contain the item to remove\n   * @param item the item to remove from the array\n   * @returns {any} the removed item or null if it wasn't part of the array\n   */\n  export function remove<T>(array: T[], item: T): T | null {\n    let index = array.indexOf(item);\n\n    if (index > -1) {\n      return array.splice(index, 1)[0];\n    } else {\n      return null;\n    }\n  }\n}\n\nexport namespace StringUtils {\n\n  export let FORMAT_HHMMSS: string = 'hh:mm:ss';\n  export let FORMAT_MMSS: string = 'mm:ss';\n\n  /**\n   * Formats a number of seconds into a time string with the pattern hh:mm:ss.\n   *\n   * @param totalSeconds the total number of seconds to format to string\n   * @param format the time format to output (default: hh:mm:ss)\n   * @returns {string} the formatted time string\n   */\n  export function secondsToTime(totalSeconds: number, format: string = FORMAT_HHMMSS): string {\n    let isNegative = totalSeconds < 0;\n\n    if (isNegative) {\n      // If the time is negative, we make it positive for the calculation below\n      // (else we'd get all negative numbers) and reattach the negative sign later.\n      totalSeconds = -totalSeconds;\n    }\n\n    // Split into separate time parts\n    let hours = Math.floor(totalSeconds / 3600);\n    let minutes = Math.floor(totalSeconds / 60) - hours * 60;\n    let seconds = Math.floor(totalSeconds) % 60;\n\n    return (isNegative ? '-' : '') + format\n        .replace('hh', leftPadWithZeros(hours, 2))\n        .replace('mm', leftPadWithZeros(minutes, 2))\n        .replace('ss', leftPadWithZeros(seconds, 2));\n  }\n\n  /**\n   * Converts a number to a string and left-pads it with zeros to the specified length.\n   * Example: leftPadWithZeros(123, 5) => '00123'\n   *\n   * @param num the number to convert to string and pad with zeros\n   * @param length the desired length of the padded string\n   * @returns {string} the padded number as string\n   */\n  function leftPadWithZeros(num: number | string, length: number): string {\n    let text = num + '';\n    let padding = '0000000000'.substr(0, length - text.length);\n    return padding + text;\n  }\n\n  /**\n   * Fills out placeholders in an ad message.\n   *\n   * Has the placeholders '{remainingTime[formatString]}', '{playedTime[formatString]}' and\n   * '{adDuration[formatString]}', which are replaced by the remaining time until the ad can be skipped, the current\n   * time or the ad duration. The format string is optional. If not specified, the placeholder is replaced by the time\n   * in seconds. If specified, it must be of the following format:\n   * - %d - Inserts the time as an integer.\n   * - %0Nd - Inserts the time as an integer with leading zeroes, if the length of the time string is smaller than N.\n   * - %f - Inserts the time as a float.\n   * - %0Nf - Inserts the time as a float with leading zeroes.\n   * - %.Mf - Inserts the time as a float with M decimal places. Can be combined with %0Nf, e.g. %04.2f (the time\n   * 10.123\n   * would be printed as 0010.12).\n   * - %hh:mm:ss\n   * - %mm:ss\n   *\n   * @param adMessage an ad message with optional placeholders to fill\n   * @param skipOffset if specified, {remainingTime} will be filled with the remaining time until the ad can be skipped\n   * @param player the player to get the time data from\n   * @returns {string} the ad message with filled placeholders\n   */\n  export function replaceAdMessagePlaceholders(adMessage: string, skipOffset: number, player: bitmovin.player.Player) {\n    let adMessagePlaceholderRegex = new RegExp(\n      '\\\\{(remainingTime|playedTime|adDuration)(}|%((0[1-9]\\\\d*(\\\\.\\\\d+(d|f)|d|f)|\\\\.\\\\d+f|d|f)|hh:mm:ss|mm:ss)})',\n      'g'\n    );\n\n    return adMessage.replace(adMessagePlaceholderRegex, (formatString) => {\n      let time = 0;\n      if (formatString.indexOf('remainingTime') > -1) {\n        if (skipOffset) {\n          time = Math.ceil(skipOffset - player.getCurrentTime());\n        } else {\n          time = player.getDuration() - player.getCurrentTime();\n        }\n      } else if (formatString.indexOf('playedTime') > -1) {\n        time = player.getCurrentTime();\n      } else if (formatString.indexOf('adDuration') > -1) {\n        time = player.getDuration();\n      }\n      return formatNumber(time, formatString);\n    });\n  }\n\n  function formatNumber(time: number, format: string) {\n    let formatStringValidationRegex = /%((0[1-9]\\d*(\\.\\d+(d|f)|d|f)|\\.\\d+f|d|f)|hh:mm:ss|mm:ss)/;\n    let leadingZeroesRegex = /(%0[1-9]\\d*)(?=(\\.\\d+f|f|d))/;\n    let decimalPlacesRegex = /\\.\\d*(?=f)/;\n\n    if (!formatStringValidationRegex.test(format)) {\n      // If the format is invalid, we set a default fallback format\n      format = '%d';\n    }\n\n    // Determine the number of leading zeros\n    let leadingZeroes = 0;\n    let leadingZeroesMatches = format.match(leadingZeroesRegex);\n    if (leadingZeroesMatches) {\n      leadingZeroes = parseInt(leadingZeroesMatches[0].substring(2));\n    }\n\n    // Determine the number of decimal places\n    let numDecimalPlaces = null;\n    let decimalPlacesMatches = format.match(decimalPlacesRegex);\n    if (decimalPlacesMatches && !isNaN(parseInt(decimalPlacesMatches[0].substring(1)))) {\n      numDecimalPlaces = parseInt(decimalPlacesMatches[0].substring(1));\n      if (numDecimalPlaces > 20) {\n        numDecimalPlaces = 20;\n      }\n    }\n\n    // Float format\n    if (format.indexOf('f') > -1) {\n      let timeString = '';\n\n      if (numDecimalPlaces !== null) {\n        // Apply fixed number of decimal places\n        timeString = time.toFixed(numDecimalPlaces);\n      } else {\n        timeString = '' + time;\n      }\n\n      // Apply leading zeros\n      if (timeString.indexOf('.') > -1) {\n        return leftPadWithZeros(timeString, timeString.length + (leadingZeroes - timeString.indexOf('.')));\n      } else {\n        return leftPadWithZeros(timeString, leadingZeroes);\n      }\n\n    }\n    // Time format\n    else if (format.indexOf(':') > -1) {\n      let totalSeconds = Math.ceil(time);\n\n      // hh:mm:ss format\n      if (format.indexOf('hh') > -1) {\n        return secondsToTime(totalSeconds);\n      }\n      // mm:ss format\n      else {\n        let minutes = Math.floor(totalSeconds / 60);\n        let seconds = totalSeconds % 60;\n\n        return leftPadWithZeros(minutes, 2) + ':' + leftPadWithZeros(seconds, 2);\n      }\n    }\n    // Integer format\n    else {\n      return leftPadWithZeros(Math.ceil(time), leadingZeroes);\n    }\n  }\n}\n\nexport namespace PlayerUtils {\n\n  import Player = bitmovin.player.Player;\n\n  export enum PlayerState {\n    IDLE,\n    PREPARED,\n    PLAYING,\n    PAUSED,\n    FINISHED,\n  }\n\n  export function isSourceLoaded(player: Player): boolean {\n    return player.getConfig().source !== undefined;\n  }\n\n  export function isTimeShiftAvailable(player: Player): boolean {\n    return player.isLive() && player.getMaxTimeShift() !== 0;\n  }\n\n  export function getState(player: Player): PlayerState {\n    if (player.hasEnded()) {\n      return PlayerState.FINISHED;\n    } else if (player.isPlaying()) {\n      return PlayerState.PLAYING;\n    } else if (player.isPaused()) {\n      return PlayerState.PAUSED;\n    } else if (isSourceLoaded(player)) {\n      return PlayerState.PREPARED;\n    } else {\n      return PlayerState.IDLE;\n    }\n  }\n\n  export interface TimeShiftAvailabilityChangedArgs extends NoArgs {\n    timeShiftAvailable: boolean;\n  }\n\n  export class TimeShiftAvailabilityDetector {\n\n    private timeShiftAvailabilityChangedEvent = new EventDispatcher<Player, TimeShiftAvailabilityChangedArgs>();\n\n    constructor(player: Player) {\n      let timeShiftAvailable: boolean = undefined;\n\n      let timeShiftDetector = () => {\n        if (player.isLive()) {\n          let timeShiftAvailableNow = PlayerUtils.isTimeShiftAvailable(player);\n\n          // When the availability changes, we fire the event\n          if (timeShiftAvailableNow !== timeShiftAvailable) {\n            this.timeShiftAvailabilityChangedEvent.dispatch(player, { timeShiftAvailable: timeShiftAvailableNow });\n            timeShiftAvailable = timeShiftAvailableNow;\n          }\n        }\n      };\n      // Try to detect timeshift availability in ON_READY, which works for DASH streams\n      player.addEventHandler(player.EVENT.ON_READY, timeShiftDetector);\n      // With HLS/NativePlayer streams, getMaxTimeShift can be 0 before the buffer fills, so we need to additionally\n      // check timeshift availability in ON_TIME_CHANGED\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, timeShiftDetector);\n    }\n\n    get onTimeShiftAvailabilityChanged(): Event<Player, TimeShiftAvailabilityChangedArgs> {\n      return this.timeShiftAvailabilityChangedEvent.getEvent();\n    }\n  }\n\n  export interface LiveStreamDetectorEventArgs extends NoArgs {\n    live: boolean;\n  }\n\n  /**\n   * Detects changes of the stream type, i.e. changes of the return value of the player#isLive method.\n   * Normally, a stream cannot change its type during playback, it's either VOD or live. Due to bugs on some\n   * platforms or browsers, it can still change. It is therefore unreliable to just check #isLive and this detector\n   * should be used as a workaround instead.\n   *\n   * Known cases:\n   *\n   * - HLS VOD on Android 4.3\n   * Video duration is initially 'Infinity' and only gets available after playback starts, so streams are wrongly\n   * reported as 'live' before playback (the live-check in the player checks for infinite duration).\n   */\n  export class LiveStreamDetector {\n\n    private liveChangedEvent = new EventDispatcher<Player, LiveStreamDetectorEventArgs>();\n\n    constructor(player: Player) {\n      let live: boolean = undefined;\n\n      let liveDetector = () => {\n        let liveNow = player.isLive();\n\n        // Compare current to previous live state flag and fire event when it changes. Since we initialize the flag\n        // with undefined, there is always at least an initial event fired that tells listeners the live state.\n        if (liveNow !== live) {\n          this.liveChangedEvent.dispatch(player, { live: liveNow });\n          live = liveNow;\n        }\n      };\n      // Initialize when player is ready\n      player.addEventHandler(player.EVENT.ON_READY, liveDetector);\n      // Re-evaluate when playback starts\n      player.addEventHandler(player.EVENT.ON_PLAY, liveDetector);\n\n      // HLS live detection workaround for Android:\n      // Also re-evaluate during playback, because that is when the live flag might change.\n      // (Doing it only in Android Chrome saves unnecessary overhead on other plattforms)\n      if (BrowserUtils.isAndroid && BrowserUtils.isChrome) {\n        player.addEventHandler(player.EVENT.ON_TIME_CHANGED, liveDetector);\n      }\n    }\n\n    get onLiveChanged(): Event<Player, LiveStreamDetectorEventArgs> {\n      return this.liveChangedEvent.getEvent();\n    }\n  }\n}\n\nexport namespace UIUtils {\n  export interface TreeTraversalCallback {\n    (component: Component<ComponentConfig>, parent?: Component<ComponentConfig>): void;\n  }\n\n  export function traverseTree(component: Component<ComponentConfig>, visit: TreeTraversalCallback): void {\n    let recursiveTreeWalker = (component: Component<ComponentConfig>, parent?: Component<ComponentConfig>) => {\n      visit(component, parent);\n\n      // If the current component is a container, visit it's children\n      if (component instanceof Container) {\n        for (let childComponent of component.getComponents()) {\n          recursiveTreeWalker(childComponent, component);\n        }\n      }\n    };\n\n    // Walk and configure the component tree\n    recursiveTreeWalker(component);\n  }\n}\n\nexport namespace BrowserUtils {\n\n  // isMobile only needs to be evaluated once (it cannot change during a browser session)\n  // Mobile detection according to Mozilla recommendation: \"In summary, we recommend looking for the string Mobi\n  // anywhere in the User Agent to detect a mobile device.\"\n  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent\n  export const isMobile = navigator && navigator.userAgent && /Mobi/.test(navigator.userAgent);\n\n  export const isChrome = navigator && navigator.userAgent && /Chrome/.test(navigator.userAgent);\n\n  export const isAndroid = navigator && navigator.userAgent && /Android/.test(navigator.userAgent);\n}"]}