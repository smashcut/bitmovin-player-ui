{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/ts/components/adclickoverlay.ts","src/ts/components/admessagelabel.ts","src/ts/components/adskipbutton.ts","src/ts/components/airplaytogglebutton.ts","src/ts/components/audioqualityselectbox.ts","src/ts/components/audiotrackselectbox.ts","src/ts/components/bufferingoverlay.ts","src/ts/components/button.ts","src/ts/components/caststatusoverlay.ts","src/ts/components/casttogglebutton.ts","src/ts/components/castuicontainer.ts","src/ts/components/checkbox.ts","src/ts/components/clickoverlay.ts","src/ts/components/closebutton.ts","src/ts/components/component.ts","src/ts/components/container.ts","src/ts/components/controlbar.ts","src/ts/components/embedvideopanel.ts","src/ts/components/embedvideotogglebutton.ts","src/ts/components/errormessageoverlay.ts","src/ts/components/fullscreentogglebutton.ts","src/ts/components/hugeplaybacktogglebutton.ts","src/ts/components/hugereplaybutton.ts","src/ts/components/label.ts","src/ts/components/listselector.ts","src/ts/components/metadatalabel.ts","src/ts/components/pictureinpicturetogglebutton.ts","src/ts/components/playbackspeedselectbox.ts","src/ts/components/playbacktimelabel.ts","src/ts/components/playbacktogglebutton.ts","src/ts/components/playbacktoggleoverlay.ts","src/ts/components/recommendationoverlay.ts","src/ts/components/seekbar.ts","src/ts/components/seekbarlabel.ts","src/ts/components/selectbox.ts","src/ts/components/settingspanel.ts","src/ts/components/settingstogglebutton.ts","src/ts/components/spacer.ts","src/ts/components/subtitleoverlay.ts","src/ts/components/subtitleselectbox.ts","src/ts/components/titlebar.ts","src/ts/components/togglebutton.ts","src/ts/components/tvnoisecanvas.ts","src/ts/components/uicontainer.ts","src/ts/components/videoqualityselectbox.ts","src/ts/components/volumecontrolbutton.ts","src/ts/components/volumeslider.ts","src/ts/components/volumetogglebutton.ts","src/ts/components/vrtogglebutton.ts","src/ts/components/watermark.ts","src/ts/dom.ts","src/ts/eventdispatcher.ts","src/ts/guid.ts","src/ts/main.ts","src/ts/timeout.ts","src/ts/uimanager.ts","src/ts/utils.ts"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","clickoverlay_1","AdClickOverlay","_super","__extends","prototype","configure","player","uimanager","_this","this","clickThroughUrl","clickThroughEnabled","getConfig","advertising","hasOwnProperty","addEventHandler","EVENT","ON_AD_STARTED","event","setUrl","adFinishedHandler","ON_AD_FINISHED","ON_AD_SKIPPED","ON_AD_ERROR","onClick","subscribe","pause","fireEvent","ON_AD_CLICKED","ClickOverlay","label_1","utils_1","AdMessageLabel","config","mergeConfig","cssClass","text","updateMessageHandler","setText","StringUtils","replaceAdMessagePlaceholders","adStartHandler","adMessage","ON_TIME_CHANGED","ON_CAST_TIME_UPDATED","adEndHandler","removeEventHandler","Label","button_1","AdSkipButton","skipMessage","countdown","skip","adEvent","updateSkipMessageHandler","skipOffset","show","hide","getCurrentTime","skipAd","Button","togglebutton_1","AirPlayToggleButton","isAirplayAvailable","showAirplayTargetPicker","console","log","airPlayAvailableHandler","ON_AIRPLAY_AVAILABLE","ToggleButton","selectbox_1","AudioQualitySelectBox","updateAudioQualities","audioQualities","getAvailableAudioQualities","clearItems","addItem","_i","audioQualities_1","audioQuality","id","label","onItemSelected","sender","value","setAudioQuality","ON_AUDIO_CHANGED","ON_SOURCE_UNLOADED","ON_READY","ON_AUDIO_DOWNLOAD_QUALITY_CHANGE","data","getDownloadedAudioData","selectItem","isAuto","SelectBox","AudioTrackSelectBox","getAudioTrackLabel","updateAudioTracks","audioTracks","getAvailableAudio","audioTracks_1","audioTrack","setAudio","audioTrackHandler","currentAudioTrack","getAudio","container_1","component_1","timeout_1","BufferingOverlay","indicators","Component","tag","hidden","components","showDelayMs","overlayShowTimeout","Timeout","showOverlay","start","hideOverlay","clear","ON_STALL_STARTED","ON_STALL_ENDED","isStalled","Container","dom_1","eventdispatcher_1","buttonEvents","EventDispatcher","toDomElement","buttonElement","DOM","type","class","getCssClasses","append","prefixCss","html","on","onClickEvent","getDomElement","find","dispatch","Object","defineProperty","getEvent","CastStatusOverlay","statusLabel","ON_CAST_WAITING_FOR_DEVICE","castDeviceName","castPayload","deviceName","ON_CAST_STARTED","ON_CAST_STOPPED","CastToggleButton","isCastAvailable","isCasting","castStop","castVideo","castAvailableHander","ON_CAST_AVAILABLE","off","uicontainer_1","CastUIContainer","isUiShown","hideUi","onControlsHide","castUiHideTimeout","hideDelay","showUi","onControlsShow","showUiPermanently","showUiWithTimeout","showUiAfterSeek","isPlaying","ON_SOURCE_LOADED","ON_PLAY","ON_PAUSED","ON_SEEK","ON_SEEKED","release","UIContainer","Checkbox","cssClasses","button","toggle","initialize","url","element","window","open","getUrl","undefined","CloseButton","target","guid_1","componentEvents","onShow","onHide","onHoverChanged","Guid","next","cssPrefix","isHidden","onComponentShow","onComponentHide","onHoverChangedEvent","defaults","base","assign","flattenedArray","concat","map","css","join","trim","cssClassOrId","addClass","CLASS_HIDDEN","onHideEvent","removeClass","onShowEvent","isShown","toggleHidden","isHovered","hovered","addComponent","component","push","removeComponent","ArrayUtils","remove","getComponents","removeComponents","_a","updateComponents","innerContainerElement","empty","containerElement","innerContainer","spacer_1","ControlBar","hoverStackCount","UIUtils","traverseTree","Spacer","args","onPreviewControlsHide","cancel","closebutton_1","checkbox_1","EmbedVideoPanel","title","closeButton","showCommentsCheckbox","codeField","toHtmlEntities","hideTimeout","reset","replace","charCodeAt","EmbedVideoToggleButton","embedVideoPanel","tvnoisecanvas_1","ErrorMessageOverlay","errorLabel","tvNoiseBackground","TvNoiseCanvas","ON_ERROR","message","messages","customMessage","stop","FullscreenToggleButton","fullscreenStateHandler","isFullscreen","ON_FULLSCREEN_ENTER","ON_FULLSCREEN_EXIT","exitFullscreen","enterFullscreen","playbacktogglebutton_1","HugePlaybackToggleButton","togglePlayback","play","toggleFullscreen","firstPlay","clickTime","doubleClickTime","now","Date","setTimeout","castInitializationHandler","ON_CAST_START","PlaybackToggleButton","HugeReplayButton","labelEvents","onTextChanged","labelElement","onTextChangedEvent","getText","clearText","isEmpty","ListSelector","listSelectorEvents","onItemAdded","onItemRemoved","items","getItemIndex","key","index","parseInt","hasItem","removeItem","onItemAddedEvent","onItemRemovedEvent","selectedItem","onItemSelectedEvent","getSelectedItem","items_1","item","itemCount","keys","MetadataLabelContent","MetadataLabel","content","toLowerCase","uiconfig","init","Title","metadata","source","Description","description","unload","PictureInPictureToggleButton","isPictureInPictureAvailable","isPictureInPicture","exitPictureInPicture","enterPictureInPicture","pipAvailableHander","ON_PICTURE_IN_PICTURE_ENTER","ON_PICTURE_IN_PICTURE_EXIT","PlaybackSpeedSelectBox","setPlaybackSpeed","parseFloat","PlaybackTimeLabelMode","PlaybackTimeLabel","timeLabelMode","CurrentAndTotalTime","hideInLivePlayback","live","liveCssClass","liveEdgeCssClass","minWidth","liveClickHandler","timeShift","updateLiveState","isLive","updateLiveTimeshiftState","unsubscribe","PlayerUtils","LiveStreamDetector","onLiveChanged","getTimeShift","playbackTimeHandler","getDuration","Infinity","setTime","width","min-width","ON_TIME_SHIFT","ON_TIME_SHIFTED","timeFormat","Math","abs","getMaxTimeShift","FORMAT_HHMMSS","FORMAT_MMSS","playbackSeconds","durationSeconds","currentTime","secondsToTime","totalTime","CurrentTime","TotalTime","handleClickEvent","isSeeking","playbackStateHandler","ON_PLAYBACK_FINISHED","ON_CAST_PLAYING","ON_CAST_PAUSED","ON_CAST_PLAYBACK_FINISHED","TimeShiftAvailabilityDetector","onTimeShiftAvailabilityChanged","timeShiftAvailable","CLASS_STOPTOGGLE","onSeek","onSeeked","hugeplaybacktogglebutton_1","PlaybackToggleOverlay","playbackToggleButton","hugereplaybutton_1","RecommendationOverlay","replayButton","clearRecommendations","RecommendationItem","setupRecommendations","hasRecommendationsInUiConfig","recommendations","hasRecommendationsInPlayerConfig","recommendations_1","itemConfig","isAd","itemElement","href","background-image","thumbnail","bgElement","titleElement","timeElement","duration","SeekBar","playbackPositionPercentage","touchSupported","seekBarEvents","onSeekPreview","vertical","smoothPlaybackPositionUpdateIntervalMs","timelineMarkers","hasLabel","getLabel","configureSeek","playbackNotInitialized","playbackPositionHandler","forceUpdate","setPlaybackPosition","setBufferPosition","videoBufferLength","getVideoBufferLength","audioBufferLength","getAudioBufferLength","bufferLength","min","Number","MAX_VALUE","bufferPercentage","SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED","isPaused","ON_SEGMENT_REQUEST_FINISHED","setSeeking","seek","percentage","subscribeRateLimited","scrubbing","position","hasTimeShift","switchVisibility","refreshPlaybackPosition","ON_PLAYER_RESIZE","onConfigured","setSeekPosition","configureSmoothPlaybackPositionUpdater","configureMarkers","currentTimeSeekBar","currentTimePlayer","smoothPlaybackPositionUpdater","updateIntervalMs","currentTimeDelta","startSmoothPlaybackPositionUpdater","stopSmoothPlaybackPositionUpdater","clearMarkers","updateMarkers","setupMarkers","hasMarkersInUiConfig","markers","hasMarkersInPlayerConfig","markers_1","marker","time","markerType","comment","avatar","number","seekBarContainer","seekBar","seekBarBufferLevel","seekBarBufferPosition","seekBarPlaybackPosition","seekBarPlaybackPositionMarker","seekBarSeekPosition","seekBarBackdrop","seekBarChapterMarkersContainer","seekBarMarkersContainer","seeking","mouseTouchMoveHandler","preventDefault","stopPropagation","targetPercentage","getOffset","onSeekPreviewEvent","mouseTouchUpHandler","document","snappedChapter","getMarkerAtPosition","onSeekedEvent","isTouchEvent","TouchEvent","onSeekEvent","className","markerDom","data-marker-time","String","data-marker-title","snappedMarker","getHorizontalOffset","eventPageX","elementOffsetPx","offset","left","widthPx","offsetPx","sanitizeOffset","getVerticalOffset","eventPageY","top","height","changedTouches","pageY","touches","pageX","MouseEvent","warn","percent","setPosition","px","style","transform","-ms-transform","scale","CLASS_SEEKING","hasClass","SeekBarLabel","timeLabel","titleLabel","commentLabel","numberLabel","avatarLabel","setTitleText","setSmashcutData","setThumbnail","setBackground","getThumb","seconds","thumbnailElement","display","w","h","background-position","x","y","onOff","metadataElement","background","listselector_1","selectElement","updateDomItems","val","selectedValue","optionElement","attr","videoqualityselectbox_1","audioqualityselectbox_1","SettingsPanel","settingsPanelEvents","onSettingsStateChanged","settingsStateChangedHandler","onSettingsStateChangedEvent","lastShownItem","getItems","SettingsPanelItem","CLASS_LAST","onActiveChanged","hasActiveSettings","isActive","selectBox","settingsPanelItemEvents","setting","handleConfigItemChanged","minItemsToDisplay","VideoQualitySelectBox","onActiveChangedEvent","SettingsToggleButton","settingsPanel","autoHideWhenNoActiveSettings","settingsPanelItemsChangedHandler","controlbar_1","SubtitleOverlay","subtitleManager","ActiveSubtitleManager","ON_CUE_ENTER","labelToAdd","cueEnter","ON_CUE_EXIT","labelToRemove","cueExit","hasCues","subtitleClearHandler","ON_SUBTITLE_CHANGED","CLASS_CONTROLBAR_VISIBLE","SubtitleLabel","activeSubtitleCueMap","calculateId","activeSubtitleCue","cueCount","SubtitleSelectBox","updateSubtitles","getAvailableSubtitles","subtitle","setSubtitle","ON_SUBTITLE_ADDED","targetSubtitle","ON_SUBTITLE_REMOVED","subtitleId","metadatalabel_1","TitleBar","keepHiddenWithoutMetadata","shouldBeShown","hasMetadataText","checkMetadataTextAndUpdateVisibility","toggleButtonEvents","onToggle","onToggleOn","onToggleOff","isOff","onState","CLASS_OFF","CLASS_ON","onToggleEvent","onToggleOnEvent","isOn","onToggleOffEvent","canvasWidth","canvasHeight","interferenceHeight","lastFrameUpdate","frameInterval","useAnimationFrame","requestAnimationFrame","canvas","canvasElement","getElements","canvasContext","getContext","noiseAnimationWindowPos","renderFrame","cancelAnimationFrame","frameUpdateHandlerId","clearTimeout","getTime","scheduleNextRender","currentPixelOffset","noiseImage","createImageData","random","putImageData","bind","configureUIShowHide","configurePlayerStates","container","isFirstTouch","uiHideTimeout","previewHideEventArgs","stateClassNames","state","PlayerState","isNaN","enumName","STATE_PREFIX","removeStates","IDLE","PREPARED","PLAYING","PAUSED","FINISHED","getState","FULLSCREEN","BUFFERING","REMOTE_CONTROL","CONTROLS_HIDDEN","CONTROLS_SHOWN","updateLayoutSizeClasses","round","substring","getFigure","createElement","flex","updateVideoQualities","videoQualities","getAvailableVideoQualities","videoQualities_1","videoQuality","setVideoQuality","ON_VIDEO_DOWNLOAD_QUALITY_CHANGE","getDownloadedVideoData","volumeslider_1","volumetogglebutton_1","VolumeControlButton","volumeToggleButton","VolumeToggleButton","volumeSlider","VolumeSlider","getVolumeToggleButton","getVolumeSlider","volumeSliderHideTimeout","volumeSliderHovered","seekbar_1","hideIfVolumeControlProhibited","detectVolumeControlAvailability","volumeChangeHandler","isMuted","getVolume","ON_VOLUME_CHANGED","ON_MUTED","ON_UNMUTED","setVolume","volume","muted","playing","mute","muteStateHandler","volumeLevelHandler","unmute","VRToggleButton","isVRConfigured","vr","contentType","isVRStereoAvailable","getVRStatus","vrStateHandler","isStereo","vrButtonVisibilityHandler","ON_VR_MODE_CHANGED","ON_VR_STEREO_CHANGED","ON_VR_ERROR","setVRStereo","Watermark","something","attributes","Array","HTMLElement","elements","Document","tagName","attributeName","attributeValue","setAttribute","selector","findChildElements","forEach","handler","findChildElementsOfElement","childElements","querySelectorAll","slice","allChildElements","arguments","setHtml","getHtml","innerHTML","HTMLSelectElement","HTMLInputElement","attribute","setAttr","getAttr","getAttribute","dataAttribute","setData","getData","childElement","_","appendChild","parent","parentNode","removeChild","elementRect","getBoundingClientRect","htmlRect","body","parentElement","offsetWidth","offsetHeight","eventName","eventHandler","split","addEventListener","removeEventListener","classList","add","RegExp","contains","test","propertyNameOrCollection","propertyName","setCss","getCss","propertyValueCollection","setCssCollection","getComputedStyle","ruleValueCollection","listeners","listener","EventListenerWrapper","subscribeOnce","rateMs","RateLimitedEventListenerWrapper","subscribedListener","unsubscribeAll","listenersToRemove","fire","isOnce","_b","listenersToRemove_1","listenerToRemove","once","eventListener","lastFireTime","rateLimitingEventListener","fireSuper","guid","uimanager_1","fullscreentogglebutton_1","playbacktimelabel_1","settingspanel_1","settingstogglebutton_1","vrtogglebutton_1","watermark_1","audiotrackselectbox_1","caststatusoverlay_1","casttogglebutton_1","errormessageoverlay_1","recommendationoverlay_1","seekbarlabel_1","subtitleoverlay_1","subtitleselectbox_1","titlebar_1","volumecontrolbutton_1","adskipbutton_1","admessagelabel_1","adclickoverlay_1","playbackspeedselectbox_1","bufferingoverlay_1","castuicontainer_1","playbacktoggleoverlay_1","airplaytogglebutton_1","pictureinpicturetogglebutton_1","TypeError","bitmovin","playerui","UIManager","UIInstanceManager","BrowserUtils","delay","callback","repeat","timeoutHandle","lastScheduleTime","delayAdjust","internalCallback","delta","embedvideotogglebutton_1","embedvideopanel_1","playerUiOrUiVariants","playerUi","uiVariants","ui","managerPlayerWrapper","PlayerWrapper","playerElement","uiInstanceManagers","uiVariantsWithoutCondition","uiVariant","condition","InternalUIInstanceManager","adStartedEvent","isMobile","resolveUiVariant","ad","adWithUI","clientType","context","isAdWithUI","documentWidth","clientWidth","nextUi","uiVariantChanged","indexOf","currentUi","getUI","isConfigured","addUi","getWrappedPlayer","fireEventInUI","getPlayer","dom","configureControls","releaseUi","releaseControls","clearEventHandlers","uiInstanceManager","Factory","buildDefaultUI","buildModernUI","buildDefaultSmallScreenUI","buildModernSmallScreenUI","buildDefaultCastReceiverUI","buildModernCastReceiverUI","smashcutUi","controlBarTop","controlBarMiddle","controlBarBottom","controlBar","modernAdsUI","modernSmallScreenUI","modernSmallScreenAdsUI","modernCastReceiverUI","legacyUI","legacyAdsUI","legacyCastReceiverUI","legacyTestUI","buildLegacyUI","buildLegacyCastReceiverUI","buildLegacyTestUI","events","playerWrapper","event_1","configureControlsTree","configured","configuredComponents","configuredComponents_1","error","constructor","name","releaseControlsTree","released","isReleased","childComponent","eventHandlers","methods","member","wrapper","methods_1","apply","eventType","playerEventData","timestamp","uiSourced","array","splice","totalSeconds","format","isNegative","hours","floor","minutes","leftPadWithZeros","num","substr","adMessagePlaceholderRegex","formatString","ceil","formatNumber","formatStringValidationRegex","leadingZeroes","leadingZeroesMatches","match","numDecimalPlaces","decimalPlacesMatches","timeString","toFixed","isSourceLoaded","isTimeShiftAvailable","hasEnded","timeShiftAvailabilityChangedEvent","timeShiftDetector","timeShiftAvailableNow","liveChangedEvent","liveDetector","liveNow","isAndroid","isChrome","visit","recursiveTreeWalker","navigator","userAgent"],"mappings":"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","file":"bitmovinplayer-ui.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import {ClickOverlay} from './clickoverlay';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A simple click capture overlay for clickThroughUrls of ads.\n */\nexport class AdClickOverlay extends ClickOverlay {\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let clickThroughUrl = <string>null;\n    let clickThroughEnabled = !player.getConfig().advertising\n      || !player.getConfig().advertising.hasOwnProperty('clickThroughEnabled')\n      || player.getConfig().advertising.clickThroughEnabled;\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, (event: bitmovin.player.AdStartedEvent) => {\n      clickThroughUrl = event.clickThroughUrl;\n\n      if (clickThroughEnabled) {\n        this.setUrl(clickThroughUrl);\n      } else {\n        // If click-through is disabled, we set the url to null to avoid it open\n        this.setUrl(null);\n      }\n    });\n\n    // Clear click-through URL when ad has finished\n    let adFinishedHandler = () => {\n      this.setUrl(null);\n    };\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adFinishedHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adFinishedHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adFinishedHandler);\n\n    this.onClick.subscribe(() => {\n      // Pause the ad when overlay is clicked\n      player.pause('ui-content-click');\n\n      // Notify the player of the clicked ad\n      player.fireEvent(player.EVENT.ON_AD_CLICKED, {\n        clickThroughUrl: clickThroughUrl\n      });\n    });\n  }\n}","import {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {StringUtils} from '../utils';\n\n/**\n * A label that displays a message about a running ad, optionally with a countdown.\n */\nexport class AdMessageLabel extends Label<LabelConfig> {\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-label-ad-message',\n      text: 'This ad will end in {remainingTime} seconds.'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let text = this.getConfig().text;\n\n    let updateMessageHandler = () => {\n      this.setText(StringUtils.replaceAdMessagePlaceholders(text, null, player));\n    };\n\n    let adStartHandler = (event: bitmovin.player.AdStartedEvent) => {\n      text = event.adMessage || text;\n      updateMessageHandler();\n\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, updateMessageHandler);\n      player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateMessageHandler);\n    };\n\n    let adEndHandler = () => {\n      player.removeEventHandler(player.EVENT.ON_TIME_CHANGED, updateMessageHandler);\n      player.removeEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateMessageHandler);\n    };\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, adStartHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adEndHandler);\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {UIInstanceManager} from '../uimanager';\nimport SkipMessage = bitmovin.player.SkipMessage;\nimport {StringUtils} from '../utils';\n\n/**\n * Configuration interface for the {@link AdSkipButton}.\n */\nexport interface AdSkipButtonConfig extends ButtonConfig {\n  skipMessage?: SkipMessage;\n}\n\n/**\n * A button that is displayed during ads and can be used to skip the ad.\n */\nexport class AdSkipButton extends Button<AdSkipButtonConfig> {\n\n  constructor(config: AdSkipButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <AdSkipButtonConfig>{\n      cssClass: 'ui-button-ad-skip',\n      skipMessage: {\n        countdown: 'Skip ad in {remainingTime}',\n        skip: 'Skip ad'\n      }\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <AdSkipButtonConfig>this.getConfig(); // TODO get rid of generic cast\n    let skipMessage = config.skipMessage;\n    let adEvent = <bitmovin.player.AdStartedEvent>null;\n\n    let updateSkipMessageHandler = () => {\n      // Display this button only if ad is skippable\n      if (adEvent.skipOffset) {\n        this.show();\n      } else {\n        this.hide();\n      }\n\n      // Update the skip message on the button\n      if (player.getCurrentTime() < adEvent.skipOffset) {\n        this.setText(\n          StringUtils.replaceAdMessagePlaceholders(config.skipMessage.countdown, adEvent.skipOffset, player));\n      } else {\n        this.setText(config.skipMessage.skip);\n      }\n    };\n\n    let adStartHandler = (event: bitmovin.player.AdStartedEvent) => {\n      adEvent = event;\n      skipMessage = adEvent.skipMessage || skipMessage;\n      updateSkipMessageHandler();\n\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, updateSkipMessageHandler);\n      player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateSkipMessageHandler);\n    };\n\n    let adEndHandler = () => {\n      player.removeEventHandler(player.EVENT.ON_TIME_CHANGED, updateSkipMessageHandler);\n      player.removeEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateSkipMessageHandler);\n    };\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, adStartHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adEndHandler);\n\n    this.onClick.subscribe(() => {\n      // Try to skip the ad (this only works if it is skippable so we don't need to take extra care of that here)\n      player.skipAd();\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles Apple AirPlay.\n */\nexport class AirPlayToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-airplaytogglebutton',\n      text: 'Apple AirPlay'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      if (player.isAirplayAvailable()) {\n        player.showAirplayTargetPicker();\n      } else {\n        if (console) {\n          console.log('AirPlay unavailable');\n        }\n      }\n    });\n\n    let airPlayAvailableHandler = () => {\n      if (player.isAirplayAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_AIRPLAY_AVAILABLE, airPlayAvailableHandler);\n\n    // Startup init\n    airPlayAvailableHandler(); // Hide button if AirPlay is not available\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between 'auto' and the available audio qualities.\n */\nexport class AudioQualitySelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let updateAudioQualities = () => {\n      let audioQualities = player.getAvailableAudioQualities();\n\n      this.clearItems();\n\n      // Add entry for automatic quality switching (default setting)\n      this.addItem('Auto', 'Auto');\n\n      // Add audio qualities\n      for (let audioQuality of audioQualities) {\n        this.addItem(audioQuality.id, audioQuality.label);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: AudioQualitySelectBox, value: string) => {\n      player.setAudioQuality(value);\n    });\n\n    // Update qualities when audio track has changed\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, updateAudioQualities);\n    // Update qualities when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateAudioQualities);\n    // Update qualities when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateAudioQualities);\n    // Update quality selection when quality is changed (from outside)\n    player.addEventHandler(player.EVENT.ON_AUDIO_DOWNLOAD_QUALITY_CHANGE, () => {\n      let data = player.getDownloadedAudioData();\n      this.selectItem(data.isAuto ? 'Auto' : data.id);\n    });\n\n    // Populate qualities at startup\n    updateAudioQualities();\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between available audio tracks (e.g. different languages).\n */\nexport class AudioTrackSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    // TODO Move to config?\n    let getAudioTrackLabel = (id: string) => {\n      switch (id) {\n        case 'en_stereo':\n          return 'English - Stereo';\n        case 'no-voices_stereo':\n          return 'No Voices - Stereo';\n        case 'en_surround':\n          return 'English - Surround';\n        default:\n          return id\n      }\n    }\n\n    let updateAudioTracks = () => {\n      let audioTracks = player.getAvailableAudio();\n\n      this.clearItems();\n\n      // Add audio tracks\n      for (let audioTrack of audioTracks) {\n        this.addItem(audioTrack.id, getAudioTrackLabel(audioTrack.label));\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: AudioTrackSelectBox, value: string) => {\n      player.setAudio(value);\n    });\n\n    let audioTrackHandler = () => {\n      let currentAudioTrack = player.getAudio();\n\n      // HLS streams don't always provide this, so we have to check\n      if (currentAudioTrack) {\n        this.selectItem(currentAudioTrack.id);\n      }\n    };\n\n    // Update selection when selected track has changed\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, audioTrackHandler);\n    // Update tracks when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateAudioTracks);\n    // Update tracks when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateAudioTracks);\n\n    // Populate tracks at startup\n    updateAudioTracks();\n\n    // When `playback.audioLanguage` is set, the `ON_AUDIO_CHANGED` event for that change is triggered before the\n    // UI is created. Therefore we need to set the audio track on configure.\n    audioTrackHandler();\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {Component, ComponentConfig} from './component';\nimport {Timeout} from '../timeout';\n\n/**\n * Configuration interface for the {@link BufferingOverlay} component.\n */\nexport interface BufferingOverlayConfig extends ContainerConfig {\n  /**\n   * Delay in milliseconds after which the buffering overlay will be displayed. Useful to bypass short stalls without\n   * displaying the overlay. Set to 0 to display the overlay instantly.\n   * Default: 1000ms (1 second)\n   */\n  showDelayMs?: number;\n}\n\n/**\n * Overlays the player and displays a buffering indicator.\n */\nexport class BufferingOverlay extends Container<BufferingOverlayConfig> {\n\n  private indicators: Component<ComponentConfig>[];\n\n  constructor(config: BufferingOverlayConfig = {}) {\n    super(config);\n\n    this.indicators = [\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n    ];\n\n    this.config = this.mergeConfig(config, <BufferingOverlayConfig>{\n      cssClass: 'ui-buffering-overlay',\n      hidden: true,\n      components: this.indicators,\n      showDelayMs: 1000,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <BufferingOverlayConfig>this.getConfig();\n\n    let overlayShowTimeout = new Timeout(config.showDelayMs, () => {\n      this.show();\n    });\n\n    let showOverlay = () => {\n      overlayShowTimeout.start();\n    };\n\n    let hideOverlay = () => {\n      overlayShowTimeout.clear();\n      this.hide();\n    };\n\n    player.addEventHandler(player.EVENT.ON_STALL_STARTED, showOverlay);\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, hideOverlay);\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, hideOverlay);\n\n    // Show overlay if player is already stalled at init\n    if (player.isStalled()) {\n      this.show();\n    }\n  }\n}\n","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {EventDispatcher, NoArgs, Event} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link Button} component.\n */\nexport interface ButtonConfig extends ComponentConfig {\n  /**\n   * The text on the button.\n   */\n  text?: string;\n}\n\n/**\n * A simple clickable button.\n */\nexport class Button<Config extends ButtonConfig> extends Component<ButtonConfig> {\n\n  private buttonEvents = {\n    onClick: new EventDispatcher<Button<Config>, NoArgs>()\n  };\n\n  constructor(config: ButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-button'\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    // Create the button element with the text label\n    let buttonElement = new DOM('button', {\n      'type': 'button',\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    }).append(new DOM('span', {\n      'class': this.prefixCss('label')\n    }).html(this.config.text));\n\n    // Listen for the click event on the button element and trigger the corresponding event on the button component\n    buttonElement.on('click', () => {\n      this.onClickEvent();\n    });\n\n    return buttonElement;\n  }\n\n  /**\n   * Sets text on the label of the button.\n   * @param text the text to put into the label of the button\n   */\n  setText(text: string): void {\n    this.getDomElement().find('.' + this.prefixCss('label')).html(text);\n  }\n\n  protected onClickEvent() {\n    this.buttonEvents.onClick.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the button is clicked.\n   * @returns {Event<Button<Config>, NoArgs>}\n   */\n  get onClick(): Event<Button<Config>, NoArgs> {\n    return this.buttonEvents.onClick.getEvent();\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport CastWaitingForDeviceEvent = bitmovin.player.CastWaitingForDeviceEvent;\nimport CastStartedEvent = bitmovin.player.CastStartedEvent;\n\n/**\n * Overlays the player and displays the status of a Cast session.\n */\nexport class CastStatusOverlay extends Container<ContainerConfig> {\n\n  private statusLabel: Label<LabelConfig>;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.statusLabel = new Label<LabelConfig>({ cssClass: 'ui-cast-status-label' });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-cast-status-overlay',\n      components: [this.statusLabel],\n      hidden: true\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    player.addEventHandler(player.EVENT.ON_CAST_WAITING_FOR_DEVICE,\n      (event: CastWaitingForDeviceEvent) => {\n        this.show();\n        // Get device name and update status text while connecting\n        let castDeviceName = event.castPayload.deviceName;\n        this.statusLabel.setText(`Connecting to <strong>${castDeviceName}</strong>...`);\n      });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, (event: CastStartedEvent) => {\n      // Session is started or resumed\n      // For cases when a session is resumed, we do not receive the previous events and therefore show the status panel\n      // here too\n      this.show();\n      let castDeviceName = event.deviceName;\n      this.statusLabel.setText(`Playing on <strong>${castDeviceName}</strong>`);\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, (event) => {\n      // Cast session gone, hide the status panel\n      this.hide();\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles casting to a Cast receiver.\n */\nexport class CastToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-casttogglebutton',\n      text: 'Google Cast'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      if (player.isCastAvailable()) {\n        if (player.isCasting()) {\n          player.castStop();\n        } else {\n          player.castVideo();\n        }\n      } else {\n        if (console) {\n          console.log('Cast unavailable');\n        }\n      }\n    });\n\n    let castAvailableHander = () => {\n      if (player.isCastAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_CAST_AVAILABLE, castAvailableHander);\n\n    // Toggle button 'on' state\n    player.addEventHandler(player.EVENT.ON_CAST_WAITING_FOR_DEVICE, () => {\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      // When a session is resumed, there is no ON_CAST_START event, so we also need to toggle here for such cases\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, () => {\n      this.off();\n    });\n\n    // Startup init\n    castAvailableHander(); // Hide button if Cast not available\n    if (player.isCasting()) {\n      this.on();\n    }\n  }\n}","import {UIContainer, UIContainerConfig} from './uicontainer';\nimport {UIInstanceManager} from '../uimanager';\nimport {Timeout} from '../timeout';\n\n/**\n * The base container for Cast receivers that contains all of the UI and takes care that the UI is shown on\n * certain playback events.\n */\nexport class CastUIContainer extends UIContainer {\n\n  private castUiHideTimeout: Timeout;\n\n  constructor(config: UIContainerConfig) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <UIContainerConfig>this.getConfig();\n\n    /*\n     * Show UI on Cast devices at certain playback events\n     *\n     * Since a Cast receiver does not have a direct HCI, we show the UI on certain playback events to give the user\n     * a chance to see on the screen what's going on, e.g. on play/pause or a seek the UI is shown and the user can\n     * see the current time and position on the seek bar.\n     * The UI is shown permanently while playback is paused, otherwise hides automatically after the configured\n     * hide delay time.\n     */\n\n    let isUiShown = false;\n\n    let hideUi = () => {\n      uimanager.onControlsHide.dispatch(this);\n      isUiShown = false;\n    };\n\n    this.castUiHideTimeout = new Timeout(config.hideDelay, hideUi);\n\n    let showUi = () => {\n      if (!isUiShown) {\n        uimanager.onControlsShow.dispatch(this);\n        isUiShown = true;\n      }\n    };\n\n    let showUiPermanently = () => {\n      showUi();\n      this.castUiHideTimeout.clear();\n    };\n\n    let showUiWithTimeout = () => {\n      showUi();\n      this.castUiHideTimeout.start();\n    };\n\n    let showUiAfterSeek = () => {\n      if (player.isPlaying()) {\n        showUiWithTimeout();\n      } else {\n        showUiPermanently();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_PLAY, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_PAUSED, showUiPermanently);\n    player.addEventHandler(player.EVENT.ON_SEEK, showUiPermanently);\n    player.addEventHandler(player.EVENT.ON_SEEKED, showUiAfterSeek);\n  }\n\n  release(): void {\n    super.release();\n    this.castUiHideTimeout.clear();\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\nimport {Container, ContainerConfig} from './container';\nimport {Label, LabelConfig} from './label';\nimport {Event, EventDispatcher, NoArgs} from '../eventdispatcher';\nimport Config = bitmovin.player.Config;\n\n/**\n * Configuration interface for a {@link Checkbox}.\n */\nexport interface CheckboxConfig extends ContainerConfig {\n  /**\n   * The label for the checkbox.\n   */\n  text: string;\n}\n\nexport class Checkbox extends Container<CheckboxConfig> {\n\n  private label: Label<LabelConfig>;\n  private button: ToggleButton<ToggleButtonConfig>;\n\n  private buttonEvents = {\n    onClick: new EventDispatcher<Checkbox, NoArgs>()\n  };\n\n  constructor(config: CheckboxConfig = {text: ''}) {\n    super(config);\n\n    this.label = new Label({cssClasses: ['checkbox-label'], text: config.text});\n    this.button = new ToggleButton({cssClasses: ['checkbox-button']});\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-checkbox',\n      components: [this.button, this.label]\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    // Listen for the click event on the element and\n    // trigger the corresponding event on the button component\n    this.getDomElement().on('click', () => {\n      this.onClickEvent()\n      this.button.toggle()\n    });\n  }\n\n  /**\n   * Sets arbitrary text on the label.\n   * @param text the text to show on the label\n   */\n  setText(text: string) {\n    this.label.setText(text);\n  }\n\n  protected onClickEvent() {\n    this.buttonEvents.onClick.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the button is clicked.\n   * @returns {Event<Checkbox, NoArgs>}\n   */\n  get onClick(): Event<Checkbox, NoArgs> {\n    return this.buttonEvents.onClick.getEvent();\n  }\n}","import {Button, ButtonConfig} from './button';\n\n/**\n * Configuration interface for a {@link ClickOverlay}.\n */\nexport interface ClickOverlayConfig extends ButtonConfig {\n  /**\n   * The url to open when the overlay is clicked. Set to null to disable the click handler.\n   */\n  url?: string;\n}\n\n/**\n * A click overlay that opens an url in a new tab if clicked.\n */\nexport class ClickOverlay extends Button<ClickOverlayConfig> {\n\n  constructor(config: ClickOverlayConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-clickoverlay'\n    }, <ClickOverlayConfig>this.config);\n  }\n\n  initialize(): void {\n    super.initialize();\n\n    this.setUrl((<ClickOverlayConfig>this.config).url);\n    let element = this.getDomElement();\n    element.on('click', () => {\n      if (element.data('url')) {\n        window.open(element.data('url'), '_blank');\n      }\n    });\n  }\n\n  /**\n   * Gets the URL that should be followed when the watermark is clicked.\n   * @returns {string} the watermark URL\n   */\n  getUrl(): string {\n    return this.getDomElement().data('url');\n  }\n\n  setUrl(url: string): void {\n    if (url === undefined || url == null) {\n      url = '';\n    }\n    this.getDomElement().data('url', url);\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {UIInstanceManager} from '../uimanager';\nimport {Component, ComponentConfig} from './component';\n\n/**\n * Configuration interface for the {@link CloseButton}.\n */\nexport interface CloseButtonConfig extends ButtonConfig {\n  /**\n   * The component that should be closed when the button is clicked.\n   */\n  target: Component<ComponentConfig>;\n}\n\n/**\n * A button that closes (hides) a configured component.\n */\nexport class CloseButton extends Button<CloseButtonConfig> {\n\n  constructor(config: CloseButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-closebutton',\n      text: 'Close'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <CloseButtonConfig>this.getConfig();\n\n    this.onClick.subscribe(() => {\n      config.target.hide();\n    });\n  }\n}","import {Guid} from '../guid';\nimport {DOM} from '../dom';\nimport {EventDispatcher, NoArgs, Event} from '../eventdispatcher';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Base configuration interface for a component.\n * Should be extended by components that want to add additional configuration options.\n */\nexport interface ComponentConfig {\n  /**\n   * The HTML tag name of the component.\n   * Default: 'div'\n   */\n  tag?: string;\n  /**\n   * The HTML ID of the component.\n   * Default: automatically generated with pattern 'ui-id-{guid}'.\n   */\n  id?: string;\n\n  /**\n   * A prefix to prepend all CSS classes with.\n   */\n  cssPrefix?: string;\n\n  /**\n   * The CSS classes of the component. This is usually the class from where the component takes its styling.\n   */\n  cssClass?: string; // 'class' is a reserved keyword, so we need to make the name more complicated\n\n  /**\n   * Additional CSS classes of the component.\n   */\n  cssClasses?: string[];\n\n  /**\n   * Specifies if the component should be hidden at startup.\n   * Default: false\n   */\n  hidden?: boolean;\n}\n\nexport interface ComponentHoverChangedEventArgs extends NoArgs {\n  /**\n   * True is the component is hovered, else false.\n   */\n  hovered: boolean;\n}\n\n/**\n * The base class of the UI framework.\n * Each component must extend this class and optionally the config interface.\n */\nexport class Component<Config extends ComponentConfig> {\n\n  /**\n   * The classname that is attached to the element when it is in the hidden state.\n   * @type {string}\n   */\n  private static readonly CLASS_HIDDEN = 'hidden';\n\n  /**\n   * Configuration object of this component.\n   */\n  protected config: Config;\n\n  /**\n   * The component's DOM element.\n   */\n  private element: DOM;\n\n  /**\n   * Flag that keeps track of the hidden state.\n   */\n  private hidden: boolean;\n\n  /**\n   * Flag that keeps track of the hover state.\n   */\n  private hovered: boolean;\n\n  /**\n   * The list of events that this component offers. These events should always be private and only directly\n   * accessed from within the implementing component.\n   *\n   * Because TypeScript does not support private properties with the same name on different class hierarchy levels\n   * (i.e. superclass and subclass cannot contain a private property with the same name), the default naming\n   * convention for the event list of a component that should be followed by subclasses is the concatenation of the\n   * camel-cased class name + 'Events' (e.g. SubClass extends Component => subClassEvents).\n   * See {@link #componentEvents} for an example.\n   *\n   * Event properties should be named in camel case with an 'on' prefix and in the present tense. Async events may\n   * have a start event (when the operation starts) in the present tense, and must have an end event (when the\n   * operation ends) in the past tense (or present tense in special cases (e.g. onStart/onStarted or onPlay/onPlaying).\n   * See {@link #componentEvents#onShow} for an example.\n   *\n   * Each event should be accompanied with a protected method named by the convention eventName + 'Event'\n   * (e.g. onStartEvent), that actually triggers the event by calling {@link EventDispatcher#dispatch dispatch} and\n   * passing a reference to the component as first parameter. Components should always trigger their events with these\n   * methods. Implementing this pattern gives subclasses means to directly listen to the events by overriding the\n   * method (and saving the overhead of passing a handler to the event dispatcher) and more importantly to trigger\n   * these events without having access to the private event list.\n   * See {@link #onShow} for an example.\n   *\n   * To provide external code the possibility to listen to this component's events (subscribe, unsubscribe, etc.),\n   * each event should also be accompanied by a public getter function with the same name as the event's property,\n   * that returns the {@link Event} obtained from the event dispatcher by calling {@link EventDispatcher#getEvent}.\n   * See {@link #onShow} for an example.\n   *\n   * Full example for an event representing an example action in a example component:\n   *\n   * <code>\n   * // Define an example component class with an example event\n   * class ExampleComponent extends Component<ComponentConfig> {\n     *\n     *     private exampleComponentEvents = {\n     *         onExampleAction: new EventDispatcher<ExampleComponent, NoArgs>()\n     *     }\n     *\n     *     // constructor and other stuff...\n     *\n     *     protected onExampleActionEvent() {\n     *        this.exampleComponentEvents.onExampleAction.dispatch(this);\n     *    }\n     *\n     *    get onExampleAction(): Event<ExampleComponent, NoArgs> {\n     *        return this.exampleComponentEvents.onExampleAction.getEvent();\n     *    }\n     * }\n   *\n   * // Create an instance of the component somewhere\n   * var exampleComponentInstance = new ExampleComponent();\n   *\n   * // Subscribe to the example event on the component\n   * exampleComponentInstance.onExampleAction.subscribe(function (sender: ExampleComponent) {\n     *     console.log('onExampleAction of ' + sender + ' has fired!');\n     * });\n   * </code>\n   */\n  private componentEvents = {\n    onShow: new EventDispatcher<Component<Config>, NoArgs>(),\n    onHide: new EventDispatcher<Component<Config>, NoArgs>(),\n    onHoverChanged: new EventDispatcher<Component<Config>, ComponentHoverChangedEventArgs>(),\n  };\n\n  /**\n   * Constructs a component with an optionally supplied config. All subclasses must call the constructor of their\n   * superclass and then merge their configuration into the component's configuration.\n   * @param config the configuration for the component\n   */\n  constructor(config: ComponentConfig = {}) {\n    // Create the configuration for this component\n    this.config = <Config>this.mergeConfig(config, {\n      tag: 'div',\n      id: 'bmpui-id-' + Guid.next(),\n      cssPrefix: 'bmpui',\n      cssClass: 'ui-component',\n      cssClasses: [],\n      hidden: false\n    }, {});\n  }\n\n  /**\n   * Initializes the component, e.g. by applying config settings.\n   * This method must not be called from outside the UI framework.\n   *\n   * This method is automatically called by the {@link UIInstanceManager}. If the component is an inner component of\n   * some component, and thus encapsulated abd managed internally and never directly exposed to the UIManager,\n   * this method must be called from the managing component's {@link #initialize} method.\n   */\n  initialize(): void {\n    this.hidden = this.config.hidden;\n\n    // Hide the component at initialization if it is configured to be hidden\n    if (this.isHidden()) {\n      this.hidden = false; // Set flag to false for the following hide() call to work (hide() checks the flag)\n      this.hide();\n    }\n  }\n\n  /**\n   * Configures the component for the supplied Player and UIInstanceManager. This is the place where all the magic\n   * happens, where components typically subscribe and react to events (on their DOM element, the Player, or the\n   * UIInstanceManager), and basically everything that makes them interactive.\n   * This method is called only once, when the UIManager initializes the UI.\n   *\n   * Subclasses usually overwrite this method to add their own functionality.\n   *\n   * @param player the player which this component controls\n   * @param uimanager the UIInstanceManager that manages this component\n   */\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    this.onShow.subscribe(() => {\n      uimanager.onComponentShow.dispatch(this);\n    });\n    this.onHide.subscribe(() => {\n      uimanager.onComponentHide.dispatch(this);\n    });\n\n    // Track the hovered state of the element\n    this.getDomElement().on('mouseenter', () => {\n      this.onHoverChangedEvent(true);\n    });\n    this.getDomElement().on('mouseleave', () => {\n      this.onHoverChangedEvent(false);\n    });\n  }\n\n  /**\n   * Releases all resources and dependencies that the component holds. Player, DOM, and UIManager events are\n   * automatically removed during release and do not explicitly need to be removed here.\n   * This method is called by the UIManager when it releases the UI.\n   *\n   * Subclasses that need to release resources should override this method and call super.release().\n   */\n  release(): void {\n    // Nothing to do here, override where necessary\n  }\n\n  /**\n   * Generate the DOM element for this component.\n   *\n   * Subclasses usually overwrite this method to extend or replace the DOM element with their own design.\n   */\n  protected toDomElement(): DOM {\n    let element = new DOM(this.config.tag, {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    return element;\n  }\n\n  /**\n   * Returns the DOM element of this component. Creates the DOM element if it does not yet exist.\n   *\n   * Should not be overwritten by subclasses.\n   *\n   * @returns {DOM}\n   */\n  getDomElement(): DOM {\n    if (!this.element) {\n      this.element = this.toDomElement();\n    }\n\n    return this.element;\n  }\n\n  /**\n   * Merges a configuration with a default configuration and a base configuration from the superclass.\n   *\n   * @param config the configuration settings for the components, as usually passed to the constructor\n   * @param defaults a default configuration for settings that are not passed with the configuration\n   * @param base configuration inherited from a superclass\n   * @returns {Config}\n   */\n  protected mergeConfig<Config>(config: Config, defaults: Config, base: Config): Config {\n    // Extend default config with supplied config\n    let merged = Object.assign({}, base, defaults, config);\n\n    // Return the extended config\n    return merged;\n  }\n\n  /**\n   * Helper method that returns a string of all CSS classes of the component.\n   *\n   * @returns {string}\n   */\n  protected getCssClasses(): string {\n    // Merge all CSS classes into single array\n    let flattenedArray = [this.config.cssClass].concat(this.config.cssClasses);\n    // Prefix classes\n    flattenedArray = flattenedArray.map((css) => {\n      return this.prefixCss(css);\n    });\n    // Join array values into a string\n    let flattenedString = flattenedArray.join(' ');\n    // Return trimmed string to prevent whitespace at the end from the join operation\n    return flattenedString.trim();\n  }\n\n  protected prefixCss(cssClassOrId: string): string {\n    return this.config.cssPrefix + '-' + cssClassOrId;\n  }\n\n  /**\n   * Returns the configuration object of the component.\n   * @returns {Config}\n   */\n  public getConfig(): Config {\n    return this.config;\n  }\n\n  /**\n   * Hides the component if shown.\n   * This method basically transfers the component into the hidden state. Actual hiding is done via CSS.\n   */\n  hide() {\n    if (!this.hidden) {\n      this.hidden = true;\n      this.getDomElement().addClass(this.prefixCss(Component.CLASS_HIDDEN));\n      this.onHideEvent();\n    }\n  }\n\n  /**\n   * Shows the component if hidden.\n   */\n  show() {\n    if (this.hidden) {\n      this.getDomElement().removeClass(this.prefixCss(Component.CLASS_HIDDEN));\n      this.hidden = false;\n      this.onShowEvent();\n    }\n  }\n\n  /**\n   * Determines if the component is hidden.\n   * @returns {boolean} true if the component is hidden, else false\n   */\n  isHidden(): boolean {\n    return this.hidden;\n  }\n\n  /**\n   * Determines if the component is shown.\n   * @returns {boolean} true if the component is visible, else false\n   */\n  isShown(): boolean {\n    return !this.isHidden();\n  }\n\n  /**\n   * Toggles the hidden state by hiding the component if it is shown, or showing it if hidden.\n   */\n  toggleHidden() {\n    if (this.isHidden()) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  }\n\n  /**\n   * Determines if the component is currently hovered.\n   * @returns {boolean} true if the component is hovered, else false\n   */\n  isHovered(): boolean {\n    return this.hovered;\n  }\n\n  /**\n   * Fires the onShow event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onShowEvent(): void {\n    this.componentEvents.onShow.dispatch(this);\n  }\n\n  /**\n   * Fires the onHide event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onHideEvent(): void {\n    this.componentEvents.onHide.dispatch(this);\n  }\n\n  /**\n   * Fires the onHoverChanged event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onHoverChangedEvent(hovered: boolean): void {\n    this.hovered = hovered;\n    this.componentEvents.onHoverChanged.dispatch(this, { hovered: hovered });\n  }\n\n  /**\n   * Gets the event that is fired when the component is showing.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   * @returns {Event<Component<Config>, NoArgs>}\n   */\n  get onShow(): Event<Component<Config>, NoArgs> {\n    return this.componentEvents.onShow.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the component is hiding.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   * @returns {Event<Component<Config>, NoArgs>}\n   */\n  get onHide(): Event<Component<Config>, NoArgs> {\n    return this.componentEvents.onHide.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the component's hover-state is changing.\n   * @returns {Event<Component<Config>, ComponentHoverChangedEventArgs>}\n   */\n  get onHoverChanged(): Event<Component<Config>, ComponentHoverChangedEventArgs> {\n    return this.componentEvents.onHoverChanged.getEvent();\n  }\n}","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {ArrayUtils} from '../utils';\n\n/**\n * Configuration interface for a {@link Container}.\n */\nexport interface ContainerConfig extends ComponentConfig {\n  /**\n   * Child components of the container.\n   */\n  components?: Component<ComponentConfig>[];\n}\n\n/**\n * A container component that can contain a collection of child components.\n * Components can be added at construction time through the {@link ContainerConfig#components} setting, or later\n * through the {@link Container#addComponent} method. The UIManager automatically takes care of all components, i.e. it\n * initializes and configures them automatically.\n *\n * In the DOM, the container consists of an outer <div> (that can be configured by the config) and an inner wrapper\n * <div> that contains the components. This double-<div>-structure is often required to achieve many advanced effects\n * in CSS and/or JS, e.g. animations and certain formatting with absolute positioning.\n *\n * DOM example:\n * <code>\n *     <div class='ui-container'>\n *         <div class='container-wrapper'>\n *             ... child components ...\n *         </div>\n *     </div>\n * </code>\n */\nexport class Container<Config extends ContainerConfig> extends Component<ContainerConfig> {\n\n  /**\n   * A reference to the inner element that contains the components of the container.\n   */\n  private innerContainerElement: DOM;\n\n  constructor(config: ContainerConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-container',\n      components: []\n    }, this.config);\n  }\n\n  /**\n   * Adds a child component to the container.\n   * @param component the component to add\n   */\n  addComponent(component: Component<ComponentConfig>) {\n    this.config.components.push(component);\n  }\n\n  /**\n   * Removes a child component from the container.\n   * @param component the component to remove\n   * @returns {boolean} true if the component has been removed, false if it is not contained in this container\n   */\n  removeComponent(component: Component<ComponentConfig>): boolean {\n    return ArrayUtils.remove(this.config.components, component) != null;\n  }\n\n  /**\n   * Gets an array of all child components in this container.\n   * @returns {Component<ComponentConfig>[]}\n   */\n  getComponents(): Component<ComponentConfig>[] {\n    return this.config.components;\n  }\n\n  /**\n   * Removes all child components from the container.\n   */\n  removeComponents(): void {\n    for (let component of this.getComponents()) {\n      this.removeComponent(component);\n    }\n  }\n\n  /**\n   * Updates the DOM of the container with the current components.\n   */\n  protected updateComponents(): void {\n    this.innerContainerElement.empty();\n\n    for (let component of this.config.components) {\n      this.innerContainerElement.append(component.getDomElement());\n    }\n  }\n\n  protected toDomElement(): DOM {\n    // Create the container element (the outer <div>)\n    let containerElement = new DOM(this.config.tag, {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    // Create the inner container element (the inner <div>) that will contain the components\n    let innerContainer = new DOM(this.config.tag, {\n      'class': this.prefixCss('container-wrapper')\n    });\n    this.innerContainerElement = innerContainer;\n\n    this.updateComponents();\n\n    containerElement.append(innerContainer);\n\n    return containerElement;\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {UIUtils} from '../utils';\nimport {Spacer} from './spacer';\n\n/**\n * Configuration interface for the {@link ControlBar}.\n */\nexport interface ControlBarConfig extends ContainerConfig {\n  // nothing yet\n}\n\n/**\n * A container for main player control components, e.g. play toggle button, seek bar, volume control, fullscreen toggle\n * button.\n */\nexport class ControlBar extends Container<ControlBarConfig> {\n\n  constructor(config: ControlBarConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-controlbar',\n      hidden: true,\n    }, <ControlBarConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    // Counts how many components are hovered and block hiding of the control bar\n    let hoverStackCount = 0;\n\n    // Track hover status of child components\n    UIUtils.traverseTree(this, (component) => {\n      // Do not track hover status of child containers or spacers, only of 'real' controls\n      if (component instanceof Container || component instanceof Spacer) {\n        return;\n      }\n\n      // Subscribe hover event and keep a count of the number of hovered children\n      component.onHoverChanged.subscribe((sender, args) => {\n        if (args.hovered) {\n          hoverStackCount++;\n        } else {\n          hoverStackCount--;\n        }\n      });\n    });\n\n    uimanager.onControlsShow.subscribe(() => {\n      this.show();\n    });\n    uimanager.onPreviewControlsHide.subscribe((sender, args) => {\n      // Cancel the hide event if hovered child components block hiding\n      args.cancel = (hoverStackCount > 0);\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      this.hide();\n    });\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {Timeout} from '../timeout';\nimport {Label, LabelConfig} from './label';\nimport {CloseButton} from './closebutton';\nimport {Checkbox} from './checkbox';\n\n/**\n * Configuration interface for a {@link EmbedVideoPanel}.\n */\nexport interface EmbedVideoPanelConfig extends ContainerConfig {\n  /**\n   * The delay in milliseconds after which the embedVideo panel will be hidden when there is no user interaction.\n   * Set to -1 to disable automatic hiding.\n   * Default: 3 seconds (3000)\n   */\n  hideDelay?: number;\n}\n\n/**\n * A panel containing a list of {@link EmbedVideoPanelItem items} that represent labelled embedVideo.\n */\nexport class EmbedVideoPanel extends Container<EmbedVideoPanelConfig> {\n\n  private closeButton: CloseButton;\n  private title: Label<LabelConfig>;\n  private showCommentsCheckbox: Checkbox;\n  private codeField: Label<LabelConfig>;\n\n\n  private hideTimeout: Timeout;\n\n  constructor(config: EmbedVideoPanelConfig) {\n    super(config);\n\n    this.title = new Label({text: 'Embed Video', cssClass: 'ui-embedvideo-panel-title'});\n    this.closeButton = new CloseButton({target: this});\n    this.showCommentsCheckbox = new Checkbox({text: 'Show comments'});\n    this.codeField = new Label({\n      text: this.toHtmlEntities('<iframe></iframe>'),\n      cssClass: 'ui-embedvideo-panel-codefield'\n    });\n\n\n    this.config = this.mergeConfig<EmbedVideoPanelConfig>(config, {\n        cssClass: 'ui-embedvideo-panel',\n        hideDelay: 3000,\n        components: [\n          new Container({\n            cssClass: 'ui-embedvideo-panel-header',\n            components: [\n              this.title,\n              this.closeButton,\n            ]\n          }),\n          this.showCommentsCheckbox,\n          this.codeField\n        ]\n      },\n      this.config\n    )\n    ;\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <EmbedVideoPanelConfig>this.getConfig(); // TODO fix generics type inference\n\n    if (config.hideDelay > -1) {\n      this.hideTimeout = new Timeout(config.hideDelay, () => {\n        this.hide();\n      });\n\n      this.onShow.subscribe(() => {\n        // Activate timeout when shown\n        this.hideTimeout.start();\n      });\n      this.getDomElement().on('mousemove', () => {\n        // Reset timeout on interaction\n        this.hideTimeout.reset();\n      });\n      this.onHide.subscribe(() => {\n        // Clear timeout when hidden from outside\n        this.hideTimeout.clear();\n      });\n    }\n  }\n\n  release(): void {\n    super.release();\n    if (this.hideTimeout) {\n      this.hideTimeout.clear();\n    }\n  }\n\n  toHtmlEntities(s: string): string {\n    return s.replace(/./gm, function (s) {\n      return '&#' + s.charCodeAt(0) + ';';\n    });\n  }\n}\n\n","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {EmbedVideoPanel} from './embedvideopanel';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Configuration interface for the {@link EmbedVideoToggleButton}.\n */\nexport interface EmbedVideoToggleButtonConfig extends ToggleButtonConfig {\n  /**\n   * The embedVideo panel whose visibility the button should toggle.\n   */\n  embedVideoPanel: EmbedVideoPanel;\n}\n\n/**\n * A button that toggles visibility of a embedVideo panel.\n */\nexport class EmbedVideoToggleButton extends ToggleButton<EmbedVideoToggleButtonConfig> {\n\n  constructor(config: EmbedVideoToggleButtonConfig) {\n    super(config);\n\n    if (!config.embedVideoPanel) {\n      throw new Error('Required EmbedVideoPanel is missing');\n    }\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-embedvideo-togglebutton',\n      text: 'Embed Video',\n      embedVideoPanel: null\n    }, <EmbedVideoToggleButtonConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <EmbedVideoToggleButtonConfig>this.getConfig(); // TODO fix generics type inference\n    let embedVideoPanel = config.embedVideoPanel;\n\n    this.onClick.subscribe(() => {\n      console.log('onClick hidden:', embedVideoPanel.isHidden())\n      embedVideoPanel.toggleHidden();\n    });\n\n    embedVideoPanel.onShow.subscribe(() => {\n      // Set toggle status to on when the embedVideo panel shows\n      this.on();\n    });\n\n    embedVideoPanel.onHide.subscribe(() => {\n      // Set toggle status to off when the embedVideo panel hides\n      this.off();\n    });\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport ErrorEvent = bitmovin.player.ErrorEvent;\nimport {TvNoiseCanvas} from './tvnoisecanvas';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\nexport interface ErrorMessageTranslator {\n  (error: ErrorEvent): string;\n}\n\nexport interface ErrorMessageMap {\n  [code: number]: string | ErrorMessageTranslator;\n}\n\n/**\n * Configuration interface for the {@link ErrorMessageOverlay}.\n */\nexport interface ErrorMessageOverlayConfig extends ContainerConfig {\n  /**\n   * Allows overwriting of the error messages displayed in the overlay for customization and localization.\n   * This is either a function that receives any {@link ErrorEvent} as parameter and translates error messages,\n   * or a map of error codes that overwrites specific error messages with a plain string or a function that\n   * receives the {@link ErrorEvent} as parameter and returns a customized string.\n   * The translation functions can be used to extract data (e.g. parameters) from the original error message.\n   *\n   * Example 1 (catch-all translation function):\n   * <code>\n   * errorMessageOverlayConfig = {\n   *   messages: function(error) {\n   *     switch (error.code) {\n   *       // Overwrite error 3000 'Unknown error'\n   *       case 3000:\n   *         return 'Houston, we have a problem'\n   *\n   *       // Transform error 3001 'Unsupported manifest format' to uppercase\n   *       case 3001:\n   *         return error.message.toUpperCase();\n   *\n   *       // Customize error 3006 'Could not load manifest, got HTTP status code XXX'\n   *       case 3006:\n   *         var statusCode = error.message.substring(46);\n   *         return 'Manifest loading failed with HTTP error ' + statusCode;\n   *     }\n   *     // Return unmodified error message for all other errors\n   *     return error.message;\n   *   }\n   * };\n   * </code>\n   *\n   * Example 2 (translating specific errors):\n   * <code>\n   * errorMessageOverlayConfig = {\n   *   messages: {\n   *     // Overwrite error 3000 'Unknown error'\n   *     3000: 'Houston, we have a problem',\n   *\n   *     // Transform error 3001 'Unsupported manifest format' to uppercase\n   *     3001: function(error) {\n   *       return error.message.toUpperCase();\n   *     },\n   *\n   *     // Customize error 3006 'Could not load manifest, got HTTP status code XXX'\n   *     3006: function(error) {\n   *       var statusCode = error.message.substring(46);\n   *       return 'Manifest loading failed with HTTP error ' + statusCode;\n   *     }\n   *   }\n   * };\n   * </code>\n   */\n  messages?: ErrorMessageMap | ErrorMessageTranslator;\n}\n\n/**\n * Overlays the player and displays error messages.\n */\nexport class ErrorMessageOverlay extends Container<ErrorMessageOverlayConfig> {\n\n  private errorLabel: Label<LabelConfig>;\n  private tvNoiseBackground: TvNoiseCanvas;\n\n  constructor(config: ErrorMessageOverlayConfig = {}) {\n    super(config);\n\n    this.errorLabel = new Label<LabelConfig>({ cssClass: 'ui-errormessage-label' });\n    this.tvNoiseBackground = new TvNoiseCanvas();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-errormessage-overlay',\n      components: [this.tvNoiseBackground, this.errorLabel],\n      hidden: true\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <ErrorMessageOverlayConfig>this.getConfig();\n\n    player.addEventHandler(player.EVENT.ON_ERROR, (event: ErrorEvent) => {\n      let message = event.message;\n\n      // Process message translations\n      if (config.messages) {\n        if (typeof config.messages === 'function') {\n          // Translation function for all errors\n          message = config.messages(event);\n        } else if (config.messages[event.code]) {\n          // It's not a translation function, so it must be a map of strings or translation functions\n          let customMessage = config.messages[event.code];\n\n          if (typeof customMessage === 'string') {\n            message = customMessage;\n          } else {\n            // The message is a translation function, so we call it\n            message = customMessage(event);\n          }\n        }\n      }\n\n      this.errorLabel.setText(message);\n      this.tvNoiseBackground.start();\n      this.show();\n    });\n\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, (event: PlayerEvent) => {\n      if (this.isShown()) {\n        this.tvNoiseBackground.stop();\n        this.hide();\n      }\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles the player between windowed and fullscreen view.\n */\nexport class FullscreenToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-fullscreentogglebutton',\n      text: 'Fullscreen'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let fullscreenStateHandler = () => {\n      if (player.isFullscreen()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_ENTER, fullscreenStateHandler);\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_EXIT, fullscreenStateHandler);\n\n    this.onClick.subscribe(() => {\n      if (player.isFullscreen()) {\n        player.exitFullscreen();\n      } else {\n        player.enterFullscreen();\n      }\n    });\n\n    // Startup init\n    fullscreenStateHandler();\n  }\n}","import {ToggleButtonConfig} from './togglebutton';\nimport {PlaybackToggleButton} from './playbacktogglebutton';\nimport {DOM} from '../dom';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\n/**\n * A button that overlays the video and toggles between playback and pause.\n */\nexport class HugePlaybackToggleButton extends PlaybackToggleButton {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-hugeplaybacktogglebutton',\n      text: 'Play/Pause'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    // Update button state through API events\n    super.configure(player, uimanager, false);\n\n    let togglePlayback = () => {\n      if (player.isPlaying()) {\n        player.pause('ui-overlay');\n      } else {\n        player.play('ui-overlay');\n      }\n    };\n\n    let toggleFullscreen = () => {\n      if (player.isFullscreen()) {\n        player.exitFullscreen();\n      } else {\n        player.enterFullscreen();\n      }\n    };\n\n    let firstPlay = true;\n    let clickTime = 0;\n    let doubleClickTime = 0;\n\n    /*\n     * YouTube-style toggle button handling\n     *\n     * The goal is to prevent a short pause or playback interval between a click, that toggles playback, and a\n     * double click, that toggles fullscreen. In this naive approach, the first click would e.g. start playback,\n     * the second click would be detected as double click and toggle to fullscreen, and as second normal click stop\n     * playback, which results is a short playback interval with max length of the double click detection\n     * period (usually 500ms).\n     *\n     * To solve this issue, we defer handling of the first click for 200ms, which is almost unnoticeable to the user,\n     * and just toggle playback if no second click (double click) has been registered during this period. If a double\n     * click is registered, we just toggle the fullscreen. In the first 200ms, undesired playback changes thus cannot\n     * happen. If a double click is registered within 500ms, we undo the playback change and switch fullscreen mode.\n     * In the end, this method basically introduces a 200ms observing interval in which playback changes are prevented\n     * if a double click happens.\n     */\n    this.onClick.subscribe(() => {\n      // Directly start playback on first click of the button.\n      // This is a required workaround for mobile browsers where video playback needs to be triggered directly\n      // by the user. A deferred playback start through the timeout below is not considered as user action and\n      // therefore ignored by mobile browsers.\n      if (firstPlay) {\n        // Try to start playback. Then we wait for ON_PLAY and only when it arrives, we disable the firstPlay flag.\n        // If we disable the flag here, onClick was triggered programmatically instead of by a user interaction, and\n        // playback is blocked (e.g. on mobile devices due to the programmatic play() call), we loose the chance to\n        // ever start playback through a user interaction again with this button.\n        togglePlayback();\n        return;\n      }\n\n      let now = Date.now();\n\n      if (now - clickTime < 200) {\n        // We have a double click inside the 200ms interval, just toggle fullscreen mode\n        toggleFullscreen();\n        doubleClickTime = now;\n        return;\n      } else if (now - clickTime < 500) {\n        // We have a double click inside the 500ms interval, undo playback toggle and toggle fullscreen mode\n        toggleFullscreen();\n        togglePlayback();\n        doubleClickTime = now;\n        return;\n      }\n\n      clickTime = now;\n\n      setTimeout(() => {\n        if (Date.now() - doubleClickTime > 200) {\n          // No double click detected, so we toggle playback and wait what happens next\n          togglePlayback();\n        }\n      }, 200);\n    });\n\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      // Playback has really started, we can disable the flag to switch to normal toggle button handling\n      firstPlay = false;\n    });\n\n    // Hide button while initializing a Cast session\n    let castInitializationHandler = (event: PlayerEvent) => {\n      if (event.type === player.EVENT.ON_CAST_START) {\n        // Hide button when session is being initialized\n        this.hide();\n      } else {\n        // Show button when session is established or initialization was aborted\n        this.show();\n      }\n    };\n    player.addEventHandler(player.EVENT.ON_CAST_START, castInitializationHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, castInitializationHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, castInitializationHandler);\n  }\n\n  protected toDomElement(): DOM {\n    let buttonElement = super.toDomElement();\n\n    // Add child that contains the play button image\n    // Setting the image directly on the button does not work together with scaling animations, because the button\n    // can cover the whole video player are and scaling would extend it beyond. By adding an inner element, confined\n    // to the size if the image, it can scale inside the player without overshooting.\n    buttonElement.append(new DOM('div', {\n      'class': this.prefixCss('image')\n    }));\n\n    return buttonElement;\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {DOM} from '../dom';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\n/**\n * A button to play/replay a video.\n */\nexport class HugeReplayButton extends Button<ButtonConfig> {\n\n  constructor(config: ButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-hugereplaybutton',\n      text: 'Replay'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      player.play('ui-overlay');\n    });\n  }\n\n  protected toDomElement(): DOM {\n    let buttonElement = super.toDomElement();\n\n    // Add child that contains the play button image\n    // Setting the image directly on the button does not work together with scaling animations, because the button\n    // can cover the whole video player are and scaling would extend it beyond. By adding an inner element, confined\n    // to the size if the image, it can scale inside the player without overshooting.\n    buttonElement.append(new DOM('div', {\n      'class': this.prefixCss('image')\n    }));\n\n    return buttonElement;\n  }\n}","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {EventDispatcher, Event, NoArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link Label} component.\n */\nexport interface LabelConfig extends ComponentConfig {\n  /**\n   * The text on the label.\n   */\n  text?: string;\n}\n\n/**\n * A simple text label.\n *\n * DOM example:\n * <code>\n *     <span class='ui-label'>...some text...</span>\n * </code>\n */\nexport class Label<Config extends LabelConfig> extends Component<LabelConfig> {\n\n  private text: string;\n\n  private labelEvents = {\n    onClick: new EventDispatcher<Label<Config>, NoArgs>(),\n    onTextChanged: new EventDispatcher<Label<Config>, string>(),\n  };\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-label'\n    }, this.config);\n\n    this.text = this.config.text;\n  }\n\n  protected toDomElement(): DOM {\n    let labelElement = new DOM('span', {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    }).html(this.text);\n\n    labelElement.on('click', () => {\n      this.onClickEvent();\n    });\n\n    return labelElement;\n  }\n\n  /**\n   * Set the text on this label.\n   * @param text\n   */\n  setText(text: string) {\n    this.text = text;\n    this.getDomElement().html(text);\n    this.onTextChangedEvent(text);\n  }\n\n  /**\n   * Gets the text on this label.\n   * @return {string} The text on the label\n   */\n  getText(): string {\n    return this.text;\n  }\n\n  /**\n   * Clears the text on this label.\n   */\n  clearText() {\n    this.getDomElement().html('');\n    this.onTextChangedEvent(null);\n  }\n\n  /**\n   * Tests if the label is empty and does not contain any text.\n   * @return {boolean} True if the label is empty, else false\n   */\n  isEmpty(): boolean {\n    return !this.text;\n  }\n\n  /**\n   * Fires the {@link #onClick} event.\n   * Can be used by subclasses to listen to this event without subscribing an event listener by overwriting the method\n   * and calling the super method.\n   */\n  protected onClickEvent() {\n    this.labelEvents.onClick.dispatch(this);\n  }\n\n  /**\n   * Fires the {@link #onClick} event.\n   * Can be used by subclasses to listen to this event without subscribing an event listener by overwriting the method\n   * and calling the super method.\n   */\n  protected onTextChangedEvent(text: string) {\n    this.labelEvents.onTextChanged.dispatch(this, text);\n  }\n\n  /**\n   * Gets the event that is fired when the label is clicked.\n   * @returns {Event<Label<LabelConfig>, NoArgs>}\n   */\n  get onClick(): Event<Label<LabelConfig>, NoArgs> {\n    return this.labelEvents.onClick.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the text on the label is changed.\n   * @returns {Event<Label<LabelConfig>, string>}\n   */\n  get onTextChanged(): Event<Label<LabelConfig>, string> {\n    return this.labelEvents.onTextChanged.getEvent();\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {EventDispatcher, Event} from '../eventdispatcher';\nimport {ArrayUtils} from '../utils';\n\n/**\n * A map of items (key/value -> label} for a {@link ListSelector} in a {@link ListSelectorConfig}.\n */\nexport interface ListItem {\n  key: string;\n  label: string;\n}\n\n/**\n * Configuration interface for a {@link ListSelector}.\n */\nexport interface ListSelectorConfig extends ComponentConfig {\n  items?: ListItem[];\n}\n\nexport abstract class ListSelector<Config extends ListSelectorConfig> extends Component<ListSelectorConfig> {\n\n  protected items: ListItem[];\n  protected selectedItem: string;\n\n  private listSelectorEvents = {\n    onItemAdded: new EventDispatcher<ListSelector<Config>, string>(),\n    onItemRemoved: new EventDispatcher<ListSelector<Config>, string>(),\n    onItemSelected: new EventDispatcher<ListSelector<Config>, string>()\n  };\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      items: [],\n      cssClass: 'ui-listselector'\n    }, this.config);\n\n    this.items = this.config.items;\n  }\n\n  private getItemIndex(key: string): number {\n    for (let index in this.items) {\n      if (key === this.items[index].key) {\n        return parseInt(index);\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Checks if the specified item is part of this selector.\n   * @param key the key of the item to check\n   * @returns {boolean} true if the item is part of this selector, else false\n   */\n  hasItem(key: string): boolean {\n    return this.getItemIndex(key) > -1;\n  }\n\n  /**\n   * Adds an item to this selector by appending it to the end of the list of items. If an item with the specified\n   * key already exists, it is replaced.\n   * @param key the key of the item to add\n   * @param label the (human-readable) label of the item to add\n   */\n  addItem(key: string, label: string) {\n    this.removeItem(key); // Try to remove key first to get overwrite behavior and avoid duplicate keys\n    this.items.push({ key: key, label: label });\n    this.onItemAddedEvent(key);\n  }\n\n  /**\n   * Removes an item from this selector.\n   * @param key the key of the item to remove\n   * @returns {boolean} true if removal was successful, false if the item is not part of this selector\n   */\n  removeItem(key: string): boolean {\n    let index = this.getItemIndex(key);\n    if (index > -1) {\n      ArrayUtils.remove(this.items, this.items[index]);\n      this.onItemRemovedEvent(key);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Selects an item from the items in this selector.\n   * @param key the key of the item to select\n   * @returns {boolean} true is the selection was successful, false if the selected item is not part of the selector\n   */\n  selectItem(key: string): boolean {\n    if (key === this.selectedItem) {\n      // itemConfig is already selected, suppress any further action\n      return true;\n    }\n\n    let index = this.getItemIndex(key);\n\n    if (index > -1) {\n      this.selectedItem = key;\n      this.onItemSelectedEvent(key);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns the key of the selected item.\n   * @returns {string} the key of the selected item or null if no item is selected\n   */\n  getSelectedItem(): string | null {\n    return this.selectedItem;\n  }\n\n  /**\n   * Removes all items from this selector.\n   */\n  clearItems() {\n    let items = this.items; // local copy for iteration after clear\n    this.items = []; // clear items\n\n    // fire events\n    for (let item of items) {\n      this.onItemRemovedEvent(item.key);\n    }\n  }\n\n  /**\n   * Returns the number of items in this selector.\n   * @returns {number}\n   */\n  itemCount(): number {\n    return Object.keys(this.items).length;\n  }\n\n  protected onItemAddedEvent(key: string) {\n    this.listSelectorEvents.onItemAdded.dispatch(this, key);\n  }\n\n  protected onItemRemovedEvent(key: string) {\n    this.listSelectorEvents.onItemRemoved.dispatch(this, key);\n  }\n\n  protected onItemSelectedEvent(key: string) {\n    this.listSelectorEvents.onItemSelected.dispatch(this, key);\n  }\n\n  /**\n   * Gets the event that is fired when an item is added to the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemAdded(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemAdded.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when an item is removed from the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemRemoved(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemRemoved.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when an item is selected from the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemSelected(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemSelected.getEvent();\n  }\n}","import {LabelConfig, Label} from './label';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Enumerates the types of content that the {@link MetadataLabel} can display.\n */\nexport enum MetadataLabelContent {\n  /**\n   * Title of the data source.\n   */\n  Title,\n  /**\n   * Description fo the data source.\n   */\n  Description,\n}\n\n/**\n * Configuration interface for {@link MetadataLabel}.\n */\nexport interface MetadataLabelConfig extends LabelConfig {\n  /**\n   * The type of content that should be displayed in the label.\n   */\n  content: MetadataLabelContent;\n}\n\n/**\n * A label that can be configured to display certain metadata.\n */\nexport class MetadataLabel extends Label<MetadataLabelConfig> {\n\n  constructor(config: MetadataLabelConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClasses: ['label-metadata', 'label-metadata-' + MetadataLabelContent[config.content].toLowerCase()]\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <MetadataLabelConfig>this.getConfig();\n    let uiconfig = uimanager.getConfig();\n\n    let init = () => {\n      switch (config.content) {\n        case MetadataLabelContent.Title:\n          if (uiconfig && uiconfig.metadata && uiconfig.metadata.title) {\n            this.setText(uiconfig.metadata.title);\n          } else if (player.getConfig().source && player.getConfig().source.title) {\n            this.setText(player.getConfig().source.title);\n          }\n          break;\n        case MetadataLabelContent.Description:\n          if (uiconfig && uiconfig.metadata && uiconfig.metadata.description) {\n            this.setText(uiconfig.metadata.description);\n          } else if (player.getConfig().source && player.getConfig().source.description) {\n            this.setText(player.getConfig().source.description);\n          }\n          break;\n      }\n    };\n\n    let unload = () => {\n      this.setText(null);\n    };\n\n    // Init label\n    init();\n    // Reinit label when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, init);\n    // Clear labels when source is unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, unload);\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles Apple macOS picture-in-picture mode.\n */\nexport class PictureInPictureToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-piptogglebutton',\n      text: 'Picture-in-Picture'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      if (player.isPictureInPictureAvailable()) {\n        if (player.isPictureInPicture()) {\n          player.exitPictureInPicture();\n        } else {\n          player.enterPictureInPicture();\n        }\n      } else {\n        if (console) {\n          console.log('PIP unavailable');\n        }\n      }\n    });\n\n    let pipAvailableHander = () => {\n      if (player.isPictureInPictureAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, pipAvailableHander);\n\n    // Toggle button 'on' state\n    player.addEventHandler(player.EVENT.ON_PICTURE_IN_PICTURE_ENTER, () => {\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_PICTURE_IN_PICTURE_EXIT, () => {\n      this.off();\n    });\n\n    // Startup init\n    pipAvailableHander(); // Hide button if PIP not available\n    if (player.isPictureInPicture()) {\n      this.on();\n    }\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection of different playback speeds.\n */\nexport class PlaybackSpeedSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem('0.25', '0.25x');\n    this.addItem('0.5', '0.5x');\n    this.addItem('1', 'Normal');\n    this.addItem('1.5', '1.5x');\n    this.addItem('2', '2x');\n\n    this.selectItem('1');\n\n\n    this.onItemSelected.subscribe((sender: PlaybackSpeedSelectBox, value: string) => {\n      player.setPlaybackSpeed(parseFloat(value));\n    });\n  }\n}","import {LabelConfig, Label} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {StringUtils, PlayerUtils} from '../utils';\nimport LiveStreamDetectorEventArgs = PlayerUtils.LiveStreamDetectorEventArgs;\n\nexport enum PlaybackTimeLabelMode {\n  CurrentTime,\n  TotalTime,\n  CurrentAndTotalTime,\n}\n\nexport interface PlaybackTimeLabelConfig extends LabelConfig {\n  timeLabelMode?: PlaybackTimeLabelMode;\n  hideInLivePlayback?: boolean;\n}\n\n/**\n * A label that display the current playback time and the total time through {@link PlaybackTimeLabel#setTime setTime}\n * or any string through {@link PlaybackTimeLabel#setText setText}.\n */\nexport class PlaybackTimeLabel extends Label<PlaybackTimeLabelConfig> {\n\n  private timeFormat: string;\n\n  constructor(config: PlaybackTimeLabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <PlaybackTimeLabelConfig>{\n      cssClass: 'ui-playbacktimelabel',\n      timeLabelMode: PlaybackTimeLabelMode.CurrentAndTotalTime,\n      hideInLivePlayback: false,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <PlaybackTimeLabelConfig>this.getConfig();\n    let live = false;\n    let liveCssClass = this.prefixCss('ui-playbacktimelabel-live');\n    let liveEdgeCssClass = this.prefixCss('ui-playbacktimelabel-live-edge');\n    let minWidth = 0;\n\n    let liveClickHandler = () => {\n      player.timeShift(0);\n    };\n\n    let updateLiveState = () => {\n      // Player is playing a live stream when the duration is infinite\n      live = player.isLive();\n\n      // Attach/detach live marker class\n      if (live) {\n        this.getDomElement().addClass(liveCssClass);\n        this.setText('Live');\n        if (config.hideInLivePlayback) {\n          this.hide();\n        }\n        this.onClick.subscribe(liveClickHandler);\n        updateLiveTimeshiftState();\n      } else {\n        this.getDomElement().removeClass(liveCssClass);\n        this.getDomElement().removeClass(liveEdgeCssClass);\n        this.show();\n        this.onClick.unsubscribe(liveClickHandler);\n      }\n    };\n\n    new PlayerUtils.LiveStreamDetector(player).onLiveChanged.subscribe((sender, args: LiveStreamDetectorEventArgs) => {\n      live = args.live;\n      updateLiveState();\n    });\n\n    let updateLiveTimeshiftState = () => {\n      if (player.getTimeShift() === 0) {\n        this.getDomElement().addClass(liveEdgeCssClass);\n      } else {\n        this.getDomElement().removeClass(liveEdgeCssClass);\n      }\n    };\n\n    let playbackTimeHandler = () => {\n      if (!live && player.getDuration() !== Infinity) {\n        this.setTime(player.getCurrentTime(), player.getDuration());\n      }\n\n      // To avoid 'jumping' in the UI by varying label sizes due to non-monospaced fonts,\n      // we gradually increase the min-width with the content to reach a stable size.\n      let width = this.getDomElement().width();\n      if (width > minWidth) {\n        minWidth = width;\n        this.getDomElement().css({\n          'min-width': minWidth + 'px'\n        });\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_TIME_CHANGED, playbackTimeHandler);\n    player.addEventHandler(player.EVENT.ON_SEEKED, playbackTimeHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, playbackTimeHandler);\n\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, updateLiveTimeshiftState);\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, updateLiveTimeshiftState);\n\n    let init = () => {\n      // Reset min-width when a new source is ready (especially for switching VOD/Live modes where the label content\n      // changes)\n      minWidth = 0;\n      this.getDomElement().css({\n        'min-width': null\n      });\n\n      // Set time format depending on source duration\n      this.timeFormat = Math.abs(player.isLive() ? player.getMaxTimeShift() : player.getDuration()) >= 3600 ?\n        StringUtils.FORMAT_HHMMSS : StringUtils.FORMAT_MMSS;\n\n      // Update time after the format has been set\n      playbackTimeHandler();\n    };\n    player.addEventHandler(player.EVENT.ON_READY, init);\n\n    init();\n  }\n\n  /**\n   * Sets the current playback time and total duration.\n   * @param playbackSeconds the current playback time in seconds\n   * @param durationSeconds the total duration in seconds\n   */\n  setTime(playbackSeconds: number, durationSeconds: number) {\n    let currentTime = StringUtils.secondsToTime(playbackSeconds, this.timeFormat);\n    let totalTime = StringUtils.secondsToTime(durationSeconds, this.timeFormat);\n\n    switch ((<PlaybackTimeLabelConfig>this.config).timeLabelMode) {\n      case PlaybackTimeLabelMode.CurrentTime:\n        this.setText(`${currentTime}`);\n        break;\n      case PlaybackTimeLabelMode.TotalTime:\n        this.setText(`${totalTime}`);\n        break;\n      case PlaybackTimeLabelMode.CurrentAndTotalTime:\n        this.setText(`${currentTime} / ${totalTime}`);\n        break;\n    }\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\nimport {PlayerUtils} from '../utils';\nimport TimeShiftAvailabilityChangedArgs = PlayerUtils.TimeShiftAvailabilityChangedArgs;\n\n/**\n * A button that toggles between playback and pause.\n */\nexport class PlaybackToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  private static readonly CLASS_STOPTOGGLE = 'stoptoggle';\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-playbacktogglebutton',\n      text: 'Play/Pause'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager, handleClickEvent: boolean = true): void {\n    super.configure(player, uimanager);\n\n    let isSeeking = false;\n\n    // Handler to update button state based on player state\n    let playbackStateHandler = (event: PlayerEvent) => {\n      // If the UI is currently seeking, playback is temporarily stopped but the buttons should\n      // not reflect that and stay as-is (e.g indicate playback while seeking).\n      if (isSeeking) {\n        return;\n      }\n\n      if (player.isPlaying()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    // Call handler upon these events\n    player.addEventHandler(player.EVENT.ON_PLAY, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_PAUSED, playbackStateHandler);\n    // when playback finishes, player turns to paused mode\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYING, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PAUSED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYBACK_FINISHED, playbackStateHandler);\n\n    // Detect absence of timeshifting on live streams and add tagging class to convert button icons to play/stop\n    new PlayerUtils.TimeShiftAvailabilityDetector(player).onTimeShiftAvailabilityChanged.subscribe(\n      (sender, args: TimeShiftAvailabilityChangedArgs) => {\n        if (!args.timeShiftAvailable) {\n          this.getDomElement().addClass(this.prefixCss(PlaybackToggleButton.CLASS_STOPTOGGLE));\n        } else {\n          this.getDomElement().removeClass(this.prefixCss(PlaybackToggleButton.CLASS_STOPTOGGLE));\n        }\n      }\n    );\n\n    if (handleClickEvent) {\n      // Control player by button events\n      // When a button event triggers a player API call, events are fired which in turn call the event handler\n      // above that updated the button state.\n      this.onClick.subscribe(() => {\n        if (player.isPlaying()) {\n          player.pause('ui-button');\n        } else {\n          player.play('ui-button');\n        }\n      });\n    }\n\n    // Track UI seeking status\n    uimanager.onSeek.subscribe(() => {\n      isSeeking = true;\n    });\n    uimanager.onSeeked.subscribe(() => {\n      isSeeking = false;\n    });\n\n    // Startup init\n    playbackStateHandler(null);\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {HugePlaybackToggleButton} from './hugeplaybacktogglebutton';\n\n/**\n * Overlays the player and displays error messages.\n */\nexport class PlaybackToggleOverlay extends Container<ContainerConfig> {\n\n  private playbackToggleButton: HugePlaybackToggleButton;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.playbackToggleButton = new HugePlaybackToggleButton();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-playbacktoggle-overlay',\n      components: [this.playbackToggleButton]\n    }, this.config);\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\nimport {UIInstanceManager, UIRecommendationConfig} from '../uimanager';\nimport {StringUtils} from '../utils';\nimport {HugeReplayButton} from './hugereplaybutton';\n\n/**\n * Overlays the player and displays recommended videos.\n */\nexport class RecommendationOverlay extends Container<ContainerConfig> {\n\n  private replayButton: HugeReplayButton;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.replayButton = new HugeReplayButton();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-recommendation-overlay',\n      hidden: true,\n      components: [this.replayButton]\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let clearRecommendations = () => {\n      for (let component of this.getComponents()) {\n        if (component instanceof RecommendationItem) {\n          this.removeComponent(component);\n        }\n      }\n      this.updateComponents();\n      this.getDomElement().removeClass(this.prefixCss('recommendations'));\n    };\n\n    let setupRecommendations = () => {\n      clearRecommendations();\n\n      let hasRecommendationsInUiConfig = uimanager.getConfig().recommendations\n        && uimanager.getConfig().recommendations.length > 0;\n      let hasRecommendationsInPlayerConfig = player.getConfig().source && player.getConfig().source.recommendations\n        && player.getConfig().source.recommendations.length > 0;\n\n      // Take markers from the UI config. If no markers defined, try to take them from the player's source config.\n      let recommendations = hasRecommendationsInUiConfig ? uimanager.getConfig().recommendations :\n        hasRecommendationsInPlayerConfig ? player.getConfig().source.recommendations : null;\n\n      // Generate timeline markers from the config if we have markers and if we have a duration\n      // The duration check is for buggy platforms where the duration is not available instantly (Chrome on Android 4.3)\n      if (recommendations) {\n        let index = 1;\n        for (let item of recommendations) {\n          this.addComponent(new RecommendationItem({\n            itemConfig: item,\n            cssClasses: ['recommendation-item-' + (index++)]\n          }));\n        }\n        this.updateComponents(); // create container DOM elements\n\n        this.getDomElement().addClass(this.prefixCss('recommendations'));\n      }\n    };\n\n    // Add recommendation when a source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, setupRecommendations);\n    // Remove recommendations and hide overlay when source is unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, () => {\n      clearRecommendations();\n      this.hide();\n    });\n    // Display recommendations when playback has finished\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, () => {\n      // Dismiss ON_PLAYBACK_FINISHED events at the end of ads\n      // TODO remove this workaround once issue #1278 is solved\n      if (player.isAd()) {\n        return;\n      }\n\n      this.show();\n    });\n    // Hide recommendations when playback starts, e.g. a restart\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      this.hide();\n    });\n\n    // Init on startup\n    setupRecommendations();\n  }\n}\n\n/**\n * Configuration interface for the {@link RecommendationItem}\n */\ninterface RecommendationItemConfig extends ComponentConfig {\n  itemConfig: UIRecommendationConfig;\n}\n\n/**\n * An item of the {@link RecommendationOverlay}. Used only internally in {@link RecommendationOverlay}.\n */\nclass RecommendationItem extends Component<RecommendationItemConfig> {\n\n  constructor(config: RecommendationItemConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-recommendation-item',\n      itemConfig: null // this must be passed in from outside\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    let config = (<RecommendationItemConfig>this.config).itemConfig; // TODO fix generics and get rid of cast\n\n    let itemElement = new DOM('a', {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n      'href': config.url\n    }).css({ 'background-image': `url(${config.thumbnail})` });\n\n    let bgElement = new DOM('div', {\n      'class': this.prefixCss('background')\n    });\n    itemElement.append(bgElement);\n\n    let titleElement = new DOM('span', {\n      'class': this.prefixCss('title')\n    }).append(new DOM('span', {\n      'class': this.prefixCss('innertitle')\n    }).html(config.title));\n    itemElement.append(titleElement);\n\n    let timeElement = new DOM('span', {\n      'class': this.prefixCss('duration')\n    }).append(new DOM('span', {\n      'class': this.prefixCss('innerduration')\n    }).html(config.duration ? StringUtils.secondsToTime(config.duration) : ''));\n    itemElement.append(timeElement);\n\n    return itemElement;\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\nimport {Event, EventDispatcher, NoArgs} from '../eventdispatcher';\nimport {SeekBarLabel} from './seekbarlabel';\nimport {UIInstanceManager, TimelineMarker, SeekPreviewArgs} from '../uimanager';\nimport {Timeout} from '../timeout';\nimport {PlayerUtils} from '../utils';\nimport TimeShiftAvailabilityChangedArgs = PlayerUtils.TimeShiftAvailabilityChangedArgs;\nimport LiveStreamDetectorEventArgs = PlayerUtils.LiveStreamDetectorEventArgs;\nimport PlayerEvent = bitmovin.player.PlayerEvent;\n\n/**\n * Configuration interface for the {@link SeekBar} component.\n */\nexport interface SeekBarConfig extends ComponentConfig {\n  /**\n   * The label above the seek position.\n   */\n  label?: SeekBarLabel;\n  /**\n   * Bar will be vertical instead of horizontal if set to true.\n   */\n  vertical?: boolean;\n  /**\n   * The interval in milliseconds in which the playback position on the seek bar will be updated. The shorter the\n   * interval, the smoother it looks and the more resource intense it is. The update interval will be kept as steady\n   * as possible to avoid jitter.\n   * Set to -1 to disable smooth updating and update it on player ON_TIME_CHANGED events instead.\n   * Default: 50 (50ms = 20fps).\n   */\n  smoothPlaybackPositionUpdateIntervalMs?: number;\n}\n\n/**\n * Event argument interface for a seek preview event.\n */\nexport interface SeekPreviewEventArgs extends SeekPreviewArgs {\n  /**\n   * Tells if the seek preview event comes from a scrubbing.\n   */\n  scrubbing: boolean;\n}\n\n/**\n * A seek bar to seek within the player's media. It displays the current playback position, amount of buffed data, seek\n * target, and keeps status about an ongoing seek.\n *\n * The seek bar displays different 'bars':\n *  - the playback position, i.e. the position in the media at which the player current playback pointer is positioned\n *  - the buffer position, which usually is the playback position plus the time span that is already buffered ahead\n *  - the seek position, used to preview to where in the timeline a seek will jump to\n */\nexport class SeekBar extends Component<SeekBarConfig> {\n\n  public static readonly SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED = -1;\n\n  /**\n   * The CSS class that is added to the DOM element while the seek bar is in 'seeking' state.\n   */\n  private static readonly CLASS_SEEKING = 'seeking';\n\n  private seekBar: DOM;\n  private seekBarPlaybackPosition: DOM;\n  private seekBarPlaybackPositionMarker: DOM;\n  private seekBarBufferPosition: DOM;\n  private seekBarSeekPosition: DOM;\n  private seekBarBackdrop: DOM;\n  private seekBarMarkersContainer: DOM;\n\n  private label: SeekBarLabel;\n\n  private timelineMarkers: TimelineMarker[];\n\n  /**\n   * Buffer of the the current playback position. The position must be buffered in case the element\n   * needs to be refreshed with {@link #refreshPlaybackPosition}.\n   * @type {number}\n   */\n  private playbackPositionPercentage = 0;\n\n  private smoothPlaybackPositionUpdater: Timeout;\n\n  // https://hacks.mozilla.org/2013/04/detecting-touch-its-the-why-not-the-how/\n  private touchSupported = ('ontouchstart' in window);\n\n  private seekBarEvents = {\n    /**\n     * Fired when a scrubbing seek operation is started.\n     */\n    onSeek: new EventDispatcher<SeekBar, NoArgs>(),\n    /**\n     * Fired during a scrubbing seek to indicate that the seek preview (i.e. the video frame) should be updated.\n     */\n    onSeekPreview: new EventDispatcher<SeekBar, SeekPreviewEventArgs>(),\n    /**\n     * Fired when a scrubbing seek has finished or when a direct seek is issued.\n     */\n    onSeeked: new EventDispatcher<SeekBar, number>()\n  };\n\n  constructor(config: SeekBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-seekbar',\n      vertical: false,\n      smoothPlaybackPositionUpdateIntervalMs: 50,\n    }, this.config);\n\n    this.label = this.config.label;\n    this.timelineMarkers = [];\n  }\n\n  initialize(): void {\n    super.initialize();\n\n    if (this.hasLabel()) {\n      this.getLabel().initialize();\n    }\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager, configureSeek: boolean = true): void {\n    super.configure(player, uimanager);\n\n    if (!configureSeek) {\n      // The configureSeek flag can be used by subclasses to disable configuration as seek bar. E.g. the volume\n      // slider is reusing this component but adds its own functionality, and does not need the seek functionality.\n      // This is actually a hack, the proper solution would be for both seek bar and volume sliders to extend\n      // a common base slider component and implement their functionality there.\n      return;\n    }\n\n    let playbackNotInitialized = true;\n    let isPlaying = false;\n    let isSeeking = false;\n\n    // Update playback and buffer positions\n    let playbackPositionHandler = (event: PlayerEvent = null, forceUpdate: boolean = false) => {\n      // Once this handler os called, playback has been started and we set the flag to false\n      playbackNotInitialized = false;\n\n      if (isSeeking) {\n        // We caught a seek preview seek, do not update the seekbar\n        return;\n      }\n\n      if (player.isLive()) {\n        if (player.getMaxTimeShift() === 0) {\n          // This case must be explicitly handled to avoid division by zero\n          this.setPlaybackPosition(100);\n        }\n        else {\n          let playbackPositionPercentage = 100 - (100 / player.getMaxTimeShift() * player.getTimeShift());\n          this.setPlaybackPosition(playbackPositionPercentage);\n        }\n\n        // Always show full buffer for live streams\n        this.setBufferPosition(100);\n      }\n      else {\n        let playbackPositionPercentage = 100 / player.getDuration() * player.getCurrentTime();\n\n        let videoBufferLength = player.getVideoBufferLength();\n        let audioBufferLength = player.getAudioBufferLength();\n        // Calculate the buffer length which is the smaller length of the audio and video buffers. If one of these\n        // buffers is not available, we set it's value to MAX_VALUE to make sure that the other real value is taken\n        // as the buffer length.\n        let bufferLength = Math.min(\n          videoBufferLength != null ? videoBufferLength : Number.MAX_VALUE,\n          audioBufferLength != null ? audioBufferLength : Number.MAX_VALUE);\n        // If both buffer lengths are missing, we set the buffer length to zero\n        if (bufferLength === Number.MAX_VALUE) {\n          bufferLength = 0;\n        }\n\n        let bufferPercentage = 100 / player.getDuration() * bufferLength;\n\n        // Update playback position only in paused state or in the initial startup state where player is neither\n        // paused nor playing. Playback updates are handled in the Timeout below.\n        if (this.config.smoothPlaybackPositionUpdateIntervalMs === SeekBar.SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED\n          || forceUpdate || player.isPaused() || (player.isPaused() === player.isPlaying())) {\n          this.setPlaybackPosition(playbackPositionPercentage);\n        }\n\n        this.setBufferPosition(playbackPositionPercentage + bufferPercentage);\n      }\n    };\n\n    // Update seekbar upon these events\n    // init playback position when the player is ready\n    player.addEventHandler(player.EVENT.ON_READY, playbackPositionHandler);\n    // update playback position when it changes\n    player.addEventHandler(player.EVENT.ON_TIME_CHANGED, playbackPositionHandler);\n    // update bufferlevel when buffering is complete\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, playbackPositionHandler);\n    // update playback position when a seek has finished\n    player.addEventHandler(player.EVENT.ON_SEEKED, playbackPositionHandler);\n    // update playback position when a timeshift has finished\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, playbackPositionHandler);\n    // update bufferlevel when a segment has been downloaded\n    player.addEventHandler(player.EVENT.ON_SEGMENT_REQUEST_FINISHED, playbackPositionHandler);\n    // update playback position of Cast playback\n    player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, playbackPositionHandler);\n\n\n    // Seek handling\n    player.addEventHandler(player.EVENT.ON_SEEK, () => {\n      this.setSeeking(true);\n    });\n    player.addEventHandler(player.EVENT.ON_SEEKED, () => {\n      this.setSeeking(false);\n    });\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, () => {\n      this.setSeeking(true);\n    });\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, () => {\n      this.setSeeking(false);\n    });\n\n    let seek = (percentage: number) => {\n      if (player.isLive()) {\n        player.timeShift(player.getMaxTimeShift() - (player.getMaxTimeShift() * (percentage / 100)));\n      } else {\n        player.seek(player.getDuration() * (percentage / 100));\n      }\n    };\n    this.onSeek.subscribe((sender) => {\n      isSeeking = true; // track seeking status so we can catch events from seek preview seeks\n\n      // Notify UI manager of started seek\n      uimanager.onSeek.dispatch(sender);\n\n      // Save current playback state\n      isPlaying = player.isPlaying();\n\n      // Pause playback while seeking\n      if (isPlaying) {\n        player.pause('ui-seek');\n      }\n    });\n    this.onSeekPreview.subscribe((sender: SeekBar, args: SeekPreviewEventArgs) => {\n      // Notify UI manager of seek preview\n      uimanager.onSeekPreview.dispatch(sender, args);\n    });\n    this.onSeekPreview.subscribeRateLimited((sender: SeekBar, args: SeekPreviewEventArgs) => {\n      // Rate-limited scrubbing seek\n      if (args.scrubbing) {\n        seek(args.position);\n      }\n    }, 200);\n    this.onSeeked.subscribe((sender, percentage) => {\n      isSeeking = false;\n\n      // Do the seek\n      seek(percentage);\n\n      // Continue playback after seek if player was playing when seek started\n      if (isPlaying) {\n        player.play('ui-seek');\n      }\n\n      // Notify UI manager of finished seek\n      uimanager.onSeeked.dispatch(sender);\n    });\n\n    if (this.hasLabel()) {\n      // Configure a seekbar label that is internal to the seekbar)\n      this.getLabel().configure(player, uimanager);\n    }\n\n    // Hide seekbar for live sources without timeshift\n    let isLive = false;\n    let hasTimeShift = false;\n    let switchVisibility = (isLive: boolean, hasTimeShift: boolean) => {\n      if (isLive && !hasTimeShift) {\n        this.hide();\n      } else {\n        this.show();\n      }\n      playbackPositionHandler(null, true);\n      this.refreshPlaybackPosition();\n    };\n    new PlayerUtils.LiveStreamDetector(player).onLiveChanged.subscribe((sender, args: LiveStreamDetectorEventArgs) => {\n      isLive = args.live;\n      switchVisibility(isLive, hasTimeShift);\n    });\n    new PlayerUtils.TimeShiftAvailabilityDetector(player).onTimeShiftAvailabilityChanged.subscribe(\n      (sender, args: TimeShiftAvailabilityChangedArgs) => {\n        hasTimeShift = args.timeShiftAvailable;\n        switchVisibility(isLive, hasTimeShift);\n      }\n    );\n\n    // Refresh the playback position when the player resized or the UI is configured. The playback position marker\n    // is positioned absolutely and must therefore be updated when the size of the seekbar changes.\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => {\n      this.refreshPlaybackPosition();\n    });\n    // Additionally, when this code is called, the seekbar is not part of the UI yet and therefore does not have a size,\n    // resulting in a wrong initial position of the marker. Refreshing it once the UI is configured solved this issue.\n    uimanager.onConfigured.subscribe(() => {\n      this.refreshPlaybackPosition();\n    });\n    // It can also happen that the value changes once the player is ready, or when a new source is loaded, so we need\n    // to update on ON_READY too\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      this.refreshPlaybackPosition();\n    });\n\n    // Initialize seekbar\n    playbackPositionHandler(); // Set the playback position\n    this.setBufferPosition(0);\n    this.setSeekPosition(0);\n    if (this.config.smoothPlaybackPositionUpdateIntervalMs !== SeekBar.SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED) {\n      this.configureSmoothPlaybackPositionUpdater(player, uimanager);\n    }\n    this.configureMarkers(player, uimanager);\n  }\n\n  private configureSmoothPlaybackPositionUpdater(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    /*\n     * Playback position update\n     *\n     * We do not update the position directly from the ON_TIME_CHANGED event, because it arrives very jittery and\n     * results in a jittery position indicator since the CSS transition time is statically set.\n     * To work around this issue, we maintain a local playback position that is updated in a stable regular interval\n     * and kept in sync with the player.\n     */\n    let currentTimeSeekBar = 0;\n    let currentTimePlayer = 0;\n    let updateIntervalMs = 50;\n    let currentTimeUpdateDeltaSecs = updateIntervalMs / 1000;\n\n    this.smoothPlaybackPositionUpdater = new Timeout(updateIntervalMs, () => {\n      currentTimeSeekBar += currentTimeUpdateDeltaSecs;\n      currentTimePlayer = player.getCurrentTime();\n\n      // Sync currentTime of seekbar to player\n      let currentTimeDelta = currentTimeSeekBar - currentTimePlayer;\n      // If the delta is larger that 2 secs, directly jump the seekbar to the\n      // player time instead of smoothly fast forwarding/rewinding.\n      if (Math.abs(currentTimeDelta) > 2) {\n        currentTimeSeekBar = currentTimePlayer;\n      }\n      // If currentTimeDelta is negative and below the adjustment threshold,\n      // the player is ahead of the seekbar and we 'fast forward' the seekbar\n      else if (currentTimeDelta <= -currentTimeUpdateDeltaSecs) {\n        currentTimeSeekBar += currentTimeUpdateDeltaSecs;\n      }\n      // If currentTimeDelta is positive and above the adjustment threshold,\n      // the player is behind the seekbar and we 'rewind' the seekbar\n      else if (currentTimeDelta >= currentTimeUpdateDeltaSecs) {\n        currentTimeSeekBar -= currentTimeUpdateDeltaSecs;\n      }\n\n      let playbackPositionPercentage = 100 / player.getDuration() * currentTimeSeekBar;\n      this.setPlaybackPosition(playbackPositionPercentage);\n    }, true);\n\n    let startSmoothPlaybackPositionUpdater = () => {\n      if (!player.isLive()) {\n        currentTimeSeekBar = player.getCurrentTime();\n        this.smoothPlaybackPositionUpdater.start();\n      }\n    };\n\n    let stopSmoothPlaybackPositionUpdater = () => {\n      this.smoothPlaybackPositionUpdater.clear();\n    };\n\n    player.addEventHandler(player.EVENT.ON_PLAY, startSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYING, startSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_PAUSED, stopSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_CAST_PAUSED, stopSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_SEEKED, () => {\n      currentTimeSeekBar = player.getCurrentTime();\n    });\n\n    if (player.isPlaying()) {\n      startSmoothPlaybackPositionUpdater();\n    }\n  }\n\n  private configureMarkers(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let clearMarkers = () => {\n      this.timelineMarkers = [];\n      this.updateMarkers();\n    };\n\n    let setupMarkers = () => {\n      clearMarkers();\n\n      let hasMarkersInUiConfig = uimanager.getConfig().metadata && uimanager.getConfig().metadata.markers\n        && uimanager.getConfig().metadata.markers.length > 0;\n      let hasMarkersInPlayerConfig = player.getConfig().source && player.getConfig().source.markers\n        && player.getConfig().source.markers.length > 0;\n\n      // Take markers from the UI config. If no markers defined, try to take them from the player's source config.\n      let markers = hasMarkersInUiConfig ? uimanager.getConfig().metadata.markers :\n        hasMarkersInPlayerConfig ? player.getConfig().source.markers : null;\n\n      // Generate timeline markers from the config if we have markers and if we have a duration\n      // The duration check is for buggy platforms where the duration is not available instantly (Chrome on Android 4.3)\n      if (markers && player.getDuration() !== Infinity) {\n        for (let o of markers) {\n          let marker = {\n            time: 100 / player.getDuration() * o.time, // convert time to percentage\n            title: o.title,\n            markerType: '' + (o.markerType || 1),\n            comment: o.comment || '',\n            avatar: o.avatar,\n            number: o.number || ''\n          }\n          this.timelineMarkers.push(marker)\n        }\n      }\n\n      // Populate the timeline with the markers\n      this.updateMarkers();\n    };\n\n    // Add markers when a source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, setupMarkers);\n    // Remove markers when unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, clearMarkers);\n\n    // Init markers at startup\n    setupMarkers();\n  }\n\n  release(): void {\n    super.release();\n\n    if (this.smoothPlaybackPositionUpdater) { // object must not necessarily exist, e.g. in volume slider subclass\n      this.smoothPlaybackPositionUpdater.clear();\n    }\n  }\n\n  protected toDomElement(): DOM {\n    if (this.config.vertical) {\n      this.config.cssClasses.push('vertical');\n    }\n\n    let seekBarContainer = new DOM('div', {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    let seekBar = new DOM('div', {\n      'class': this.prefixCss('seekbar')\n    });\n    this.seekBar = seekBar;\n\n    // Indicator that shows the buffer fill level\n    let seekBarBufferLevel = new DOM('div', {\n      'class': this.prefixCss('seekbar-bufferlevel')\n    });\n    this.seekBarBufferPosition = seekBarBufferLevel;\n\n    // Indicator that shows the current playback position\n    let seekBarPlaybackPosition = new DOM('div', {\n      'class': this.prefixCss('seekbar-playbackposition')\n    });\n    this.seekBarPlaybackPosition = seekBarPlaybackPosition;\n\n    // A marker of the current playback position, e.g. a dot or line\n    let seekBarPlaybackPositionMarker = new DOM('div', {\n      'class': this.prefixCss('seekbar-playbackposition-marker')\n    });\n    this.seekBarPlaybackPositionMarker = seekBarPlaybackPositionMarker;\n\n    // Indicator that show where a seek will go to\n    let seekBarSeekPosition = new DOM('div', {\n      'class': this.prefixCss('seekbar-seekposition')\n    });\n    this.seekBarSeekPosition = seekBarSeekPosition;\n\n    // Indicator that shows the full seekbar\n    let seekBarBackdrop = new DOM('div', {\n      'class': this.prefixCss('seekbar-backdrop')\n    });\n    this.seekBarBackdrop = seekBarBackdrop;\n\n    let seekBarChapterMarkersContainer = new DOM('div', {\n      'class': this.prefixCss('seekbar-markers')\n    });\n    this.seekBarMarkersContainer = seekBarChapterMarkersContainer;\n\n    seekBar.append(seekBarBackdrop, seekBarBufferLevel, seekBarSeekPosition,\n      seekBarPlaybackPosition, seekBarChapterMarkersContainer, seekBarPlaybackPositionMarker);\n\n    let seeking = false;\n\n    // Define handler functions so we can attach/remove them later\n    let mouseTouchMoveHandler = (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n      // Avoid propagation to VR handler\n      e.stopPropagation();\n\n      let targetPercentage = 100 * this.getOffset(e);\n      this.setSeekPosition(targetPercentage);\n      this.setPlaybackPosition(targetPercentage);\n      this.onSeekPreviewEvent(targetPercentage, true);\n    };\n    let mouseTouchUpHandler = (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      // Remove handlers, seek operation is finished\n      new DOM(document).off('touchmove mousemove', mouseTouchMoveHandler);\n      new DOM(document).off('touchend mouseup', mouseTouchUpHandler);\n\n      let targetPercentage = 100 * this.getOffset(e);\n      let snappedChapter = this.getMarkerAtPosition(targetPercentage);\n\n      this.setSeeking(false);\n      seeking = false;\n\n      // Fire seeked event\n      this.onSeekedEvent(snappedChapter ? snappedChapter.time : targetPercentage);\n    };\n\n    // A seek always start with a touchstart or mousedown directly on the seekbar.\n    // To track a mouse seek also outside the seekbar (for touch events this works automatically),\n    // so the user does not need to take care that the mouse always stays on the seekbar, we attach the mousemove\n    // and mouseup handlers to the whole document. A seek is triggered when the user lifts the mouse key.\n    // A seek mouse gesture is thus basically a click with a long time frame between down and up events.\n    seekBar.on('touchstart mousedown', (e: MouseEvent | TouchEvent) => {\n      let isTouchEvent = this.touchSupported && e instanceof TouchEvent;\n\n      // Prevent selection of DOM elements (also prevents mousedown if current event is touchstart)\n      e.preventDefault();\n      // Avoid propagation to VR handler\n      e.stopPropagation();\n\n      this.setSeeking(true); // Set seeking class on DOM element\n      seeking = true; // Set seek tracking flag\n\n      // Fire seeked event\n      this.onSeekEvent();\n\n      // Add handler to track the seek operation over the whole document\n      new DOM(document).on(isTouchEvent ? 'touchmove' : 'mousemove', mouseTouchMoveHandler);\n      new DOM(document).on(isTouchEvent ? 'touchend' : 'mouseup', mouseTouchUpHandler);\n    });\n\n    // Display seek target indicator when mouse hovers or finger slides over seekbar\n    seekBar.on('touchmove mousemove', (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      if (seeking) {\n        // During a seek (when mouse is down or touch move active), we need to stop propagation to avoid\n        // the VR viewport reacting to the moves.\n        e.stopPropagation();\n        // Because the stopped propagation inhibits the event on the document, we need to call it from here\n        mouseTouchMoveHandler(e);\n      }\n\n      let position = 100 * this.getOffset(e);\n      this.setSeekPosition(position);\n      this.onSeekPreviewEvent(position, false);\n\n      if (this.hasLabel() && this.getLabel().isHidden()) {\n        this.getLabel().show();\n      }\n    });\n\n    // Hide seek target indicator when mouse or finger leaves seekbar\n    seekBar.on('touchend mouseleave', (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      this.setSeekPosition(0);\n\n      if (this.hasLabel()) {\n        this.getLabel().hide();\n      }\n    });\n\n    seekBarContainer.append(seekBar);\n\n    if (this.label) {\n      seekBarContainer.append(this.label.getDomElement());\n    }\n\n    return seekBarContainer;\n  }\n\n  protected updateMarkers(): void {\n    this.seekBarMarkersContainer.empty();\n\n    for (let marker of this.timelineMarkers) {\n      let className = marker.markerType === '2' ? this.prefixCss('seekbar-marker-typetwo') : this.prefixCss('seekbar-marker')\n\n      let markerDom = new DOM('div', {\n        'class': className,\n        'data-marker-time': String(marker.time),\n        'data-marker-title': String(marker.title),\n      }).css({\n        'width': marker.time + '%',\n      })\n      this.seekBarMarkersContainer.append(markerDom)\n    }\n  }\n\n  protected getMarkerAtPosition(percentage: number): TimelineMarker | null {\n    let snappedMarker: TimelineMarker = null;\n    let snappingRange = 1;\n    if (this.timelineMarkers.length > 0) {\n      for (let marker of this.timelineMarkers) {\n        if (percentage >= marker.time - snappingRange && percentage <= marker.time + snappingRange) {\n          snappedMarker = marker;\n          break;\n        }\n      }\n    }\n\n    return snappedMarker;\n  }\n\n  /**\n   * Gets the horizontal offset of a mouse/touch event point from the left edge of the seek bar.\n   * @param eventPageX the pageX coordinate of an event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1], where 0 is the left edge and 1 is the right edge\n   */\n  private getHorizontalOffset(eventPageX: number): number {\n    let elementOffsetPx = this.seekBar.offset().left;\n    let widthPx = this.seekBar.width();\n    let offsetPx = eventPageX - elementOffsetPx;\n    let offset = 1 / widthPx * offsetPx;\n\n    return this.sanitizeOffset(offset);\n  }\n\n  /**\n   * Gets the vertical offset of a mouse/touch event point from the bottom edge of the seek bar.\n   * @param eventPageY the pageX coordinate of an event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1], where 0 is the bottom edge and 1 is the top edge\n   */\n  private getVerticalOffset(eventPageY: number): number {\n    let elementOffsetPx = this.seekBar.offset().top;\n    let widthPx = this.seekBar.height();\n    let offsetPx = eventPageY - elementOffsetPx;\n    let offset = 1 / widthPx * offsetPx;\n\n    return 1 - this.sanitizeOffset(offset);\n  }\n\n  /**\n   * Gets the mouse or touch event offset for the current configuration (horizontal or vertical).\n   * @param e the event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1]\n   * @see #getHorizontalOffset\n   * @see #getVerticalOffset\n   */\n  private getOffset(e: MouseEvent | TouchEvent): number {\n    if (this.touchSupported && e instanceof TouchEvent) {\n      if (this.config.vertical) {\n        return this.getVerticalOffset(e.type === 'touchend' ? e.changedTouches[0].pageY : e.touches[0].pageY);\n      } else {\n        return this.getHorizontalOffset(e.type === 'touchend' ? e.changedTouches[0].pageX : e.touches[0].pageX);\n      }\n    }\n    else if (e instanceof MouseEvent) {\n      if (this.config.vertical) {\n        return this.getVerticalOffset(e.pageY);\n      } else {\n        return this.getHorizontalOffset(e.pageX);\n      }\n    }\n    else {\n      if (console) {\n        console.warn('invalid event');\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Sanitizes the mouse offset to the range of [0, 1].\n   *\n   * When tracking the mouse outside the seek bar, the offset can be outside the desired range and this method\n   * limits it to the desired range. E.g. a mouse event left of the left edge of a seek bar yields an offset below\n   * zero, but to display the seek target on the seek bar, we need to limit it to zero.\n   *\n   * @param offset the offset to sanitize\n   * @returns {number} the sanitized offset.\n   */\n  private sanitizeOffset(offset: number) {\n    // Since we track mouse moves over the whole document, the target can be outside the seek range,\n    // and we need to limit it to the [0, 1] range.\n    if (offset < 0) {\n      offset = 0;\n    } else if (offset > 1) {\n      offset = 1;\n    }\n\n    return offset;\n  }\n\n  /**\n   * Sets the position of the playback position indicator.\n   * @param percent a number between 0 and 100 as returned by the player\n   */\n  setPlaybackPosition(percent: number) {\n    this.playbackPositionPercentage = percent;\n\n    // Set position of the bar\n    this.setPosition(this.seekBarPlaybackPosition, percent);\n\n    // Set position of the marker\n    let px = (this.config.vertical ? this.seekBar.height() : this.seekBar.width()) / 100 * percent;\n    if (this.config.vertical) {\n      px = this.seekBar.height() - px;\n    }\n    let style = this.config.vertical ?\n      // -ms-transform required for IE9\n      { 'transform': 'translateY(' + px + 'px)', '-ms-transform': 'translateY(' + px + 'px)' } :\n      { 'transform': 'translateX(' + px + 'px)', '-ms-transform': 'translateX(' + px + 'px)' };\n    this.seekBarPlaybackPositionMarker.css(style);\n  }\n\n  /**\n   * Refreshes the playback position. Can be used by subclasses to refresh the position when\n   * the size of the component changes.\n   */\n  protected refreshPlaybackPosition() {\n    this.setPlaybackPosition(this.playbackPositionPercentage);\n  }\n\n  /**\n   * Sets the position until which media is buffered.\n   * @param percent a number between 0 and 100\n   */\n  setBufferPosition(percent: number) {\n    this.setPosition(this.seekBarBufferPosition, percent);\n  }\n\n  /**\n   * Sets the position where a seek, if executed, would jump to.\n   * @param percent a number between 0 and 100\n   */\n  setSeekPosition(percent: number) {\n    this.setPosition(this.seekBarSeekPosition, percent);\n  }\n\n  /**\n   * Set the actual position (width or height) of a DOM element that represent a bar in the seek bar.\n   * @param element the element to set the position for\n   * @param percent a number between 0 and 100\n   */\n  private setPosition(element: DOM, percent: number) {\n    let scale = percent / 100;\n    let style = this.config.vertical ?\n      // -ms-transform required for IE9\n      { 'transform': 'scaleY(' + scale + ')', '-ms-transform': 'scaleY(' + scale + ')' } :\n      { 'transform': 'scaleX(' + scale + ')', '-ms-transform': 'scaleX(' + scale + ')' };\n    element.css(style);\n  }\n\n  /**\n   * Puts the seek bar into or out of seeking state by adding/removing a class to the DOM element. This can be used\n   * to adjust the styling while seeking.\n   *\n   * @param seeking should be true when entering seek state, false when exiting the seek state\n   */\n  setSeeking(seeking: boolean) {\n    if (seeking) {\n      this.getDomElement().addClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n    } else {\n      this.getDomElement().removeClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n    }\n  }\n\n  /**\n   * Checks if the seek bar is currently in the seek state.\n   * @returns {boolean} true if in seek state, else false\n   */\n  isSeeking(): boolean {\n    return this.getDomElement().hasClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n  }\n\n  /**\n   * Checks if the seek bar has a {@link SeekBarLabel}.\n   * @returns {boolean} true if the seek bar has a label, else false\n   */\n  hasLabel(): boolean {\n    return this.label != null;\n  }\n\n  /**\n   * Gets the label of this seek bar.\n   * @returns {SeekBarLabel} the label if this seek bar has a label, else null\n   */\n  getLabel(): SeekBarLabel | null {\n    return this.label;\n  }\n\n  protected onSeekEvent() {\n    this.seekBarEvents.onSeek.dispatch(this);\n  }\n\n  protected onSeekPreviewEvent(percentage: number, scrubbing: boolean) {\n    let snappedMarker = this.getMarkerAtPosition(percentage);\n\n    if (this.label) {\n      this.label.getDomElement().css({\n        'left': (snappedMarker ? snappedMarker.time : percentage) + '%'\n      });\n    }\n\n    this.seekBarEvents.onSeekPreview.dispatch(this, {\n      scrubbing: scrubbing,\n      position: percentage,\n      marker: snappedMarker,\n    });\n  }\n\n  protected onSeekedEvent(percentage: number) {\n    this.seekBarEvents.onSeeked.dispatch(this, percentage);\n  }\n\n  /**\n   * Gets the event that is fired when a scrubbing seek operation is started.\n   * @returns {Event<SeekBar, NoArgs>}\n   */\n  get onSeek(): Event<SeekBar, NoArgs> {\n    return this.seekBarEvents.onSeek.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired during a scrubbing seek (to indicate that the seek preview, i.e. the video frame,\n   * should be updated), or during a normal seek preview when the seek bar is hovered (and the seek target,\n   * i.e. the seek bar label, should be updated).\n   * @returns {Event<SeekBar, SeekPreviewEventArgs>}\n   */\n  get onSeekPreview(): Event<SeekBar, SeekPreviewEventArgs> {\n    return this.seekBarEvents.onSeekPreview.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when a scrubbing seek has finished or when a direct seek is issued.\n   * @returns {Event<SeekBar, number>}\n   */\n  get onSeeked(): Event<SeekBar, number> {\n    return this.seekBarEvents.onSeeked.getEvent();\n  }\n\n\n  protected onShowEvent(): void {\n    super.onShowEvent();\n\n    // Refresh the position of the playback position when the seek bar becomes visible. To correctly set the position,\n    // the DOM element must be fully initialized an have its size calculated, because the position is set as an absolute\n    // value calculated from the size. This required size is not known when it is hidden.\n    // For such cases, we refresh the position here in onShow because here it is guaranteed that the component knows\n    // its size and can set the position correctly.\n    this.refreshPlaybackPosition();\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {Label, LabelConfig} from './label';\nimport {Component, ComponentConfig} from './component';\nimport {UIInstanceManager, SeekPreviewArgs} from '../uimanager';\nimport {StringUtils} from '../utils';\n\n/**\n * Configuration interface for a {@link SeekBarLabel}.\n */\nexport interface SeekBarLabelConfig extends ContainerConfig {\n  // nothing yet\n}\n\n/**\n * A label for a {@link SeekBar} that can display the seek target time, a thumbnail, and title (e.g. chapter title).\n */\nexport class SeekBarLabel extends Container<SeekBarLabelConfig> {\n\n  private timeLabel: Label<LabelConfig>;\n  private titleLabel: Label<LabelConfig>;\n  private numberLabel: Label<LabelConfig>;\n  private commentLabel: Label<LabelConfig>;\n  private avatarLabel: Label<LabelConfig>;\n  private thumbnail: Component<ComponentConfig>;\n  private metadata: Component<ComponentConfig>;\n\n  private timeFormat: string;\n\n  constructor(config: SeekBarLabelConfig = {}) {\n    super(config);\n\n    this.timeLabel = new Label({cssClasses: ['seekbar-label-time']});\n    this.titleLabel = new Label({cssClasses: ['seekbar-label-title']});\n    this.commentLabel = new Label({cssClasses: ['seekbar-label-comment']});\n    this.numberLabel = new Label({cssClasses: ['seekbar-label-number']});\n    this.avatarLabel = new Label({cssClasses: ['seekbar-label-avatar']});\n    this.thumbnail = new Component({cssClasses: ['seekbar-thumbnail']});\n    this.metadata = new Container({\n      components: [\n        new Container({\n          components: [\n            this.avatarLabel,\n            this.titleLabel,\n            this.numberLabel],\n          cssClass: 'seekbar-label-metadata-title',\n        }),\n        new Container({\n          components: [\n            this.commentLabel,\n            this.timeLabel],\n          cssClass: 'seekbar-label-metadata-content',\n        }),\n      ],\n      cssClass: 'seekbar-label-metadata'\n    });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-seekbar-label',\n      components: [new Container({\n        components: [\n          this.thumbnail,\n          this.metadata\n        ],\n        cssClass: 'seekbar-label-inner',\n      })],\n      hidden: true\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    uimanager.onSeekPreview.subscribe((sender, args: SeekPreviewArgs) => {\n      if (player.isLive()) {\n        let time = player.getMaxTimeShift() - player.getMaxTimeShift() * (args.position / 100);\n        this.setTime(time);\n      } else {\n        let percentage = 0;\n        if (args.marker) {\n          this.setTitleText(args.marker.title);\n          this.setSmashcutData(args.marker);\n          this.setTime(args.marker.time);\n          this.setThumbnail(null);\n          this.setBackground(true);\n        } else {\n          percentage = args.position;\n          this.setTitleText(null);\n          this.setSmashcutData(null);\n          let time = player.getDuration() * (percentage / 100);\n          this.setTime(time);\n          this.setThumbnail(player.getThumb(time));\n          this.setBackground(false);\n        }\n      }\n    });\n\n    let init = () => {\n      // Set time format depending on source duration\n      this.timeFormat = Math.abs(player.isLive() ? player.getMaxTimeShift() : player.getDuration()) >= 3600 ?\n        StringUtils.FORMAT_HHMMSS : StringUtils.FORMAT_MMSS;\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, init);\n    init();\n  }\n\n  /**\n   * Sets arbitrary text on the label.\n   * @param text the text to show on the label\n   */\n  setText(text: string) {\n    this.timeLabel.setText(text);\n  }\n\n  /**\n   * Sets a time to be displayed on the label.\n   * @param seconds the time in seconds to display on the label\n   */\n  setTime(seconds: number) {\n    this.setText(StringUtils.secondsToTime(seconds, this.timeFormat));\n  }\n\n  /**\n   * Sets the text on the title label.\n   * @param text the text to show on the label\n   */\n  setTitleText(text: string) {\n    this.titleLabel.setText(text);\n  }\n\n  setSmashcutData(marker: any) {\n    if (marker) {\n      this.commentLabel.setText(marker.comment);\n      this.numberLabel.setText(marker.number);\n      this.avatarLabel.setText(marker.avatar);\n    } else {\n      this.commentLabel.setText(null);\n      this.numberLabel.setText(null);\n      this.avatarLabel.setText(null);\n    }\n  }\n\n  /**\n   * Sets or removes a thumbnail on the label.\n   * @param thumbnail the thumbnail to display on the label or null to remove a displayed thumbnail\n   */\n  setThumbnail(thumbnail: bitmovin.player.Thumbnail = null) {\n    let thumbnailElement = this.thumbnail.getDomElement();\n\n    if (thumbnail == null) {\n      thumbnailElement.css({\n        'background-image': null,\n        'display': 'null',\n        'width': 'null',\n        'height': 'null'\n      });\n    }\n    else {\n      thumbnailElement.css({\n        'display': 'inherit',\n        'background-image': `url(${thumbnail.url})`,\n        'width': thumbnail.w + 'px',\n        'height': thumbnail.h + 'px',\n        'background-position': `-${thumbnail.x}px -${thumbnail.y}px`\n      });\n    }\n  }\n\n  setBackground(onOff: boolean) {\n    let metadataElement = this.metadata.getDomElement();\n\n    if (onOff) {\n      metadataElement.css({\n        'background': '#000'\n      });\n    }\n    else {\n      metadataElement.css({\n        'background': 'initial'\n      });\n    }\n  }\n}","import {ListSelector, ListSelectorConfig} from './listselector';\nimport {DOM} from '../dom';\n\n/**\n * A simple select box providing the possibility to select a single item out of a list of available items.\n *\n * DOM example:\n * <code>\n *     <select class='ui-selectbox'>\n *         <option value='key'>label</option>\n *         ...\n *     </select>\n * </code>\n */\nexport class SelectBox extends ListSelector<ListSelectorConfig> {\n\n  private selectElement: DOM;\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-selectbox'\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    let selectElement = new DOM('select', {\n      'id': this.config.id,\n      'class': this.getCssClasses()\n    });\n\n    this.selectElement = selectElement;\n    this.updateDomItems();\n\n    selectElement.on('change', () => {\n      let value = selectElement.val();\n      this.onItemSelectedEvent(value, false);\n    });\n\n    return selectElement;\n  }\n\n  protected updateDomItems(selectedValue: string = null) {\n    // Delete all children\n    this.selectElement.empty();\n\n    // Add updated children\n    for (let item of this.items) {\n      let optionElement = new DOM('option', {\n        'value': item.key\n      }).html(item.label);\n\n      if (item.key === selectedValue + '') { // convert selectedValue to string to catch 'null'/null case\n        optionElement.attr('selected', 'selected');\n      }\n\n      this.selectElement.append(optionElement);\n    }\n  }\n\n  protected onItemAddedEvent(value: string) {\n    super.onItemAddedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemRemovedEvent(value: string) {\n    super.onItemRemovedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemSelectedEvent(value: string, updateDomItems: boolean = true) {\n    super.onItemSelectedEvent(value);\n    if (updateDomItems) {\n      this.updateDomItems(value);\n    }\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {SelectBox} from './selectbox';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {VideoQualitySelectBox} from './videoqualityselectbox';\nimport {AudioQualitySelectBox} from './audioqualityselectbox';\nimport {Timeout} from '../timeout';\nimport {Event, EventDispatcher, NoArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link SettingsPanel}.\n */\nexport interface SettingsPanelConfig extends ContainerConfig {\n  /**\n   * The delay in milliseconds after which the settings panel will be hidden when there is no user interaction.\n   * Set to -1 to disable automatic hiding.\n   * Default: 3 seconds (3000)\n   */\n  hideDelay?: number;\n}\n\n/**\n * A panel containing a list of {@link SettingsPanelItem items} that represent labelled settings.\n */\nexport class SettingsPanel extends Container<SettingsPanelConfig> {\n\n  private static readonly CLASS_LAST = 'last';\n\n  private settingsPanelEvents = {\n    onSettingsStateChanged: new EventDispatcher<SettingsPanel, NoArgs>()\n  };\n\n  private hideTimeout: Timeout;\n\n  constructor(config: SettingsPanelConfig) {\n    super(config);\n\n    this.config = this.mergeConfig<SettingsPanelConfig>(config, {\n      cssClass: 'ui-settings-panel',\n      hideDelay: 3000\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <SettingsPanelConfig>this.getConfig(); // TODO fix generics type inference\n\n    if (config.hideDelay > -1) {\n      this.hideTimeout = new Timeout(config.hideDelay, () => {\n        this.hide();\n      });\n\n      this.onShow.subscribe(() => {\n        // Activate timeout when shown\n        this.hideTimeout.start();\n      });\n      this.getDomElement().on('mousemove', () => {\n        // Reset timeout on interaction\n        this.hideTimeout.reset();\n      });\n      this.onHide.subscribe(() => {\n        // Clear timeout when hidden from outside\n        this.hideTimeout.clear();\n      });\n    }\n\n    // Fire event when the state of a settings-item has changed\n    let settingsStateChangedHandler = () => {\n      this.onSettingsStateChangedEvent();\n\n      // Attach marker class to last visible item\n      let lastShownItem = null;\n      for (let component of this.getItems()) {\n        if (component instanceof SettingsPanelItem) {\n          component.getDomElement().removeClass(this.prefixCss(SettingsPanel.CLASS_LAST));\n          if (component.isShown()) {\n            lastShownItem = component;\n          }\n        }\n      }\n      if (lastShownItem) {\n        lastShownItem.getDomElement().addClass(this.prefixCss(SettingsPanel.CLASS_LAST));\n      }\n    };\n    for (let component of this.getItems()) {\n      if (component instanceof SettingsPanelItem) {\n        component.onActiveChanged.subscribe(settingsStateChangedHandler);\n      }\n    }\n  }\n\n  release(): void {\n    super.release();\n    if (this.hideTimeout) {\n      this.hideTimeout.clear();\n    }\n  }\n\n  /**\n   * Checks if there are active settings within this settings panel. An active setting is a setting that is visible\n   * and enabled, which the user can interact with.\n   * @returns {boolean} true if there are active settings, false if the panel is functionally empty to a user\n   */\n  hasActiveSettings(): boolean {\n    for (let component of this.getItems()) {\n      if (component.isActive()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private getItems(): SettingsPanelItem[] {\n    return <SettingsPanelItem[]>this.config.components;\n  }\n\n  protected onSettingsStateChangedEvent() {\n    this.settingsPanelEvents.onSettingsStateChanged.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when one or more {@link SettingsPanelItem items} have changed state.\n   * @returns {Event<SettingsPanel, NoArgs>}\n   */\n  get onSettingsStateChanged(): Event<SettingsPanel, NoArgs> {\n    return this.settingsPanelEvents.onSettingsStateChanged.getEvent();\n  }\n}\n\n/**\n * An item for a {@link SettingsPanel}, containing a {@link Label} and a component that configures a setting.\n * Supported setting components: {@link SelectBox}\n */\nexport class SettingsPanelItem extends Container<ContainerConfig> {\n\n  private label: Label<LabelConfig>;\n  private setting: SelectBox;\n\n  private settingsPanelItemEvents = {\n    onActiveChanged: new EventDispatcher<SettingsPanelItem, NoArgs>()\n  };\n\n  constructor(label: string, selectBox: SelectBox, config: ContainerConfig = {}) {\n    super(config);\n\n    this.label = new Label({ text: label });\n    this.setting = selectBox;\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-settings-panel-item',\n      components: [this.label, this.setting]\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let handleConfigItemChanged = () => {\n      // The minimum number of items that must be available for the setting to be displayed\n      // By default, at least two items must be available, else a selection is not possible\n      let minItemsToDisplay = 2;\n      // Audio/video quality select boxes contain an additional 'auto' mode, which in combination with a single\n      // available quality also does not make sense\n      if (this.setting instanceof VideoQualitySelectBox || this.setting instanceof AudioQualitySelectBox) {\n        minItemsToDisplay = 3;\n      }\n\n      // Hide the setting if no meaningful choice is available\n      if (this.setting.itemCount() < minItemsToDisplay) {\n        this.hide();\n      } else {\n        this.show();\n      }\n\n      // Visibility might have changed and therefore the active state might have changed so we fire the event\n      // TODO fire only when state has really changed (e.g. check if visibility has really changed)\n      this.onActiveChangedEvent();\n    };\n\n    this.setting.onItemAdded.subscribe(handleConfigItemChanged);\n    this.setting.onItemRemoved.subscribe(handleConfigItemChanged);\n\n    // Initialize hidden state\n    handleConfigItemChanged();\n  }\n\n  /**\n   * Checks if this settings panel item is active, i.e. visible and enabled and a user can interact with it.\n   * @returns {boolean} true if the panel is active, else false\n   */\n  isActive(): boolean {\n    return this.isShown();\n  }\n\n  protected onActiveChangedEvent() {\n    this.settingsPanelItemEvents.onActiveChanged.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the 'active' state of this item changes.\n   * @see #isActive\n   * @returns {Event<SettingsPanelItem, NoArgs>}\n   */\n  get onActiveChanged(): Event<SettingsPanelItem, NoArgs> {\n    return this.settingsPanelItemEvents.onActiveChanged.getEvent();\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {SettingsPanel} from './settingspanel';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Configuration interface for the {@link SettingsToggleButton}.\n */\nexport interface SettingsToggleButtonConfig extends ToggleButtonConfig {\n  /**\n   * The settings panel whose visibility the button should toggle.\n   */\n  settingsPanel: SettingsPanel;\n\n  /**\n   * Decides if the button should be automatically hidden when the settings panel does not contain any active settings.\n   * Default: true\n   */\n  autoHideWhenNoActiveSettings?: boolean;\n}\n\n/**\n * A button that toggles visibility of a settings panel.\n */\nexport class SettingsToggleButton extends ToggleButton<SettingsToggleButtonConfig> {\n\n  constructor(config: SettingsToggleButtonConfig) {\n    super(config);\n\n    if (!config.settingsPanel) {\n      throw new Error('Required SettingsPanel is missing');\n    }\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-settingstogglebutton',\n      text: 'Settings',\n      settingsPanel: null,\n      autoHideWhenNoActiveSettings: true\n    }, <SettingsToggleButtonConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <SettingsToggleButtonConfig>this.getConfig(); // TODO fix generics type inference\n    let settingsPanel = config.settingsPanel;\n\n    this.onClick.subscribe(() => {\n      settingsPanel.toggleHidden();\n    });\n    settingsPanel.onShow.subscribe(() => {\n      // Set toggle status to on when the settings panel shows\n      this.on();\n    });\n    settingsPanel.onHide.subscribe(() => {\n      // Set toggle status to off when the settings panel hides\n      this.off();\n    });\n\n    // Handle automatic hiding of the button if there are no settings for the user to interact with\n    if (config.autoHideWhenNoActiveSettings) {\n      // Setup handler to show/hide button when the settings change\n      let settingsPanelItemsChangedHandler = () => {\n        if (settingsPanel.hasActiveSettings()) {\n          if (this.isHidden()) {\n            this.show();\n          }\n        } else {\n          if (this.isShown()) {\n            this.hide();\n          }\n        }\n      };\n      // Wire the handler to the event\n      settingsPanel.onSettingsStateChanged.subscribe(settingsPanelItemsChangedHandler);\n      // Call handler for first init at startup\n      settingsPanelItemsChangedHandler();\n    }\n  }\n}","import {Component, ComponentConfig} from './component';\n\n/**\n * A dummy component that just reserves some space and does nothing else.\n */\nexport class Spacer extends Component<ComponentConfig> {\n\n  constructor(config: ComponentConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-spacer',\n    }, this.config);\n  }\n\n\n  protected onShowEvent(): void {\n    // disable event firing by overwriting and not calling super\n  }\n\n  protected onHideEvent(): void {\n    // disable event firing by overwriting and not calling super\n  }\n\n  protected onHoverChangedEvent(hovered: boolean): void {\n    // disable event firing by overwriting and not calling super\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport SubtitleCueEvent = bitmovin.player.SubtitleCueEvent;\nimport {Label, LabelConfig} from './label';\nimport {ComponentConfig, Component} from './component';\nimport {ControlBar} from './controlbar';\n\n/**\n * Overlays the player to display subtitles.\n */\nexport class SubtitleOverlay extends Container<ContainerConfig> {\n\n  private static readonly CLASS_CONTROLBAR_VISIBLE = 'controlbar-visible';\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitle-overlay',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let subtitleManager = new ActiveSubtitleManager();\n\n    player.addEventHandler(player.EVENT.ON_CUE_ENTER, (event: SubtitleCueEvent) => {\n      let labelToAdd = subtitleManager.cueEnter(event);\n\n      this.addComponent(labelToAdd);\n      this.updateComponents();\n\n      this.show();\n    });\n    player.addEventHandler(player.EVENT.ON_CUE_EXIT, (event: SubtitleCueEvent) => {\n      let labelToRemove = subtitleManager.cueExit(event);\n\n      this.removeComponent(labelToRemove);\n      this.updateComponents();\n\n      if (!subtitleManager.hasCues) {\n        this.hide();\n      }\n    });\n\n    let subtitleClearHandler = () => {\n      this.hide();\n      subtitleManager.clear();\n      this.removeComponents();\n      this.updateComponents();\n    };\n\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_CHANGED, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_SEEK, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, subtitleClearHandler);\n\n    uimanager.onComponentShow.subscribe((component: Component<ComponentConfig>) => {\n      if (component instanceof ControlBar) {\n        this.getDomElement().addClass(this.prefixCss(SubtitleOverlay.CLASS_CONTROLBAR_VISIBLE));\n      }\n    });\n    uimanager.onComponentHide.subscribe((component: Component<ComponentConfig>) => {\n      if (component instanceof ControlBar) {\n        this.getDomElement().removeClass(this.prefixCss(SubtitleOverlay.CLASS_CONTROLBAR_VISIBLE));\n      }\n    });\n\n    // Init\n    subtitleClearHandler();\n  }\n}\n\ninterface ActiveSubtitleCue {\n  event: SubtitleCueEvent;\n  label: SubtitleLabel;\n}\n\ninterface ActiveSubtitleCueMap {\n  [id: string]: ActiveSubtitleCue;\n}\n\nclass SubtitleLabel extends Label<LabelConfig> {\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitle-label'\n    }, this.config);\n  }\n}\n\nclass ActiveSubtitleManager {\n\n  private activeSubtitleCueMap: ActiveSubtitleCueMap;\n\n  constructor() {\n    this.activeSubtitleCueMap = {};\n  }\n\n  /**\n   * Calculates a unique ID for a subtitle cue, which is needed to associate an ON_CUE_ENTER with its ON_CUE_EXIT\n   * event so we can remove the correct subtitle in ON_CUE_EXIT when multiple subtitles are active at the same time.\n   * The start time plus the text should make a unique identifier, and in the only case where a collision\n   * can happen, two similar texts will displayed at a similar time so it does not matter which one we delete.\n   * The start time should always be known, because it is required to schedule the ON_CUE_ENTER event. The end time\n   * must not necessarily be known and therefore cannot be used for the ID.\n   * @param event\n   * @return {string}\n   */\n  private static calculateId(event: SubtitleCueEvent): string {\n    return event.start + event.text;\n  }\n\n  /**\n   * Adds a subtitle cue to the manager and returns the label that should be added to the subtitle overlay.\n   * @param event\n   * @return {SubtitleLabel}\n   */\n  cueEnter(event: SubtitleCueEvent): SubtitleLabel {\n    let id = ActiveSubtitleManager.calculateId(event);\n\n    let label = new SubtitleLabel({\n      // Prefer the HTML subtitle text if set, else use the plain text\n      text: event.html || event.text\n    });\n\n    this.activeSubtitleCueMap[id] = { event, label };\n\n    return label;\n  }\n\n  /**\n   * Removes the subtitle cue from the manager and returns the label that should be removed from the subtitle overlay.\n   * @param event\n   * @return {SubtitleLabel}\n   */\n  cueExit(event: SubtitleCueEvent): SubtitleLabel {\n    let id = ActiveSubtitleManager.calculateId(event);\n    let activeSubtitleCue = this.activeSubtitleCueMap[id];\n    delete this.activeSubtitleCueMap[id];\n    return activeSubtitleCue.label;\n  }\n\n  /**\n   * Returns the number of active subtitle cues.\n   * @return {number}\n   */\n  get cueCount(): number {\n    return Object.keys(this.activeSubtitleCueMap).length;\n  }\n\n  /**\n   * Returns true if there are active subtitle cues, else false.\n   * @return {boolean}\n   */\n  get hasCues(): boolean {\n    return this.cueCount > 0;\n  }\n\n  /**\n   * Removes all subtitle cues from the manager.\n   */\n  clear(): void {\n    this.activeSubtitleCueMap = {};\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\nimport SubtitleAddedEvent = bitmovin.player.SubtitleAddedEvent;\nimport SubtitleChangedEvent = bitmovin.player.SubtitleChangedEvent;\nimport SubtitleRemovedEvent = bitmovin.player.SubtitleRemovedEvent;\n\n/**\n * A select box providing a selection between available subtitle and caption tracks.\n */\nexport class SubtitleSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let getLabel = (id: string) => {\n      switch (id) {\n        case 'off' :\n          return 'Off'\n        case 'en' :\n          return 'English'\n        case 'fr' :\n          return 'Francais'\n        case 'de' :\n          return 'Deutsch'\n        case 'es' :\n          return 'Espaniol'\n        default:\n          return id\n      }\n    }\n\n    let updateSubtitles = () => {\n      this.clearItems();\n\n      for (let subtitle of player.getAvailableSubtitles()) {\n        this.addItem(subtitle.id, getLabel(subtitle.label));\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: SubtitleSelectBox, value: string) => {\n      player.setSubtitle(value === 'null' ? null : value);\n    });\n\n    // React to API events\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_ADDED, (event: SubtitleAddedEvent) => {\n      this.addItem(event.subtitle.id, event.subtitle.label);\n    });\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_CHANGED, (event: SubtitleChangedEvent) => {\n      this.selectItem(event.targetSubtitle.id);\n    });\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_REMOVED, (event: SubtitleRemovedEvent) => {\n      this.removeItem(event.subtitleId);\n    });\n\n    // Update subtitles when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateSubtitles);\n    // Update subtitles when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateSubtitles);\n\n    // Populate subtitles at startup\n    updateSubtitles();\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {MetadataLabel, MetadataLabelContent} from './metadatalabel';\n\n/**\n * Configuration interface for a {@link TitleBar}.\n */\nexport interface TitleBarConfig extends ContainerConfig {\n  /**\n   * Specifies if the title bar should stay hidden when no metadata label contains any text. Does not make a lot\n   * of sense if the title bar contains other components than just MetadataLabels (like in the default configuration).\n   * Default: false\n   */\n  keepHiddenWithoutMetadata?: boolean;\n}\n\n/**\n * Displays a title bar containing a label with the title of the video.\n */\nexport class TitleBar extends Container<TitleBarConfig> {\n\n  constructor(config: TitleBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-titlebar',\n      hidden: true,\n      components: [\n        new MetadataLabel({ content: MetadataLabelContent.Title }),\n        new MetadataLabel({ content: MetadataLabelContent.Description })\n      ],\n      keepHiddenWithoutMetadata: false,\n    }, <TitleBarConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <TitleBarConfig>this.getConfig();\n    let shouldBeShown = !this.isHidden();\n    let hasMetadataText = true; // Flag to track if any metadata label contains text\n\n    let checkMetadataTextAndUpdateVisibility = () => {\n      hasMetadataText = false;\n\n      // Iterate through metadata labels and check if at least one of them contains text\n      for (let component of this.getComponents()) {\n        if (component instanceof MetadataLabel) {\n          if (!component.isEmpty()) {\n            hasMetadataText = true;\n            break;\n          }\n        }\n      }\n\n      if (this.isShown()) {\n        // Hide a visible titlebar if it does not contain any text and the hidden flag is set\n        if (config.keepHiddenWithoutMetadata && !hasMetadataText) {\n          this.hide();\n        }\n      } else if (shouldBeShown) {\n        // Show a hidden titlebar if it should actually be shown\n        this.show();\n      }\n    };\n\n    // Listen to text change events to update the hasMetadataText flag when the metadata dynamically changes\n    for (let component of this.getComponents()) {\n      if (component instanceof MetadataLabel) {\n        component.onTextChanged.subscribe(checkMetadataTextAndUpdateVisibility);\n      }\n    }\n\n    uimanager.onControlsShow.subscribe(() => {\n      shouldBeShown = true;\n      if (!(config.keepHiddenWithoutMetadata && !hasMetadataText)) {\n        this.show();\n      }\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      shouldBeShown = false;\n      this.hide();\n    });\n\n    // init\n    checkMetadataTextAndUpdateVisibility();\n  }\n}","import {Button, ButtonConfig} from './button';\nimport {NoArgs, EventDispatcher, Event} from '../eventdispatcher';\n\n/**\n * Configuration interface for a toggle button component.\n */\nexport interface ToggleButtonConfig extends ButtonConfig {\n  /**\n   * The text on the button.\n   */\n  text?: string;\n}\n\n/**\n * A button that can be toggled between 'on' and 'off' states.\n */\nexport class ToggleButton<Config extends ToggleButtonConfig> extends Button<ToggleButtonConfig> {\n\n  private static readonly CLASS_ON = 'on';\n  private static readonly CLASS_OFF = 'off';\n\n  private onState: boolean;\n\n  private toggleButtonEvents = {\n    onToggle: new EventDispatcher<ToggleButton<Config>, NoArgs>(),\n    onToggleOn: new EventDispatcher<ToggleButton<Config>, NoArgs>(),\n    onToggleOff: new EventDispatcher<ToggleButton<Config>, NoArgs>()\n  };\n\n  constructor(config: ToggleButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-togglebutton'\n    }, this.config);\n  }\n\n  /**\n   * Toggles the button to the 'on' state.\n   */\n  on() {\n    if (this.isOff()) {\n      this.onState = true;\n      this.getDomElement().removeClass(this.prefixCss(ToggleButton.CLASS_OFF));\n      this.getDomElement().addClass(this.prefixCss(ToggleButton.CLASS_ON));\n\n      this.onToggleEvent();\n      this.onToggleOnEvent();\n    }\n  }\n\n  /**\n   * Toggles the button to the 'off' state.\n   */\n  off() {\n    if (this.isOn()) {\n      this.onState = false;\n      this.getDomElement().removeClass(this.prefixCss(ToggleButton.CLASS_ON));\n      this.getDomElement().addClass(this.prefixCss(ToggleButton.CLASS_OFF));\n\n      this.onToggleEvent();\n      this.onToggleOffEvent();\n    }\n  }\n\n  /**\n   * Toggle the button 'on' if it is 'off', or 'off' if it is 'on'.\n   */\n  toggle() {\n    if (this.isOn()) {\n      this.off();\n    } else {\n      this.on();\n    }\n  }\n\n  /**\n   * Checks if the toggle button is in the 'on' state.\n   * @returns {boolean} true if button is 'on', false if 'off'\n   */\n  isOn(): boolean {\n    return this.onState;\n  }\n\n  /**\n   * Checks if the toggle button is in the 'off' state.\n   * @returns {boolean} true if button is 'off', false if 'on'\n   */\n  isOff(): boolean {\n    return !this.isOn();\n  }\n\n  protected onClickEvent() {\n    super.onClickEvent();\n\n    // Fire the toggle event together with the click event\n    // (they are technically the same, only the semantics are different)\n    this.onToggleEvent();\n  }\n\n  protected onToggleEvent() {\n    this.toggleButtonEvents.onToggle.dispatch(this);\n  }\n\n  protected onToggleOnEvent() {\n    this.toggleButtonEvents.onToggleOn.dispatch(this);\n  }\n\n  protected onToggleOffEvent() {\n    this.toggleButtonEvents.onToggleOff.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggle(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggle.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled 'on'.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggleOn(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggleOn.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled 'off'.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggleOff(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggleOff.getEvent();\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\n\n/**\n * Animated analog TV static noise.\n */\nexport class TvNoiseCanvas extends Component<ComponentConfig> {\n\n  private canvas: DOM;\n\n  private canvasElement: HTMLCanvasElement;\n  private canvasContext: CanvasRenderingContext2D;\n  private canvasWidth = 160;\n  private canvasHeight = 90;\n  private interferenceHeight = 50;\n  private lastFrameUpdate: number = 0;\n  private frameInterval: number = 60;\n  private useAnimationFrame: boolean = !!window.requestAnimationFrame;\n  private noiseAnimationWindowPos: number;\n  private frameUpdateHandlerId: number;\n\n  constructor(config: ComponentConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-tvnoisecanvas'\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    return this.canvas = new DOM('canvas', { 'class': this.getCssClasses() });\n  }\n\n  start(): void {\n    this.canvasElement = <HTMLCanvasElement>this.canvas.getElements()[0];\n    this.canvasContext = this.canvasElement.getContext('2d');\n    this.noiseAnimationWindowPos = -this.canvasHeight;\n    this.lastFrameUpdate = 0;\n\n    this.canvasElement.width = this.canvasWidth;\n    this.canvasElement.height = this.canvasHeight;\n\n    this.renderFrame();\n  }\n\n  stop(): void {\n    if (this.useAnimationFrame) {\n      cancelAnimationFrame(this.frameUpdateHandlerId);\n    } else {\n      clearTimeout(this.frameUpdateHandlerId);\n    }\n  }\n\n  private renderFrame(): void {\n    // This code has been copied from the player controls.js and simplified\n\n    if (this.lastFrameUpdate + this.frameInterval > new Date().getTime()) {\n      // It's too early to render the next frame\n      this.scheduleNextRender();\n      return;\n    }\n\n    let currentPixelOffset;\n    let canvasWidth = this.canvasWidth;\n    let canvasHeight = this.canvasHeight;\n\n    // Create texture\n    let noiseImage = this.canvasContext.createImageData(canvasWidth, canvasHeight);\n\n    // Fill texture with noise\n    for (let y = 0; y < canvasHeight; y++) {\n      for (let x = 0; x < canvasWidth; x++) {\n        currentPixelOffset = (canvasWidth * y * 4) + x * 4;\n        noiseImage.data[currentPixelOffset] = Math.random() * 255;\n        if (y < this.noiseAnimationWindowPos || y > this.noiseAnimationWindowPos + this.interferenceHeight) {\n          noiseImage.data[currentPixelOffset] *= 0.85;\n        }\n        noiseImage.data[currentPixelOffset + 1] = noiseImage.data[currentPixelOffset];\n        noiseImage.data[currentPixelOffset + 2] = noiseImage.data[currentPixelOffset];\n        noiseImage.data[currentPixelOffset + 3] = 50;\n      }\n    }\n\n    // Put texture onto canvas\n    this.canvasContext.putImageData(noiseImage, 0, 0);\n\n    this.lastFrameUpdate = new Date().getTime();\n    this.noiseAnimationWindowPos += 7;\n    if (this.noiseAnimationWindowPos > canvasHeight) {\n      this.noiseAnimationWindowPos = -canvasHeight;\n    }\n\n    this.scheduleNextRender();\n  }\n\n  private scheduleNextRender(): void {\n    if (this.useAnimationFrame) {\n      this.frameUpdateHandlerId = window.requestAnimationFrame(this.renderFrame.bind(this));\n    } else {\n      this.frameUpdateHandlerId = setTimeout(this.renderFrame.bind(this), this.frameInterval);\n    }\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {DOM} from '../dom';\nimport {Timeout} from '../timeout';\nimport {PlayerUtils} from '../utils';\nimport PlayerResizeEvent = bitmovin.player.PlayerResizeEvent;\nimport {CancelEventArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link UIContainer}.\n */\nexport interface UIContainerConfig extends ContainerConfig {\n  /**\n   * The delay in milliseconds after which the control bar will be hidden when there is no user interaction.\n   * Default: 5 seconds (5000)\n   */\n  hideDelay?: number;\n}\n\n/**\n * The base container that contains all of the UI. The UIContainer is passed to the {@link UIManager} to build and\n * setup the UI.\n */\nexport class UIContainer extends Container<UIContainerConfig> {\n\n  private static readonly STATE_PREFIX = 'player-state-';\n\n  private static readonly FULLSCREEN = 'fullscreen';\n  private static readonly BUFFERING = 'buffering';\n  private static readonly REMOTE_CONTROL = 'remote-control';\n  private static readonly CONTROLS_SHOWN = 'controls-shown';\n  private static readonly CONTROLS_HIDDEN = 'controls-hidden';\n\n  private uiHideTimeout: Timeout;\n\n  constructor(config: UIContainerConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <UIContainerConfig>{\n      cssClass: 'ui-uicontainer',\n      hideDelay: 5000,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.configureUIShowHide(player, uimanager);\n    this.configurePlayerStates(player, uimanager);\n  }\n\n  private configureUIShowHide(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let container = this.getDomElement();\n    let config = <UIContainerConfig>this.getConfig();\n\n    let isUiShown = false;\n    let isSeeking = false;\n    let isFirstTouch = true;\n\n    let showUi = () => {\n      if (!isUiShown) {\n        // Let subscribers know that they should reveal themselves\n        uimanager.onControlsShow.dispatch(this);\n        isUiShown = true;\n      }\n      // Don't trigger timeout while seeking (it will be triggered once the seek is finished) or casting\n      if (!isSeeking && !player.isCasting()) {\n        this.uiHideTimeout.start();\n      }\n    };\n\n    let hideUi = () => {\n      // Hide the UI only if it is shown, and if not casting\n      if (isUiShown && !player.isCasting()) {\n        // Issue a preview event to check if we are good to hide the controls\n        let previewHideEventArgs = <CancelEventArgs>{};\n        uimanager.onPreviewControlsHide.dispatch(this, previewHideEventArgs);\n\n        if (!previewHideEventArgs.cancel) {\n          // If the preview wasn't canceled, let subscribers know that they should now hide themselves\n          uimanager.onControlsHide.dispatch(this);\n          isUiShown = false;\n        } else {\n          // If the hide preview was canceled, continue to show UI\n          showUi();\n        }\n      }\n    };\n\n    // Timeout to defer UI hiding by the configured delay time\n    this.uiHideTimeout = new Timeout(config.hideDelay, hideUi);\n\n    // On touch displays, the first touch reveals the UI\n    container.on('touchend', (e) => {\n      if (!isUiShown) {\n        // Only if the UI is hidden, we prevent other actions (except for the first touch) and reveal the UI instead.\n        // The first touch is not prevented to let other listeners receive the event and trigger an initial action, e.g.\n        // the huge playback button can directly start playback instead of requiring a double tap which 1. reveals\n        // the UI and 2. starts playback.\n        if (isFirstTouch) {\n          isFirstTouch = false;\n        } else {\n          e.preventDefault();\n        }\n        showUi();\n      }\n    });\n    // When the mouse enters, we show the UI\n    container.on('mouseenter', () => {\n      showUi();\n    });\n    // When the mouse moves within, we show the UI\n    container.on('mousemove', () => {\n      showUi();\n    });\n    // When the mouse leaves, we can prepare to hide the UI, except a seek is going on\n    container.on('mouseleave', () => {\n      // When a seek is going on, the seek scrub pointer may exit the UI area while still seeking, and we do not hide\n      // the UI in such cases\n      if (!isSeeking) {\n        this.uiHideTimeout.start();\n      }\n    });\n\n    uimanager.onSeek.subscribe(() => {\n      this.uiHideTimeout.clear(); // Don't hide UI while a seek is in progress\n      isSeeking = true;\n    });\n    uimanager.onSeeked.subscribe(() => {\n      isSeeking = false;\n      this.uiHideTimeout.start(); // Re-enable UI hide timeout after a seek\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      showUi(); // Show UI when a Cast session has started (UI will then stay permanently on during the session)\n    });\n  }\n\n  private configurePlayerStates(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    let container = this.getDomElement();\n\n    // Convert player states into CSS class names\n    let stateClassNames = <any>[];\n    for (let state in PlayerUtils.PlayerState) {\n      if (isNaN(Number(state))) {\n        let enumName = PlayerUtils.PlayerState[<any>PlayerUtils.PlayerState[state]];\n        stateClassNames[PlayerUtils.PlayerState[state]] =\n          this.prefixCss(UIContainer.STATE_PREFIX + enumName.toLowerCase());\n      }\n    }\n\n    let removeStates = () => {\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.IDLE]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PREPARED]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PLAYING]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PAUSED]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.FINISHED]);\n    };\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PREPARED]);\n    });\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PLAYING]);\n    });\n    player.addEventHandler(player.EVENT.ON_PAUSED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PAUSED]);\n    });\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.FINISHED]);\n    });\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.IDLE]);\n    });\n    // Init in current player state\n    container.addClass(stateClassNames[PlayerUtils.getState(player)]);\n\n    // Fullscreen marker class\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_ENTER, () => {\n      container.addClass(this.prefixCss(UIContainer.FULLSCREEN));\n    });\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_EXIT, () => {\n      container.removeClass(this.prefixCss(UIContainer.FULLSCREEN));\n    });\n    // Init fullscreen state\n    if (player.isFullscreen()) {\n      container.addClass(this.prefixCss(UIContainer.FULLSCREEN));\n    }\n\n    // Buffering marker class\n    player.addEventHandler(player.EVENT.ON_STALL_STARTED, () => {\n      container.addClass(this.prefixCss(UIContainer.BUFFERING));\n    });\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, () => {\n      container.removeClass(this.prefixCss(UIContainer.BUFFERING));\n    });\n    // Init buffering state\n    if (player.isStalled()) {\n      container.addClass(this.prefixCss(UIContainer.BUFFERING));\n    }\n\n    // RemoteControl marker class\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      container.addClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, () => {\n      container.removeClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    });\n    // Init RemoteControl state\n    if (player.isCasting()) {\n      container.addClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    }\n\n    // Controls visibility marker class\n    uimanager.onControlsShow.subscribe(() => {\n      container.removeClass(this.prefixCss(UIContainer.CONTROLS_HIDDEN));\n      container.addClass(this.prefixCss(UIContainer.CONTROLS_SHOWN));\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      container.removeClass(this.prefixCss(UIContainer.CONTROLS_SHOWN));\n      container.addClass(this.prefixCss(UIContainer.CONTROLS_HIDDEN));\n    });\n\n    // Layout size classes\n    let updateLayoutSizeClasses = (width: number, height: number) => {\n      container.removeClass(this.prefixCss('layout-max-width-400'));\n      container.removeClass(this.prefixCss('layout-max-width-600'));\n      container.removeClass(this.prefixCss('layout-max-width-800'));\n      container.removeClass(this.prefixCss('layout-max-width-1200'));\n\n      if (width <= 400) {\n        container.addClass(this.prefixCss('layout-max-width-400'));\n      } else if (width <= 600) {\n        container.addClass(this.prefixCss('layout-max-width-600'));\n      } else if (width <= 800) {\n        container.addClass(this.prefixCss('layout-max-width-800'));\n      } else if (width <= 1200) {\n        container.addClass(this.prefixCss('layout-max-width-1200'));\n      }\n    };\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, (e: PlayerResizeEvent) => {\n      // Convert strings (with \"px\" suffix) to ints\n      let width = Math.round(Number(e.width.substring(0, e.width.length - 2)));\n      let height = Math.round(Number(e.height.substring(0, e.height.length - 2)));\n\n      updateLayoutSizeClasses(width, height);\n    });\n\n    // Init layout state\n    updateLayoutSizeClasses(new DOM(player.getFigure()).width(), new DOM(player.getFigure()).height());\n  }\n\n  release(): void {\n    super.release();\n    this.uiHideTimeout.clear();\n  }\n\n  protected toDomElement(): DOM {\n    let container = super.toDomElement();\n\n    // Detect flexbox support (not supported in IE9)\n    if (document && typeof document.createElement('p').style.flex !== 'undefined') {\n      container.addClass(this.prefixCss('flexbox'));\n    } else {\n      container.addClass(this.prefixCss('no-flexbox'));\n    }\n\n    return container;\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between 'auto' and the available video qualities.\n */\nexport class VideoQualitySelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let updateVideoQualities = () => {\n      let videoQualities = player.getAvailableVideoQualities();\n\n      this.clearItems();\n\n      // Add entry for automatic quality switching (default setting)\n      this.addItem('Auto', 'Auto');\n\n      // Add video qualities\n      for (let videoQuality of videoQualities) {\n        this.addItem(videoQuality.id, videoQuality.label);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender: VideoQualitySelectBox, value: string) => {\n      player.setVideoQuality(value);\n    });\n\n    // Update qualities when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateVideoQualities);\n    // Update qualities when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateVideoQualities);\n    // Update quality selection when quality is changed (from outside)\n    player.addEventHandler(player.EVENT.ON_VIDEO_DOWNLOAD_QUALITY_CHANGE, () => {\n      let data = player.getDownloadedVideoData();\n      this.selectItem(data.isAuto ? 'Auto' : data.id);\n    });\n\n    // Populate qualities at startup\n    updateVideoQualities();\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {VolumeSlider} from './volumeslider';\nimport {VolumeToggleButton} from './volumetogglebutton';\nimport {UIInstanceManager} from '../uimanager';\nimport {Timeout} from '../timeout';\n\n/**\n * Configuration interface for a {@link VolumeControlButton}.\n */\nexport interface VolumeControlButtonConfig extends ContainerConfig {\n  /**\n   * The delay after which the volume slider will be hidden when there is no user interaction.\n   * Care must be taken that the delay is long enough so users can reach the slider from the toggle button, e.g. by\n   * mouse movement. If the delay is too short, the sliders disappears before the mouse pointer has reached it and\n   * the user is not able to use it.\n   * Default: 500ms\n   */\n  hideDelay?: number;\n  /**\n   * Specifies if the volume slider should be vertically or horizontally aligned.\n   * Default: true\n   */\n  vertical?: boolean;\n}\n\n/**\n * A composite volume control that consists of and internally manages a volume control button that can be used\n * for muting, and a (depending on the CSS style, e.g. slide-out) volume control bar.\n */\nexport class VolumeControlButton extends Container<VolumeControlButtonConfig> {\n\n  private volumeToggleButton: VolumeToggleButton;\n  private volumeSlider: VolumeSlider;\n\n  private volumeSliderHideTimeout: Timeout;\n\n  constructor(config: VolumeControlButtonConfig = {}) {\n    super(config);\n\n    this.volumeToggleButton = new VolumeToggleButton();\n    this.volumeSlider = new VolumeSlider({\n      vertical: config.vertical != null ? config.vertical : true,\n      hidden: true\n    });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-volumecontrolbutton',\n      components: [this.volumeToggleButton, this.volumeSlider],\n      hideDelay: 500\n    }, <VolumeControlButtonConfig>this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let volumeToggleButton = this.getVolumeToggleButton();\n    let volumeSlider = this.getVolumeSlider();\n\n    this.volumeSliderHideTimeout = new Timeout((<VolumeControlButtonConfig>this.getConfig()).hideDelay, () => {\n      volumeSlider.hide();\n    });\n\n    /*\n     * Volume Slider visibility handling\n     *\n     * The volume slider shall be visible while the user hovers the mute toggle button, while the user hovers the\n     * volume slider, and while the user slides the volume slider. If none of these situations are true, the slider\n     * shall disappear.\n     */\n    let volumeSliderHovered = false;\n    volumeToggleButton.getDomElement().on('mouseenter', () => {\n      // Show volume slider when mouse enters the button area\n      if (volumeSlider.isHidden()) {\n        volumeSlider.show();\n      }\n      // Avoid hiding of the slider when button is hovered\n      this.volumeSliderHideTimeout.clear();\n    });\n    volumeToggleButton.getDomElement().on('mouseleave', () => {\n      // Hide slider delayed when button is left\n      this.volumeSliderHideTimeout.reset();\n    });\n    volumeSlider.getDomElement().on('mouseenter', () => {\n      // When the slider is entered, cancel the hide timeout activated by leaving the button\n      this.volumeSliderHideTimeout.clear();\n      volumeSliderHovered = true;\n    });\n    volumeSlider.getDomElement().on('mouseleave', () => {\n      // When mouse leaves the slider, only hide it if there is no slide operation in progress\n      if (volumeSlider.isSeeking()) {\n        this.volumeSliderHideTimeout.clear();\n      } else {\n        this.volumeSliderHideTimeout.reset();\n      }\n      volumeSliderHovered = false;\n    });\n    volumeSlider.onSeeked.subscribe(() => {\n      // When a slide operation is done and the slider not hovered (mouse outside slider), hide slider delayed\n      if (!volumeSliderHovered) {\n        this.volumeSliderHideTimeout.reset();\n      }\n    });\n  }\n\n  release(): void {\n    super.release();\n    this.volumeSliderHideTimeout.clear();\n  }\n\n  /**\n   * Provides access to the internally managed volume toggle button.\n   * @returns {VolumeToggleButton}\n   */\n  getVolumeToggleButton(): VolumeToggleButton {\n    return this.volumeToggleButton;\n  }\n\n  /**\n   * Provides access to the internally managed volume silder.\n   * @returns {VolumeSlider}\n   */\n  getVolumeSlider(): VolumeSlider {\n    return this.volumeSlider;\n  }\n}","import {SeekBar, SeekBarConfig} from './seekbar';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Configuration interface for the {@link VolumeSlider} component.\n */\nexport interface VolumeSliderConfig extends SeekBarConfig {\n  /**\n   * Specifies if the volume slider should be automatically hidden when volume control is prohibited by the\n   * browser or platform. This currently only applies to iOS.\n   * Default: true\n   */\n  hideIfVolumeControlProhibited: boolean;\n}\n\n/**\n * A simple volume slider component to adjust the player's volume setting.\n */\nexport class VolumeSlider extends SeekBar {\n\n  constructor(config: SeekBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <VolumeSliderConfig>{\n      cssClass: 'ui-volumeslider',\n      hideIfVolumeControlProhibited: true,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager, false);\n\n    let config = <VolumeSliderConfig>this.getConfig();\n\n    if (config.hideIfVolumeControlProhibited && !this.detectVolumeControlAvailability(player)) {\n      this.hide();\n\n      // We can just return from here, because the user will never interact with the control and any configured\n      // functionality would only eat resources for no reason.\n      return;\n    }\n\n    let volumeChangeHandler = () => {\n      if (player.isMuted()) {\n        this.setPlaybackPosition(0);\n        this.setBufferPosition(0);\n      } else {\n        this.setPlaybackPosition(player.getVolume());\n\n        this.setBufferPosition(player.getVolume());\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_VOLUME_CHANGED, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_MUTED, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_UNMUTED, volumeChangeHandler);\n\n    this.onSeekPreview.subscribe((sender, args) => {\n      if (args.scrubbing) {\n        player.setVolume(args.position);\n      }\n    });\n    this.onSeeked.subscribe((sender, percentage) => {\n      player.setVolume(percentage);\n    });\n\n    // Update the volume slider marker when the player resized, a source is loaded and player is ready,\n    // or the UI is configured. Check the seekbar for a detailed description.\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => {\n      this.refreshPlaybackPosition();\n    });\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      this.refreshPlaybackPosition();\n    });\n    uimanager.onConfigured.subscribe(() => {\n      this.refreshPlaybackPosition();\n    });\n\n    // Init volume bar\n    volumeChangeHandler();\n  }\n\n  private detectVolumeControlAvailability(player: bitmovin.player.Player): boolean {\n    // Store current player state so we can restore it later\n    let volume = player.getVolume();\n    let muted = player.isMuted();\n    let playing = player.isPlaying();\n\n    /*\n     * \"On iOS devices, the audio level is always under the users physical control. The volume property is not\n     * settable in JavaScript. Reading the volume property always returns 1.\"\n     * https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html\n     *\n     * Our player API returns a volume range of [0, 100] so we need to check for 100 instead of 1.\n     */\n\n    // Only if the volume is 100, there's the possibility we are on a volume-control-restricted iOS device\n    if (volume === 100) {\n      // We set the volume to zero (that's the only value that does not unmute a muted player!)\n      player.setVolume(0);\n      // Then we check if the value is still 100\n      if (player.getVolume() === 100) {\n        // If the volume stayed at 100, we're on a volume-control-restricted device\n        return false;\n      } else {\n        // We can control volume, so we must restore the previous player state\n        player.setVolume(volume);\n        if (muted) {\n          player.mute();\n        }\n        if (playing) {\n          // The volume restore above pauses autoplay on mobile devices (e.g. Android) so we need to resume playback\n          // (We cannot check isPaused() here because it is not set when playback is prohibited by the mobile platform)\n          player.play();\n        }\n        return true;\n      }\n    } else {\n      // Volume is not 100, so we're definitely not on a volume-control-restricted iOS device\n      return true;\n    }\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles audio muting.\n */\nexport class VolumeToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-volumetogglebutton',\n      text: 'Volume/Mute'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let muteStateHandler = () => {\n      if (player.isMuted()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    let volumeLevelHandler = () => {\n      // Toggle low class to display low volume icon below 50% volume\n      if (player.getVolume() < 50) {\n        this.getDomElement().addClass(this.prefixCss('low'));\n      } else {\n        this.getDomElement().removeClass(this.prefixCss('low'));\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_MUTED, muteStateHandler);\n    player.addEventHandler(player.EVENT.ON_UNMUTED, muteStateHandler);\n    player.addEventHandler(player.EVENT.ON_VOLUME_CHANGED, volumeLevelHandler);\n\n    this.onClick.subscribe(() => {\n      if (player.isMuted()) {\n        player.unmute();\n      } else {\n        player.mute();\n      }\n    });\n\n    // Startup init\n    muteStateHandler();\n    volumeLevelHandler();\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles the video view between normal/mono and VR/stereo.\n */\nexport class VRToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-vrtogglebutton',\n      text: 'VR'\n    }, this.config);\n  }\n\n  configure(player: bitmovin.player.Player, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let isVRConfigured = () => {\n      // VR availability cannot be checked through getVRStatus() because it is asynchronously populated and not\n      // available at UI initialization. As an alternative, we check the VR settings in the config.\n      // TODO use getVRStatus() through isVRStereoAvailable() once the player has been rewritten and the status is\n      // available in ON_READY\n      let config = player.getConfig();\n      return config.source && config.source.vr && config.source.vr.contentType !== 'none';\n    };\n\n    let isVRStereoAvailable = () => {\n      return player.getVRStatus().contentType !== 'none';\n    };\n\n    let vrStateHandler = () => {\n      if (isVRConfigured() && isVRStereoAvailable()) {\n        this.show(); // show button in case it is hidden\n\n        if (player.getVRStatus().isStereo) {\n          this.on();\n        } else {\n          this.off();\n        }\n      } else {\n        this.hide(); // hide button if no stereo mode available\n      }\n    };\n\n    let vrButtonVisibilityHandler = () => {\n      if (isVRConfigured()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_VR_MODE_CHANGED, vrStateHandler);\n    player.addEventHandler(player.EVENT.ON_VR_STEREO_CHANGED, vrStateHandler);\n    player.addEventHandler(player.EVENT.ON_VR_ERROR, vrStateHandler);\n    // Hide button when VR source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, vrButtonVisibilityHandler);\n    // Show button when a new source is loaded and it's VR\n    player.addEventHandler(player.EVENT.ON_READY, vrButtonVisibilityHandler);\n\n    this.onClick.subscribe(() => {\n      if (!isVRStereoAvailable()) {\n        if (console) {\n          console.log('No VR content');\n        }\n      } else {\n        if (player.getVRStatus().isStereo) {\n          player.setVRStereo(false);\n        } else {\n          player.setVRStereo(true);\n        }\n      }\n    });\n\n    // Set startup visibility\n    vrButtonVisibilityHandler();\n  }\n}","import {ClickOverlay, ClickOverlayConfig} from './clickoverlay';\n\n/**\n * Configuration interface for a {@link ClickOverlay}.\n */\nexport interface WatermarkConfig extends ClickOverlayConfig {\n  // nothing yet\n}\n\n/**\n * A watermark overlay with a clickable logo.\n */\nexport class Watermark extends ClickOverlay {\n\n  constructor(config: WatermarkConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-watermark',\n      url: 'http://bitmovin.com'\n    }, <WatermarkConfig>this.config);\n  }\n}","export interface Offset {\n  left: number;\n  top: number;\n}\n\n/**\n * Simple DOM manipulation and DOM element event handling modeled after jQuery (as replacement for jQuery).\n *\n * Like jQuery, DOM operates on single elements and lists of elements. For example: creating an element returns a DOM\n * instance with a single element, selecting elements returns a DOM instance with zero, one, or many elements. Similar\n * to jQuery, setters usually affect all elements, while getters operate on only the first element.\n * Also similar to jQuery, most methods (except getters) return the DOM instance facilitating easy chaining of method\n * calls.\n *\n * Built with the help of: http://youmightnotneedjquery.com/\n */\nexport class DOM {\n\n  private document: Document;\n\n  /**\n   * The list of elements that the instance wraps. Take care that not all methods can operate on the whole list,\n   * getters usually just work on the first element.\n   */\n  private elements: HTMLElement[];\n\n  /**\n   * Creates a DOM element.\n   * @param tagName the tag name of the DOM element\n   * @param attributes a list of attributes of the element\n   */\n  constructor(tagName: string, attributes: {[name: string]: string});\n  /**\n   * Selects all elements from the DOM that match the specified selector.\n   * @param selector the selector to match DOM elements with\n   */\n  constructor(selector: string);\n  /**\n   * Wraps a plain HTMLElement with a DOM instance.\n   * @param element the HTMLElement to wrap with DOM\n   */\n  constructor(element: HTMLElement);\n  /**\n   * Wraps a list of plain HTMLElements with a DOM instance.\n   * @param element the HTMLElements to wrap with DOM\n   */\n  constructor(elements: HTMLElement[]);\n  /**\n   * Wraps the document with a DOM instance. Useful to attach event listeners to the document.\n   * @param document the document to wrap\n   */\n  constructor(document: Document);\n  constructor(something: string | HTMLElement | HTMLElement[] | Document, attributes?: {[name: string]: string}) {\n    this.document = document; // Set the global document to the local document field\n\n    if (something instanceof Array) {\n      if (something.length > 0 && something[0] instanceof HTMLElement) {\n        let elements = something;\n        this.elements = elements;\n      }\n    }\n    else if (something instanceof HTMLElement) {\n      let element = something;\n      this.elements = [element];\n    }\n    else if (something instanceof Document) {\n      // When a document is passed in, we do not do anything with it, but by setting this.elements to null\n      // we give the event handling method a means to detect if the events should be registered on the document\n      // instead of elements.\n      this.elements = null;\n    }\n    else if (attributes) {\n      let tagName = something;\n      let element = document.createElement(tagName);\n\n      for (let attributeName in attributes) {\n        let attributeValue = attributes[attributeName];\n        element.setAttribute(attributeName, attributeValue);\n      }\n\n      this.elements = [element];\n    }\n    else {\n      let selector = something;\n      this.elements = this.findChildElements(selector);\n    }\n  }\n\n  /**\n   * Gets the number of elements that this DOM instance currently holds.\n   * @returns {number} the number of elements\n   */\n  get length(): number {\n    return this.elements ? this.elements.length : 0;\n  }\n\n  /**\n   * Gets the HTML elements that this DOM instance currently holds.\n   * @returns {HTMLElement[]} the raw HTML elements\n   */\n  getElements(): HTMLElement[] {\n    return this.elements;\n  }\n\n  /**\n   * A shortcut method for iterating all elements. Shorts this.elements.forEach(...) to this.forEach(...).\n   * @param handler the handler to execute an operation on an element\n   */\n  private forEach(handler: (element: HTMLElement) => void): void {\n    this.elements.forEach((element) => {\n      handler(element);\n    });\n  }\n\n  private findChildElementsOfElement(element: HTMLElement | Document, selector: string): HTMLElement[] {\n    let childElements = element.querySelectorAll(selector);\n\n    // Convert NodeList to Array\n    // https://toddmotto.com/a-comprehensive-dive-into-nodelists-arrays-converting-nodelists-and-understanding-the-dom/\n    return [].slice.call(childElements);\n  }\n\n  private findChildElements(selector: string): HTMLElement[] {\n    let allChildElements = <HTMLElement[]>[];\n\n    if (this.elements) {\n      this.forEach((element) => {\n        allChildElements = allChildElements.concat(this.findChildElementsOfElement(element, selector));\n      });\n    }\n    else {\n      return this.findChildElementsOfElement(document, selector);\n    }\n\n    return allChildElements;\n  }\n\n  /**\n   * Finds all child elements of all elements matching the supplied selector.\n   * @param selector the selector to match with child elements\n   * @returns {DOM} a new DOM instance representing all matched children\n   */\n  find(selector: string): DOM {\n    let allChildElements = this.findChildElements(selector);\n    return new DOM(allChildElements);\n  }\n\n  /**\n   * Returns a string of the inner HTML content of the first element.\n   */\n  html(): string;\n  /**\n   * Sets the inner HTML content of all elements.\n   * @param content a string of plain text or HTML markup\n   */\n  html(content: string): DOM;\n  html(content?: string): string | DOM {\n    if (arguments.length > 0) {\n      return this.setHtml(content);\n    }\n    else {\n      return this.getHtml();\n    }\n  }\n\n  private getHtml(): string | null {\n    return this.elements[0].innerHTML;\n  }\n\n  private setHtml(content: string): DOM {\n    if (content === undefined || content == null) {\n      // Set to empty string to avoid innerHTML getting set to 'undefined' (all browsers) or 'null' (IE9)\n      content = '';\n    }\n\n    this.forEach((element) => {\n      element.innerHTML = content;\n    });\n\n    return this;\n  }\n\n  /**\n   * Clears the inner HTML of all elements (deletes all children).\n   * @returns {DOM}\n   */\n  empty(): DOM {\n    this.forEach((element) => {\n      element.innerHTML = '';\n    });\n    return this;\n  }\n\n  /**\n   * Returns the current value of the first form element, e.g. the selected value of a select box or the text if an\n   * input field.\n   * @returns {string} the value of a form element\n   */\n  val(): string {\n    let element = this.elements[0];\n\n    if (element instanceof HTMLSelectElement || element instanceof HTMLInputElement) {\n      return element.value;\n    }\n    else {\n      // TODO add support for missing form elements\n      throw new Error(`val() not supported for ${typeof element}`);\n    }\n  }\n\n  /**\n   * Returns the value of an attribute on the first element.\n   * @param attribute\n   */\n  attr(attribute: string): string | null;\n  /**\n   * Sets an attribute on all elements.\n   * @param attribute the name of the attribute\n   * @param value the value of the attribute\n   */\n  attr(attribute: string, value: string): DOM;\n  attr(attribute: string, value?: string): string | null | DOM {\n    if (arguments.length > 1) {\n      return this.setAttr(attribute, value);\n    }\n    else {\n      return this.getAttr(attribute);\n    }\n  }\n\n  private getAttr(attribute: string): string | null {\n    return this.elements[0].getAttribute(attribute);\n  }\n\n  private setAttr(attribute: string, value: string): DOM {\n    this.forEach((element) => {\n      element.setAttribute(attribute, value);\n    });\n    return this;\n  }\n\n  /**\n   * Returns the value of a data element on the first element.\n   * @param dataAttribute the name of the data attribute without the 'data-' prefix\n   */\n  data(dataAttribute: string): string | null;\n  /**\n   * Sets a data attribute on all elements.\n   * @param dataAttribute the name of the data attribute without the 'data-' prefix\n   * @param value the value of the data attribute\n   */\n  data(dataAttribute: string, value: string): DOM;\n  data(dataAttribute: string, value?: string): string | null | DOM {\n    if (arguments.length > 1) {\n      return this.setData(dataAttribute, value);\n    }\n    else {\n      return this.getData(dataAttribute);\n    }\n  }\n\n  private getData(dataAttribute: string): string | null {\n    return this.elements[0].getAttribute('data-' + dataAttribute);\n  }\n\n  private setData(dataAttribute: string, value: string): DOM {\n    this.forEach((element) => {\n      element.setAttribute('data-' + dataAttribute, value);\n    });\n    return this;\n  }\n\n  /**\n   * Appends one or more DOM elements as children to all elements.\n   * @param childElements the chrild elements to append\n   * @returns {DOM}\n   */\n  append(...childElements: DOM[]): DOM {\n    this.forEach((element) => {\n      childElements.forEach((childElement) => {\n        childElement.elements.forEach((_, index) => {\n          element.appendChild(childElement.elements[index]);\n        });\n      });\n    });\n    return this;\n  }\n\n  /**\n   * Removes all elements from the DOM.\n   */\n  remove(): void {\n    this.forEach((element) => {\n      let parent = element.parentNode;\n      if (parent) {\n        parent.removeChild(element);\n      }\n    });\n  }\n\n  /**\n   * Returns the offset of the first element from the document's top left corner.\n   * @returns {Offset}\n   */\n  offset(): Offset {\n    let element = this.elements[0];\n    let elementRect = element.getBoundingClientRect();\n    let htmlRect = document.body.parentElement.getBoundingClientRect();\n\n    // Virtual viewport scroll handling (e.g. pinch zoomed viewports in mobile browsers or desktop Chrome/Edge)\n    // 'normal' zooms and virtual viewport zooms (aka layout viewport) result in different\n    // element.getBoundingClientRect() results:\n    //  - with normal scrolls, the clientRect decreases with an increase in scroll(Top|Left)/page(X|Y)Offset\n    //  - with pinch zoom scrolls, the clientRect stays the same while scroll/pageOffset changes\n    // This means, that the combination of clientRect + scroll/pageOffset does not work to calculate the offset\n    // from the document's upper left origin when pinch zoom is used.\n    // To work around this issue, we do not use scroll/pageOffset but get the clientRect of the html element and\n    // subtract it from the element's rect, which always results in the offset from the document origin.\n    // NOTE: the current way of offset calculation was implemented specifically to track event positions on the\n    // seek bar, and it might break compatibility with jQuery's offset() method. If this ever turns out to be a\n    // problem, this method should be reverted to the old version and the offset calculation moved to the seek bar.\n\n    return {\n      top: elementRect.top - htmlRect.top,\n      left: elementRect.left - htmlRect.left\n    };\n  }\n\n  /**\n   * Returns the width of the first element.\n   * @returns {number} the width of the first element\n   */\n  width(): number {\n    // TODO check if this is the same as jQuery's width() (probably not)\n    return this.elements[0].offsetWidth;\n  }\n\n  /**\n   * Returns the height of the first element.\n   * @returns {number} the height of the first element\n   */\n  height(): number {\n    // TODO check if this is the same as jQuery's height() (probably not)\n    return this.elements[0].offsetHeight;\n  }\n\n  /**\n   * Attaches an event handler to one or more events on all elements.\n   * @param eventName the event name (or multiple names separated by space) to listen to\n   * @param eventHandler the event handler to call when the event fires\n   * @returns {DOM}\n   */\n  on(eventName: string, eventHandler: EventListenerOrEventListenerObject): DOM {\n    let events = eventName.split(' ');\n\n    events.forEach((event) => {\n      if (this.elements == null) {\n        this.document.addEventListener(event, eventHandler);\n      }\n      else {\n        this.forEach((element) => {\n          element.addEventListener(event, eventHandler);\n        });\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Removes an event handler from one or more events on all elements.\n   * @param eventName the event name (or multiple names separated by space) to remove the handler from\n   * @param eventHandler the event handler to remove\n   * @returns {DOM}\n   */\n  off(eventName: string, eventHandler: EventListenerOrEventListenerObject): DOM {\n    let events = eventName.split(' ');\n\n    events.forEach((event) => {\n      if (this.elements == null) {\n        this.document.removeEventListener(event, eventHandler);\n      }\n      else {\n        this.forEach((element) => {\n          element.removeEventListener(event, eventHandler);\n        });\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds the specified class(es) to all elements.\n   * @param className the class(es) to add, multiple classes separated by space\n   * @returns {DOM}\n   */\n  addClass(className: string): DOM {\n    this.forEach((element) => {\n      if (element.classList) {\n        element.classList.add(className);\n      }\n      else {\n        element.className += ' ' + className;\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Removed the specified class(es) from all elements.\n   * @param className the class(es) to remove, multiple classes separated by space\n   * @returns {DOM}\n   */\n  removeClass(className: string): DOM {\n    this.forEach((element) => {\n      if (element.classList) {\n        element.classList.remove(className);\n      }\n      else {\n        element.className = element.className.replace(\n          new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Checks if any of the elements has the specified class.\n   * @param className the class name to check\n   * @returns {boolean} true if one of the elements has the class attached, else if no element has it attached\n   */\n  hasClass(className: string): boolean {\n    let hasClass = false;\n\n    this.forEach((element) => {\n      if (element.classList) {\n        if (element.classList.contains(className)) {\n          // Since we are inside a handler, we can't just 'return true'. Instead, we save it to a variable\n          // and return it at the end of the function body.\n          hasClass = true;\n        }\n      }\n      else {\n        if (new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className)) {\n          // See comment above\n          hasClass = true;\n        }\n      }\n    });\n\n    return hasClass;\n  }\n\n  /**\n   * Returns the value of a CSS property of the first element.\n   * @param propertyName the name of the CSS property to retrieve the value of\n   */\n  css(propertyName: string): string | null;\n  /**\n   * Sets the value of a CSS property on all elements.\n   * @param propertyName the name of the CSS property to set the value for\n   * @param value the value to set for the given CSS property\n   */\n  css(propertyName: string, value: string): DOM;\n  /**\n   * Sets a collection of CSS properties and their values on all elements.\n   * @param propertyValueCollection an object containing pairs of property names and their values\n   */\n  css(propertyValueCollection: {[propertyName: string]: string}): DOM;\n  css(propertyNameOrCollection: string | {[propertyName: string]: string}, value?: string): string | null | DOM {\n    if (typeof propertyNameOrCollection === 'string') {\n      let propertyName = propertyNameOrCollection;\n\n      if (arguments.length === 2) {\n        return this.setCss(propertyName, value);\n      }\n      else {\n        return this.getCss(propertyName);\n      }\n    }\n    else {\n      let propertyValueCollection = propertyNameOrCollection;\n      return this.setCssCollection(propertyValueCollection);\n    }\n  }\n\n  private getCss(propertyName: string): string | null {\n    return getComputedStyle(this.elements[0])[<any>propertyName];\n  }\n\n  private setCss(propertyName: string, value: string): DOM {\n    this.forEach((element) => {\n      // <any> cast to resolve TS7015: http://stackoverflow.com/a/36627114/370252\n      element.style[<any>propertyName] = value;\n    });\n    return this;\n  }\n\n  private setCssCollection(ruleValueCollection: {[ruleName: string]: string}): DOM {\n    this.forEach((element) => {\n      // http://stackoverflow.com/a/34490573/370252\n      Object.assign(element.style, ruleValueCollection);\n    });\n\n    return this;\n  }\n}\n","import {ArrayUtils} from './utils';\n/**\n * Function interface for event listeners on the {@link EventDispatcher}.\n */\nexport interface EventListener<Sender, Args> {\n  (sender: Sender, args: Args): void;\n}\n\n/**\n * Empty type for creating {@link EventDispatcher event dispatchers} that do not carry any arguments.\n */\nexport interface NoArgs {\n}\n\n/**\n * Event args for an event that can be canceled.\n */\nexport interface CancelEventArgs extends NoArgs {\n  /**\n   * Gets or sets a flag whether the event should be canceled.\n   */\n  cancel?: boolean;\n}\n\n/**\n * Public interface that represents an event. Can be used to subscribe to and unsubscribe from events.\n */\nexport interface Event<Sender, Args> {\n  /**\n   * Subscribes an event listener to this event dispatcher.\n   * @param listener the listener to add\n   */\n  subscribe(listener: EventListener<Sender, Args>): void;\n\n  /**\n   * Subscribes an event listener to this event dispatcher that is only called once.\n   * @param listener the listener to add\n   */\n  subscribeOnce(listener: EventListener<Sender, Args>): void;\n\n  /**\n   * Subscribes an event listener to this event dispatcher that will be called at a limited rate with a minimum\n   * interval of the specified milliseconds.\n   * @param listener the listener to add\n   * @param rateMs the rate in milliseconds to which calling of the listeners should be limited\n   */\n  subscribeRateLimited(listener: EventListener<Sender, Args>, rateMs: number): void;\n\n  /**\n   * Unsubscribes a subscribed event listener from this dispatcher.\n   * @param listener the listener to remove\n   * @returns {boolean} true if the listener was successfully unsubscribed, false if it isn't subscribed on this\n   *   dispatcher\n   */\n  unsubscribe(listener: EventListener<Sender, Args>): boolean;\n}\n\n/**\n * Event dispatcher to subscribe and trigger events. Each event should have its own dispatcher.\n */\nexport class EventDispatcher<Sender, Args> implements Event<Sender, Args> {\n\n  private listeners: EventListenerWrapper<Sender, Args>[] = [];\n\n  constructor() {\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribe(listener: EventListener<Sender, Args>) {\n    this.listeners.push(new EventListenerWrapper(listener));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribeOnce(listener: EventListener<Sender, Args>) {\n    this.listeners.push(new EventListenerWrapper(listener, true));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribeRateLimited(listener: EventListener<Sender, Args>, rateMs: number) {\n    this.listeners.push(new RateLimitedEventListenerWrapper(listener, rateMs));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  unsubscribe(listener: EventListener<Sender, Args>): boolean {\n    // Iterate through listeners, compare with parameter, and remove if found\n    for (let i = 0; i < this.listeners.length; i++) {\n      let subscribedListener = this.listeners[i];\n      if (subscribedListener.listener === listener) {\n        ArrayUtils.remove(this.listeners, subscribedListener);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Removes all listeners from this dispatcher.\n   */\n  unsubscribeAll(): void {\n    this.listeners = [];\n  }\n\n  /**\n   * Dispatches an event to all subscribed listeners.\n   * @param sender the source of the event\n   * @param args the arguments for the event\n   */\n  dispatch(sender: Sender, args: Args = null) {\n    let listenersToRemove = [];\n\n    // Call every listener\n    for (let listener of this.listeners) {\n      listener.fire(sender, args);\n\n      if (listener.isOnce()) {\n        listenersToRemove.push(listener);\n      }\n    }\n\n    // Remove one-time listener\n    for (let listenerToRemove of listenersToRemove) {\n      ArrayUtils.remove(this.listeners, listenerToRemove);\n    }\n  }\n\n  /**\n   * Returns the event that this dispatcher manages and on which listeners can subscribe and unsubscribe event handlers.\n   * @returns {Event}\n   */\n  getEvent(): Event<Sender, Args> {\n    // For now, just cast the event dispatcher to the event interface. At some point in the future when the\n    // codebase grows, it might make sense to split the dispatcher into separate dispatcher and event classes.\n    return <Event<Sender, Args>>this;\n  }\n}\n\n/**\n * A basic event listener wrapper to manage listeners within the {@link EventDispatcher}. This is a 'private' class\n * for internal dispatcher use and it is therefore not exported.\n */\nclass EventListenerWrapper<Sender, Args> {\n\n  private eventListener: EventListener<Sender, Args>;\n  private once: boolean;\n\n  constructor(listener: EventListener<Sender, Args>, once: boolean = false) {\n    this.eventListener = listener;\n    this.once = once;\n  }\n\n  /**\n   * Returns the wrapped event listener.\n   * @returns {EventListener<Sender, Args>}\n   */\n  get listener(): EventListener<Sender, Args> {\n    return this.eventListener;\n  }\n\n  /**\n   * Fires the wrapped event listener with the given arguments.\n   * @param sender\n   * @param args\n   */\n  fire(sender: Sender, args: Args) {\n    this.eventListener(sender, args);\n  }\n\n  /**\n   * Checks if this listener is scheduled to be called only once.\n   * @returns {boolean} once if true\n   */\n  isOnce(): boolean {\n    return this.once;\n  }\n}\n\n/**\n * Extends the basic {@link EventListenerWrapper} with rate-limiting functionality.\n */\nclass RateLimitedEventListenerWrapper<Sender, Args> extends EventListenerWrapper<Sender, Args> {\n\n  private rateMs: number;\n  private rateLimitingEventListener: EventListener<Sender, Args>;\n\n  private lastFireTime: number;\n\n  constructor(listener: EventListener<Sender, Args>, rateMs: number) {\n    super(listener); // sets the event listener sink\n\n    this.rateMs = rateMs;\n    this.lastFireTime = 0;\n\n    // Wrap the event listener with an event listener that does the rate-limiting\n    this.rateLimitingEventListener = (sender: Sender, args: Args) => {\n      if (Date.now() - this.lastFireTime > this.rateMs) {\n        // Only if enough time since the previous call has passed, call the\n        // actual event listener and record the current time\n        this.fireSuper(sender, args);\n        this.lastFireTime = Date.now();\n      }\n    };\n  }\n\n  private fireSuper(sender: Sender, args: Args) {\n    // Fire the actual external event listener\n    super.fire(sender, args);\n  }\n\n  fire(sender: Sender, args: Args) {\n    // Fire the internal rate-limiting listener instead of the external event listener\n    this.rateLimitingEventListener(sender, args);\n  }\n}","export namespace Guid {\n\n  let guid = 1;\n\n  export function next() {\n    return guid++;\n  }\n}\n","/// <reference path='player.d.ts' />\nimport {UIManager, UIInstanceManager} from './uimanager';\nimport {Button} from './components/button';\nimport {ControlBar} from './components/controlbar';\nimport {FullscreenToggleButton} from './components/fullscreentogglebutton';\nimport {HugePlaybackToggleButton} from './components/hugeplaybacktogglebutton';\nimport {PlaybackTimeLabel, PlaybackTimeLabelMode} from './components/playbacktimelabel';\nimport {PlaybackToggleButton} from './components/playbacktogglebutton';\nimport {SeekBar} from './components/seekbar';\nimport {SelectBox} from './components/selectbox';\nimport {SettingsPanel, SettingsPanelItem} from './components/settingspanel';\nimport {SettingsToggleButton} from './components/settingstogglebutton';\nimport {ToggleButton} from './components/togglebutton';\nimport {VideoQualitySelectBox} from './components/videoqualityselectbox';\nimport {VolumeToggleButton} from './components/volumetogglebutton';\nimport {VRToggleButton} from './components/vrtogglebutton';\nimport {Watermark} from './components/watermark';\nimport {UIContainer} from './components/uicontainer';\nimport {Container} from './components/container';\nimport {Label} from './components/label';\nimport {AudioQualitySelectBox} from './components/audioqualityselectbox';\nimport {AudioTrackSelectBox} from './components/audiotrackselectbox';\nimport {CastStatusOverlay} from './components/caststatusoverlay';\nimport {CastToggleButton} from './components/casttogglebutton';\nimport {Component} from './components/component';\nimport {ErrorMessageOverlay} from './components/errormessageoverlay';\nimport {RecommendationOverlay} from './components/recommendationoverlay';\nimport {SeekBarLabel} from './components/seekbarlabel';\nimport {SubtitleOverlay} from './components/subtitleoverlay';\nimport {SubtitleSelectBox} from './components/subtitleselectbox';\nimport {TitleBar} from './components/titlebar';\nimport {VolumeControlButton} from './components/volumecontrolbutton';\nimport {ClickOverlay} from './components/clickoverlay';\nimport {AdSkipButton} from './components/adskipbutton';\nimport {AdMessageLabel} from './components/admessagelabel';\nimport {AdClickOverlay} from './components/adclickoverlay';\nimport {PlaybackSpeedSelectBox} from './components/playbackspeedselectbox';\nimport {HugeReplayButton} from './components/hugereplaybutton';\nimport {BufferingOverlay} from './components/bufferingoverlay';\nimport {CastUIContainer} from './components/castuicontainer';\nimport {PlaybackToggleOverlay} from './components/playbacktoggleoverlay';\nimport {CloseButton} from './components/closebutton';\nimport {MetadataLabel, MetadataLabelContent} from './components/metadatalabel';\nimport {AirPlayToggleButton} from './components/airplaytogglebutton';\nimport {VolumeSlider} from './components/volumeslider';\nimport {PictureInPictureToggleButton} from './components/pictureinpicturetogglebutton';\nimport {Spacer} from './components/spacer';\nimport {ArrayUtils, StringUtils, PlayerUtils, UIUtils, BrowserUtils} from './utils';\n\n// Object.assign polyfill for ES5/IE9\n// https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nif (typeof Object.assign !== 'function') {\n  Object.assign = function(target: any) {\n    'use strict';\n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    target = Object(target);\n    for (let index = 1; index < arguments.length; index++) {\n      let source = arguments[index];\n      if (source != null) {\n        for (let key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n    }\n    return target;\n  };\n}\n\n// Expose classes to window\n(window as any).bitmovin.playerui = {\n  // Management\n  UIManager,\n  UIInstanceManager,\n  // Utils\n  ArrayUtils,\n  StringUtils,\n  PlayerUtils,\n  UIUtils,\n  BrowserUtils,\n  // Components\n  AdClickOverlay,\n  AdMessageLabel,\n  AdSkipButton,\n  AirPlayToggleButton,\n  AudioQualitySelectBox,\n  AudioTrackSelectBox,\n  BufferingOverlay,\n  Button,\n  CastStatusOverlay,\n  CastToggleButton,\n  CastUIContainer,\n  ClickOverlay,\n  CloseButton,\n  Component,\n  Container,\n  ControlBar,\n  ErrorMessageOverlay,\n  FullscreenToggleButton,\n  HugePlaybackToggleButton,\n  HugeReplayButton,\n  Label,\n  MetadataLabel,\n  MetadataLabelContent,\n  PictureInPictureToggleButton,\n  PlaybackSpeedSelectBox,\n  PlaybackTimeLabel,\n  PlaybackTimeLabelMode,\n  PlaybackToggleButton,\n  PlaybackToggleOverlay,\n  RecommendationOverlay,\n  SeekBar,\n  SeekBarLabel,\n  SelectBox,\n  SettingsPanel,\n  SettingsPanelItem,\n  SettingsToggleButton,\n  Spacer,\n  SubtitleOverlay,\n  SubtitleSelectBox,\n  TitleBar,\n  ToggleButton,\n  UIContainer,\n  VideoQualitySelectBox,\n  VolumeControlButton,\n  VolumeSlider,\n  VolumeToggleButton,\n  VRToggleButton,\n  Watermark,\n};","// TODO change to internal (not exported) class, how to use in other files?\n/**\n * Executes a callback after a specified amount of time,\n * optionally repeatedly until stopped. When delay is <= 0\n * the timeout is disabled\n */\nexport class Timeout {\n\n  private delay: number;\n  private callback: () => void;\n  private repeat: boolean;\n  private timeoutHandle: number;\n\n  /**\n   * Creates a new timeout callback handler.\n   * @param delay the delay in milliseconds after which the callback should be executed\n   * @param callback the callback to execute after the delay time\n   * @param repeat if true, call the callback repeatedly in delay intervals\n   */\n  constructor(delay: number, callback: () => void, repeat: boolean = false) {\n    this.delay = delay;\n    this.callback = callback;\n    this.repeat = repeat;\n    this.timeoutHandle = 0;\n  }\n\n  /**\n   * Starts the timeout and calls the callback when the timeout delay has passed.\n   * @returns {Timeout} the current timeout (so the start call can be chained to the constructor)\n   */\n  start(): this {\n    this.reset();\n    return this;\n  }\n\n  /**\n   * Clears the timeout. The callback will not be called if clear is called during the timeout.\n   */\n  clear(): void {\n    clearTimeout(this.timeoutHandle);\n  }\n\n  /**\n   * Resets the passed timeout delay to zero. Can be used to defer the calling of the callback.\n   */\n  reset(): void {\n    let lastScheduleTime = 0;\n    let delayAdjust = 0;\n\n    this.clear();\n\n    let internalCallback = () => {\n      this.callback();\n\n      if (this.repeat) {\n        let now = Date.now();\n\n        // The time of one iteration from scheduling to executing the callback (usually a bit longer than the delay\n        // time)\n        let delta = now - lastScheduleTime;\n\n        // Calculate the delay adjustment for the next schedule to keep a steady delay interval over time\n        delayAdjust = this.delay - delta + delayAdjust;\n\n        lastScheduleTime = now;\n\n        // Schedule next execution by the adjusted delay\n        this.timeoutHandle = setTimeout(internalCallback, this.delay + delayAdjust);\n      }\n    };\n\n    lastScheduleTime = Date.now();\n    if (this.delay > 0) {\n      this.timeoutHandle = setTimeout(internalCallback, this.delay);\n    }\n  }\n}","import {UIContainer} from './components/uicontainer';\nimport {DOM} from './dom';\nimport {Component, ComponentConfig} from './components/component';\nimport {Container} from './components/container';\nimport {PlaybackToggleButton} from './components/playbacktogglebutton';\nimport {FullscreenToggleButton} from './components/fullscreentogglebutton';\nimport {VRToggleButton} from './components/vrtogglebutton';\nimport {VolumeToggleButton} from './components/volumetogglebutton';\nimport {SeekBar} from './components/seekbar';\nimport {PlaybackTimeLabel, PlaybackTimeLabelMode} from './components/playbacktimelabel';\nimport {ControlBar} from './components/controlbar';\nimport {NoArgs, EventDispatcher, CancelEventArgs} from './eventdispatcher';\nimport {EmbedVideoToggleButton} from './components/embedvideotogglebutton';\nimport {EmbedVideoPanel} from './components/embedvideopanel';\nimport {SettingsToggleButton} from './components/settingstogglebutton';\nimport {SettingsPanel, SettingsPanelItem} from './components/settingspanel';\nimport {VideoQualitySelectBox} from './components/videoqualityselectbox';\nimport {Watermark} from './components/watermark';\nimport {AudioQualitySelectBox} from './components/audioqualityselectbox';\nimport {AudioTrackSelectBox} from './components/audiotrackselectbox';\nimport {SeekBarLabel} from './components/seekbarlabel';\nimport {VolumeSlider} from './components/volumeslider';\nimport {SubtitleSelectBox} from './components/subtitleselectbox';\nimport {SubtitleOverlay} from './components/subtitleoverlay';\nimport {VolumeControlButton} from './components/volumecontrolbutton';\nimport {CastToggleButton} from './components/casttogglebutton';\nimport {CastStatusOverlay} from './components/caststatusoverlay';\nimport {ErrorMessageOverlay} from './components/errormessageoverlay';\nimport {TitleBar} from './components/titlebar';\nimport Player = bitmovin.player.Player;\nimport {RecommendationOverlay} from './components/recommendationoverlay';\nimport {AdMessageLabel} from './components/admessagelabel';\nimport {AdSkipButton} from './components/adskipbutton';\nimport {AdClickOverlay} from './components/adclickoverlay';\nimport EVENT = bitmovin.player.EVENT;\nimport PlayerEventCallback = bitmovin.player.PlayerEventCallback;\nimport AdStartedEvent = bitmovin.player.AdStartedEvent;\nimport {ArrayUtils, UIUtils, BrowserUtils} from './utils';\nimport {PlaybackSpeedSelectBox} from './components/playbackspeedselectbox';\nimport {BufferingOverlay} from './components/bufferingoverlay';\nimport {CastUIContainer} from './components/castuicontainer';\nimport {PlaybackToggleOverlay} from './components/playbacktoggleoverlay';\nimport {CloseButton} from './components/closebutton';\nimport {MetadataLabel, MetadataLabelContent} from './components/metadatalabel';\nimport {Label} from './components/label';\nimport PlayerEvent = bitmovin.player.PlayerEvent;\nimport {AirPlayToggleButton} from './components/airplaytogglebutton';\nimport {PictureInPictureToggleButton} from './components/pictureinpicturetogglebutton';\nimport {Spacer} from './components/spacer';\n\n\nexport interface UIRecommendationConfig {\n  title: string;\n  url: string;\n  thumbnail?: string;\n  duration?: number;\n}\n\nexport interface TimelineMarker {\n  time: number;\n  title?: string;\n  markerType?: string;\n  comment?: string;\n  avatar?: string;\n  number?: string;\n}\n\nexport interface UIConfig {\n  metadata?: {\n    title?: string;\n    description?: string;\n    markers?: TimelineMarker[];\n  };\n  recommendations?: UIRecommendationConfig[];\n}\n\n/**\n * The context that will be passed to a {@link UIConditionResolver} to determine if it's conditions fulfil the context.\n */\nexport interface UIConditionContext {\n  isAd: boolean;\n  isAdWithUI: boolean;\n  isFullscreen: boolean;\n  isMobile: boolean;\n  documentWidth: number;\n  width: number;\n}\n\n/**\n * Resolves the conditions of its associated UI in a {@link UIVariant} upon a {@link UIConditionContext} and decides\n * if the UI should be displayed. If it returns true, the UI is a candidate for display; if it returns false, it will\n * not be displayed in the given context.\n */\nexport interface UIConditionResolver {\n  (context: UIConditionContext): boolean;\n}\n\n/**\n * Associates a UI instance with an optional {@link UIConditionResolver} that determines if the UI should be displayed.\n */\nexport interface UIVariant {\n  ui: UIContainer;\n  condition?: UIConditionResolver;\n}\n\nexport class UIManager {\n\n  private player: Player;\n  private playerElement: DOM;\n  private uiVariants: UIVariant[];\n  private uiInstanceManagers: InternalUIInstanceManager[];\n  private currentUi: InternalUIInstanceManager;\n  private config: UIConfig;\n  private managerPlayerWrapper: PlayerWrapper;\n\n  /**\n   * Creates a UI manager with a single UI variant that will be permanently shown.\n   * @param player the associated player of this UI\n   * @param ui the UI to add to the player\n   * @param config optional UI configuration\n   */\n  constructor(player: Player, ui: UIContainer, config?: UIConfig);\n  /**\n   * Creates a UI manager with a list of UI variants that will be dynamically selected and switched according to\n   * the context of the UI.\n   *\n   * Every time the UI context changes, the conditions of the UI variants will be sequentially resolved and the first\n   * UI, whose condition evaluates to true, will be selected and displayed. The last variant in the list might omit the\n   * condition resolver and will be selected as default/fallback UI when all other conditions fail. If there is no\n   * fallback UI and all conditions fail, no UI will be displayed.\n   *\n   * @param player the associated player of this UI\n   * @param uiVariants a list of UI variants that will be dynamically switched\n   * @param config optional UI configuration\n   */\n  constructor(player: Player, uiVariants: UIVariant[], config?: UIConfig);\n  constructor(player: Player, playerUiOrUiVariants: UIContainer | UIVariant[], config: UIConfig = {}) {\n    if (playerUiOrUiVariants instanceof UIContainer) {\n      // Single-UI constructor has been called, transform arguments to UIVariant[] signature\n      let playerUi = <UIContainer>playerUiOrUiVariants;\n      let adsUi = null;\n\n      let uiVariants = [];\n\n      // Add the ads UI if defined\n      if (adsUi) {\n        uiVariants.push({\n          ui: adsUi,\n          condition: (context: UIConditionContext) => {\n            return context.isAdWithUI;\n          },\n        });\n      }\n\n      // Add the default player UI\n      uiVariants.push({ui: playerUi});\n\n      this.uiVariants = uiVariants;\n    }\n    else {\n      // Default constructor (UIVariant[]) has been called\n      this.uiVariants = <UIVariant[]>playerUiOrUiVariants;\n    }\n\n    this.player = player;\n    this.config = config;\n    this.managerPlayerWrapper = new PlayerWrapper(player);\n    this.playerElement = new DOM(player.getFigure());\n\n    // Create UI instance managers for the UI variants\n    // The instance managers map to the corresponding UI variants by their array index\n    this.uiInstanceManagers = [];\n    let uiVariantsWithoutCondition = [];\n    for (let uiVariant of this.uiVariants) {\n      if (uiVariant.condition == null) {\n        // Collect variants without conditions for error checking\n        uiVariantsWithoutCondition.push(uiVariant);\n      }\n      // Create the instance manager for a UI variant\n      this.uiInstanceManagers.push(new InternalUIInstanceManager(player, uiVariant.ui, this.config));\n    }\n    // Make sure that there is only one UI variant without a condition\n    // It does not make sense to have multiple variants without condition, because only the first one in the list\n    // (the one with the lowest index) will ever be selected.\n    if (uiVariantsWithoutCondition.length > 1) {\n      throw Error('Too many UIs without a condition: You cannot have more than one default UI');\n    }\n    // Make sure that the default UI variant, if defined, is at the end of the list (last index)\n    // If it comes earlier, the variants with conditions that come afterwards will never be selected because the\n    // default variant without a condition always evaluates to 'true'\n    if (uiVariantsWithoutCondition.length > 0\n      && uiVariantsWithoutCondition[0] !== this.uiVariants[this.uiVariants.length - 1]) {\n      throw Error('Invalid UI variant order: the default UI (without condition) must be at the end of the list');\n    }\n\n    let adStartedEvent: AdStartedEvent = null; // keep the event stored here during ad playback\n    let isMobile = BrowserUtils.isMobile;\n\n    // Dynamically select a UI variant that matches the current UI condition.\n    let resolveUiVariant = (event: PlayerEvent) => {\n      // Make sure that the ON_AD_STARTED event data is persisted through ad playback in case other events happen\n      // in the meantime, e.g. player resize. We need to store this data because there is no other way to find out\n      // ad details (e.g. the ad client) while an ad is playing.\n      // Existing event data signals that an ad is currently active. We cannot use player.isAd() because it returns\n      // true on ad start and also on ad end events, which is problematic.\n      if (event != null) {\n        switch (event.type) {\n          // When the ad starts, we store the event data\n          case player.EVENT.ON_AD_STARTED:\n            adStartedEvent = <AdStartedEvent>event;\n            break;\n          // When the ad ends, we delete the event data\n          case player.EVENT.ON_AD_FINISHED:\n          case player.EVENT.ON_AD_SKIPPED:\n          case player.EVENT.ON_AD_ERROR:\n            adStartedEvent = null;\n        }\n      }\n\n      // Detect if an ad has started\n      let ad = adStartedEvent != null;\n      let adWithUI = ad && adStartedEvent.clientType === 'vast';\n\n      // Determine the current context for which the UI variant will be resolved\n      let context: UIConditionContext = {\n        isAd: ad,\n        isAdWithUI: adWithUI,\n        isFullscreen: this.player.isFullscreen(),\n        isMobile: isMobile,\n        width: this.playerElement.width(),\n        documentWidth: document.body.clientWidth,\n      };\n\n      let nextUi: InternalUIInstanceManager = null;\n      let uiVariantChanged = false;\n\n      // Select new UI variant\n      // If no variant condition is fulfilled, we switch to *no* UI\n      for (let uiVariant of this.uiVariants) {\n        if (uiVariant.condition == null || uiVariant.condition(context) === true) {\n          nextUi = this.uiInstanceManagers[this.uiVariants.indexOf(uiVariant)];\n          break;\n        }\n      }\n\n      // Determine if the UI variant is changing\n      if (nextUi !== this.currentUi) {\n        uiVariantChanged = true;\n        // console.log('switched from ', this.currentUi ? this.currentUi.getUI() : 'none',\n        //   ' to ', nextUi ? nextUi.getUI() : 'none');\n      }\n\n      // Only if the UI variant is changing, we need to do some stuff. Else we just leave everything as-is.\n      if (uiVariantChanged) {\n        // Hide the currently active UI variant\n        if (this.currentUi) {\n          this.currentUi.getUI().hide();\n        }\n\n        // Assign the new UI variant as current UI\n        this.currentUi = nextUi;\n\n        // When we switch to a different UI instance, there's some additional stuff to manage. If we do not switch\n        // to an instance, we're done here.\n        if (this.currentUi != null) {\n          // Add the UI to the DOM (and configure it) the first time it is selected\n          if (!this.currentUi.isConfigured()) {\n            this.addUi(this.currentUi);\n          }\n\n          // If this is an ad UI, we need to relay the saved ON_AD_STARTED event data so ad components can configure\n          // themselves for the current ad.\n          if (context.isAd) {\n            /* Relay the ON_AD_STARTED event to the ads UI\n             *\n             * Because the ads UI is initialized in the ON_AD_STARTED handler, i.e. when the ON_AD_STARTED event has\n             * already been fired, components in the ads UI that listen for the ON_AD_STARTED event never receive it.\n             * Since this can break functionality of components that rely on this event, we relay the event to the\n             * ads UI components with the following call.\n             */\n            this.currentUi.getWrappedPlayer().fireEventInUI(this.player.EVENT.ON_AD_STARTED, adStartedEvent);\n          }\n\n          this.currentUi.getUI().show();\n        }\n      }\n    };\n\n    // Listen to the following events to trigger UI variant resolution\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_STARTED, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_FINISHED, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_SKIPPED, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_ERROR, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_PLAYER_RESIZE, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_FULLSCREEN_ENTER, resolveUiVariant);\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_FULLSCREEN_EXIT, resolveUiVariant);\n\n    // Initialize the UI\n    resolveUiVariant(null);\n  }\n\n  getConfig(): UIConfig {\n    return this.config;\n  }\n\n  private addUi(ui: InternalUIInstanceManager): void {\n    let dom = ui.getUI().getDomElement();\n    ui.configureControls();\n    /* Append the UI DOM after configuration to avoid CSS transitions at initialization\n     * Example: Components are hidden during configuration and these hides may trigger CSS transitions that are\n     * undesirable at this time. */\n\n    /* Append ui to parent instead of player */\n    let parentElement = new DOM(this.playerElement.getElements()[0].parentElement);\n    parentElement.addClass('smashcut-custom-ui-bitmovin-player-holder');\n    parentElement.append(dom);\n\n    // Fire onConfigured after UI DOM elements are successfully added. When fired immediately, the DOM elements\n    // might not be fully configured and e.g. do not have a size.\n    // https://swizec.com/blog/how-to-properly-wait-for-dom-elements-to-show-up-in-modern-browsers/swizec/6663\n    if (window.requestAnimationFrame) {\n      requestAnimationFrame(() => {\n        ui.onConfigured.dispatch(ui.getUI());\n      });\n    } else {\n      // IE9 fallback\n      setTimeout(() => {\n        ui.onConfigured.dispatch(ui.getUI());\n      }, 0);\n    }\n  }\n\n  private releaseUi(ui: InternalUIInstanceManager): void {\n    ui.releaseControls();\n    ui.getUI().getDomElement().remove();\n    ui.clearEventHandlers();\n  }\n\n  release(): void {\n    for (let uiInstanceManager of this.uiInstanceManagers) {\n      this.releaseUi(uiInstanceManager);\n    }\n    this.managerPlayerWrapper.clearEventHandlers();\n  }\n}\n\nexport namespace UIManager.Factory {\n\n  export function buildDefaultUI(player: Player, config: UIConfig = {}): UIManager {\n    return UIManager.Factory.buildModernUI(player, config);\n  }\n\n  export function buildDefaultSmallScreenUI(player: Player, config: UIConfig = {}): UIManager {\n    return UIManager.Factory.buildModernSmallScreenUI(player, config);\n  }\n\n  export function buildDefaultCastReceiverUI(player: Player, config: UIConfig = {}): UIManager {\n    return UIManager.Factory.buildModernCastReceiverUI(player, config);\n  }\n\n  function smashcutUi() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let embedVideoPanel = new EmbedVideoPanel({\n      hidden: true\n    });\n\n    let controlBarTop = new Container({\n      cssClasses: ['controlbar-top'],\n      components: [\n        new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n        new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n      ]\n    });\n\n    let controlBarMiddle = new Container({\n      cssClasses: ['controlbar-middle'],\n      components: [\n        new SeekBar({label: new SeekBarLabel()}),\n      ]\n    });\n\n    let controlBarBottom = new Container({\n      cssClasses: ['controlbar-bottom'],\n      components: [\n        new Spacer(),\n        new VolumeSlider(),\n        new VolumeToggleButton(),\n        new SettingsToggleButton({settingsPanel: settingsPanel}),\n        new EmbedVideoToggleButton({embedVideoPanel: embedVideoPanel}),\n        new FullscreenToggleButton(),\n      ]\n    });\n\n\n    let controlBar = new ControlBar({\n      components: [\n        new PlaybackToggleButton(),\n        new Container({\n          cssClasses: ['controlbar-inner'],\n          components: [\n            settingsPanel,\n            embedVideoPanel,\n            controlBarTop,\n            controlBarMiddle,\n            controlBarBottom,\n          ]\n        })\n      ]\n    });\n\n    return new UIContainer({\n      hideDelay: 0,\n      cssClasses: ['ui-skin-modern ui-skin-smashcut'],\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new PlaybackToggleOverlay(),\n        controlBar,\n        new TitleBar(),\n        new RecommendationOverlay(),\n        new ErrorMessageOverlay()\n      ]\n    });\n  }\n\n  function modernUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBar = new ControlBar({\n      components: [\n        settingsPanel,\n        new Container({\n          components: [\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n            new SeekBar({label: new SeekBarLabel()}),\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n          ],\n          cssClasses: ['controlbar-top']\n        }),\n        new Container({\n          components: [\n            new PlaybackToggleButton(),\n            new VolumeToggleButton(),\n            new VolumeSlider(),\n            new Spacer(),\n            new PictureInPictureToggleButton(),\n            new AirPlayToggleButton(),\n            new CastToggleButton(),\n            new VRToggleButton(),\n            new SettingsToggleButton({settingsPanel: settingsPanel}),\n            new FullscreenToggleButton(),\n          ],\n          cssClasses: ['controlbar-bottom']\n        }),\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new PlaybackToggleOverlay(),\n        new CastStatusOverlay(),\n        controlBar,\n        new TitleBar(),\n        new RecommendationOverlay(),\n        new Watermark(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-modern']\n    });\n  }\n\n  function modernAdsUI() {\n    return new UIContainer({\n      components: [\n        new BufferingOverlay(),\n        new AdClickOverlay(),\n        new PlaybackToggleOverlay(),\n        new Container({\n          components: [\n            new AdMessageLabel({text: 'Ad: {remainingTime} secs'}),\n            new AdSkipButton()\n          ],\n          cssClass: 'ui-ads-status'\n        }),\n        new ControlBar({\n          components: [\n            new Container({\n              components: [\n                new PlaybackToggleButton(),\n                new VolumeToggleButton(),\n                new VolumeSlider(),\n                new Spacer(),\n                new FullscreenToggleButton(),\n              ],\n              cssClasses: ['controlbar-bottom']\n            }),\n          ]\n        })\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-ads']\n    });\n  }\n\n  function modernSmallScreenUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true,\n      hideDelay: -1,\n    });\n    settingsPanel.addComponent(new CloseButton({target: settingsPanel}));\n\n    let controlBar = new ControlBar({\n      components: [\n        new Container({\n          components: [\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n            new SeekBar({label: new SeekBarLabel()}),\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n          ],\n          cssClasses: ['controlbar-top']\n        }),\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        controlBar,\n        new TitleBar({\n          components: [\n            new MetadataLabel({content: MetadataLabelContent.Title}),\n            new CastToggleButton(),\n            /*new VRToggleButton(),*/\n            new SettingsToggleButton({settingsPanel: settingsPanel}),\n            new FullscreenToggleButton(),\n          ]\n        }),\n        settingsPanel,\n        new RecommendationOverlay(),\n        new Watermark(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-smallscreen']\n    });\n  }\n\n  function modernSmallScreenAdsUI() {\n    return new UIContainer({\n      components: [\n        new BufferingOverlay(),\n        new AdClickOverlay(),\n        new PlaybackToggleOverlay(),\n        new TitleBar({\n          components: [\n            // dummy label with no content to move buttons to the right\n            new Label({cssClass: 'label-metadata-title'}),\n            new FullscreenToggleButton(),\n          ]\n        }),\n        new Container({\n          components: [\n            new AdMessageLabel({text: 'Ad: {remainingTime} secs'}),\n            new AdSkipButton()\n          ],\n          cssClass: 'ui-ads-status'\n        }),\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-ads', 'ui-skin-smallscreen']\n    });\n  }\n\n  function modernCastReceiverUI() {\n    let controlBar = new ControlBar({\n      components: [\n        new Container({\n          components: [\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true}),\n            new SeekBar({smoothPlaybackPositionUpdateIntervalMs: -1}),\n            new PlaybackTimeLabel({timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right']}),\n          ],\n          cssClasses: ['controlbar-top']\n        }),\n      ]\n    });\n\n    return new CastUIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new BufferingOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        controlBar,\n        new TitleBar({keepHiddenWithoutMetadata: true}),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-modern', 'ui-skin-cast-receiver']\n    });\n  }\n\n  export function buildModernUI(player: Player, config: UIConfig = {}): UIManager {\n    // show smallScreen UI only on mobile/handheld devices\n    let smallScreenSwitchWidth = 600;\n\n    return new UIManager(player, [{\n      ui: modernSmallScreenAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isMobile && context.documentWidth < smallScreenSwitchWidth && context.isAdWithUI;\n      }\n    }, {\n      ui: modernAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isAdWithUI;\n      }\n    }, {\n      ui: modernSmallScreenUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isMobile && context.documentWidth < smallScreenSwitchWidth;\n      }\n    }, {\n      ui: smashcutUi()\n    }], config);\n  }\n\n  export function buildModernSmallScreenUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, [{\n      ui: modernSmallScreenAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isAdWithUI;\n      }\n    }, {\n      ui: modernSmallScreenUI()\n    }], config);\n  }\n\n  export function buildModernCastReceiverUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, modernCastReceiverUI(), config);\n  }\n\n  function legacyUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBar = new ControlBar({\n      components: [\n        settingsPanel,\n        new PlaybackToggleButton(),\n        new SeekBar({label: new SeekBarLabel()}),\n        new PlaybackTimeLabel(),\n        new VRToggleButton(),\n        new VolumeControlButton(),\n        new SettingsToggleButton({settingsPanel: settingsPanel}),\n        new CastToggleButton(),\n        new FullscreenToggleButton()\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        new RecommendationOverlay(),\n        controlBar,\n        new TitleBar(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-legacy']\n    });\n  }\n\n  function legacyAdsUI() {\n    return new UIContainer({\n      components: [\n        new AdClickOverlay(),\n        new ControlBar({\n          components: [\n            new PlaybackToggleButton(),\n            new AdMessageLabel(),\n            new VolumeControlButton(),\n            new FullscreenToggleButton()\n          ]\n        }),\n        new AdSkipButton()\n      ], cssClasses: ['ui-skin-legacy', 'ui-skin-ads']\n    });\n  }\n\n  function legacyCastReceiverUI() {\n    let controlBar = new ControlBar({\n      components: [\n        new SeekBar(),\n        new PlaybackTimeLabel(),\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        controlBar,\n        new TitleBar(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-legacy', 'ui-skin-cast-receiver']\n    });\n  }\n\n  function legacyTestUI() {\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n        new SettingsPanelItem('Subtitles', new SubtitleSelectBox())\n      ],\n      hidden: true\n    });\n\n    let controlBar = new ControlBar({\n      components: [settingsPanel,\n        new PlaybackToggleButton(),\n        new SeekBar({label: new SeekBarLabel()}),\n        new PlaybackTimeLabel(),\n        new VRToggleButton(),\n        new VolumeToggleButton(),\n        new VolumeSlider(),\n        new VolumeControlButton(),\n        new VolumeControlButton({vertical: false}),\n        new SettingsToggleButton({settingsPanel: settingsPanel}),\n        new CastToggleButton(),\n        new FullscreenToggleButton()\n      ]\n    });\n\n    return new UIContainer({\n      components: [\n        new SubtitleOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        new Watermark(),\n        new RecommendationOverlay(),\n        controlBar,\n        new TitleBar(),\n        new ErrorMessageOverlay()\n      ], cssClasses: ['ui-skin-legacy']\n    });\n  }\n\n  export function buildLegacyUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, [{\n      ui: legacyAdsUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isAdWithUI;\n      }\n    }, {\n      ui: legacyUI()\n    }], config);\n  }\n\n  export function buildLegacyCastReceiverUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, legacyCastReceiverUI(), config);\n  }\n\n  export function buildLegacyTestUI(player: Player, config: UIConfig = {}): UIManager {\n    return new UIManager(player, legacyTestUI(), config);\n  }\n}\n\nexport interface SeekPreviewArgs extends NoArgs {\n  /**\n   * The timeline position in percent where the event originates from.\n   */\n  position: number;\n  /**\n   * The timeline marker associated with the current position, if existing.\n   */\n  marker?: TimelineMarker;\n}\n\n/**\n * Encapsulates functionality to manage a UI instance. Used by the {@link UIManager} to manage multiple UI instances.\n */\nexport class UIInstanceManager {\n  private playerWrapper: PlayerWrapper;\n  private ui: UIContainer;\n  private config: UIConfig;\n\n  private events = {\n    onConfigured: new EventDispatcher<UIContainer, NoArgs>(),\n    onSeek: new EventDispatcher<SeekBar, NoArgs>(),\n    onSeekPreview: new EventDispatcher<SeekBar, SeekPreviewArgs>(),\n    onSeeked: new EventDispatcher<SeekBar, NoArgs>(),\n    onComponentShow: new EventDispatcher<Component<ComponentConfig>, NoArgs>(),\n    onComponentHide: new EventDispatcher<Component<ComponentConfig>, NoArgs>(),\n    onControlsShow: new EventDispatcher<UIContainer, NoArgs>(),\n    onPreviewControlsHide: new EventDispatcher<UIContainer, CancelEventArgs>(),\n    onControlsHide: new EventDispatcher<UIContainer, NoArgs>(),\n  };\n\n  constructor(player: Player, ui: UIContainer, config: UIConfig = {}) {\n    this.playerWrapper = new PlayerWrapper(player);\n    this.ui = ui;\n    this.config = config;\n  }\n\n  getConfig(): UIConfig {\n    return this.config;\n  }\n\n  getUI(): UIContainer {\n    return this.ui;\n  }\n\n  getPlayer(): Player {\n    return this.playerWrapper.getPlayer();\n  }\n\n  /**\n   * Fires when the UI is fully configured and added to the DOM.\n   * @returns {EventDispatcher}\n   */\n  get onConfigured(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onConfigured;\n  }\n\n  /**\n   * Fires when a seek starts.\n   * @returns {EventDispatcher}\n   */\n  get onSeek(): EventDispatcher<SeekBar, NoArgs> {\n    return this.events.onSeek;\n  }\n\n  /**\n   * Fires when the seek timeline is scrubbed.\n   * @returns {EventDispatcher}\n   */\n  get onSeekPreview(): EventDispatcher<SeekBar, SeekPreviewArgs> {\n    return this.events.onSeekPreview;\n  }\n\n  /**\n   * Fires when a seek is finished.\n   * @returns {EventDispatcher}\n   */\n  get onSeeked(): EventDispatcher<SeekBar, NoArgs> {\n    return this.events.onSeeked;\n  }\n\n  /**\n   * Fires when a component is showing.\n   * @returns {EventDispatcher}\n   */\n  get onComponentShow(): EventDispatcher<Component<ComponentConfig>, NoArgs> {\n    return this.events.onComponentShow;\n  }\n\n  /**\n   * Fires when a component is hiding.\n   * @returns {EventDispatcher}\n   */\n  get onComponentHide(): EventDispatcher<Component<ComponentConfig>, NoArgs> {\n    return this.events.onComponentHide;\n  }\n\n  /**\n   * Fires when the UI controls are showing.\n   * @returns {EventDispatcher}\n   */\n  get onControlsShow(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onControlsShow;\n  }\n\n  /**\n   * Fires before the UI controls are hiding to check if they are allowed to hide.\n   * @returns {EventDispatcher}\n   */\n  get onPreviewControlsHide(): EventDispatcher<UIContainer, CancelEventArgs> {\n    return this.events.onPreviewControlsHide;\n  }\n\n  /**\n   * Fires when the UI controls are hiding.\n   * @returns {EventDispatcher}\n   */\n  get onControlsHide(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onControlsHide;\n  }\n\n  protected clearEventHandlers(): void {\n    this.playerWrapper.clearEventHandlers();\n\n    let events = <any>this.events; // avoid TS7017\n    for (let event in events) {\n      let dispatcher = <EventDispatcher<Object, Object>>events[event];\n      dispatcher.unsubscribeAll();\n    }\n  }\n}\n\n/**\n * Extends the {@link UIInstanceManager} for internal use in the {@link UIManager} and provides access to functionality\n * that components receiving a reference to the {@link UIInstanceManager} should not have access to.\n */\nclass InternalUIInstanceManager extends UIInstanceManager {\n\n  private configured: boolean;\n  private released: boolean;\n\n  getWrappedPlayer(): WrappedPlayer {\n    // TODO find a non-hacky way to provide the WrappedPlayer to the UIManager without exporting it\n    // getPlayer() actually returns the WrappedPlayer but its return type is set to Player so the WrappedPlayer does\n    // not need to be exported\n    return <WrappedPlayer>this.getPlayer();\n  }\n\n  configureControls(): void {\n    this.configureControlsTree(this.getUI());\n    this.configured = true;\n  }\n\n  isConfigured(): boolean {\n    return this.configured;\n  }\n\n  private configureControlsTree(component: Component<ComponentConfig>) {\n    let configuredComponents: Component<ComponentConfig>[] = [];\n\n    UIUtils.traverseTree(component, (component) => {\n      // First, check if we have already configured a component, and throw an error if we did. Multiple configuration\n      // of the same component leads to unexpected UI behavior. Also, a component that is in the UI tree multiple\n      // times hints at a wrong UI structure.\n      // We could just skip configuration in such a case and not throw an exception, but enforcing a clean UI tree\n      // seems like the better choice.\n      for (let configuredComponent of configuredComponents) {\n        if (configuredComponent === component) {\n          // Write the component to the console to simplify identification of the culprit\n          // (e.g. by inspecting the config)\n          if (console) {\n            console.error('Circular reference in UI tree', component);\n          }\n\n          // Additionally throw an error, because this case must not happen and leads to unexpected UI behavior.\n          throw Error('Circular reference in UI tree: ' + component.constructor.name);\n        }\n      }\n\n      component.initialize();\n      component.configure(this.getPlayer(), this);\n      configuredComponents.push(component);\n    });\n  }\n\n  releaseControls(): void {\n    // Do not call release methods if the components have never been configured; this can result in exceptions\n    if (this.configured) {\n      this.releaseControlsTree(this.getUI());\n      this.configured = false;\n    }\n    this.released = true;\n  }\n\n  isReleased(): boolean {\n    return this.released;\n  }\n\n  private releaseControlsTree(component: Component<ComponentConfig>) {\n    component.release();\n\n    if (component instanceof Container) {\n      for (let childComponent of component.getComponents()) {\n        this.releaseControlsTree(childComponent);\n      }\n    }\n  }\n\n  clearEventHandlers(): void {\n    super.clearEventHandlers();\n  }\n}\n\n/**\n * Extended interface of the {@link Player} for use in the UI.\n */\ninterface WrappedPlayer extends Player {\n  /**\n   * Fires an event on the player that targets all handlers in the UI but never enters the real player.\n   * @param event the event to fire\n   * @param data data to send with the event\n   */\n  fireEventInUI(event: EVENT, data: {}): void;\n}\n\n/**\n * Wraps the player to track event handlers and provide a simple method to remove all registered event\n * handlers from the player.\n */\nclass PlayerWrapper {\n\n  private player: Player;\n  private wrapper: WrappedPlayer;\n\n  private eventHandlers: { [eventType: string]: PlayerEventCallback[]; } = {};\n\n  constructor(player: Player) {\n    this.player = player;\n\n    // Collect all public API methods of the player\n    let methods = <any[]>[];\n    for (let member in player) {\n      if (typeof (<any>player)[member] === 'function') {\n        methods.push(member);\n      }\n    }\n\n    // Create wrapper object and add function wrappers for all API methods that do nothing but calling the base method\n    // on the player\n    let wrapper = <any>{};\n    for (let member of methods) {\n      wrapper[member] = function () {\n        // console.log('called ' + member); // track method calls on the player\n        return (<any>player)[member].apply(player, arguments);\n      };\n    }\n\n    // Collect all public properties of the player and add it to the wrapper\n    for (let member in player) {\n      if (typeof (<any>player)[member] !== 'function') {\n        wrapper[member] = (<any>player)[member];\n      }\n    }\n\n    // Explicitly add a wrapper method for 'addEventHandler' that adds added event handlers to the event list\n    wrapper.addEventHandler = (eventType: EVENT, callback: PlayerEventCallback) => {\n      player.addEventHandler(eventType, callback);\n\n      if (!this.eventHandlers[eventType]) {\n        this.eventHandlers[eventType] = [];\n      }\n\n      this.eventHandlers[eventType].push(callback);\n\n      return wrapper;\n    };\n\n    // Explicitly add a wrapper method for 'removeEventHandler' that removes removed event handlers from the event list\n    wrapper.removeEventHandler = (eventType: EVENT, callback: PlayerEventCallback) => {\n      player.removeEventHandler(eventType, callback);\n\n      if (this.eventHandlers[eventType]) {\n        ArrayUtils.remove(this.eventHandlers[eventType], callback);\n      }\n\n      return wrapper;\n    };\n\n    wrapper.fireEventInUI = (event: EVENT, data: {}) => {\n      if (this.eventHandlers[event]) { // check if there are handlers for this event registered\n        // Extend the data object with default values to convert it to a {@link PlayerEvent} object.\n        let playerEventData = <PlayerEvent>Object.assign({}, {\n          timestamp: Date.now(),\n          type: event,\n          // Add a marker property so the UI can detect UI-internal player events\n          uiSourced: true,\n        }, data);\n\n        // Execute the registered callbacks\n        for (let callback of this.eventHandlers[event]) {\n          callback(playerEventData);\n        }\n      }\n    };\n\n    this.wrapper = <WrappedPlayer>wrapper;\n  }\n\n  /**\n   * Returns a wrapped player object that can be used on place of the normal player object.\n   * @returns {WrappedPlayer} a wrapped player\n   */\n  getPlayer(): WrappedPlayer {\n    return this.wrapper;\n  }\n\n  /**\n   * Clears all registered event handlers from the player that were added through the wrapped player.\n   */\n  clearEventHandlers(): void {\n    for (let eventType in this.eventHandlers) {\n      for (let callback of this.eventHandlers[eventType]) {\n        this.player.removeEventHandler(eventType, callback);\n      }\n    }\n  }\n}\n","import {EventDispatcher, Event, NoArgs} from './eventdispatcher';\nimport {Component, ComponentConfig} from './components/component';\nimport {Container} from './components/container';\n\nexport namespace ArrayUtils {\n  /**\n   * Removes an item from an array.\n   * @param array the array that may contain the item to remove\n   * @param item the item to remove from the array\n   * @returns {any} the removed item or null if it wasn't part of the array\n   */\n  export function remove<T>(array: T[], item: T): T | null {\n    let index = array.indexOf(item);\n\n    if (index > -1) {\n      return array.splice(index, 1)[0];\n    } else {\n      return null;\n    }\n  }\n}\n\nexport namespace StringUtils {\n\n  export let FORMAT_HHMMSS: string = 'hh:mm:ss';\n  export let FORMAT_MMSS: string = 'mm:ss';\n\n  /**\n   * Formats a number of seconds into a time string with the pattern hh:mm:ss.\n   *\n   * @param totalSeconds the total number of seconds to format to string\n   * @param format the time format to output (default: hh:mm:ss)\n   * @returns {string} the formatted time string\n   */\n  export function secondsToTime(totalSeconds: number, format: string = FORMAT_HHMMSS): string {\n    let isNegative = totalSeconds < 0;\n\n    if (isNegative) {\n      // If the time is negative, we make it positive for the calculation below\n      // (else we'd get all negative numbers) and reattach the negative sign later.\n      totalSeconds = -totalSeconds;\n    }\n\n    // Split into separate time parts\n    let hours = Math.floor(totalSeconds / 3600);\n    let minutes = Math.floor(totalSeconds / 60) - hours * 60;\n    let seconds = Math.floor(totalSeconds) % 60;\n\n    return (isNegative ? '-' : '') + format\n        .replace('hh', leftPadWithZeros(hours, 2))\n        .replace('mm', leftPadWithZeros(minutes, 2))\n        .replace('ss', leftPadWithZeros(seconds, 2));\n  }\n\n  /**\n   * Converts a number to a string and left-pads it with zeros to the specified length.\n   * Example: leftPadWithZeros(123, 5) => '00123'\n   *\n   * @param num the number to convert to string and pad with zeros\n   * @param length the desired length of the padded string\n   * @returns {string} the padded number as string\n   */\n  function leftPadWithZeros(num: number | string, length: number): string {\n    let text = num + '';\n    let padding = '0000000000'.substr(0, length - text.length);\n    return padding + text;\n  }\n\n  /**\n   * Fills out placeholders in an ad message.\n   *\n   * Has the placeholders '{remainingTime[formatString]}', '{playedTime[formatString]}' and\n   * '{adDuration[formatString]}', which are replaced by the remaining time until the ad can be skipped, the current\n   * time or the ad duration. The format string is optional. If not specified, the placeholder is replaced by the time\n   * in seconds. If specified, it must be of the following format:\n   * - %d - Inserts the time as an integer.\n   * - %0Nd - Inserts the time as an integer with leading zeroes, if the length of the time string is smaller than N.\n   * - %f - Inserts the time as a float.\n   * - %0Nf - Inserts the time as a float with leading zeroes.\n   * - %.Mf - Inserts the time as a float with M decimal places. Can be combined with %0Nf, e.g. %04.2f (the time\n   * 10.123\n   * would be printed as 0010.12).\n   * - %hh:mm:ss\n   * - %mm:ss\n   *\n   * @param adMessage an ad message with optional placeholders to fill\n   * @param skipOffset if specified, {remainingTime} will be filled with the remaining time until the ad can be skipped\n   * @param player the player to get the time data from\n   * @returns {string} the ad message with filled placeholders\n   */\n  export function replaceAdMessagePlaceholders(adMessage: string, skipOffset: number, player: bitmovin.player.Player) {\n    let adMessagePlaceholderRegex = new RegExp(\n      '\\\\{(remainingTime|playedTime|adDuration)(}|%((0[1-9]\\\\d*(\\\\.\\\\d+(d|f)|d|f)|\\\\.\\\\d+f|d|f)|hh:mm:ss|mm:ss)})',\n      'g'\n    );\n\n    return adMessage.replace(adMessagePlaceholderRegex, (formatString) => {\n      let time = 0;\n      if (formatString.indexOf('remainingTime') > -1) {\n        if (skipOffset) {\n          time = Math.ceil(skipOffset - player.getCurrentTime());\n        } else {\n          time = player.getDuration() - player.getCurrentTime();\n        }\n      } else if (formatString.indexOf('playedTime') > -1) {\n        time = player.getCurrentTime();\n      } else if (formatString.indexOf('adDuration') > -1) {\n        time = player.getDuration();\n      }\n      return formatNumber(time, formatString);\n    });\n  }\n\n  function formatNumber(time: number, format: string) {\n    let formatStringValidationRegex = /%((0[1-9]\\d*(\\.\\d+(d|f)|d|f)|\\.\\d+f|d|f)|hh:mm:ss|mm:ss)/;\n    let leadingZeroesRegex = /(%0[1-9]\\d*)(?=(\\.\\d+f|f|d))/;\n    let decimalPlacesRegex = /\\.\\d*(?=f)/;\n\n    if (!formatStringValidationRegex.test(format)) {\n      // If the format is invalid, we set a default fallback format\n      format = '%d';\n    }\n\n    // Determine the number of leading zeros\n    let leadingZeroes = 0;\n    let leadingZeroesMatches = format.match(leadingZeroesRegex);\n    if (leadingZeroesMatches) {\n      leadingZeroes = parseInt(leadingZeroesMatches[0].substring(2));\n    }\n\n    // Determine the number of decimal places\n    let numDecimalPlaces = null;\n    let decimalPlacesMatches = format.match(decimalPlacesRegex);\n    if (decimalPlacesMatches && !isNaN(parseInt(decimalPlacesMatches[0].substring(1)))) {\n      numDecimalPlaces = parseInt(decimalPlacesMatches[0].substring(1));\n      if (numDecimalPlaces > 20) {\n        numDecimalPlaces = 20;\n      }\n    }\n\n    // Float format\n    if (format.indexOf('f') > -1) {\n      let timeString = '';\n\n      if (numDecimalPlaces !== null) {\n        // Apply fixed number of decimal places\n        timeString = time.toFixed(numDecimalPlaces);\n      } else {\n        timeString = '' + time;\n      }\n\n      // Apply leading zeros\n      if (timeString.indexOf('.') > -1) {\n        return leftPadWithZeros(timeString, timeString.length + (leadingZeroes - timeString.indexOf('.')));\n      } else {\n        return leftPadWithZeros(timeString, leadingZeroes);\n      }\n\n    }\n    // Time format\n    else if (format.indexOf(':') > -1) {\n      let totalSeconds = Math.ceil(time);\n\n      // hh:mm:ss format\n      if (format.indexOf('hh') > -1) {\n        return secondsToTime(totalSeconds);\n      }\n      // mm:ss format\n      else {\n        let minutes = Math.floor(totalSeconds / 60);\n        let seconds = totalSeconds % 60;\n\n        return leftPadWithZeros(minutes, 2) + ':' + leftPadWithZeros(seconds, 2);\n      }\n    }\n    // Integer format\n    else {\n      return leftPadWithZeros(Math.ceil(time), leadingZeroes);\n    }\n  }\n}\n\nexport namespace PlayerUtils {\n\n  import Player = bitmovin.player.Player;\n\n  export enum PlayerState {\n    IDLE,\n    PREPARED,\n    PLAYING,\n    PAUSED,\n    FINISHED,\n  }\n\n  export function isSourceLoaded(player: Player): boolean {\n    return player.getConfig().source !== undefined;\n  }\n\n  export function isTimeShiftAvailable(player: Player): boolean {\n    return player.isLive() && player.getMaxTimeShift() !== 0;\n  }\n\n  export function getState(player: Player): PlayerState {\n    if (player.hasEnded()) {\n      return PlayerState.FINISHED;\n    } else if (player.isPlaying()) {\n      return PlayerState.PLAYING;\n    } else if (player.isPaused()) {\n      return PlayerState.PAUSED;\n    } else if (isSourceLoaded(player)) {\n      return PlayerState.PREPARED;\n    } else {\n      return PlayerState.IDLE;\n    }\n  }\n\n  export interface TimeShiftAvailabilityChangedArgs extends NoArgs {\n    timeShiftAvailable: boolean;\n  }\n\n  export class TimeShiftAvailabilityDetector {\n\n    private timeShiftAvailabilityChangedEvent = new EventDispatcher<Player, TimeShiftAvailabilityChangedArgs>();\n\n    constructor(player: Player) {\n      let timeShiftAvailable: boolean = undefined;\n\n      let timeShiftDetector = () => {\n        if (player.isLive()) {\n          let timeShiftAvailableNow = PlayerUtils.isTimeShiftAvailable(player);\n\n          // When the availability changes, we fire the event\n          if (timeShiftAvailableNow !== timeShiftAvailable) {\n            this.timeShiftAvailabilityChangedEvent.dispatch(player, { timeShiftAvailable: timeShiftAvailableNow });\n            timeShiftAvailable = timeShiftAvailableNow;\n          }\n        }\n      };\n      // Try to detect timeshift availability in ON_READY, which works for DASH streams\n      player.addEventHandler(player.EVENT.ON_READY, timeShiftDetector);\n      // With HLS/NativePlayer streams, getMaxTimeShift can be 0 before the buffer fills, so we need to additionally\n      // check timeshift availability in ON_TIME_CHANGED\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, timeShiftDetector);\n    }\n\n    get onTimeShiftAvailabilityChanged(): Event<Player, TimeShiftAvailabilityChangedArgs> {\n      return this.timeShiftAvailabilityChangedEvent.getEvent();\n    }\n  }\n\n  export interface LiveStreamDetectorEventArgs extends NoArgs {\n    live: boolean;\n  }\n\n  /**\n   * Detects changes of the stream type, i.e. changes of the return value of the player#isLive method.\n   * Normally, a stream cannot change its type during playback, it's either VOD or live. Due to bugs on some\n   * platforms or browsers, it can still change. It is therefore unreliable to just check #isLive and this detector\n   * should be used as a workaround instead.\n   *\n   * Known cases:\n   *\n   * - HLS VOD on Android 4.3\n   * Video duration is initially 'Infinity' and only gets available after playback starts, so streams are wrongly\n   * reported as 'live' before playback (the live-check in the player checks for infinite duration).\n   */\n  export class LiveStreamDetector {\n\n    private liveChangedEvent = new EventDispatcher<Player, LiveStreamDetectorEventArgs>();\n\n    constructor(player: Player) {\n      let live: boolean = undefined;\n\n      let liveDetector = () => {\n        let liveNow = player.isLive();\n\n        // Compare current to previous live state flag and fire event when it changes. Since we initialize the flag\n        // with undefined, there is always at least an initial event fired that tells listeners the live state.\n        if (liveNow !== live) {\n          this.liveChangedEvent.dispatch(player, { live: liveNow });\n          live = liveNow;\n        }\n      };\n      // Initialize when player is ready\n      player.addEventHandler(player.EVENT.ON_READY, liveDetector);\n      // Re-evaluate when playback starts\n      player.addEventHandler(player.EVENT.ON_PLAY, liveDetector);\n\n      // HLS live detection workaround for Android:\n      // Also re-evaluate during playback, because that is when the live flag might change.\n      // (Doing it only in Android Chrome saves unnecessary overhead on other plattforms)\n      if (BrowserUtils.isAndroid && BrowserUtils.isChrome) {\n        player.addEventHandler(player.EVENT.ON_TIME_CHANGED, liveDetector);\n      }\n    }\n\n    get onLiveChanged(): Event<Player, LiveStreamDetectorEventArgs> {\n      return this.liveChangedEvent.getEvent();\n    }\n  }\n}\n\nexport namespace UIUtils {\n  export interface TreeTraversalCallback {\n    (component: Component<ComponentConfig>, parent?: Component<ComponentConfig>): void;\n  }\n\n  export function traverseTree(component: Component<ComponentConfig>, visit: TreeTraversalCallback): void {\n    let recursiveTreeWalker = (component: Component<ComponentConfig>, parent?: Component<ComponentConfig>) => {\n      visit(component, parent);\n\n      // If the current component is a container, visit it's children\n      if (component instanceof Container) {\n        for (let childComponent of component.getComponents()) {\n          recursiveTreeWalker(childComponent, component);\n        }\n      }\n    };\n\n    // Walk and configure the component tree\n    recursiveTreeWalker(component);\n  }\n}\n\nexport namespace BrowserUtils {\n\n  // isMobile only needs to be evaluated once (it cannot change during a browser session)\n  // Mobile detection according to Mozilla recommendation: \"In summary, we recommend looking for the string Mobi\n  // anywhere in the User Agent to detect a mobile device.\"\n  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent\n  export const isMobile = navigator && navigator.userAgent && /Mobi/.test(navigator.userAgent);\n\n  export const isChrome = navigator && navigator.userAgent && /Chrome/.test(navigator.userAgent);\n\n  export const isAndroid = navigator && navigator.userAgent && /Android/.test(navigator.userAgent);\n}"]}